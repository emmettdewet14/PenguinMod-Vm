module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded chunks
/******/ 	// "0" means "already loaded"
/******/ 	var installedChunks = {
/******/ 		"scratch-vm": 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var promises = [];
/******/
/******/
/******/ 		// require() chunk loading for javascript
/******/
/******/ 		// "0" is the signal for "already loaded"
/******/ 		if(installedChunks[chunkId] !== 0) {
/******/ 			var chunk = require("./" + ({"iframe-extension-worker":"iframe-extension-worker"}[chunkId]||chunkId) + ".js");
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids;
/******/ 			for(var moduleId in moreModules) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 			for(var i = 0; i < chunkIds.length; i++)
/******/ 				installedChunks[chunkIds[i]] = 0;
/******/ 		}
/******/ 		return Promise.all(promises);
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// uncaught error handler for webpack runtime
/******/ 	__webpack_require__.oe = function(err) {
/******/ 		process.nextTick(function() {
/******/ 			throw err; // catch this error by using import().catch()
/******/ 		});
/******/ 	};
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@turbowarp/json/src/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@turbowarp/json/src/index.js ***!
  \***************************************************/
/*! exports provided: _parse, parse, stringify */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_parse", function() { return _parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stringify", function() { return stringify; });
/**
 * @param {string} source
 * @returns {unknown}
 */
const _parse = (source) => {
  let index = 0;

  const lineInfo = () => {
    let line = 0;
    let column = 0;
    for (let i = 0; i < index; i++) {
      if (source[i] === '\n') {
        line++;
        column = 0;
      } else {
        column++;
      }
    }
    return { line: line + 1, column: column + 1 };
  };

  const error = (message) => {
    const { line, column } = lineInfo();
    throw new SyntaxError(
      `${message} (Line ${line} Column ${column})`
    );
  };

  const charAt = (index) => {
    if (index >= source.length) {
      error('Unexpected end of input');
    }
    return source[index];
  };

  const currentChar = () => charAt(index);

  const next = () => {
    index++;
  };

  const expect = (char) => {
    if (currentChar() !== char) {
      error(`Expected '${char}' but found '${currentChar()}'`);
    }
    next();
  };

  const peek = (length = 1, offset = 1) => {
    if (index + offset + length > source.length) {
      return '';
    }
    if (length === 1) {
      return charAt(index + offset);
    }
    let result = '';
    for (let i = 0; i < length; i++) {
      result += charAt(index + offset + i);
    }
    return result;
  };

  const skipWhitespaceAndComments = () => {
    while (true) {
      if (/\s/.test(currentChar())) {
        next();
      } else if (peek(2, 0) === '//') {
        next(); // consume /
        next(); // consume /
        while (currentChar() !== '\n') {
          next();
        }
      } else if (peek(2, 0) === '/*') {
        next(); // consume /
        next(); // consume *
        while (peek(2, 0) !== '*/') {
          next();
        }
        next(); // consume *
        next(); // consume /
      } else {
        break;
      }
    }
  };

  const parseValue = () => {
    skipWhitespaceAndComments();
    const char = currentChar();
    switch (char) {
      case '"':
        return parseString();
      case '{':
        return parseObject();
      case '[':
        return parseList();
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '-':
        return parseNumber();
      default:
        return parseWord();
    }
  };

  const parseWord = () => {
    if (peek(4, 0) === 'null') {
      for (let i = 0; i < 4; i++) {
        next();
      }
      return null;
    }
    if (peek(4, 0) === 'true') {
      for (let i = 0; i < 4; i++) {
        next();
      }
      return true;
    }
    if (peek(5, 0) === 'false') {
      for (let i = 0; i < 5; i++) {
        next();
      }
      return false;
    }
    // Non-standard extensions
    if (peek(8, 0) === 'Infinity') {
      for (let i = 0; i < 8; i++) {
        next();
      }
      return Infinity;
    }
    if (peek(3, 0) === 'NaN') {
      for (let i = 0; i < 3; i++) {
        next();
      }
      return NaN;
    }
    error(`Unexpected character '${currentChar()}'`);
  };

  const parseNumber = () => {
    // Non-standard extension
    if (peek(9, 0) === '-Infinity') {
      for (let i = 0; i < 9; i++) {
        next();
      }
      return -Infinity;
    }
    let number = '';
    while (true) {
      number += currentChar();
      if (/[\d.e+-]/i.test(peek())) {
        next();
      } else {
        break;
      }
    }
    next();
    const value = +number;
    if (Number.isNaN(value)) {
      error(`Not a number: ${number}`);
    }
    return value;    
  };

  const parseString = () => {
    expect('"');
    let result = '';
    if (currentChar() === '"') {
      next();
      return '';
    }
    while (true) {
      const char = currentChar();
      if (char === '\\') {
        next();
        switch (currentChar()) {
          case '"':
            result += '"';
            break;
          case '/':
            result += '/';
            break;
          case '\\':
            result += '\\';
            break;
          case 'b':
            result += '\b';
            break;
          case 'f':
            result += '\f';
            break;
          case 'n':
            result += '\n';
            break;
          case 'r':
            result += '\r';
            break;
          case 't':
            result += '\t';
            break;
          case 'u': {
            let hexString = '';
            for (let i = 0; i < 4; i++) {
              next();
              const nextChar = currentChar();
              if (!/[0-9a-f]/i.test(nextChar)) {
                error(`Invalid hex code: ${nextChar}`);
              }
              hexString += nextChar;
            }
            const hexNumber = Number.parseInt(hexString, 16);
            const letter = String.fromCharCode(hexNumber);
            result += letter;
            break;
          }
          default:
            error(`Invalid escape code: \\${currentChar()}`);
        }
      } else {
        result += char;
      }
      if (peek() === '"') {
        break;
      }
      next();
    }
    next();
    expect('"');
    return result;
  };

  const parseList = () => {
    expect('[');
    skipWhitespaceAndComments();
    const result = [];
    while (true) {
      skipWhitespaceAndComments();
      if (currentChar() === ']') {
        break;
      }
      const value = parseValue();
      result.push(value);
      skipWhitespaceAndComments();
      if (currentChar() === ',') {
        next();
      } else {
        break;
      }
    }
    expect(']');
    return result;
  };

  const parseObject = () => {
    expect('{');
    skipWhitespaceAndComments();
    const result = {};
    while (true) {
      skipWhitespaceAndComments();
      if (currentChar() === '}') {
        break;
      }
      const key = parseString();
      skipWhitespaceAndComments();
      expect(':');
      const value = parseValue();
      result[key] = value;
      skipWhitespaceAndComments();
      if (currentChar() === ',') {
        next();
      } else {
        break;
      }
    }
    expect('}');
    return result;
  };

  return parseValue();
};

/**
 * @param {string} source
 * @returns {unknown}
 */
const parse = (source) => {
  try {
    return JSON.parse(source);
  } catch (e1) {
    try {
      return _parse(source);
    } catch (e2) {
      // The error from JSON.parse is probably more useful.
      throw e1;
    }
  }
};

/**
 * @param {unknown} object
 * @returns {string}
 */
const stringify = (object) => {
  if (typeof object === 'string') {
    return JSON.stringify(object);
  }
  if (typeof object === 'number' || typeof object === 'boolean') {
    // Difference from regular JSON: [-]Infinity and NaN will be sanitized as-is
    return object.toString();
  }
  if (object === null || typeof object === 'undefined' || typeof object === 'symbol') {
    return 'null';
  }
  if (Array.isArray(object)) {
    return `[${object.map((i) => stringify(i)).join(',')}]`;
  }
  if (typeof object === 'object') {
    let result = '{';
    let isFirstItem = true;
    const keys = Object.keys(object);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const value = object[key];
      if (typeof value !== 'undefined') {
        if (!isFirstItem) {
          result += ',';
        }
        result += `${JSON.stringify(key)}:${stringify(value)}`;
        isFirstItem = false;
      }
    }
    result += '}';
    return result;
  }
  if (typeof object === 'bigint') {
    throw new TypeError('Can not stringify bigint');
  }
  throw new TypeError(`Can not stringify: ${object}`);
};


/***/ }),

/***/ "./node_modules/@vernier/godirect/dist/godirect.min.umd.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@vernier/godirect/dist/godirect.min.umd.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2019 Vernier Software. All rights reserved.
 * This code may only be used under the BSD 3-Clause license found at
 * https://raw.githubusercontent.com/VernierST/godirect-js/master/LICENSE
 */

!function(e,t){ true?module.exports=t():undefined}(this,function(){"use strict";function e(e,t,n,r,i,a,o){try{var s=e[a](o),u=s.value}catch(e){return void n(e)}s.done?t(u):Promise.resolve(u).then(r,i)}function t(t){return function(){var n=this,r=arguments;return new Promise(function(i,a){var o=t.apply(n,r);function s(t){e(o,i,a,s,u,"next",t)}function u(t){e(o,i,a,s,u,"throw",t)}s(void 0)})}}function n(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function r(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function i(e,t,n){return t&&r(e.prototype,t),n&&r(e,n),e}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&s(e,t)}function o(e){return(o=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function s(e,t){return(s=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function u(e,t){return!t||"object"!=typeof t&&"function"!=typeof t?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):t}!function(e){var t,n=Object.prototype,r=n.hasOwnProperty,i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",o=i.asyncIterator||"@@asyncIterator",s=i.toStringTag||"@@toStringTag",u="object"==typeof module,c=e.regeneratorRuntime;if(c)u&&(module.exports=c);else{(c=e.regeneratorRuntime=u?module.exports:{}).wrap=b;var f="suspendedStart",h="suspendedYield",l="executing",p="completed",d={},m={};m[a]=function(){return this};var v=Object.getPrototypeOf,g=v&&v(v(C([])));g&&g!==n&&r.call(g,a)&&(m=g);var y=x.prototype=_.prototype=Object.create(m);k.prototype=y.constructor=x,x.constructor=k,x[s]=k.displayName="GeneratorFunction",c.isGeneratorFunction=function(e){var t="function"==typeof e&&e.constructor;return!!t&&(t===k||"GeneratorFunction"===(t.displayName||t.name))},c.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,x):(e.__proto__=x,s in e||(e[s]="GeneratorFunction")),e.prototype=Object.create(y),e},c.awrap=function(e){return{__await:e}},E(S.prototype),S.prototype[o]=function(){return this},c.AsyncIterator=S,c.async=function(e,t,n,r){var i=new S(b(e,t,n,r));return c.isGeneratorFunction(t)?i:i.next().then(function(e){return e.done?e.value:i.next()})},E(y),y[s]="Generator",y[a]=function(){return this},y.toString=function(){return"[object Generator]"},c.keys=function(e){var t=[];for(var n in e)t.push(n);return t.reverse(),function n(){for(;t.length;){var r=t.pop();if(r in e)return n.value=r,n.done=!1,n}return n.done=!0,n}},c.values=C,A.prototype={constructor:A,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(M),!e)for(var n in this)"t"===n.charAt(0)&&r.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=t)},stop:function(){this.done=!0;var e=this.tryEntries[0].completion;if("throw"===e.type)throw e.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var n=this;function i(r,i){return s.type="throw",s.arg=e,n.next=r,i&&(n.method="next",n.arg=t),!!i}for(var a=this.tryEntries.length-1;a>=0;--a){var o=this.tryEntries[a],s=o.completion;if("root"===o.tryLoc)return i("end");if(o.tryLoc<=this.prev){var u=r.call(o,"catchLoc"),c=r.call(o,"finallyLoc");if(u&&c){if(this.prev<o.catchLoc)return i(o.catchLoc,!0);if(this.prev<o.finallyLoc)return i(o.finallyLoc)}else if(u){if(this.prev<o.catchLoc)return i(o.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<o.finallyLoc)return i(o.finallyLoc)}}}},abrupt:function(e,t){for(var n=this.tryEntries.length-1;n>=0;--n){var i=this.tryEntries[n];if(i.tryLoc<=this.prev&&r.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var a=i;break}}a&&("break"===e||"continue"===e)&&a.tryLoc<=t&&t<=a.finallyLoc&&(a=null);var o=a?a.completion:{};return o.type=e,o.arg=t,a?(this.method="next",this.next=a.finallyLoc,d):this.complete(o)},complete:function(e,t){if("throw"===e.type)throw e.arg;return"break"===e.type||"continue"===e.type?this.next=e.arg:"return"===e.type?(this.rval=this.arg=e.arg,this.method="return",this.next="end"):"normal"===e.type&&t&&(this.next=t),d},finish:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var n=this.tryEntries[t];if(n.finallyLoc===e)return this.complete(n.completion,n.afterLoc),M(n),d}},catch:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var n=this.tryEntries[t];if(n.tryLoc===e){var r=n.completion;if("throw"===r.type){var i=r.arg;M(n)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(e,n,r){return this.delegate={iterator:C(e),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=t),d}}}function b(e,t,n,r){var i=t&&t.prototype instanceof _?t:_,a=Object.create(i.prototype),o=new A(r||[]);return a._invoke=function(e,t,n){var r=f;return function(i,a){if(r===l)throw new Error("Generator is already running");if(r===p){if("throw"===i)throw a;return L()}for(n.method=i,n.arg=a;;){var o=n.delegate;if(o){var s=R(o,n);if(s){if(s===d)continue;return s}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(r===f)throw r=p,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);r=l;var u=w(e,t,n);if("normal"===u.type){if(r=n.done?p:h,u.arg===d)continue;return{value:u.arg,done:n.done}}"throw"===u.type&&(r=p,n.method="throw",n.arg=u.arg)}}}(e,n,o),a}function w(e,t,n){try{return{type:"normal",arg:e.call(t,n)}}catch(e){return{type:"throw",arg:e}}}function _(){}function k(){}function x(){}function E(e){["next","throw","return"].forEach(function(t){e[t]=function(e){return this._invoke(t,e)}})}function S(e){var t;this._invoke=function(n,i){function a(){return new Promise(function(t,a){!function t(n,i,a,o){var s=w(e[n],e,i);if("throw"!==s.type){var u=s.arg,c=u.value;return c&&"object"==typeof c&&r.call(c,"__await")?Promise.resolve(c.__await).then(function(e){t("next",e,a,o)},function(e){t("throw",e,a,o)}):Promise.resolve(c).then(function(e){u.value=e,a(u)},function(e){return t("throw",e,a,o)})}o(s.arg)}(n,i,t,a)})}return t=t?t.then(a,a):a()}}function R(e,n){var r=e.iterator[n.method];if(r===t){if(n.delegate=null,"throw"===n.method){if(e.iterator.return&&(n.method="return",n.arg=t,R(e,n),"throw"===n.method))return d;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return d}var i=w(r,e.iterator,n.arg);if("throw"===i.type)return n.method="throw",n.arg=i.arg,n.delegate=null,d;var a=i.arg;return a?a.done?(n[e.resultName]=a.value,n.next=e.nextLoc,"return"!==n.method&&(n.method="next",n.arg=t),n.delegate=null,d):a:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,d)}function U(e){var t={tryLoc:e[0]};1 in e&&(t.catchLoc=e[1]),2 in e&&(t.finallyLoc=e[2],t.afterLoc=e[3]),this.tryEntries.push(t)}function M(e){var t=e.completion||{};t.type="normal",delete t.arg,e.completion=t}function A(e){this.tryEntries=[{tryLoc:"root"}],e.forEach(U,this),this.reset(!0)}function C(e){if(e){var n=e[a];if(n)return n.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var i=-1,o=function n(){for(;++i<e.length;)if(r.call(e,i))return n.value=e[i],n.done=!1,n;return n.value=t,n.done=!0,n};return o.next=o}}return{next:L}}function L(){return{value:t,done:!0}}}(function(){return this||"object"==typeof self&&self}()||Function("return this")());var c=new Uint8Array([88,0,0,0]),f=new Uint8Array([26,165,74,6,73,7,72,8,71,9,70,10,69,11,68,12,67,13,66,14,65]),h=new Uint8Array([24,255,1,0,0,0,0,0,0,0,0,0,0,0,0]),l=new Uint8Array([25,255,0,255,255,255,255]),p=new Uint8Array([27,255,0,0,0,0,0,0,0,0,0]),d={HEADER:c,INIT:f,DISCONNECT:new Uint8Array([84]),START_MEASUREMENTS:h,STOP_MEASUREMENTS:l,SET_MEASUREMENT_PERIOD:p,GET_INFO:new Uint8Array([85]),GET_STATUS:new Uint8Array([16]),GET_SENSOR_IDS:new Uint8Array([81]),GET_SENSOR_INFO:new Uint8Array([80,0]),GET_DEFAULT_SENSORS_MASK:new Uint8Array([86])},m=6,v=7,g=10,y=8,b=9,w=11,_=12,k=13,x=14,E=32,S=function(e){return 0!==e},R=function(){function e(){n(this,e),this._listenerMap=new Map}return i(e,[{key:"on",value:function(e,t){this._listenerMap.has(e)||this._listenerMap.set(e,[]),this._listenerMap.get(e).push(t)}},{key:"off",value:function(e,t){var n=this._listenerMap.get(e);if(n&&n.length){var r=n.reduce(function(e,n,r){return"function"==typeof n&&n===t?e=r:e},-1);if(r>-1)return n.splice(r,1),this._listenerMap.set(e,n),!0}return!1}},{key:"unbind",value:function(){this._listenerMap.clear()}},{key:"emit",value:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];var i=this._listenerMap.get(e);return!(!i||!i.length)&&(i.forEach(function(e){e.apply(void 0,n)}),!0)}}]),e}(),U=function(){},M=function(){};function A(e){return Array.from(new Uint8Array(e)).map(function(e){return e.toString(16).padStart(2,"0")}).join(" ")}var C,L=function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};n(this,e),this.type=t.type,this.mode=t.mode,this.minValue=t.minValue,this.maxValue=t.maxValue,this.uncertainty=t.uncertainty,this.minPeriod=t.minPeriod,this.maxPeriod=t.maxPeriod,this.typicalPeriod=t.typicalPeriod,this.granularity=t.granularity},P=function e(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};n(this,e),this.number=t.number,this.name=t.name,this.unit=t.unit,this.id=t.id,this.mutalExclusionMask=t.mutalExclusionMask,this.measurementInfo=t.measurementInfo},T=function(e){function t(e){var r;return n(this,t),(r=u(this,o(t).call(this))).number=e.number,r.name=e.name,r.unit=e.unit,r.specs=e,r.enabled=!1,r.values=[],r.value=null,r}return a(t,R),i(t,[{key:"clear",value:function(){this.value=null,this.values=[]}},{key:"setValue",value:function(e,t){this.value=e,t&&this.values.push(this.value),this.emit("value-changed",this)}},{key:"setEnabled",value:function(e){this.enabled!==e&&(this.enabled=e,this.emit("state-changed",this))}}]),t}(),N=function(e){function r(e){var t;if(n(this,r),t=u(this,o(r).call(this)),"undefined"==typeof TextDecoder){var i=__webpack_require__(/*! text-encoding */ "text-encoding");C=i.TextDecoder}else C=TextDecoder;return t.device=e,t.sensors=[],t.opened=!1,t.rollingCounter=0,t.collecting=!1,t.measurementPeriod=10,t.response=null,t.remainingResponseLength=0,t.defaultSensorsMask=0,t.keepValues=!0,t.minMeasurementPeriod=10,t.serialNumber="",t.orderCode="",t.name="",t}return a(r,R),i(r,[{key:"getBatteryLevel",value:function(){var e=t(regeneratorRuntime.mark(function e(){var t;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this._getStatus();case 2:return t=e.sent,e.abrupt("return",t.battery);case 4:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"getChargingState",value:function(){var e=t(regeneratorRuntime.mark(function e(){var t;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this._getStatus();case 2:return t=e.sent,e.abrupt("return",t.chargingStatus);case 4:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"open",value:function(){var e=t(regeneratorRuntime.mark(function e(){var t,n=arguments;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return t=n.length>0&&void 0!==n[0]&&n[0],e.prev=1,e.next=4,this._connect();case 4:return e.next=6,this._init();case 6:return e.next=8,this._getStatus();case 8:return e.next=10,this._getDeviceInfo();case 10:return e.next=12,this._getDefaultSensorsMask();case 12:return e.next=14,this._getAvailableSensors();case 14:this._onOpened(),t&&this.start(),e.next=21;break;case 18:e.prev=18,e.t0=e.catch(1),console.error(e.t0);case 21:case"end":return e.stop()}},e,this,[[1,18]])}));return function(){return e.apply(this,arguments)}}()},{key:"close",value:function(){var e=t(regeneratorRuntime.mark(function e(){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this._stopMeasurements();case 2:return e.next=4,this._sendCommand(d.DISCONNECT);case 4:return e.abrupt("return",this._disconnect());case 5:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"enableDefaultSensors",value:function(){for(var e=1,t=0;t<32;++t){if((this.defaultSensorsMask&e)===e){var n=this.getSensor(t);n&&n.setEnabled(!0)}e<<=1}}},{key:"start",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=this.sensors.filter(function(e){return e.enabled});0===t.length&&(this.enableDefaultSensors(),t=this.sensors.filter(function(e){return e.enabled})),t.forEach(function(e){return e.clear()}),e&&(this.measurementPeriod=e),this._startMeasurements()}},{key:"stop",value:function(){this._stopMeasurements()}},{key:"getSensor",value:function(e){return this.sensors.find(function(t){return t.number===e})}},{key:"_connect",value:function(){var e=t(regeneratorRuntime.mark(function e(){var t=this;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",this.device.setup({onClosed:function(){return t._onClosed()},onResponse:function(e){return t._handleResponse(e)}}));case 1:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"_disconnect",value:function(){var e=t(regeneratorRuntime.mark(function e(){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",this.device.close());case 1:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"_init",value:function(){return this.collecting=!1,this.rollingCounter=255,this.writeQueue=[],this._sendCommand(d.INIT)}},{key:"_handleResponse",value:function(e){if(U("command notified: ".concat(A(e.buffer))),this.remainingResponseLegnth>0){if(this.remainingResponseLegnth-=e.buffer.byteLength,this.response=new DataView((t=this.response.buffer,n=e.buffer.slice(0),(r=new Uint8Array(t.byteLength+n.byteLength)).set(new Uint8Array(t),0),r.set(new Uint8Array(n),t.byteLength),r.buffer)),this.remainingResponseLegnth>0)return}else this.response=e;var t,n,r,i=this.response.getUint8(1);if(i>this.response.buffer.byteLength)this.remainingResponseLegnth=i-this.response.buffer.byteLength;else switch(U("handle command: ".concat(A(this.response.buffer))),this.response.getUint8(0)){case E:this._processMeasurements(this.response);break;default:var a=this.response.getUint8(4),o=this.response.getUint8(5),s=new DataView(this.response.buffer,6);this._resolveWriteCommand(a,o,s),this.remainingResponseLegnth=0,this.response=null}}},{key:"_getSensorsWithMask",value:function(e){for(var t=[],n=1,r=0;r<32;++r){if((e&n)===n){var i=this.getSensor(r);i&&(t.push(i),U("available: [".concat(e,"] ").concat(t[t.length-1].number)))}n<<=1}return t}},{key:"_processMeasurements",value:function(e){var t=[],n=!0,r=0,i=0,a=e.getUint8(4);switch(a){case m:t=this._getSensorsWithMask(e.getUint16(5,!0)),r=e.getUint8(7,!0),i=9;break;case v:t=this._getSensorsWithMask(e.getUint32(5,!0)),r=e.getUint8(9,!0),i=11;break;case g:case y:t[0]=this.getSensor(e.getUint8(6)),r=e.getUint8(7,!0),i=8;break;case w:case b:t[0]=this.getSensor(e.getUint8(6)),r=e.getUint8(7,!0),i=8,n=!1;break;case _:case k:case x:U("Purposely Ignoring packet type: ".concat(a));break;default:U("Unknown packet type: ".concat(a))}for(var o=0;o<r;++o)for(var s=0;s<t.length;++s)n?t[s].setValue(e.getFloat32(i,!0),this.keepValues):t[s].setValue(e.getInt32(i,!0),this.keepValues),i+=4}},{key:"_resolveWriteCommand",value:function(e,t,n){var r=this.writeQueue.find(function(n){return n.command===e&&n.rollingCounter===t});r&&(r.resolve(n),this.writeQueue=this.writeQueue.filter(function(e){return e!==r}))}},{key:"_onOpened",value:function(){U("opened"),this.opened=!0,this.emit("device-opened")}},{key:"_onClosed",value:function(){U("closed"),this.opened=!1,this.emit("device-closed")}},{key:"_decRollingCounter",value:function(){return this.rollingCounter-=1,this.rollingCounter}},{key:"_calculateChecksum",value:function(e){for(var t=e[1],n=-1*e[3],r=0;r<t;++r)n+=e[r],n&=255;return n<0||n>255?(U("Checksum failed!"),0):n}},{key:"_sendCommand",value:function(e){var t=new Uint8Array(d.HEADER.byteLength+e.byteLength);return t.set(new Uint8Array(d.HEADER),0),t.set(new Uint8Array(e),d.HEADER.byteLength),t[1]=t.length,t[2]=this._decRollingCounter(),t[3]=this._calculateChecksum(t),this._queueWriteCommand(t,0,t.length)}},{key:"_writeCommand",value:function(){var e=t(regeneratorRuntime.mark(function e(t,n,r){var i;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(!(r>0)){e.next=12;break}return e.prev=1,r>20?(i=t.subarray(n,n+20),r-=20,n+=20):(i=t.subarray(n,n+r),r=0),e.next=5,this.device.writeCommand(i);case 5:e.next=10;break;case 7:e.prev=7,e.t0=e.catch(1),U("Write Failure: ".concat(e.t0));case 10:e.next=0;break;case 12:case"end":return e.stop()}},e,this,[[1,7]])}));return function(t,n,r){return e.apply(this,arguments)}}()},{key:"_queueWriteCommand",value:function(e,t,n){var r=this;U("command queued: ".concat(A(e)));var i=new Promise(function(t,n){r.writeQueue.push({command:e[4],rollingCounter:e[2],resolve:t,reject:n}),setTimeout(function(){r.writeQueue=r.writeQueue.filter(function(t){return t.command===e[4]&&t.rollingCounter!==e[2]}),n(new Error("write command timed out after 5s. Command: ".concat(e[4].toString(16)," Rolling Counter: ").concat(e[2].toString(16))))},1e4)});return this._writeCommand(e,t,n),i}},{key:"_getStatus",value:function(){var e=t(regeneratorRuntime.mark(function e(){var t,n;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this._sendCommand(d.GET_STATUS);case 2:return t=e.sent,n={masterFirmwareVersion:"".concat(t.getUint8(2),".").concat(t.getUint8(3)),bleFirmwareVersion:"".concat(t.getUint8(6),".").concat(t.getUint8(9)),battery:t.getUint8(10),chargingStatus:"".concat(t.getUint8(11))},e.abrupt("return",n);case 5:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"_getAvailableSensors",value:function(){var e=t(regeneratorRuntime.mark(function e(){var t,n,r=this;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this._sendCommand(d.GET_SENSOR_IDS).then(function(e){r.availableSensors=e.getUint32(0,!0),U("Get Available Sensors Returned ".concat(r.availableSensors))});case 2:t=1,n=0;case 4:if(!(n<31)){e.next=12;break}if((this.availableSensors&t)!==t){e.next=8;break}return e.next=8,this._getSensorInfo(n);case 8:t<<=1;case 9:++n,e.next=4;break;case 12:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"_getDefaultSensorsMask",value:function(){var e=this;return this._sendCommand(d.GET_DEFAULT_SENSORS_MASK).then(function(t){e.defaultSensorsMask=t.getUint32(0,!0),U("Default Sensors:"),M(e)})}},{key:"_getDeviceInfo",value:function(){var e=this;return this._sendCommand(d.GET_INFO).then(function(t){var n=new C("utf-8");e.orderCode=n.decode(new Uint8Array(t.buffer,6,16).filter(S)),e.serialNumber=n.decode(new Uint8Array(t.buffer,22,16).filter(S)),e.name=n.decode(new Uint8Array(t.buffer,38,32).filter(S)),U("Device Info:"),M(e)})}},{key:"_getSensorInfo",value:function(){var e=t(regeneratorRuntime.mark(function e(t){var n,r=this;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return(n=new Uint8Array(d.GET_SENSOR_INFO))[1]=t,e.abrupt("return",this._sendCommand(n).then(function(e){var t=e.getUint32(2,!0);if(t>0){var n=new C("utf-8"),i=new L({type:e.getUint8(6),mode:e.getUint8(7),minValue:e.getFloat64(108,!0),maxValue:e.getFloat64(116,!0),uncertainty:e.getFloat64(100,!0),minPeriod:e.getUint32(124,!0)/1e3,maxPeriod:((e.getUint32(132,!0)<<32)+e.getUint32(128,!0))/1e3,typicalPeriod:e.getUint32(136,!0)/1e3,granularity:e.getUint32(140,!0)/1e3}),a=new P({number:e.getUint8(0),name:n.decode(new Uint8Array(e.buffer,14,60).filter(S)),unit:n.decode(new Uint8Array(e.buffer,74,32).filter(S)),mutalExclusiveMask:e.getUint32(144,!0),measurementInfo:i,sensorId:t}),o=new T(a);U("Get Sensor Info Returned"),M(o),r.sensors.push(o),o.on("state-changed",function(){U("Sensor Restart: ".concat(o.number)),o.enabled&&(r.measurementPeriod=o.specs.measurementInfo.typicalPeriod,r.sensors.forEach(function(e){if(o.number!==e.number&&e.enabled){var t=1<<e.number;(t&o.specs.mutalExclusiveMask)===t?e.enabled=!1:e.specs.measurementInfo.typicalPeriod>r.measurementPeriod&&(r.measurementPeriod=e.specs.measurementInfo.typicalPeriod)}})),r._restartMeasurements()})}}));case 3:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"_restartMeasurements",value:function(){var e=t(regeneratorRuntime.mark(function e(){var t;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(t=this.collecting,!this.collecting){e.next=10;break}return e.prev=2,e.next=5,this._stopMeasurements();case 5:e.next=10;break;case 7:e.prev=7,e.t0=e.catch(2),console.error(e.t0);case 10:if(this.collecting||!t){e.next=19;break}return e.prev=11,e.next=14,this._startMeasurements();case 14:e.next=19;break;case 16:e.prev=16,e.t1=e.catch(11),console.error(e.t1);case 19:case"end":return e.stop()}},e,this,[[2,7],[11,16]])}));return function(){return e.apply(this,arguments)}}()},{key:"_setMeasurementPeriod",value:function(e){var t=new Uint8Array(d.SET_MEASUREMENT_PERIOD),n=1e3*this.minMeasurementPeriod;return e<n&&(e=n),U("MeasurementPeriod: ".concat(e)),t[3]=e>>0&255,t[4]=e>>8&255,t[5]=e>>16&255,t[6]=e>>24&255,this._sendCommand(t)}},{key:"_getEnabledChannelMask",value:function(){var e=0;return this.sensors.filter(function(e){return e.enabled}).forEach(function(t){e+=1<<t.number}),e}},{key:"_startMeasurements",value:function(){var e=this;return this._setMeasurementPeriod(1e3*this.measurementPeriod).then(function(){var t=e._getEnabledChannelMask();U("ChannelMask: ".concat(t));var n=new Uint8Array(d.START_MEASUREMENTS);return n[3]=t>>0&255,n[4]=t>>8&255,n[5]=t>>16&255,n[6]=t>>24&255,e._sendCommand(n).then(function(t){0===t.getUint8(0)&&(e.collecting=!0,e.emit("measurements-started"))})})}},{key:"_stopMeasurements",value:function(){var e=this;return this._sendCommand(d.STOP_MEASUREMENTS).then(function(t){0===t.getUint8(0)&&(e.collecting=!1,e.emit("measurements-stopped"))})}}]),r}(),O=function(){function e(t){n(this,e),this.webBluetoothNativeDevice=t,this.deviceCommand=null,this.deviceResponse=null}return i(e,[{key:"writeCommand",value:function(){var e=t(regeneratorRuntime.mark(function e(t){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",this.deviceCommand.writeValue(t));case 1:case"end":return e.stop()}},e,this)}));return function(t){return e.apply(this,arguments)}}()},{key:"setup",value:function(){var e=t(regeneratorRuntime.mark(function e(t){var n,r,i,a,o=this;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return n=t.onClosed,r=t.onResponse,this.webBluetoothNativeDevice.addEventListener("gattserverdisconnected",n),e.prev=2,e.next=5,this.webBluetoothNativeDevice.gatt.connect();case 5:return i=e.sent,e.next=8,i.getPrimaryService("d91714ef-28b9-4f91-ba16-f0d9a604f112");case 8:return a=e.sent,e.next=11,a.getCharacteristics();case 11:e.sent.forEach(function(e){switch(e.uuid){case"f4bf14a6-c7d5-4b6d-8aa8-df1a7c83adcb":o.deviceCommand=e;break;case"b41e6675-a329-40e0-aa01-44d2f444babe":o.deviceResponse=e,o.deviceResponse.addEventListener("characteristicvaluechanged",function(e){var t=e.target.value;r(t)}),o.deviceResponse.startNotifications();break;default:U("No case found for ".concat(e.uuid))}}),e.next=18;break;case 15:e.prev=15,e.t0=e.catch(2),console.error(e.t0);case 18:if(this.deviceCommand&&this.deviceResponse){e.next=20;break}throw new Error("Expected command and response characteristics not found.");case 20:case"end":return e.stop()}},e,this,[[2,15]])}));return function(t){return e.apply(this,arguments)}}()},{key:"close",value:function(){var e=t(regeneratorRuntime.mark(function e(){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",this.webBluetoothNativeDevice.gatt.disconnect());case 1:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()},{key:"godirectAdapter",get:function(){return!0}}]),e}(),D={createDevice:function(){var e=t(regeneratorRuntime.mark(function e(t){var n,r,i,a,o,s,u,c=arguments;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(n=c.length>1&&void 0!==c[1]?c[1]:{},r=n.open,i=void 0===r||r,a=n.startMeasurements,o=void 0===a||a,(s=t).godirectAdapter||(s=new O(t)),u=new N(s),!i){e.next=14;break}return e.prev=5,e.next=8,u.open(o);case 8:e.next=14;break;case 10:throw e.prev=10,e.t0=e.catch(5),console.error(e.t0),e.t0;case 14:return e.abrupt("return",u);case 15:case"end":return e.stop()}},e,this,[[5,10]])}));return function(t){return e.apply(this,arguments)}}(),selectDevice:function(){var e=t(regeneratorRuntime.mark(function e(){var t;return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(navigator.bluetooth){e.next=2;break}return e.abrupt("return",Promise.reject(new Error("No Web Bluetooth support.")));case 2:return e.next=4,navigator.bluetooth.requestDevice({filters:[{namePrefix:"GDX"}],optionalServices:["d91714ef-28b9-4f91-ba16-f0d9a604f112"]});case 4:return t=e.sent,e.abrupt("return",D.createDevice(t));case 6:case"end":return e.stop()}},e,this)}));return function(){return e.apply(this,arguments)}}()};return D});


/***/ }),

/***/ "./node_modules/atob/node-atob.js":
/*!****************************************!*\
  !*** ./node_modules/atob/node-atob.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function atob(str) {
  return Buffer.from(str, 'base64').toString('binary');
}

module.exports = atob.atob = atob;


/***/ }),

/***/ "./node_modules/base64-loader/index.js!./node_modules/scratch-render-fonts/src/Grand9K-Pixel.ttf":
/*!**********************************************************************************************!*\
  !*** ./node_modules/base64-loader!./node_modules/scratch-render-fonts/src/Grand9K-Pixel.ttf ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "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GgIaPhqAGrQa0hr+GyYbTBt6G6Ab0hv0HCYcWhyOHMIc6B0YHVQdYB2gHc4d9B4wHm4eoB7gHyAfSh90H7Af5iAYIF4gnCDCINAg3iDsIPohDiEiITYhUCFeIXghpCHOIgIiNAACAAAAAAUABwAAAwAHAAABESERAREhEQUA+wABAAMABwD5AAcA/v/7AQUAAAIAAAAAAQAHAAADAAcAADERIREBESERAQD/AAEAAQD/AAIABQD7AAACAAAFAAMABwAAAwAHAAAZASERIREhEQEAAQABAAUAAgD+AAIA/gAAAgAAAAAGAAcAAAMAHwAAAREhEQERIREhESERIREhESERIREhESERIREhESERIREEAP4A/wD/AAEA/wABAAEAAgABAAEA/wABAP8A/wD+AAIAAwD9AP4AAQABAAMAAQABAP8AAQD/AP8A/QD/AP8AAQD/AAADAAAAAAUABwAAAwAHACMAAAERIREBESERAREhESERIREhESERIREhESERIREhESERIREhEQQAAQD7AAEAAQD+AAIA/wABAP8AAQABAAIA/gABAP8AAQD/AAIAAQD/AAIAAQD/APwAAQABAAEAAQABAAEAAQD/AP8A/wD/AP8A/wD/AAAPAAAAAAcABwAAAwAHAAsADwATABcAGwAfACMAJwArAC8AMwA3ADsAADERIREhESERAREhGQIhEQERIREhESERAREhESERIREhESERAREhESERIREhESERAREhEQERIREhESERAQAEAAEA+wABAAEAAQABAAEAAQD6AAEAAQABAAEAAQD+AAEA+wABAAEAAQACAAEA+wABAAQAAQABAP8AAQD/AAEAAQD/AAEAAQD/AP8AAgD+AAIA/gACAAEA/wABAP8AAQD/AAEAAQD/AAIA/gACAP4AAQABAP8AAQABAP8AAQD/AAAABQAAAAAFAAcAAAMABwAPABMAFwAAIREhEQERIREhESERIREhEQERIRkCIREBAAMA/AABAAMA/QADAAEA+wABAAMAAQD/AAEAAgD+AAIAAQABAPwAAwACAP4AAgABAP8AAAAAAAEAAAUAAQAHAAADAAAZASERAQAFAAIA/gAAAAADAAAAAAMABwAAAwAHAAsAACERIREBESEZAiERAQACAP0AAQACAAEA/wABAAUA+wAFAAEA/wAAAAMAAAAAAwAHAAADAAcACwAAMREhGQIhEQERIRECAAEA/QACAAEA/wABAAUA+wAFAAEA/wAAAAAABQAAAgAFAAcAAAMABwALAA8AGwAAGQEhESERIREBESERIREhEQERIREhESERIREhEQEAAwABAPsAAQADAAEA/QD/AAEAAQABAP8AAwABAP8AAQD/AAIAAQD/AAEA/wD9AAIAAQACAP4A/wD+AAAAAAEAAAEABQAGAAALAAABESERIREhESERIRECAP4AAgABAAIA/gABAAIAAQACAP4A/wD+AAABAAD/AAEAAQAAAwAAGQEhEQEA/wACAP4AAAAAAQAAAwAEAAQAAAMAABkBIREEAAMAAQD/AAAAAAEAAAAAAQABAAADAAAxESERAQABAP8AAAMAAAAAAwAHAAADAAcACwAAMREhGQIhGQIhEQEAAQABAAIA/gACAAMA/QADAAIA/gAAAAAFAAAAAAUABwAAAwAHAA8AFwAbAAAhESERAREhEQERIREhESERIREhESERIREBESERAQADAP4AAQD9AAEAAQD/AAMA/wABAAEA/AADAAEA/wADAAEA/wD+AAUA/QD/AP8AAwABAAEA+wAFAAEA/wAAAQAAAAACAAcAAAUAACERIREhEQEA/wACAAYAAQD5AAAEAAAAAAUABwAABQAJAA0AEQAAMREhESERAREhGQIhEQERIREBAAQA/AADAAEA+wAEAAMA/gD/AAMAAQD/AAEAAgD+AAIAAQD/AAAABQAAAAAEAAcAAAMABwALAA8AEwAAMREhGQIhEQERIRkCIREBESERAwABAPwAAwABAPwAAwABAP8AAQACAP4AAgABAP8AAQACAP4AAgABAP8AAAAAAwAAAAAFAAcAAAMABwATAAABESEZAiERAREhESERIREhESERAQABAAEAAQD8AAEAAwD/AAIABAABAP8AAQABAP8A+wACAAIA/wADAAEA+QAAAAAAAwAAAAAFAAcAAAMABwAPAAAxESEZAiERAREhESERIREEAAEA+wAFAPwAAwABAP8AAQACAP4AAgAEAP8A/gD/AAAAAAAEAAAAAAUABwAAAwAHAA8AEwAAIREhGQIhESERIREhESEZAiERAQADAAEA+wABAAMA/QADAAEA/wABAAIA/gAFAP4A/wD+AAUAAQD/AAAAAAMAAAAABQAHAAADAAcADQAAIREhGQIhGQIhESERAgABAAEA/AAFAAMA/QADAAIA/gACAAEAAQD+AAAAAAcAAAAABQAHAAADAAcACwAPABMAFwAbAAAhESERAREhESERIREBESERAREhESERIREBESERAQADAPwAAQADAAEA/AADAPwAAQADAAEA/AADAAEA/wABAAIA/gACAP4AAgABAP8AAQACAP4AAgD+AAIAAQD/AAAAAAQAAAAABQAHAAADAAcADwATAAAhESERAREhEQERIREhESERAREhEQEAAwD8AAEAAwD9AAMAAQD8AAMAAQD/AAQAAgD+AP0AAgABAAIA+wAFAAEA/wAAAAACAAAAAAEABQAAAwAHAAAxESERAREhEQEA/wABAAEA/wAEAAEA/wAAAgAA/wABAAUAAAMABwAAGQEhEQERIREBAP8AAQD/AAIA/gAFAAEA/wAAAAAHAAAAAAQABwAAAwAHAAsADwATABcAGwAAIREhEQERIREBESERAREhGQIhGQIhGQIhEQMAAQD+AAEA/gABAP4AAQABAAEAAQABAP8AAQABAP8AAQABAP8AAQABAP8AAQABAP8AAQABAP8AAQABAP8AAAAAAAIAAAIABAAFAAADAAcAABkBIREBESERBAD8AAQAAgABAP8AAgABAP8AAAAABwAAAAAEAAcAAAMABwALAA8AEwAXABsAADERIRkCIRkCIRkCIREBESERAREhEQERIREBAAEAAQABAP4AAQD+AAEA/gABAAEA/wABAAEA/wABAAEA/wABAAEA/wABAAEA/wABAAEA/wABAAEA/wAAAAUAAAAABAAHAAADAAcACwAPABMAACERIREBESEZAiEZAiERAREhEQEAAQD/AAEAAQABAPwAAwABAP8AAgABAP8AAQABAP8AAQACAP4AAgABAP8AAAYAAP8ABwAHAAADAAcAEQAVABkAHQAAAREhEQERIRkCIREhESERIREBESERAREhEQERIREBAAUA/AABAAEA/wACAAEA+gABAAUAAQD6AAUA/wABAP8AAwACAP4A/wABAAIAAQD9AP8A/wAGAPoAAgAEAPwABAABAP8AAAACAAAAAAUABwAACwAPAAAxESERIREhESERIRkCIREBAAMAAQD/AP0AAwAGAP0AAwD6AAIA/gAGAAEA/wAAAAAAAwAAAAAFAAcAAAMABwATAAABESERAREhEQERIREhESERIREhEQQAAQD/AAEA+wAEAP0AAwD9AAMAAQACAP4AAwACAP4A/AAHAP8A/gD/AP4A/wAAAwAAAAAEAAcAAAMABwALAAAhESERAREhGQIhEQEAAwD8AAEAAwABAP8AAQAFAPsABQABAP8AAAACAAAAAAUABwAAAwALAAABESERAREhESERIREEAAEA+wAEAP0AAwABAAUA+wD/AAcA/wD7AP8AAAEAAAAABAAHAAALAAAxESERIREhESERIREEAP0AAwD9AAMABwD/AP4A/wD+AP8AAAEAAAAABAAHAAAJAAAxESERIREhESERBAD9AAMA/QAHAP8A/gD/AP0AAAAAAwAAAAAFAAcAAAcACwAPAAAhESERIREhEQERIRkCIREBAAMA/wACAPsAAQAEAAEAAgABAPwAAQAFAPsABQABAP8AAAABAAAAAAUABwAACwAAMREhESERIREhESERAQADAAEA/wD9AAcA/QADAPkAAwD9AAABAAAAAAEABwAAAwAAMREhEQEABwD5AAACAAAAAAUABwAAAwAHAAAxESEZAiERBAABAAEA/wABAAYA+gAAAAAABwAAAAAFAAcAAAMABwALAA8AEwAbAB8AACERIREBESERAREhEQERIRkCIREBESERIREhEQERIREEAAEA/gABAP4AAQD/AAEAAQD8AAEAAQD/AAMAAQABAP8AAQABAP8AAQABAP8AAgABAP8AAQABAP8A+wAHAP0A/wD9AAYAAQD/AAAAAQAAAAAFAAcAAAUAADERIREhEQEABAAHAPoA/wAAAAADAAAAAAUABwAAAwALABMAAAERIREBESERIREhESERIREhESERAgABAP0AAQABAP8AAwD/AAEAAQAEAAEA/wD8AAcA/wD/APsABQABAAEA+QAAAAADAAAAAAUABwAAAwALABMAAAERIREBESERIREhESERIREhESERAgABAP0AAQABAP8AAwD/AAEAAQAEAAEA/wD8AAcA/wD/APsAAwABAAMA+QAAAAAEAAAAAAUABwAAAwAHAAsADwAAIREhEQERIREhESERAREhEQEAAwD8AAEAAwABAPwAAwABAP8AAQAFAPsABQD7AAUAAQD/AAACAAAAAAUABwAAAwANAAABESERAREhESERIREhEQQAAQD7AAQA/QADAP0AAwADAP0A/QAHAP8A/QD/AP4AAAAABQAA/wAGAAcAAAMABwALAA8AEwAAAREhEQERIREBESERIREhEQERIREEAAIA+wADAPwAAQADAAEA/AADAP8AAQD/AAEAAQD/AAEABQD7AAUA+wAFAAEA/wAAAAADAAAAAAUABwAAAwAHABEAACERIREBESERAREhESERIREhEQQAAQD/AAEA+wAEAP0AAwD9AAIA/gADAAMA/QD9AAcA/wD9AP8A/gAABQAAAAAFAAcAAAMABwALAA8AEwAAMREhGQIhEQERIREBESEZAiERBAABAPwAAwD8AAEABAABAP8AAQACAP4AAgABAP8AAQACAP4AAgABAP8AAAAAAQAAAAAFAAcAAAcAACERIREhESERAgD+AAUA/gAGAAEA/wD6AAAAAAMAAAAABQAHAAADAAcACwAAIREhEQERIREhESERAQADAPwAAQADAAEAAQD/AAEABgD6AAYA+gAABQAAAAAFAAcAAAMABwALAA8AEwAAIREhEQERIREhESERAREhESERIRECAAEA/gABAAEAAQD8AAEAAwABAAEA/wABAAEA/wABAP8AAQAFAPsABQD7AAAAAAMAAAAABQAHAAADAAsAEwAAAREhEQERIREhESERIREhESERIRECAAEA/QABAAEA/wADAP8AAQABAAIAAQD/AP4ABwD7AP8A/wABAAEABQD5AAAAAAkAAAAABQAHAAADAAcACwAPABMAFwAbAB8AIwAAMREhESERIREBESERIREhEQERIREBESERIREhEQERIREhESERAQADAAEA/AABAAEAAQD+AAEA/gABAAEAAQD8AAEAAwABAAIA/gACAP4AAgABAP8AAQD/AAEAAQD/AAEAAQD/AAEA/wABAAIA/gACAP4AAAMAAAAABQAHAAAHAAsADwAAIREhESERIREBESERIREhEQIA/wADAP8A/QABAAMAAQADAAEA/wD9AAQAAwD9AAMA/QAABQAAAAAFAAcAAAUACQANABEAFwAAMREhESERAREhGQIhGQIhGQIhESERAQAEAPwAAQABAAEA/AAFAAIA/wD/AAIAAQD/AAEAAQD/AAEAAQD/AAEAAQABAP4AAAABAAAAAAMABwAABwAAMREhESERIREDAP4AAgAHAP8A+wD/AAADAAAAAAMABwAAAwAHAAsAACERIREBESERAREhEQIAAQD+AAEA/gABAAIA/gACAAMA/QADAAIA/gAAAAABAAAAAAMABwAABwAAMREhESERIRECAP4AAwABAAUAAQD5AAAFAAAEAAUABwAAAwAHAAsADwATAAAZASERIREhEQERIREhESERAREhEQEAAwABAPwAAQABAAEA/gABAAQAAQD/AAEA/wABAAEA/wABAP8AAQABAP8AAAAAAQAA/wAEAAAAAAMAABkBIREEAP8AAQD/AAAAAAIAAAUAAgAHAAADAAcAAAERIREBESERAQABAP4AAQAFAAEA/wABAAEA/wAAAwAAAAAEAAUAAAMADQARAAAZASEZAiERIREhESERAREhEQEAAgD+AAIAAQD9AAIAAQABAP8A/wABAAEAAQABAPwABAABAP8AAAAAAAIAAAAABAAHAAADAA0AAAERIREBESERIREhESERAwABAPwAAQACAP4AAgABAAMA/QD/AAcA/gD/AP0A/wAAAAADAAAAAAMABQAAAwAHAAsAACERIREBESEZAiERAQACAP0AAQACAAEA/wABAAMA/QADAAEA/wAAAAIAAAAABAAHAAADAA0AABkBIRkCIREhESERIREBAAIA/gACAAEAAQADAP0A/wABAAMAAQACAPkAAAAAAAMAAAAABAAFAAADAA0AEQAAIREhEQERIREhESERIRkCIREBAAMA/AABAAIAAQD9AAIAAQD/AAEAAwD/AAEA/gD/AAMAAQD/AAAAAAACAAAAAAQABwAACwAPAAAhESERIREhESERIRkCIREBAP8AAQABAAIA/gACAAQAAQABAP8A/wD8AAYAAQD/AAAAAwAA/wAEAAUAAAMABwARAAAZASERAREhEQERIREhESERIREDAP0AAQACAP4AAgD+AAMA/wABAP8AAwACAP4A/gABAAEAAgABAPsAAAIAAAAABAAHAAADAAsAACERIREhESERIREhEQMAAQD8AAEAAgD+AAQA/AAHAP4A/wD8AAACAAAAAAEABwAAAwAHAAAxESERAREhEQEA/wABAAUA+wAGAAEA/wAAAwAA/wADAAcAAAMABwALAAAZASEZAiERAREhEQIAAQD/AAEA/wABAP8AAQAFAPsABgABAP8AAAAFAAAAAAQABwAAAwAHAAsADwAXAAAhESERAREhEQERIRkCIREBESERIREhEQMAAQD+AAEA/wABAAEA/AABAAEA/wABAP8AAQABAP8AAgABAP8AAQABAP8A/AAHAPwA/wD+AAAAAQAAAAABAAcAAAMAADERIREBAAcA+QAABAAAAAAFAAUAAAMABwANABEAAAERIREBESERIREhESERAREhEQIAAQABAAEA+wACAP8AAgABAAEAAwD9AP8ABAD8AAUA/wD8AAQAAQD/AAACAAAAAAQABQAAAwAJAAAhESERIREhESERAwABAPwAAwD+AAQA/AAFAP8A/AAAAAAEAAAAAAQABQAAAwAHAAsADwAAIREhEQERIREhESERAREhEQEAAgD9AAEAAgABAP0AAgABAP8AAQADAP0AAwD9AAMAAQD/AAACAAD/AAQABQAAAwANAAABESERAREhESERIREhEQMAAQD8AAMA/gACAP4AAQADAP0A/gAGAP8A/QD/AP8AAAAAAgAA/wAEAAUAAAMADQAAGQEhEQERIREhESERIREBAAIA/gACAP4AAwABAAMA/QD+AAEAAQADAAEA+gAAAgAAAAAEAAUAAAcACwAAMREhESERIREBESERAQABAP8AAQACAAUA/wD/AP0ABAABAP8AAAUAAAAABAAFAAADAAcACwAPABMAADERIRkCIREBESERAREhGQIhEQMAAQD9AAIA/QABAAMAAQD/AAEAAQD/AAEAAQD/AAEAAQD/AAEAAQD/AAAAAAIAAAAABAAHAAADAA8AACERIREBESERIREhESERIRECAAIA/QD/AAEAAQACAP4AAQD/AAEAAwABAAIA/gD/AP0AAAAAAgAAAAAEAAUAAAMACQAAGQEhGQIhESERAQACAAEAAQAEAPwA/wABAAQA+wAAAAAABQAAAAAFAAUAAAMABwALAA8AEwAAIREhEQERIREhESERAREhESERIRECAAEA/gABAAEAAQD8AAEAAwABAAEA/wABAAEA/wABAP8AAQADAP0AAwD9AAAAAAUAAAAABQAFAAADAAcACwAPABMAACERIREhESERAREhESERIREhESERAQABAAEAAQD+AAEA/QABAAMAAQABAP8AAQD/AAEAAwD9AAQA/AAEAPwAAAkAAAAABQAFAAADAAcACwAPABMAFwAbAB8AIwAAMREhESERIREBESERIREhEQERIREBESERIREhEQERIREhESERAQADAAEA/AABAAEAAQD+AAEA/gABAAEAAQD8AAEAAwABAAEA/wABAP8AAQABAP8AAQD/AAEAAQD/AAEAAQD/AAEA/wABAAEA/wABAP8AAAMAAP8ABAAFAAADAAcADwAAGQEhEQERIREBESERIREhEQMA/QABAAIA/gACAAEA/wABAP8AAwADAP0A/gABAAEAAwD7AAAAAAMAAAAABQAFAAAHAAsAEwAAMREhESERIREBESEZAiERIREhEQEAAQADAP0AAQD9AAUA/wABAAEA/wD/AAIAAQD/AAEAAQABAP8A/wAAAAAABQAAAAAEAAcAAAMABwALAA8AEwAAIREhEQERIREBESEZAiEZAiERAgACAP0AAQD+AAEAAQACAAEA/wABAAIA/gACAAEA/wABAAIA/gACAAEA/wAAAQAAAAABAAcAAAMAADERIREBAAcA+QAABQAAAAAEAAcAAAMABwALAA8AEwAAMREhGQIhGQIhEQERIREBESERAgABAAEA/gABAP0AAgABAP8AAQACAP4AAgABAP8AAQACAP4AAgABAP8AAAAABAAABQAGAAcAAAMABwALAA8AABkBIREhESERAREhESERIREBAAIAAgD8AAIAAgABAAUAAQD/AAEA/wABAAEA/wABAP8AAAAAAgAAAAABAAcAAAMABwAAMREhEQERIREBAP8AAQAFAPsABgABAP8AAAIAAAAABAAHAAADABcAABkBIREBESERIREhESERIREhESERIREhEQEAAQD/AAEA/wABAAEAAQD/AAEA/wACAAMA/QD+AAEAAQADAAEAAQD/AP8A/QD/AP8AAAAAAgAAAAAFAAcAAA8AEwAAMREhESERIREhESERIREhEQERIREBAP8AAQABAAIA/gADAP0AAwABAAIAAQACAP4A/wD+AP8ABgABAP8AAAMAAP8ABQAHAAAXABsAHwAAAREhESERIREhESERIREhESERIREhESERAREhESERIRECAP4AAgD+AAIA/wADAP8AAgD+AAIA/gD9AAEAAwABAP8AAQABAAEAAQABAAEA/wD/AP8A/wD/AP8ABgACAP4AAgD+AAAAAAIAAAAAAQAHAAADAAcAADERIREBESERAQD/AAEAAwD9AAQAAwD9AAACAAAGAAMABwAAAwAHAAAZASERIREhEQEAAQABAAYAAQD/AAEA/wAACwAA/wAIAAcAAAMABwALAA8AEwAXABsAHwAjACcAKwAAAREhEQERIREhESERAREhEQERIREBESERAREhEQERIREBESERIREhEQERIRECAAQA+wABAAQAAQD8AAIA/QABAP0AAQACAAIAAgABAPkAAQAEAAEA+wAEAP8AAQD/AAEAAQD/AAEA/wABAAEA/wABAAIA/gD/AAQA/AADAAEA/wD9AAQA/AAEAAEA/wABAP8AAQABAP8AAAoAAAEABgAGAAADAAcACwAPABMAFwAbAB8AIwAnAAABESERIREhEQERIREhESERAREhESERIREBESERIREhEQERIREhESERAgABAAIAAQD7AAEAAgABAPsAAQACAAEA/QABAAIAAQD9AAEAAgABAAEAAQD/AAEA/wABAAEA/wABAP8AAQABAP8AAQD/AAEAAQD/AAEA/wABAAEA/wABAP8AAAAAAQAAAQAEAAQAAAUAAAERIREhEQMA/QAEAAEAAgABAP0AAAAACwAA/wAIAAcAAAMABwALAA8AEwAXACEAJQApAC0AMQAAAREhEQERIREhESERAREhEQERIREBESERIREhESERIREhESERIREBESERIREhEQERIRECAAQA+wABAAQAAQD+AAEA/wABAPoAAQABAAMA/gACAP4ABAABAPkAAQAEAAEA+wAEAP8AAQD/AAEAAQD/AAEA/wABAAEA/wACAAEA/wD+AAQA/AAEAP8A/wD/AP8ABAD8AAQAAQD/AAEA/wABAAEA/wAAAAAEAAAEAAMABwAAAwAHAAsADwAAAREhEQERIREhESERAREhEQEAAQD+AAEAAQABAP4AAQAEAAEA/wABAAEA/wABAP8AAQABAP8AAAAAAgAAAAAFAAcAAAMADwAAMREhEQERIREhESERIREhEQUA/QD+AAIAAQACAP4AAQD/AAIAAgABAAIA/gD/AP4AAAIAAAUAAgAHAAADAAcAABkBIRkCIREBAAEABQABAP8AAQABAP8AAAACAAD/AAQABQAABwALAAAZASERIREhEQERIREBAAIA/gACAAEA/wAGAPwA/wD/AAIABAD8AAAAAAEAAP8ABQAHAAANAAABESERIREhESERIREhEQIA/wD/AAEABAD/AP8A/wAEAAEAAgABAPgABwD5AAAAAAEAAAMAAQAEAAADAAAZASERAQADAAEA/wAAAAACAAD+AAIAAAAAAwAHAAAZASEZAiERAQABAP4AAQD/AAEAAQD/AAAACgAAAQAGAAYAAAMABwALAA8AEwAXABsAHwAjACcAABkBIREhESERAREhESERIREBESERIREhEQERIREhESERAREhESERIREBAAIAAQD9AAEAAgABAP0AAQACAAEA+wABAAIAAQD7AAEAAgABAAEAAQD/AAEA/wABAAEA/wABAP8AAQABAP8AAQD/AAEAAQD/AAEA/wABAAEA/wABAP8AAAUAAAAABAAHAAADAAcACwAPABMAACERIREBESEZAiEZAiERAREhEQEAAwD8AAEAAQABAP8AAQABAP8AAQACAP4AAgABAP8AAQABAP8AAgABAP8AAAQAAAAABQAKAAALAA8AEwAXAAAxESERIREhESERIRkCIREBESERAREhEQEAAwABAP8A/QADAP4AAQD+AAEABgD9AAMA+gACAP4ABgABAP8AAgABAP8AAQABAP8AAAAAAAQAAAAABQAKAAALAA8AEwAXAAAxESERIREhESERIRkCIREBESEZAiERAQADAAEA/wD9AAMA/gABAAEABgD9AAMA+gACAP4ABgABAP8AAgABAP8AAQABAP8AAAAABQAAAAAFAAoAAAsADwATABcAGwAAMREhESERIREhESEZAiERAREhESERIREBESERAQADAAEA/wD9AAMA/QABAAEAAQD+AAEABgD9AAMA+gACAP4ABgABAP8AAgABAP8AAQD/AAEAAQD/AAAABgAAAAAGAAoAAAsADwATABcAGwAfAAAxESERIREhESERIRkCIREBESERIREhEQERIREhESERAQADAAEA/wD9AAMA/AABAAIAAgD8AAIAAgABAAYA/QADAPoAAgD+AAYAAQD/AAIAAQD/AAEA/wABAAEA/wABAP8AAAAAAAQAAAAABQAJAAALAA8AEwAXAAAxESERIREhESERIRkCIREBESERIREhEQEAAwABAP8A/QADAPwAAQADAAEABgD9AAMA+gACAP4ABgABAP8AAgABAP8AAQD/AAAABQAAAAAFAAoAAAsAEwAXABsAHwAAMREhESERIREhESEZAiERIREhEQERIREhESERAREhEQEAAwABAP8A/QABAAEAAQD9AAEAAQABAP4AAQAGAP0AAwD6AAIA/gAGAAEAAQD/AP8AAgABAP8AAQD/AAEAAQD/AAAAAQAAAAAGAAcAABUAADERIREhESERIREhESERIREhESERIREBAAIA/gAFAP4AAgD+AAIA/QD+AAYA/QADAAEA/wD+AP8A/gD/AAIA/gAAAAAEAAD+AAQABwAAAwALAA8AEwAAAREhGQIhESERIREBESEZAiERAQABAP8AAwD/AP0AAQADAP4AAQD/AAEAAQABAP8A/wACAAUA+wAFAAEA/wAAAAADAAAAAAQACgAACwAPABMAADERIREhESERIREhEQERIREBESERBAD9AAMA/QADAP4AAQD+AAEABwD/AP4A/wD+AP8ACAABAP8AAQABAP8AAAMAAAAABAAKAAALAA8AEwAAMREhESERIREhESERAREhGQIhEQQA/QADAP0AAwD9AAEAAQAHAP8A/gD/AP4A/wAIAAEA/wABAAEA/wAAAAAABAAAAAAEAAoAAAsADwATABcAADERIREhESERIREhEQERIREhESERAREhEQQA/QADAP0AAwD9AAEAAQABAP4AAQAHAP8A/gD/AP4A/wAIAAEA/wABAP8AAQABAP8AAAAAAwAAAAAEAAkAAAsADwATAAAxESERIREhESERIREBESERIREhEQQA/QADAP0AAwD8AAEAAgABAAcA/wD+AP8A/gD/AAgAAQD/AAEA/wAAAAADAQAAAAMACgAAAwAHAAsAACERIREBESEZAiERAQABAP8AAQABAAcA+QAIAAEA/wABAAEA/wAAAAMAAAAAAgAKAAADAAcACwAAIREhEQERIREBESERAQABAP8AAQD+AAEABwD5AAgAAQD/AAEAAQD/AAAAAAQAAAAAAwAKAAADAAcACwAPAAAhESERAREhESERIREBESERAQABAP4AAQABAAEA/gABAAcA+QAIAAEA/wABAP8AAQABAP8AAAMAAAAAAwAJAAADAAcACwAAIREhEQERIREhESERAQABAP4AAQABAAEABwD5AAgAAQD/AAEA/wAAAgAAAAAGAAcAAAMAEwAAAREhEQERIREhESERIREhESERIREFAAEA+wD/AAEABAD9AAEA/wADAAEABQD7AP8AAwABAAMA/wD+AP8A/gD/AAAHAAAAAAYACgAAAwALABMAFwAbAB8AIwAAAREhEQERIREhESERIREhESERIREBESERIREhEQERIREhESERAgABAP0AAQABAP8AAwD/AAEAAQD7AAEAAgACAPwAAgACAAEABAABAP8A/AAHAP8A/wD7AAMAAQADAPkACAABAP8AAQD/AAEAAQD/AAEA/wAAAAAGAAAAAAUACgAAAwAHAAsADwATABcAACERIREBESERIREhEQERIREBESERAREhEQEAAwD8AAEAAwABAPwAAwD+AAEA/gABAAEA/wABAAUA+wAFAPsABQABAP8AAgABAP8AAQABAP8AAAYAAAAABQAKAAADAAcACwAPABMAFwAAIREhEQERIREhESERAREhEQERIRkCIREBAAMA/AABAAMAAQD8AAMA/gABAAEAAQD/AAEABQD7AAUA+wAFAAEA/wACAAEA/wABAAEA/wAAAAAABwAAAAAFAAoAAAMABwALAA8AEwAXABsAACERIREBESERIREhEQERIREBESERIREhEQERIREBAAMA/AABAAMAAQD8AAMA/QABAAEAAQD+AAEAAQD/AAEABQD7AAUA+wAFAAEA/wACAAEA/wABAP8AAQABAP8AAAAACAAAAAAGAAoAAAMABwALAA8AEwAXABsAHwAAIREhEQERIREhESERAREhEQERIREhESERAREhESERIREBAAMA/AABAAMAAQD8AAMA/AABAAIAAgD8AAIAAgABAAEA/wABAAUA+wAFAPsABQABAP8AAgABAP8AAQD/AAEAAQD/AAEA/wAABgAAAAAFAAkAAAMABwALAA8AEwAXAAAhESERAREhESERIREBESERAREhESERIREBAAMA/AABAAMAAQD8AAMA/AABAAMAAQABAP8AAQAFAPsABQD7AAUAAQD/AAIAAQD/AAEA/wAAAAAJAAABAAUABgAAAwAHAAsADwATABcAGwAfACMAABkBIREhESERAREhESERIREBESERAREhESERIREBESERIREhEQEAAwABAPwAAQABAAEA/gABAP4AAQABAAEA/AABAAMAAQABAAEA/wABAP8AAQABAP8AAQD/AAEAAQD/AAEAAQD/AAEA/wABAAEA/wABAP8AAAAABQAAAAAFAAcAAAMABwAPABcAGwAAIREhEQERIREBESERIREhESERIREhESERAREhEQEAAwD+AAEA/QABAAEA/wADAP8AAQABAPwAAwABAP8AAwABAP8A/gAFAP0A/wD/AAMAAQABAPsABQABAP8AAAUAAAAABQAKAAADAAcACwAPABMAACERIREBESERIREhEQERIREBESERAQADAPwAAQADAAEA/QABAP4AAQABAP8AAQAGAPoABgD6AAcAAQD/AAEAAQD/AAAFAAAAAAUACgAAAwAHAAsADwATAAAhESERAREhESERIREBESEZAiERAQADAPwAAQADAAEA/QABAAEAAQD/AAEABgD6AAYA+gAHAAEA/wABAAEA/wAAAAAABgAAAAAFAAoAAAMABwALAA8AEwAXAAAhESERAREhESERIREBESERIREhEQERIREBAAMA/AABAAMAAQD8AAEAAQABAP4AAQABAP8AAQAGAPoABgD6AAcAAQD/AAEA/wABAAEA/wAAAAAFAAAAAAUACQAAAwAHAAsADwATAAAhESERAREhESERIREBESERIREhEQEAAwD8AAEAAwABAPsAAQADAAEAAQD/AAEABgD6AAYA+gAHAAEA/wABAP8AAAAABQAAAAAFAAoAAAcACwAPABMAFwAAIREhESERIREBESERIREhEQERIRkCIRECAP8AAwD/AP0AAQADAAEA/QABAAEAAwABAP8A/QAEAAMA/QADAP0ABAABAP8AAQABAP8AAAAAAAIAAAAABQAHAAADAA8AAAERIREBESERIREhESERIREEAAEA+wABAAMA/QADAP0AAgADAP0A/gAHAP8A/wD9AP8A/wAABgAAAAAFAAcAAAMABwALAA8AEwAXAAAhESEZAiERAREhEQERIREBESERAREhEQIAAgABAP0AAgD8AAEAAwABAPwAAwABAP8AAQACAP4AAgABAP8A/QAGAPoABAACAP4AAgABAP8AAAAFAAAAAAQACAAAAwANABEAFQAZAAAZASEZAiERIREhESERAREhEQERIREBESERAQACAP4AAgABAP0AAgD/AAEA/gABAAEAAQD/AP8AAQABAAEAAQD8AAQAAQD/AAIAAQD/AAEAAQD/AAAAAAAFAAAAAAQACAAAAwANABEAFQAZAAAZASEZAiERIREhESERAREhEQERIRkCIREBAAIA/gACAAEA/QACAP4AAQABAAEAAQD/AP8AAQABAAEAAQD8AAQAAQD/AAIAAQD/AAEAAQD/AAAAAAYAAAAABAAIAAADAA0AEQAVABkAHQAAGQEhGQIhESERIREhEQERIREBESERIREhEQERIREBAAIA/gACAAEA/QACAP4AAQABAAEA/gABAAEAAQD/AP8AAQABAAEAAQD8AAQAAQD/AAIAAQD/AAEA/wABAAEA/wAAAAcAAAAABAAIAAADAA0AEQAVABkAHQAhAAAZASEZAiERIREhESERAREhEQERIREhESERAREhESERIREBAAIA/gACAAEA/QACAP0AAQABAAEA/gABAAEAAQABAAEA/wD/AAEAAQABAAEA/AAEAAEA/wACAAEA/wABAP8AAQABAP8AAQD/AAAAAAAFAAAAAAQABwAAAwANABEAFQAZAAAZASEZAiERIREhESERAREhEQERIREhESERAQACAP4AAgABAP0AAgD9AAEAAgABAAEAAQD/AP8AAQABAAEAAQD8AAQAAQD/AAIAAQD/AAEA/wAAAAcAAAAABAAJAAADAA0AEQAVABkAHQAhAAAZASEZAiERIREhESERAREhEQERIREBESERIREhEQERIREBAAIA/gACAAEA/QACAP8AAQD+AAEAAQABAP4AAQABAAEA/wD/AAEAAQABAAEA/AAEAAEA/wACAAEA/wABAAEA/wABAP8AAQABAP8AAAAEAAAAAAUABQAAAwAVABkAHQAAGQEhGQIhESERIREhESERIREhESERAREhESERIREBAAEA/wABAAEAAQABAP4AAgD8AAEAAQABAAEAAQD/AP8AAQABAAEAAQD/AAEA/gD/AP8ABAABAP8AAQD/AAAABAAA/gADAAUAAAMACQANABEAABkBIRkCIREhEQERIRkCIREBAAIA/wD+AAEAAgD+AAEA/wABAAIA/wD/AAIAAwD9AAMAAQD/AAAAAAUAAAAABAAIAAADAA0AEQAVABkAACERIREBESERIREhESEZAiERAREhEQERIREBAAMA/AABAAIAAQD9AAIA/wABAP4AAQABAP8AAQADAP8AAQD+AP8AAwABAP8AAgABAP8AAQABAP8AAAAAAAUAAAAABAAIAAADAA0AEQAVABkAACERIREBESERIREhESEZAiERAREhGQIhEQEAAwD8AAEAAgABAP0AAgD+AAEAAQABAP8AAQADAP8AAQD+AP8AAwABAP8AAgABAP8AAQABAP8AAAAABgAAAAAEAAgAAAMADQARABUAGQAdAAAhESERAREhESERIREhGQIhEQERIREhESERAREhEQEAAwD8AAEAAgABAP0AAgD+AAEAAQABAP4AAQABAP8AAQADAP8AAQD+AP8AAwABAP8AAgABAP8AAQD/AAEAAQD/AAAABQAAAAAEAAcAAAMADQARABUAGQAAIREhEQERIREhESERIRkCIREBESERIREhEQEAAwD8AAEAAgABAP0AAgD9AAEAAgABAAEA/wABAAMA/wABAP4A/wADAAEA/wACAAEA/wABAP8AAAADAAAAAAIACAAAAwAHAAsAACERIREBESERAREhEQEAAQD/AAEA/gABAAUA+wAGAAEA/wABAAEA/wAAAAADAQAAAAMACAAAAwAHAAsAACERIREBESEZAiERAQABAP8AAQABAAUA+wAGAAEA/wABAAEA/wAAAAQAAAAAAwAIAAADAAcACwAPAAAhESERAREhESERIREBESERAQABAP4AAQABAAEA/gABAAUA+wAGAAEA/wABAP8AAQABAP8AAAMAAAAAAwAHAAADAAcACwAAIREhEQERIREhESERAQABAP4AAQABAAEABQD7AAYAAQD/AAEA/wAAAgAAAAAFAAgAAAMAFQAAGQEhGQIhESERIREhESERIREhESERAQACAP4AAgD/AAEAAQABAP8AAQADAP0A/wABAAMAAQABAAEAAQD/AP8A+gAAAAAABgAAAAAEAAgAAAMACQANABEAFQAZAAAhESERIREhESERAREhESERIREBESERIREhEQMAAQD8AAMA/gD/AAEAAQABAP4AAQABAAEABAD8AAUA/wD8AAYAAQD/AAEA/wABAAEA/wABAP8AAAAABgAAAAAEAAgAAAMABwALAA8AEwAXAAAhESERAREhESERIREBESERAREhEQERIREBAAIA/QABAAIAAQD9AAIA/wABAP4AAQABAP8AAQADAP0AAwD9AAMAAQD/AAIAAQD/AAEAAQD/AAAGAAAAAAQACAAAAwAHAAsADwATABcAACERIREBESERIREhEQERIREBESEZAiERAQACAP0AAQACAAEA/QACAP4AAQABAAEA/wABAAMA/QADAP0AAwABAP8AAgABAP8AAQABAP8AAAAAAAcAAAAABAAIAAADAAcACwAPABMAFwAbAAAhESERAREhESERIREBESERAREhESERIREBESERAQACAP0AAQACAAEA/QACAP4AAQABAAEA/gABAAEA/wABAAMA/QADAP0AAwABAP8AAgABAP8AAQD/AAEAAQD/AAAAAAgAAAAABAAIAAADAAcACwAPABMAFwAbAB8AACERIREBESERIREhEQERIREBESERIREhEQERIREhESERAQACAP0AAQACAAEA/QACAP0AAQABAAEA/gABAAEAAQABAP8AAQADAP0AAwD9AAMAAQD/AAIAAQD/AAEA/wABAAEA/wABAP8AAAYAAAAABAAHAAADAAcACwAPABMAFwAAIREhEQERIREhESERAREhEQERIREhESERAQACAP0AAQACAAEA/QACAP0AAQACAAEAAQD/AAEAAwD9AAMA/QADAAEA/wACAAEA/wABAP8AAAAAAwAAAQAFAAYAAAMABwALAAABESERAREhEQERIRECAAEA/QAFAP0AAQABAAEA/wACAAEA/wACAAEA/wAAAwAAAAAEAAUAAAMACwAVAAAhESERAREhESERIREhESERIREhESERAQACAP0AAQABAP8AAgD/AP8AAgABAAEA/wABAAMA/wD/AP8AAgABAAEA/wD9AAAAAAQAAAAABAAIAAADAAkADQARAAAZASEZAiERIREBESERAREhEQEAAgABAP4AAQD+AAEAAQAEAPwA/wABAAQA+wAGAAEA/wABAAEA/wAAAAAABAAAAAAEAAgAAAMACQANABEAABkBIRkCIREhEQERIRkCIREBAAIAAQD9AAEAAQABAAQA/AD/AAEABAD7AAYAAQD/AAEAAQD/AAAAAAUAAAAABAAIAAADAAkADQARABUAABkBIRkCIREhEQERIREhESERAREhEQEAAgABAP0AAQABAAEA/gABAAEABAD8AP8AAQAEAPsABgABAP8AAQD/AAEAAQD/AAAABAAAAAAEAAcAAAMACQANABEAABkBIRkCIREhEQERIREhESERAQACAAEA/AABAAIAAQABAAQA/AD/AAEABAD7AAYAAQD/AAEA/wAAAAUAAP8ABAAIAAADAAcADwATABcAABkBIREBESERAREhESERIREBESEZAiERAwD9AAEAAgD+AAIAAQD9AAEAAQD/AAEA/wADAAMA/QD+AAEAAQADAPsABgABAP8AAQABAP8AAAACAAD/AAQABwAAAwAPAAABESERAREhESERIREhESERAwABAPwAAQACAP4AAgD+AAEAAwD9AP4ACAD+AP8A/QD/AP8AAAUAAP8ABAAHAAADAAcADwATABcAABkBIREBESERAREhESERIREBESERIREhEQMA/QABAAIA/gACAAEA/AABAAIAAQD/AAEA/wADAAMA/QD+AAEAAQADAPsABgABAP8AAQD/AAAGAAAAAAQACgAAAwAHAAsADwATABcAACERIREBESEZAiERAREhEQERIREhESERAQADAPwAAQADAP4AAQD+AAEAAQABAAEA/wABAAUA+wAFAAEA/wACAAEA/wABAAEA/wABAP8AAAAAAAYAAAAAAwAIAAADAAcACwAPABMAFwAAIREhEQERIRkCIREBESERAREhESERIREBAAIA/QABAAIA/gABAP4AAQABAAEAAQD/AAEAAwD9AAMAAQD/AAIAAQD/AAEAAQD/AAEA/wAAAAAABQAAAAAFAAoAAAMACwAPABMAFwAAAREhEQERIREhESERAREhEQERIREhESERBAABAPsABAD9AAMA/gABAP4AAQABAAEAAQAFAPsA/wAHAP8A+wD/AAgAAQD/AAEAAQD/AAEA/wAAAAADAAAAAAYABwAAAwANABEAABkBIRkCIREhESERIREBESERAQACAP4AAgABAAEAAQABAAMA/QD/AAEAAwABAAIA+QAFAAIA/gAAAAAABAAAAAAEAAoAAAsADwATABcAADERIREhESERIREhEQERIREBESERIREhEQQA/QADAP0AAwD+AAEA/gABAAEAAQAHAP8A/gD/AP4A/wAIAAEA/wABAAEA/wABAP8AAAAABgAAAAAEAAgAAAMADQARABUAGQAdAAAhESERAREhESERIREhGQIhEQERIREBESERIREhEQEAAwD8AAEAAgABAP0AAgD/AAEA/gABAAEAAQABAP8AAQADAP8AAQD+AP8AAwABAP8AAgABAP8AAQABAP8AAQD/AAAAAQAAAAABAAUAAAMAADERIREBAAUA+wAABgAAAAAFAAoAAAMACwATABcAGwAfAAABESERAREhESERIREhESERIREhEQERIREBESERIREhEQIAAQD9AAEAAQD/AAMA/wABAAEA/QABAP4AAQABAAEABAABAP8A/AAHAP8A/wD7AAMAAQADAPkACAABAP8AAQABAP8AAQD/AAAFAAAAAAQACAAAAwAJAA0AEQAVAAAhESERIREhESERAREhEQERIREhESERAwABAPwAAwD+AAEAAQD+AAEAAQABAAQA/AAFAP8A/AAGAAEA/wABAAEA/wABAP8AAAIAAAAABgAHAAADABMAABkBIRkCIREhESERIREhESERIREBAAIA/gAFAP4AAgD+AAIAAQAFAPsA/wABAAUAAQD/AP4A/wD+AP8AAAAGAAAAAAUABQAAAwAHAAsAFQAZAB0AACERIREhESERAREhESERIREhESERIREBESERIREhEQEAAQABAAIA+wABAAEAAQABAAEA/gD+AAEAAQABAAEA/wABAP8AAQADAP0AAwD/AAEA/gD/AAMAAQD/AAEA/wAAAAAGAAAAAAUACgAAAwAHABEAFQAZAB0AACERIREBESERAREhESERIREhEQERIREBESERIREhEQQAAQD/AAEA+wAEAP0AAwD9AAEAAQD+AAEAAQABAAIA/gADAAMA/QD9AAcA/wD9AP8A/gAIAAEA/wABAAEA/wABAP8AAAAABQAAAAAEAAgAAAcACwAPABMAFwAAMREhESERIREBESERAREhEQERIREhESERAQABAP8AAQACAP4AAQD+AAEAAQABAAUA/wD/AP0ABAABAP8AAgABAP8AAQABAP8AAQD/AAAAAAgAAAAABQAKAAADAAcACwAPABMAFwAbAB8AADERIRkCIREBESERAREhGQIhEQERIREBESERIREhEQQAAQD8AAMA/AABAAQA/QABAP4AAQABAAEAAQD/AAEAAgD+AAIAAQD/AAEAAgD+AAIAAQD/AAIAAQD/AAEAAQD/AAEA/wAACAAAAAAEAAgAAAMABwALAA8AEwAXABsAHwAAMREhGQIhEQERIREBESEZAiERAREhEQERIREhESERAwABAP0AAgD9AAEAAwD+AAEA/gABAAEAAQABAP8AAQABAP8AAQABAP8AAQABAP8AAQABAP8AAgABAP8AAQABAP8AAQD/AAAEAAAAAAUACgAABwALAA8AEwAAIREhESERIREBESERAREhESERIRECAP4ABQD+AP8AAQD+AAEAAQABAAYAAQD/APoACAABAP8AAQABAP8AAQD/AAADAAAAAAYABwAAAwAPABMAACERIREBESERIREhESERIREBESERAgACAP0A/wABAAEAAgD+AAMAAQABAP8AAQADAAEAAgD+AP8A/QAEAAIA/gAAAAAHAAAAAAUACwAAAwAHAAsADwATABcAGwAAIREhEQERIREhESERAREhEQERIREhESERAREhEQEAAwD8AAEAAwABAP0AAQD+AAEAAQABAP4AAQABAP8AAQAGAPoABgD6AAcAAQD/AAEAAQD/AAEA/wABAAEA/wAAAAAGAAAAAAQACQAAAwAJAA0AEQAVABkAABkBIRkCIREhEQERIREBESERIREhEQERIREBAAIAAQD+AAEA/gABAAEAAQD+AAEAAQAEAPwA/wABAAQA+wAGAAEA/wABAAEA/wABAP8AAQABAP8AAAAFAAAAAAUACQAABwALAA8AEwAXAAAhESERIREhEQERIREhESERAREhESERIRECAP8AAwD/AP0AAQADAAEA+wABAAMAAQADAAEA/wD9AAQAAwD9AAMA/QAEAAEA/wABAP8AAAAACAAAAAAFAAoAAAUACQANABEAFwAbAB8AIwAAMREhESERAREhGQIhGQIhGQIhESERAREhEQERIREhESERAQAEAPwAAQABAAEA/AAFAP0AAQD+AAEAAQABAAIA/wD/AAIAAQD/AAEAAQD/AAEAAQD/AAEAAQABAP4AAwABAP8AAQABAP8AAQD/AAAAAAAGAAAAAAUACAAABwALABMAFwAbAB8AADERIREhESERAREhGQIhESERIREBESERAREhESERIREBAAEAAwD9AAEA/QAFAP8A/gABAP4AAQABAAEAAQABAP8A/wACAAEA/wABAAEAAQD/AP8AAwABAP8AAQABAP8AAQD/AAAAAwAA/wAFAAcAAAMADwATAAAZASEZAiERIREhESERIRkCIRECAP8AAQABAAEA/wACAP8AAQD/AAEAAwABAAIA/gD/AP0ABgABAP8AAAEAAAMABQAEAAADAAAZASERBQADAAEA/wAAAAABAAAFAAEABwAAAwAAGQEhEQEABQACAP4AAAAAAQAABQABAAcAAAMAABkBIREBAAUAAgD+AAAAAAEAAP8AAQABAAADAAAZASERAQD/AAIA/gAAAAACAAAFAAMABwAAAwAHAAAZASERIREhEQEAAQABAAUAAgD+AAIA/gAAAgAABQADAAcAAAMABwAAGQEhESERIREBAAEAAQAFAAIA/gACAP4AAAIAAP8AAwABAAADAAcAABkBIREhESERAQABAAEA/wACAP4AAgD+AAABAAAAAAUABwAACwAAIREhESERIREhESERAgD+AAIAAQACAP4ABQABAAEA/wD/APsAAAAAAQAAAwABAAQAAAMAABkBIREBAAMAAQD/AAAAAAMAAAAABQABAAADAAcACwAAMREhESERIREhESERAQABAAEAAQABAAEA/wABAP8AAQD/AAAFAAABAAMABgAAAwAHAAsADwATAAABESERAREhEQERIRkCIRkCIRECAAEA/gABAP4AAQABAAEAAQABAP8AAQABAP8AAQABAP8AAQABAP8AAQABAP8AAAAABQAAAQADAAYAAAMABwALAA8AEwAAGQEhGQIhGQIhEQERIREBESERAQABAAEA/gABAP4AAQABAAEA/wABAAEA/wABAAEA/wABAAEA/wABAAEA/wAAAwAAAAAFAAcAAAMAFwAbAAAhESERAREhESERIREhESERIREhESERIRkCIRECAAMA/AD/AAEA/wABAAEAAgD+AAIA/gADAAEA/wABAAEAAQABAAEAAQD/AP8A/wD/AP8ABQABAP8AAAADAAADAAgABwAAAwARABkAAAERIREBESERIREhESERIREhESERIREhESERBQABAPsA/wAEAAEA/wD/AP8ABQD/AAEAAQAEAAEA/wD/AAMAAQD/AP8A/gADAP0AAgABAAEA/AAAAAAWAQ4AAQAAAAAAAABNAAAAAQAAAAAAAQANAE0AAQAAAAAAAgAHAFsAAQAAAAAAAwAVAE0AAQAAAAAABAAVAE0AAQAAAAAABQAXAGIAAQAAAAAABgATAHkAAQAAAAAACQAfAIwAAQAAAAAACgA/AKsAAQAAAAAADAAlAOoAAQAAAAAADgAuAQ8AAwABBAkAAACaAT0AAwABBAkAAQAaAdcAAwABBAkAAgAOAfMAAwABBAkAAwAqAdcAAwABBAkABAAqAdcAAwABBAkABQAuAgEAAwABBAkABgAmAi8AAwABBAkACQA+AlUAAwABBAkACgB+ApMAAwABBAkADABKAxEAAwABBAkADgBcA1upIDIwMDksIDIwMTAsIDIwMTEsIDIwMTIsIDIwMTMgR3JhbmQgQ2hhb3MgUHJvZHVjdGlvbnMuIFNvbWUgUmlnaHRzIFJlc2VydmVkLkdyYW5kOUsgUGl4ZWwgUmVndWxhclZlcnNpb24gMS4wIC0gNS8xMy8yMDEzR3JhbmQ5S1BpeGVsUmVndWxhckpheXZlZSBELiBFbmFndWFzIChHcmFuZCBDaGFvcylUaGlzIGZvbnQgd2FzIGNyZWF0ZWQgdXNpbmcgRm9udENyZWF0b3IgNS42IGZyb20gSGlnaC1Mb2dpYy5jb21odHRwOi8vZ3JhbmRjaGFvczkwMDAuZGV2aWFudGFydC5jb20vaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktc2EvMy4wLwCpACAAMgAwADAAOQAsACAAMgAwADEAMAAsACAAMgAwADEAMQAsACAAMgAwADEAMgAsACAAMgAwADEAMwAgAEcAcgBhAG4AZAAgAEMAaABhAG8AcwAgAFAAcgBvAGQAdQBjAHQAaQBvAG4AcwAuACAAUwBvAG0AZQAgAFIAaQBnAGgAdABzACAAUgBlAHMAZQByAHYAZQBkAC4ARwByAGEAbgBkADkASwAgAFAAaQB4AGUAbAAgAFIAZQBnAHUAbABhAHIAVgBlAHIAcwBpAG8AbgAgADEALgAwACAALQAgADUALwAxADMALwAyADAAMQAzAEcAcgBhAG4AZAA5AEsAUABpAHgAZQBsAFIAZQBnAHUAbABhAHIASgBhAHkAdgBlAGUAIABEAC4AIABFAG4AYQBnAHUAYQBzACAAKABHAHIAYQBuAGQAIABDAGgAYQBvAHMAKQBUAGgAaQBzACAAZgBvAG4AdAAgAHcAYQBzACAAYwByAGUAYQB0AGUAZAAgAHUAcwBpAG4AZwAgAEYAbwBuAHQAQwByAGUAYQB0AG8AcgAgADUALgA2ACAAZgByAG8AbQAgAEgAaQBnAGgALQBMAG8AZwBpAGMALgBjAG8AbQBoAHQAdABwADoALwAvAGcAcgBhAG4AZABjAGgAYQBvAHMAOQAwADAAMAAuAGQAZQB2AGkAYQBuAHQAYQByAHQALgBjAG8AbQAvAGgAdAB0AHAAOgAvAC8AYwByAGUAYQB0AGkAdgBlAGMAbwBtAG0AbwBuAHMALgBvAHIAZwAvAGwAaQBjAGUAbgBzAGUAcwAvAGIAeQAtAHMAYQAvADMALgAwAC8AAAAAAgAAAAAAAP8nAJYAAAAAAAAAAAAAAAAAAAAAAAAAAADZAAAAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAQIAowCEAIUAlgDoAI4AiwCpAKQAigCDAJMAjQCXAIgAwwDeAKoAogCtAMkAxwCuAGIAYwCQAGQAywBlAMgAygDPAMwAzQDOAOkAZgDTANAA0QCvAGcA8ACRANYA1ADVAGgA6wDtAIkAagBpAGsAbQBsAG4AoABvAHEAcAByAHMAdQB0AHYAdwDqAHgAegB5AHsAfQB8ALgAoQB/AH4AgACBAOwA7gC6AP8BAAEDAQQBBQEGANcBBwEIALAAsQEJAQoA5ADlAQsBDAENAQ4AuwDmAOcApgCzALYAtwDEALQAtQDFAIIAhwCrAL4AvwEPAIwHdW5pMDBBMAZEY2Fyb24GZGNhcm9uBkVjYXJvbgZlY2Fyb24GTmNhcm9uBm5jYXJvbgZSY2Fyb24GcmNhcm9uBlRjYXJvbgZ0Y2Fyb24FVXJpbmcFdXJpbmcERXVybwAAAAAB//8AAg=="

/***/ }),

/***/ "./node_modules/base64-loader/index.js!./node_modules/scratch-render-fonts/src/Griffy-Regular.ttf":
/*!***********************************************************************************************!*\
  !*** ./node_modules/base64-loader!./node_modules/scratch-render-fonts/src/Griffy-Regular.ttf ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "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AgYGAgQBAgQJBgIDAQIEAQEBAgICBwQHAwYCAgQEBwMEBgMFAgUCAQkIAwUDBwIBBgQKCAUJAQoIBAMGBAQGBAcHAwcEAgoBBQkFCREJBgwMCQQJFQsLFQ0ECAsKAwgEBQ4GCw0IBAUJAw8FCAUFCgYGDAULDRENCgYCCgcKCwkFIAkFBwMMAVsBAQEEAQQCAgEBAQIBAQIBCgIHFAoNFAgPDwcLAwIMBgQMDQUIAQwCCAMIDQYJBwIFAwUEAgYNAgMCBQcJAgQFAwcBAgIEAQEDBQYBAgQCAgYCAgQCAwcCAgMCAwUCAgMCBwICCgQLCAUGBwwIDAoFCAQIGQYRHw8FBwUFCgQJBgIKBQICBQIFAQICCAEBAQEFAQEBAgEBAQECAw0dDwUIBQUJBQICBQEBBg4bDAUIBQYNBgIGKwUIBAYJBQMGAwUKBQggEAkRCggSCQgPCA4lEQECAQEBAgIEAQwECA8LAwECAQIBBBIlEBISCwgOCwMGAgQFAgQGAwMHBQkWCwULBQsGAgYIBQIEAgcFBQMFAwIGBgMCAgMFBgEBAQEBAQEBAgEDAQICAQIDAQQBAwEBAQEBAQIDAgICAgIBAQICAgIDBAUBAgoCBQMDBQIDAggJBwoDAgsEAw0NBAkIBQMFBQkIBAkRCAQKBQ0OBgEHAgoFFDISAwcCAwkDCAMCAgUDBQ8GDAMIBAQGCAcFCgkDBgIIAQILDAMEAwkBBgMIBwMIAQkGAgIEAgICAgcDAgcBAgYCAwUDBAcDAwEBAwECAgICAwEBAgMDAQEBAgEBAwEBAgIBAQQFBgYIBQICAQIBAQIDAQMD2QcPCAwICwIXIQ8JBAcMBwYLBQQIAQIFAgMEAgQHAwMDAQYEAggJBAQCAQcBBgoKBQIEAQUCBAMCBQkFERYFDRAJCxkNHBgECAQFBwQNBgMQEA4MBQgJAg0EBQgEBQwFAwYCBAYDBAgFCQUCBAYEDwcFBAQJBAUDAQICAgEBAgIBAQEBCAEBBQEBAggCBgcECBgHBgYBCREIAwcDCwMGAw4SCw4cDg4cDQIGAgEBAwINBwEEBgIJAQQDAgECAQEBAxUpAAACAB4AAwHNAyQBHAH9AAABFgYVFBYVBhQHBgYHBjEGBwYGBwYGBwYGBwYGBwYGBwYGBwYUBwYGBwYHBgYHBgYHBgYjBiYHIgYnIicmJicm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AQsFAQQCAQEDAQEGAgQBBgECAgIBAgEBAQMBAQIBAQEBAQECAwIBAgEGBwUFBQMIAgcGAgQGBA0LBQQGBAQHBRAhDgQGAwwIBAQHAwoMBgwGBAIGAwUJBQIGAgIDBQUCAwUDAgMCBgEBAQEBAgECAgoCCAQCEQwHDAgCBgMJDggKEQgGDAMDCQIICAICAgEEBAUEBgcIEQgFCQUFCQUCBgIBAQEEAQcBDQMDCAUCBgIDAgMFCAUGDAUCBAECAQMBAgECBAkECRILEQMLBAIGBgsGBAMCAwICBQIBBQIHAQIDCQUEBwQIEQYDCAMQFQsOBwcOBwUHBQUJBQgPAi8OCAoFCgEHBwQBBwICBQMGAgEFAQECBAIDAQICAgEDAQEDAQEBAwEBAQICAgICAgIEAggDBAcCAgkBBwUCAgQCCQYFCggFDAgFBQwFBg8HCwcFBw0HDAUDBAkFDiURBQkFCBEKEQYEBgQLBgMDBQMGBAUKBQMHAwUIBQYGBAgIBQgBAQgIBAUFBAICAQECBgICAwICBQMIAgQDAQIFBQMFAwQHAwMLBAQaHhoDGhoMBQIIAgIHAgEBAQECBwYEBQQIBgQMCAQFDAcDBgMDBgIFDAUDBwMIBAoUCwwHCAILBQUIBQgQCg4gDgUHBQUQBggNCgQGBAcPCQYSBQQGAgUNBgsDBA4QAgcDBAgFAwkFBQsGBQ8HCAEBBQIBAwcCBgQCBgICAgIGAQUBAQMGAwIDBgQEAQECAwIBAgQBAwEBAQECAQIBAwEBAgIJCAUEBgQPEwIGAxEEBgoGCAMEEAgGBQL+SQoSBQYHBAIEAgQHAgkBBgQBEw8ECAgOCA8FCAQJAwMFBAUKBAwbDQMHAwMGAxALBQcNBQMGAwQHBQUIBAMFAwMGBQIIAgMCAgUBAgEBAgYCAwMCAgIBAQEDAgICAQIEAQICBgMBCQMDBAICAgIFDQUDBQMDBwEDBAIFBgUDBwQOAwIHBAQHBBQkFAULBxANBQIIAwwLBwcKAgILBAQGAgEBBAEBAQECAQgCCw8LCgwICwURCwUFAgICBQEBAQIEAgMECwIRAggFAQkCAwkEBgkFDAQCCwsEAQIBAwYGBQ0IBAgDBAcEBAgEAwQCAgEDAQYBBAIGCwoCAQQIBAcTBwUJBAcHAgcGAgMEAwEGAgEBAgUCAgEEAgMCAgICAgECAwkA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CwoEBAYEEA0HBw8JDgIGBgIDBQICAQUBBAkBAwIBAgMHAwMCBAIDAwEBAQUCBQECCQ4NCREKChQCBQgFCwYFAwoFBQYGDwsFAgkFAwUEBgYEAgYCCgMKCgEBCQMCAwYFAgYEBwEBBgMCEwoLEgoDCgUDAgAABAAo/+QCVAL2AOMB/QKYAsIAAAEGBgcGBgcGBwYGBwYHBwYGBwYGBwYGBwYGBwYGBwYGBwYUBwYGBwcGBgcGBgcGBgcGBwcGBgcGBgcGBwYGBwYGBwYGBwYHBgYHBgYHBgYHBgYHBgYHBgYHBjEGBgciJicmFSInJiYjNjY3NjY3NjY3JjY3NjY3NjY3NjY3NjY3NjY3NjY3NjY3NiY3NjQ3NjY3NjY3NjY3NjM2Mjc2Njc2Njc2Njc2Njc2NzY2NzY2NzY2NzY2NzY2NzY2NzY2NzY2NzY2Nzc2Njc2Njc2Njc2Jjc2Njc2MhcWNhcWFhcWMhcWMgUWNhcyFhcWMhcWFhcWFgcGBgcGFAcGBgcGBgcGBgcGBgcGBgcGIgcGBgcGJgcGBiciJicmBicmJjcGJicmJicmJyYmJzY2NzY2NzY2NzYGFxYWFxYXFhYXMhYXFjIXFhY3MjY3Njc2Njc2NzYxJiYnJiYnJiYjBiYjBgYHBiIHBgYnJjYnJiY3NjY3NjY3NjI3NjY3NjY3NzY3NjQ3JiYnJiYHBgYHBhQHBgcGBwYGBwYGBwYGBwYGBwYGJyY2NTQmJyYnJiYnJjQ1NCY3NhYjFgYXFhYXFhYXFhYXFjY3NjY3NjY3NjY3NjY3NjI3NjY3NjM2NjMyFhc2MhcWFhcWFhcWFhcWFhUWFAcGBgcGBgcGFAcGBgcGBgUWBgcGFhUUBhUUFhUUBhUUBhYWFxY2NzY2MxYGFRQWFQYGByImIyYGIwYGFxQGFxYWFxYXFhYXFgYVBgYHBgYHBiIHBgYnNjY3NzY0NzY2NzYmNyYGIyYjIgYHBgYHBiIHBgYjJiYnJjYnJjQnJjU2Njc2Njc2Njc2Njc2Njc2Njc2Njc2Njc2Njc2Njc2Njc2Njc2Jjc2FhY2BwYGBwYGBwYGBwYHBgYHBgYHBgYHFjYXFzYXMjYXMzQ2JzQmJyY0JwYGAi0BAwIDBwUHBgICAgQDBwgGBAIHBAQIBQcKBQgLBwIDAgYBAgQCEwUIBQYBAgQFAwMFCQQCAgYBAgYBBgYGAgcEBAUDBAYFAgECBgMFBAIGDgYCAwIFAgEFAgEECgwHCwkCCQECAQkDAgIBBQcGAgUCAgICCAEEAwkEBAcGBAECBgICAwcDBAEBCAECBAIGBgMHCAQDAwMCAggHAwICAgIEAgYGAgYBAgQCAgcEAgMCAgQCAgICAgYCBgEEAggFAgMCBgQFAgcIBQUHBQcBAgQCAQUHAggDAQwHBQgCAQUE/rYECgUDBQQFCQMGBwUEAwIBAQIFAgYFAQQEAgMGAwIFAwUSCAoHAwcOBwcJBAIFBQMHAwcEAQkFAQMFAgcGAgYCBwcBAggDAwYEBAkFDAECAgcECAMNAgQGCAQDBgQFBwgGDgUFBgUHAwQCAgIFAgIIAgYHCAoCAggKBAkDAgUGBQMCAQQDAgIGBQIFAwUHAgUFBQUEBQYLAwQDAgECBh0PBQgFBwELBQYCBAQCAwECCQMBBgwHAwcGBQYFAQECAwIBAQICCQUBAQIBAQIBAgQCAwIEAgcEBwMBBQUCAwEBBAYCCQYCAwUCCAoKBAIDCQMJCQMNBgQOBwkBAQIBAgECBAECBQoFCAECBwIGBgE1AgUBAQIBAwIBAQECCBYKBQcEBQMCAQIBBg0FCRIKAwEBAQEBCAMJAw4UBwEGESQSCRIJBwcDBAgEAggFCAICAgkBAgQDCxYMDQoLCAUEBwUIEQgEBwQEAQMDAQIEAgQECQQECQQKAgIKCAgCBQIEBgQDBAUCBQMDBgICAgIBAgICAwEBAgMJFBQUOwIEAgUCAQUCAQQFBwICBQMEBBEFAwYEEAcIDw0HFgQDAwEBAQUGAssFCQMFBwUJBgIGAwYDCwkLAgcMBggPCA4TCQsaCwMHAgcDAgMGAiYIDQgJBwMICwUHBQ8IBQIIBQIKAQcMBQgMBwUQCAkECQsCBQoFCQkEDxwNBAgFCwkECwQKAwwEBQEBBQMGBQUJAQEGDgUFBQMFBwMMBwILEggKEQcNBQUHBgMFCQUHAwEKAgICCAMKCwULDQcKCAIQDgYDBwMFBwQJCAQLAQUGBAULBQYEAwYDAgMHBAUIBgkGAgkRCAMGBAoIBQMQEQkQEQoLBQQGBgIMAgoCAgkEBQgBA5cBAgEDAgIBAwkCCxANBg0FCgcDCwMCBwYDAgYDAgQCBQgEBgECAgIEAQEBAgECAQUBAQkDAwEFAgUFAg0G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AwUGBgIFCAIFBAQCBQIKAQIJCAMIEgUKBQQIBAQHBAMGBAQHBAMGBAoEBAQCCgQCCgYDBgQCAwMDBAMEAwECAgIEAQYNBAgFBAYDBQoFBwICBgAAAAQACv/lAmYC9AHUAjECvQMSAAABBhYHBgYHBgYHBgYHBgYHBgYHBgYHBgYHBgYVBgcGBgcGBgcGBgcGBgcGBwYHBiIHBgYHBgYHBgYHBgYHBgYHBhQHBgYHBgYHBgYHBwYGBwYGBwYGBwYGBwYGBwYGBwYGBwYHBgYHBgYHBhQHBgYHBgYHBhYHBiYnJiYjJgYjIgYnJjY3NjI1NjM2NDc2NzY2NzY2NzY2NzY2NzY2NzY2NzY2NzY2NzY2NzY2NzQ3NiY3NjY3Njc2Njc2Njc2Njc2Njc2Njc2NDc2Njc2Njc2NzYyNzY3NjY3NjY3NjY3NjY3NjYnNjY3NDY3NiY3Njc2Njc2NTY2NzY2NzY2NzY2NSYGBwYGBwYGBwYiBwYGBwYGBwYmJwYWFRQUBwYGBwYGBwYGBwYVBgcGBgcGMgcGBgcGBgcGBgcGIgcGBgcGBgciJiciJicmJyYmJyYnJiYnJic0JicmNSYmJyYnJjQnNCY1NDY3NDY3NDY3NjY3NiY3NjY3NjY3NjY3NjY3NjY3NjY3FjY3NjY3NjYzNhYXFhYXFhYXFjIXFhYXFhcWFzIWFxYWFxYyFxYWMzYyNzY2NzYyNzYWNzY2FzY2NzY2NzY2NzY2NzYmNzYWFxYWFxYWFxYWBSYGBwYHBgYHBgYHBgcGBgcGBgcGFAcGBgcUBhcWFhcWFhcXFhYXFgYzFhY3Njc2Njc2Njc2Njc3NjY3NjY3Njc2Njc2Njc2Njc2NjU0JicmJicmNCcmJyYmJyYmAQYGBwYHBgYjBiIHJiYnJiYnJiYnJgYnJiYHNCYnJiYnJicmJicmJicmJicmJicmNjc0Jjc0Njc2Njc2Jjc2NzY2NzYzNjY3NjY3NjY3Njc2Njc2NzY2NzY2NzY2MzYyNxYWFxYWFxYWFxYUFxYWFxYWFRQWBxQGFQYUBwYGBwYGBwYHBhYHBgYHBgYDBiIHBgYHBgYHBgcGFAcGFgcGBhUUFhUWFCMWFhUWFhcWFhcWFhcWFjc2Njc2NDc2Njc2Njc2NDc2NjUmNjU2JicmNjUmJicmNCcmJicmJiMiJgcGAjwCAQECBgIFAgEGAgIHCAIFAwICBAIGAQIFBAUBAgICCwUFBggDBggDBgEICAQCAQcCAQIDAgIDAQUDAgICAgYBBAICBAMCBAcDCQIFAwUHBQcBAQIEBAMIBQUKBQQBAgUEBwgGAQcCAgICCAMCBgIDAgUKEwsDBgMFBwUDCAQCBgQGAgcBBwIFAwIIAwUCAQIDBAIFAwUJBQIEAgIGAgUCAgICAwQEBAIFAQEKBQMKAQIDBQIHAwMGAwQGAwMFAwICBwQCBAUCAQQHAQEEAgYEAQUBAgQDAgkFAgUEAgMCBAMBBQEBBwEEBgIGBQQCAgMCAwYCAwIFAwMDBQILGAsDBgIEBwQEDgQJHQ0CAQEEAgICBAIDBgMHCwYDBgUJAgIFCwUHBwUDBgIIBQMECAUFBwUFCwYEBgUIBAQCAwUFBAwGAgQFAgQFAQEEAQEBAgQCAgEDAQMGAgMBAgUCAgIGAggBAQcFAwYJCwINBAUIAwkBAggFAggaCAQFBAUEBAYCAgIEAxIOAwIDBQMHBQQKBQIECAULBQMDCwUHBwMIAwICBwUNBQMEBwIEBQMFAgUBCwQKDAYDBgQECAMIDP6ICBUGCQYFBAQGBQIHAgcCBQEFAgIBAQIBAgEBBgMBAQEIAwICBwEBBw0ECQEJBwIEAwIEAwILAwICBwcBAgEFAQIHAgIGBAIBAQMCAgECAQEEAQIEAggQAVkDBQQHBgQRAwQGAg4LBQYLBQMGBAoCAgQDAwYCAgECBgICAQICCAICAgICBgEBAwEBAgMCAQEBBQEBAgIHAgIEAwQCAQIGAgUIBQoEAwUDBAkEBwQFBwUJAgIFCgUKDgUIEgcFBgMFAQIGAgECAQECAQIBBQICBQIFCAYBAQYLBQIERwcDAQQIBAMDAQcDAgEBAQEBBAMBAQMDAwQCAgUFAgcCBRQEBwsEAwEFAQIDCAICAgECAQIBAQEBAQEEAQcBAgICCAMDAw4FBwLQAwYCBQcEBwcCBAcDDQYECwICBAgECgQCBwEBBwMDBQIODAcMDQUMCgUMAQoIBwIKAQECBwQHAQIJAQIDCQMJBAIDBwMGBAIQDAYPAwcEBw4ICwMCAwcCCBAHCAwHAwcCCQYJDwYGCgYCBwQHEAgFDAUJCAQCBwMBAgECAwQFCAMJAQoKAgIIAwUEBQgBAgIHAgQHBQcPCAQIBAQGBAsCAgIIAwUJ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BgQDCAICBwUEBwUGAgUFAwoFBwIBAgQCCgMKBwUIBQoLBQUJBQUHBAQDBQIFAgMFAgQEAgUGAgIDAQEDAgIHAgkEAgICBQYFCQgFBQYCAgsFAwcEBAYFDAYDCAQIFwYSFAkIBQgJAwQHBQsHBAwECg8KCwIHAQQDAwgGBwQEAtYFBgIFCgUJAQIGAgMFAwYLBQMGBQoFCQMCCgQJBAIGAgYCAgIEAwwFAgUDBQYFAwcECAQECxYKAgIDBwQLBAgQCREHAQcDBwICAgIBAwEBAgQCBgQDBwYDBw4ICAMFBwQDCA0FAw8OBQsOBggICgUCCwEEBwEBAggDAgEBAQECAgEBAQQCChYNCgMCBQsFBAMFBAEBAgMBAgMBAgMCBQYDBAQEAwEFAwEGAwEIBgUJAQICBAMJCgQHBwMDBgIFCQUDCAMICQgOCwYCDw4GCAsIDAYDAwcDAwgDBAUCAgIFBQMBAgMCBAIGEAsIAQgDAggCAgUGDgcIDwMMCQMGDQgIAQEGAgMEAgcEAgMJAwQIAgEKCwgDCwYCCQQEBwMEBgMGAwQEBQEDAgMEAQEBAgECBgQCBQIGBAgBAQoECQMHBgMHBwMDBQQFBAIFBwIIBgQEBAMHAgICAwMBCREIBQgFDAoFDQUCAgUEDAUCCQULEAcJCwIBAgIBAQMEBgcCAwQCAwQKBgQEAgQEAgMCBAICBAQJAQIBBQIEBQkBCAMFBgQKBQQHBAwVCw0FAQYDCAINBwMCBwYIAgIHAQYCAgQCAgIBAQEBAQEBAQIBAgIBAQEEAQEFAgIGAwkDCAYDDw0GAwcEAwYEAwYDCgUKCQMGCwUJBwMDBgMFCgUFCwUFCAQKBAIKBgMHBgIHCAUHBQQEBwQDBgQGAQECBQIHAgMBCQEBAgQBAgMCAgICAQQEAgMCBQwFCgYDFycRBAoCCwYCAgUEBQkFDgQDBQMCCAMHCAQFBAICBgICAgICAwIHBAIEAQICAQYEAgEFAgICBAIFAwQKCAIIAQQCCAEDAgYEBAQCAAABAA4BqgBrAuAATQAAExYWFAYHBhYVFAYUFBUUBhUUFhQWFRwDBwYGBwYjJgYjJiYnJiY3NCYnNDY1JjY1JiY1NDYnJiY1NDYnJiYnJjY1JjY1NjYzOgIWaAIBAwIDAwECAQEBAQEDAg8ICQIIBQUCAwEDAQEDAQEBAQEBAgEB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CwYFCwULEwoJAg4gDAsMDAQCBwwFDg0FFBMJCQYCAgECBgQCBAEEAQcDAgMCAgEFBwEBAQMCAQICAQMBAwECAQECBAUFAgYDAwIKAQQDAwIBBwQDCQUDAgYCAwUDERAHCgQECwYDBQgFBQgFCREJBQgFBQkFBQoFBgwKAgQFCxILBAIGEAgOGwsIAgIRBQoICQUlDA0fDgUCAQoGBwsDAgMBAQQBAgcDBgQCCgQDCgIDAQUCBAQCBgcFAQcCAwYCCRAKBgoFAQIBAQMBAgUCAQEAAAAAAQAJ/+QCGQMEAoQAADcWNhcWFjMyNjMyFjM2NzIWMzY2FzYyMzI2MzY3NhYzNjY3NjY3Njc2Njc2Njc2NDc2Njc2Njc2NjU2Jjc0NjcWBhUWFhcWFhcWBhUWBhcWFhUGFhUUFhUUBhcWFhUWFgcmJicmJyYnJiYnJiInIiYnIgYnJiYHBiIHBgYHBgYHBgYHBgYHBgYnNiY1JjY3NjY3NjY3NjY3NjI1NjY3NjY3NjQ3NjY3NjY3NjQ3NjY3Njc2Njc2MTY2NzY2NzY2NzY2NzY2NzY3NjY3NjY3NjY3NjY3NjY3NiY3Njc2Njc2Njc2NTY2NzY2JyYmJyYmJyYmJyYmJyYmJyYGBwYGBwYmBwYGBwYiBwYjBiYHBwYiBwYGBwYGBwYHBwYGBwYGBwYGBwYUBwYGFxYUFxYWFxYWFxYWFzIWNzI2NxY3MjY3NjY3NjM2Njc2NzY2NzYnNCYnJiYnJgYnJiYjBgcGBgcGFhcWNjM2NhcUBgcGBwYGBwYmNzY2NzY3NjY3NjY3NjM3FjYzFhYXFhYXFhYXBhYVFhYXFhcWFgcUBgcGBgcGBwYHBgYHBgYHBgcGBgcGIgcGBicmJicmJyYmJyYmJyYmJyY2JyY0JyYmJyYmNzc2NDc2JjU2Njc2Njc2Njc2Njc2Njc2Njc2Njc2Njc2Njc2NzY2NzY2NzY3NjM2Njc2Mjc2NjM2Fjc2Fjc2NhcWFjMWFhcWNhcWFhcWFhcWFhcWIhcWFhcWFxYWFxYWFxYWFxQWBwYWBwYWBwYUBwYGFQYWBwYGBwYHBgYHBiYVBiMGMgcGBgcGBwYGBwYxBgYHBgYHBgYHBgYHBiMGBgcGBgcGBgcUBgcGBgcWBgcUFhcWBhcGFsIFDAYDBgQFDAYIDwgIBQMHBAQIBQMTBQUKBgcECQQCCwcDBAYCBgYDBQMJBwIBAQEBAQIDAwMEAQIBAgELAgECAgICAgIBBQICAgIBAQEBAQEDAgECCQ0HDQ8HCQUYCBg1GAUJBQUIBAgLBw8NCAQFBQobDAkVCQMGBAUMBgIFAQEBAQQEAgICAgMDBAICBAICAgIEAQIEAgMEAggBBwQFCAICCQQJBgICDgwGAgYCCRUJAwYDBwECCQMDBQIDBwICAQIECAMIAQEEAwIBAgUCAgMEBAICAQICCwYFCgUGCwcGDAYLBAIJDwgJEQgFBgIEBgQDCAMJBQUFAgsLAwEFCQULAwIGBAoEAwIHAwICAwIFAQIBAgEBAgcEBQQCDhQNBgwGBQoFDQMIFAoFCgUHAwYGAwYDAwcCAgICAwIFBAMOCAULBw0FBQICAgICDA0IBAoFCAQHBggOCBMPAgEFAgEEAQEDAgMCCAgRAQcDBAgEBQcFCA0IAQIEBgMDAgMCAQMBAQEBDAEHBgUKBQoEAgYIBQgJBw8IFzkVAwgEBwIFDgYDBQIBAQIHAQEEAgIBAQMGAQEDAQQBAgQCAwECAgMBAwMCAQUCAgICAgYCBgMDAgcDBgMJAwULDQgFBQ8CCQQCBQkFBQcEBgsGEiAOBhMIAwUEDgkEBQwFDAMCCgICCBAFBQECAwgCBQIEBAIBAgEBAQEDAgIDAgMBAQUBAgQEAQICBQIHAgQDAgcCCQEIAQECBwQJAwMIAwsFDQYDBQMJAQIOEAgJAxIcDgYMBgUKBgEBAQMBAQEBAwICAQMDBjcCAgEBAgIBAgEBAQMCAQEBAQMBBQIBAgECBAcDBQQPDAcCBgMCBwIIEwgLCgMDCAMIDgsCCAUECAUIEQkKAgEQDwgKBwMRHggFCQUGCwUDBwMNEwkBBAMGAgUFAwMBAwMDAQEBAQECAwIBAQEDCQICAwIBAgECAgILFwwLGgsRIwsDBAMGDAYLAQYJBAMFBQgGAwUGBAQHAgsBAgkGBAQDAgMDCQQDAgkKBQMDAwkQCAIGAwgBAwcDAwcDAwUEAgYDBQcFCgQCBwQECQULCQUIAxEgFQoWCQcJBQUIBQIIAwMIAgIBAQECAgIEAgQBAQEDAQICBAQCAggGAQIFAggCAgQHCgYCAg0HCQUKBQ0IAwgKCgQIAwYNCAwLBREYCQEBAgEBAQMDAgUCBQYEAwcDAwsGCAoJEwoECgICAQECAwIDAwgFEhMJDQkDBQIFBQIEBAUJAQIiFQcOBwsCBQIEAgUECgUCAgEGAgIFAgUMAwQFAwQKBQgCBQUICQUDAwYCCwIGBwQIBQcBAQQGBAIBAgICBAYFBwUKBAcNCAQFAgIHAgYCAgUHAwMGAgsRDAsRDAUHAgIECwUIAwQDBwIIBgQDAwICBgICAwIGBQICBgIGAgQBAQUBAgUBAwIBAQEBAQMCAgEFAQEBAQEBAgEDAQIBAQUDAggCAgcKBggCAw8FBAcGCwgFCgUFDwkIDAoGAwMFBQIMBQIFCgUCBgIEBQMLCgEIAwkBAQ0IAQIKBAUDAgUCBwcHBgIFAgUCAQkKBggOFAoGDQcIDggFCQUFBwQHBwUMFQsMCAMKDwAAAAABABT/2wIGAycCiAAAExYWFxYWFxYWFxYWFxY2NzY3NjY3NjY3NjY3NjU2Mjc2Njc2NjMyNjMyFjcWMhcWMxYWFxYWFxYWFxY2FxYWFxYWFxYWFxYWFxYWFxYWFRQWFRYHFAYVFBYVBhYHBgYHBwYGBwYGBwYGBwYGBxYWFxYXFhcWFhcWFhcWFxYWFxYUFxYUFxYXFhQXFgYVFgYHBhUGBgcGBgcGBwYGBwYGBwYGBwYUBwYGBwYGBwYGBwYGBwYGBwYGBwYGBwYiBwYGBwYGBwYnBiYnJiMmIyYmJyYmJyYmNSYmIyYmJycmJicmJicmNjUmJjU0NjU0JjUmNDc0Jjc0NDc2Fjc2NhcWBhUUFhUWFBcWBhcWFhcWFhcWMhcWFhcWMhcWFhcWFhcWFhcWFhc2Njc2Njc2Njc2Njc2Njc2Njc2Jjc2Njc2MzY2NzY2NzYmNzY2NzY2NzQ2NTY0NSYmJyY0JyYmJyYnJiYnJicmIicmJiciJicmJicmJgcGBgcGBhcWFhcyFhcWFjc2Njc2NjU2JicmJjc2FxYWFxYXFhYXFgYHBgYjIiYnJiInJiInJiYnJiY3NjY3NjY3NjY3NjY3JiYnJjYnJjY1NjY3NiY3NDY3NjY3NjY3NjYzFhYXFhYXFhYXBgYHBhYHBgYnJiInJjU2Fhc2Njc2JicmBgcGBgcGBhUUFxY3MxY3MjY3NjY3NjY3Njc2Njc2Njc2NjU0NDc1NDYnJiYnJiYnJiYnJiYnJiYnJiInJgYHBiIHBgYnBgYHBgYHBgYHBgYHBgYHBgYHFAYHBwYGBwYGBwYGBwYGBwYnNiY3JjYnNCY1JjYnJicmNicmNCcmNCcmJjUmNCcmJjY2NTQ2NTY2NzQ0Ny4HAgIBAwECAgMHCQYICQgJBgoGBQMEBQYEAwoNBwMDBwIGCAgEBgMJFAoECAUGBgwGAwUJBQQMBQgFAgUHAwsUCwgFBAMIAgEGAQEBAQIBAgEBAQUBBAIGAwoEBQgFCw4GBQgDAgcDBwYHCAsEAwgFBAQHAggCAQEEAgMBBQEDAgIBAgICAQICAgIDBQIEAgMGAgcEAgoBBwICAwgDCgICAgcDCxkNBQwFAwUDAgcDBgsGChAJDRQKEQMKAwgFBQgCCwQCCQYKCQoFEQUKAQYCAgMCAwEBBAECAgICAgILBQIFCAMBAgIBAgQBAQEDAgMFAwcEAgoNBQcEAgUKBAMEAwwGBQUMBgUMBwYPBQoMBQoOBgkJBAIFAwsBAQkEAgkCAwgEAwUBAgECAQECAgUCAgIBBAEBAgIHBAoCBwECDwkEBQQDBgUIBgUDBwMMGQ8HCQgIDQIBBQMCBgMFEwgEBwMJAQIJBQYLAgsEBQcCBgMDCQIDAQgQFgsGEAgCBwICCwMICAUCBwEBBAICBQIDBwIDBQIBCQICAQIEAgIBAQQBBAQBBAsDCAwICA4ICAYFBAkCAwcCAQUCAgEDBRYKCgQBCAoQBgMKAQIGAggYCwkPAwUEExAUHAYHBQwFAgcDBAgFDAMIAwIIBAQBAQEFBAIFAwICBAoFAgoMBRAJBQsHAwoGBQQGAwULBgIHBQkRCwQHBAoEAgoLBgUKCAIBBgQEAgICAgIDAgIFAgsCAQEBAQIBAgICAQECAQECAwEBAQMBAgIDAgECAQECAQEDJwIRCAQGBAcMBw0IAgQEBQYCBwUDAwMCAgECBAEDAgECAQIBAQICAwIDAwIBAgECAgUCBQECAgcDAw8GBQgEAwUDBQUCBhQJDAgEDQUFBwUDBgMYHQsDBQIWCAwIAgcECQ8GBAcFAwQBBAECBAYDAwgGAgoLBAkFAgYDCQYFCQQOCAQJAwISEw0IBgcKBQQHBgsCBgICBgYDCgICBgIBAgICAgQCBQQBAQEBBQwFAgICAQMBAQICAgECBQIDAgECBQIHBQECCAICCQEDAQwGBwcMBgYCBRAHCwYDCA4LBQgEAwcDBgsFAwYCBgsGBQEBAQMDDxwPBw0IBQwFCQcEAgYDAgQCBgEJBgUGAgUEAgIFAgQDAgIEAgMBAQIDAwQCAgUEAgQBAgECAgQBAQQDAgcFCggEBgMDBgMECAUFDgkLAwIIEQcIEAgGCgUFCgQIAQcEAQYFAgIBAQICAQEBAQIEBAIGAgcZDgUIBQMCAQECAgQCBgEBBQsCBQEHBwIBCQIFAwIHBQgcBgEFAwIBAQICBA4HDRIMBQgEAwYDAwYEAwcCBQgFBgIDCA8FCAMCEQwFAgkBBQYFAgcCAgYBBQMCBAIEBwMICQQECAUGCAEFAQQECQICAgQFBQYGBQEEBgcECBkFFwkKAQICBAIBBQIDCAMLAwsEAgwSDgUDBgULBwwOKREIEAgHBwQHAgIHBgQGBAMHAQUCAQEBAQIBAgEBBAkDBAQCBgECBwsFDBcKBQgDDAQGBAUJBQUJBQUSBQkJCgIFCwICAwgCCxkLBAoGDQQFBQIFCgYFBgIKBwMFEhMTBgQHBQUGAggBAgAAAAL/6v/0AgwC+wF2AewAAAEWBgcGBgcGBgcUFhUUBgcGFhUGBgcUFAcGFhUGFRYWFRQGBxQUBwYWBzY2NzI3NjY3NzY2NzY2NzY2NzY2NzY3NjY3JhcWBgcGFBUGFAcWBhUGBgcUBwYGBwYGBwYWFRQGFwYGByYmJyYmJyYmJyYmJyY0JyYnJiYnJgYnBhYVFBYHFRQGFRQGFxYWFxYVFhYXFjIXFjYXFhYXFhYXMhcWIhciBgciIgciBiMGJiMGBiMiJgciBiMGJiMGBgcmBiMmBgcGIgcGJyY+Aic2NzY2NzY2NzY0NzY2NzYmNzY2NTYmNTY2NSY2JyYiJyYjIiYjIgYnIiIHBgYjBgYHIjEiBiMGBgciIgcGBgcmJicmJicmIjc0NzY2NzY2NzY2NzY2NTY3NzY2NzY2NzY2NzY2NzY2NzY2NzY2NzYxNjE2NzY2NzY3NjY3NjYnNjY3NjY3NjY3NjY3Njc3NjY3NjY3NjQ3FhYXFjIXFhYXFjIXFjYzFjM2AzYmNTY2NSY2NTY3NjY3JjQ3NjY3NicmJicmJic0Jic0JyYmJyY2JwYiBwYiBwcGBgcGBgcGBgcGBgcGBgcGBgcGBgcGBgcGFAcGBgcHBhYHBhQHBhYHBgYHBgcGBgcGBgcWMhc2MjM2FhcyNjMyNjMyFjcmNgGXAwMBAwECAQIBAQIBAQEBAQEBAQEEAQICAQECAgIPCwUIAwgHAggEBAICCAIDAQIFBAIDAgEBAgEKBAUBAQECAQICAgEBAQQBAgECAQEHBQEFAgUDAgYBAgIDAgIBAQMCAwcDBwkGCwYCAQECAQICAgcEBwQHBAkCAQcBAgwKAw8WCwcDAQgBHjUXBgsFAwYCBAcFAgYDBQkFBQoFBQsFAwUDDAQCDgsGAwcDCwoBAgMDAQQIChgMBg4FBgEHBQIBAQEBAQEBAgEBAgELFgsKAQsZCAwZDAgTCQgLAgoBAgwDBQMDBwMDBwILFQsEAwICBAIDBgIGCAUCBwcEBQECAgQGBgkGCwUFCAQGAwICAwIDAgICBgIFBQIGBwIEAgECBQMEBgUBAgEGBgQCBQMDBgMCBAMKAQgGAgECAgQBAgsHBQsFAgUJBAcPCgoBAgkCDFYBAQEEAgIBBQEBAgEBAQMBAgIBAgEBAgEDAgEFAgECAQUIAQEFAQEHCQUDAwUCBwICBQUECQQCAwgDAwUCCAYDAwEHBgIEBwEBBAEGAQEEBgIIBgUDAQQFAgwSCwMGAwoOBg0lERAMBgsVCgECAuYGDQYPHQ4HDQcFCgUJEgsFBwUGDgcIDwgHAQMSBQMHAwgRCAgTCBUpFAECAQEEBAIJAgYEBQsGBwcDCgwFCgQDBgILAREOCAUJBQcRBgwCAhEOCAoEAwcEBxcLCAYFChMLBAIEAQkFBgYCAwYCCQECBQQCCAMIBgIBAgIIDwgFDAgUDQ8HCA8FBgUECQMDBQMJAQUBAQcBBAILBAUFBQQCAQIBAQECAQECAQEBAQEBAgECAQEBAwMEAwMDBAEGCA4IBQwIBgMCCggLCA0JCxMJBQwFCwEBDhQJAwECAgIBAgEBAgEBAgEBAQECCgIGDwgEBgQJAwYGCgQCCggFBgICAgcFAgUJEQwIBw4FCgICAgYCBQYCBAcFDQYECgoEBgMFAgoHBQ0FBQEFBQwGAwkFBQoFBAcEDAwIDAECAwcCBQkDAQYCAgECBAECAQMCAQT+YwQJBAUKBQgCARwXAwwBBwgFCBAIFhYDBwMDBgMNGwkKBA0FAwoUCAgBCQIKCwgEBAYDDAQCCQkFDQsFCA0IBQkFCgwGBgMCDQkFCwsDAgQIAgkBAQQGBA8GCwICBg0GAgICAgEBAwEDAgUIAAEAMv/MAhsDAQJSAAABFgYVBgYVFAcWBgcGFgcGBgcGFAcGBgcGFAcGFAcGBgcGFgcGBgcmNic0JyYmJyY2JzQmJyYmJyYmJyYmJyYmJyYmJyYmJyYmIwYGBwYmByIGIyImIwYGBwYGBwYGBwYUFxQGFRQWFRQGFQYXFBYVBhYVFAYHBhQHBhYVFBYVFgYXNjY3NjY3Njc2Njc2Njc2NzY2NzYyNzY2NzYWNzI3NhYzFjIXFhYXFhYXFhYXFhQXFhYXFhQXFhYXFhYXFhQXFgYXFhYHFBQVFhYVBhYVBhQHBhQHBgYHBgYHBjEGBgcGBgcGBgcGBgcGBgcGBwYGBwYGBwYGBwYGBwYHBgYHBgYHBgYHBgYHBgYjIiYjJiYnJiYnJiYnJicmJicmJicGBgcGBgcGFhUGBgcGByY2NSYmJzQ3NDY3NjQ3NDY1NiY1NjY3NiY3NDY3NDY3NjQ3FgYVFBcWFhcWFhcWFBcWFhcWFhcWMhcWFhcWFhcWFhcWMhcWNjMyFjM2Njc2Njc2NzYzNjY/AjY2NzY2NzY3NjY3NjY3NjY1NjQ3NDQnJjYnJjQnJiYnJiYnJiYnJiYnJiYnJiYjIgYHBgYHBgYHBgYHBgYHBgYHBiIHBgYHBgYHBgYHBgYHJiYnJiciBwYGBwYGJyY2NzYmNzY2NzY2NzY0NzQ2NSY2NTQmNzQ2NTQmNTU0NCcmJjc1NDY1NjQ3NhYzFhcWFjM2FjMyNhcWMzI2MzIWMzYUMzI2MzYWMzc2NjMWNjM3FjYzFjYzNjY3NhY3NjY3NjI3MjYzNjI3NhYCBQUDBAMCAQIBAQEBAQMBAQEBAwECAQIBAQIBAQEBAQMHBAEBAgEBAgUCAgQCAgECBgICAgICBAcIBwsJBQoICBYJBQoFDRYLBAYECQMBBQcFBw0JBg0IBAEBAQEBAQEBBAMBAQEEAwEBAQMEAwIJBgIHAwUKAgIFAw0DCgsFAwYDAwcCBhEGDAIMCQUMEggDBgUFCQUIEQwKAgkBAQoCBQMEAQQCAwEFAQICBgEBBAEEAQEGAgQCAgQDAQYIBgMFAgEGAgIDBgMCBwQIBgkEBAYHBQULBgYNBgYGAwUCCwYFCAwGDw4IBg8FAwcDCwgHBAUCAwUFAQYDBAMDCAkFBQQCAgIDAQUEAgYDBAEBAQECAQECAgMBAQECAQEBAQIBAQEBBggEAgMGAgECAQIEAQICAgUCBQIBBQYCCQwIBQoFBAgCAwgGBQkFBw8ICBEJCgEGBQQLBQoNAwUCBgoFBgEBAwIECwQEAwEBAgMCAQQBAgYDAwcFBQkFCAEBCAcFBQcHBQwGBg0FBQgFBAkEAgcCCgIBBQQCCwgEAwQCAgQCCQUECA8ICBESCwkHAwQPAwYFAQEBAQEBAQEBAQIBAgEBAgECBgEBAQEBAQMEBQMHCwsFAgUGAwUJCA4QBAgEBAYDCwIDBwQDBgMLCQUCCQcDDQIHAgoKCAoGBQQHBBYZCwUJBAQGBAgQBwcFAwEDBgIRGg4ECAwGAwMHBAYLBgcOBwUKBQgNBwcNBwIFBAMGAwQNAQULBgQIBQsHDwsFBgoFBQsFDwgGBQcGBgMFBAUCAQICAgIBAQEBAQEBAQEDAgIBAgIDAhEXDAcMBQUKBQQHAwwNBQsGDAcEBQoFAgYDDQwFBQcFCxMKAQYDBwUDBQMCAwEBAgIFAQQEAgEBAQIBAQEBAQEDAQQCAwEBAQEFCgIHAgEGAgEGAwIDBwIFDAYIBAIKCQQHCQoECQUIDgkPCwYHEgUNCgYKBAIHBgIKCwMCBgEBAwMCAgQDAgUCBQMHAgIEAwICBwIDBQIDAgIDAQICAQMCAgYBAgECAQEBAwQBAQIIAQMGBQgHBgoCAwkFBQcFBgMCDhEJBgEDCQUFCQUWDAgNBhMSCgUJBQgNCAUNCAUIBgIKBQMFAwUMAgURCAcIBQwIAwcEBwoEAQcCBAYECgEHBQQEDQMCAQEBAQICAgEEAQIBAgMBAgIDAgUGAgICBQ4IDQICBgQIDwkOBwUECgUJEggNBgQMCAQLEwoECAQDBwMDAgEFBAICBAMCAgECAgQCAgIDAgIBBwEBBQIIBwMCAwICBQIFBwICAwICAgMDAgEBAwINEAgKFgsDCQMLFAwGDQYFDAUDBwMKEgkGDQYJEAsnDQsHCxINDAMIAgkCAgIEAwEDAgEBAQIEAQIBAQIBAQICAQEBBAIDAQIBAQEBAQEFAgIBAQMCAgQBAAAAAgAf/98CNgMkAeQCTgAAARYUFQYUBxQGFQYWBwYGBxQGFRQGBwYGBxQWBwYWBxYGByYmNSY2NSYnJicmJicmJicmJicmJicmJicmJicmJyYmJyYmJyYmBwYHBgYnBgYHBgYHBgYHBgYHBgYHBgcGBgcGFQYGBwYGBwYGBwYGBwYGBwYGBwYG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AwMFAgUMBgULBQMIBQgKCwgJBAkMBwgKBQwKBQICBgEBAgIDAQFbAwMCCAYDAgYDCwUHAwgBAgsCAwgFBQgDBQYEBAgEDAMEBgUCCAMKFAgFBQIHAwIDCAIIDAcDCwMBAgEEAgIDAgIBAQICAQIBAgICAgYCAQEBBQIKBwMFDQYFBwUNBwMLCwUMGgwDBgIGBQIHBQIFBgQFCAgSCAQJAgYHAgMFAgICAQQBAQICAwECAQIEAQEDCAIFCAUNGA8ICQUIAwQCAgQHAgcCCAICAwECAwIFBAcFCBYGEgYDBgsDBwIFEAUCCAEKAwcHBwUIAg0GAgIFAgECAQMIAgMICwgEBgUIDQcBCg0CBwMEBwIDBQIEAgIDAQMBAgUCBwMDCAMDBwMIDAgDCAwDBgsGCQIKBwUUCwcCAgQCVQQCAQkRCAkDAwEDAgEBAgECAwMBBQcBAQgBAgcCAQIDAgYBAgwMAwgDCwcDCQUDCgECBwMCBQgFCBEJCwwFCAUEBwwFCg0FDgkFCAsFDgkFCwUGAwcBAQcIBAIGAgQDDQsFBQEBAQECAgIBAgIBAQEDAQICAQECBgEGAgEDBgMFBwUCCgUIAQwNBQoBAhAFBQoEAwYECBQJFwcOCAYEAgkKBQsSCgEIAwQIBQUHAggHBgYFAgMEAwYCBQMCAgQDAwEBAQICAwECBAQBAgYCAgMCBwEBBwIBBwEKBAIKBwQDBAICDAULAwIGDwcHDAUFCgUIAw4NCAgSCgsYDgcOBgcDAgMFBAUJBQwEAg8LBQUMBQQHBQsDAQ8LBgsCAQcICBAICAcEDQcCCAUEAgQDCgQCBAIPBgIBAQIGAgEBAQMBAgMCAgUCAQECAgIBAgQDBAQCAwYKBQUJAwUKBgIKAhMGBAILBgICBgIHAQMGAgUCAQgBAgICAgIBAQIBAQMBAQMCAwIFCggCBQIFBgIDBwMNDQcKFAsCBgMJAwcKCQMCBQUCCAICAwcEBw8HBgwGBQcDBAUECQYEBQYFBgIDAgEGAgUBBQMBAQUBAQUBAQIBAgIEBAgEAgQCAwsCAwoEAwQEBAgDBAcECQYDAgcEBwwFBQQFAwgGCgcDCgUFCwIBAwMCAwYBAQUFAgYHCAYFCAUKFwsIAwUFBAEFAgMDBw8RAQIEBAICAQMFBAIFAQECCAQCBwQFDQQCAwkCDQECCAECAQEBAQIBAgQBBgMDBgQGBQMDAgYUCBIDBQkECQgFCAUFBwUECAIBAgUBAgEBBAIEBgMEBQ4AAAIAE//5AH4BTgAqAFIAADc2FhcWFxYWFxUWBgcGBgcGBgcGBgcGJyYmJyYmJyYmNzY2NzY2MzY2NzY3FhYHBhQHBwYGBwYGBwYjBgYnIiYjJiYnJiYnJiY3Njc2Njc2NzY2SAITBAsGAgUBAQMCAQECAggCCgYECgwCBQQFBwMHCAcCBAIJAQECBwMHMwQHAwMBCwcBAQkBAggFBQgDBQYGAwMBAwMBBQICBgMCCQQHAxEaXwIFAQQKBgYDEwQGAgMHAgIHAgUGAgICAQUCBAIFChwPAwUDBwQBAQED5w8YEQkFAg4DAwEDAgECAQEBBAYBAgQHAggLDgsHBAsDBAMEBAAAAgAT/7cAkgFOADgAXgAAFzY2NzY0NzYmNyYGIiYnJiYnJiYnJiY3NjY3NjY3NjYXFhcWFhcWFgcGFAcUBgcGBgcGBgcGBiMGExYWBwYGBwYGBwYiBwYjBiciJiMmJicmJicmJjc2NzY2NzY3NjZCBA4IBgEEAgEHERAPBAUEAwIBAgIFAQUFBAgEAgUSCw4SCQsFBAMBAQEDAQIDAgQWDAIHAg5ABQYCAwEBCAECCQQCDAcLBAUGBwMDAQIEAQUCAgUFAggFBwMQGzMGBQIHAgEHCwcBAgMGAgQFAgMFBBAJCwwCAwQCAwMBAQoFDAsIEg8FCwQCCAQHCAUJDwUBAgEBjw8YEQkFAggEAggBBgIBBAYBAgQHAggLDgoIBAsDBAMEBAAAAAAB//cAeAE5Ad8AvQAAExcWFxYWFxYWMxYXFhcWFxYUMxYWFxYWFxYWFxYWFxYGFxYHBhYHBhYVBgcmJicmJicmJicmJyYmJyYmJyYmJyYmJyYiJyYGJyYmJyYmJyYiJyYmJyYmJyYxJiYnJjY3NjY3NjY3Njc2Njc2Njc2Njc2Njc2Njc2MzY3NjY3NjY3NjY3NjY3NjY3NjY3NjcWBhcWFhUGBgcGBgcGBgcGBwYjBiIHBiIHBgYHBgYHBgYHBgYHBwYGBwYGBxYWF3gKDAUCCAMJAQIHCw4JCwQJAQUHAgUFAgUVBwIGAwMCAQMCAwIBAwMEAgoHBQQJBAMJBBIRCwICBgoGDAwHBg0HCQQBBgMCAgYDCwYDBgQCCQECDAQECgIMAgIFAggEAwMHBA0IBAcEBQYEBgwGBggEBAYECgEJAQsIBQYMBwgEBAUNBgMHAgcMBwgICgMBAQMBBAECBgMMCgUEBwgDBwMCCwIBDgYDBQYEBwMCCwMCCwsKBQoKAwMIBQEiBQUEAgICBAIFBAcDBwIEAQMDAQICAQIMAwEBAgIOAgQHCQYCDAYDCgEFBQIDBgIFBgIMCAcCAQIKAggGBAUFBQcBBQEBAQUCBgECBAIEAwIGAwEFAQICBwICBAICAgUCBgYCBAICBAIECAQDBQICBAIGBQEGBQIEBwMEAgICBwMDAwIFCAMGAgEFAgwLBg0WBAIBAQYDAgICAwQBBQEFBAICAgEFAQEGAQEFBgYEBQcCAgMCAAIACgDPAawBswBHAKEAAAEGBhUWFhUGFhUmBgcmJiMmJicGJiMGIicjIiYjIgYnJgYjJiInIiYjIiYjBiMiIwYGByY2JzYWMzMWNjcWNjc2FjMyNjc2FgcWBhUUFgcGByYmJyIGIyYGIyYGJyImIwYGJyImBwYGIwYGByYmJyYmJyY0JyY0NxY0MxY2MzIWMxY2MzIWNzI2MzMyNjM2Fjc2MhcyFjMWNjMWFjMyNjcWNgGsAgMBAQEEBQMDBQsFBg0GDAUCEy8bEwYJBQgWCwgDAgUNBwsVCwgCAg0ICgYIDggJBAQXLRcNHUMgDSELER8RDhkOBgMLAgEDBQYEBQYFAgYDCgEBCx4OFBYLChMJDx4RESERDx8PAwICAgICAQECAgwBDAwFBQwFCx8QAwYGCAoFFRARCQgJBgQIBAQGAwQGBA4aDhIRCQUFAa8GCQoHBgQMBgQCBAQEAQEBAQICAQIBAQIDAgEBAgEDAgQCDiAQBQcCAQEBAgEBAgQCAQOeBAsFDhAGAwQBAgEBAgEDAQEBAQEBAwEBAQEGBAMJBQMGBQMHBQ0HBQMDAwMCAQMCAgEBAQMBAQEDAQMCBAEBAQUAAQAUAHgBVwHgAK8AABM2NyYmJyYmJyYnJyYmJyYnJiYnJiInJiInJyYnJiYnJiYnJiY3JjYnNiY3FhYXFhYXFhYXFhYXFhYXFhYXFhYXFjIXFhcWFxYWFxYWFxYWFxYWFxYXFhYXFxYXBgYHBgcGBwYHBgcGBgcGBgcHBgYHBgYHBgYHBgYHBgYHBgYHBgcGBgcGBgcGJyY2NSY2NSY3NiY3Njc2Njc2NTY2NzY0MzY3Njc2Nzc2Njc2NzY34AkIAwsECgsECQEOCwMCDQcDBwQLAgEMAwIKCwMHCgUKBwECBAEBAwECAwQJBgENDAUFBwMGCwYEBQMLCwgECAUKBAIJAwcGBAgECQsHBAYEAwkDBwcMBgMKDAIGCwMKAQ8ECQILAgMGAgsHAgsIBAIHDAcGDAYNCgUIAgEPEQgIBgYKAgUHAwkCAwMDAQQDAQMDBAgGFQYKAwgBCQEIBg8GEQgLAwgCBQgKBAEpAwQCBwIHBgIEAQcGAQEFBAIEAQUBBQEFAgIDAwIFAQIEFgQPCwQKBQICAQEICAMEAwMDBwICAgIFBwQCBQIIAgQCBAQCBQIFCAQCBAICBAIFAwYFAgUHAgcCAQQBCQEGAgUCAgECBgUBBQQDAQUFBQQGBAYKAgUBAQgKBQYEBQYDAgUCAwUJBgQKBgMOAwIOAgICAwwCBAEBAwEEAQQEBwMHBQUDAgIEAgYCAAAC////4gHVAvgB2QIFAAATBhYXBjYVFgYVFBYHBiYnIiYjJiYnJjc2Njc2Njc2NDc2NzY2NzQmNzY2JyYmNTYmNzY2NzYmNzYWFxYWFxYWFxYXNhY3NjY3NzY2NzY2NzY2NzY0NzY2NzY2NzY2NzY3NjY3NjY3NjY1NiY1JiYnJiYnJiYnJicmJicmIicmIicmJiMmJicmJicmBiciJiMiDgIHBiIHBgYHBgYHBiMGBgcGBhUGFhcWFhcWFhcWFxYWFxYWFxYWNzI0MzI2NzY2NzY2NzY3NjYnJiYnJiYnJiYnJgYHBgcGBgcGFzI2NzI2FxYGBwYGByYGJyYnJiYnNjY3Njc2Njc2Fjc2Njc2FhcWFhcWFxYXFhYXFhYXBhYHBgYVBgYHBjEGIwYGBwYGBwYGBwYmIyIGJyImIyInJiYnJiYnJiYnJiYnJjQnJiYnJjQnJiY3NjQ1NjY3NjQ3Njc2NzY2NzY2NzY3NjY3NjYzMhYzFjYzMxY2FxYWMzI2FxY2MxY2MxYWFxYWFxYWFxYWFxYXFhYXFhUWFxYWFxYWFxYWFxYWBwYGBwYWFRQGFRYGFQYUBxQGFQYWBwYHBgYHBiIHBgYHBgYHBgYHBiIHBgYjBiciBgciJiMiIgciBiMiJiMmBhcWFBcWFhcWFhUUBgcGBgcGBgcGBgcGJicmJyYmNzY2NzQ2NzY2NzY2NzY2vAsKBwEJCAMDAQgTCQULBQ4iDwEDAQQCAgMBAgIFAwECAQEBAQEBAQEBAQIBBQECAgUGBgMDBgMFEgQKCwYKBAsaChIHDAUKBAICBgUCAggKAwICAQIBAgEEBAQCAQEBBAMBBAEICAIGAwQMBgMIBQ0IBwMCAwwFAwcDAwcDBAUDCBQJBAcECREUEgUIBAMHBwQCAQICAwIFAgIEAgEDAQMCAwQCBAkICAQGCAMRHg0KAgUFAgcCAQICAgUEAwQBAQQCCQUDAwUEBQkFCQkIDwMDCQgLAwcDCQQJBQUIBgsEAgoEBQkBAQECAwQIBgUFCAUHDAcIDwYEBQQGBgcCAgECAgMBAQICAwICBgQFBgMGAQEDCAUDBwQIDwkFCAUFCgULCwcMBQoLBQIGAwQHAgcBCQcCAgEBBQEBAQMBAgIECAYECQMCCwcFCQIFCwcGCggGDggGDQYhEB8PBQgEBAcECwECCAMCAwYDBggFBQwDBQQCDQUCBAIHAwQCAwIGAQICBAIGAwIBAwEBAQIBAQEBAwIDAgQEBgUDBQICBAgFBwkIAwoFBAgEAwcDDxMMBwQFBgQECAMDBgMEBwUIEAwDAgIEAQECAgIICQYFCQUIDQYNDggMCAMIBQQIBQYCAwQEBREMDBcBKRY3FQUCBQ4MBgUHAwwFAgEBAQUKCwMJBQIHAwMHBA0OAwYDAwYEBgkIBQkFCRIGBQcFBQsDAgcCAgcCAwQBAwEBAwEBAQQIBwgFCAMCAwcCAgcCCw0GAwgCBQcEAwgOBgMECwUODAYHEQYTIgsDCQICBgQCBAMGAgIBAgEBAwEBAQECAQECAQIBAwUDBAIDBgcCBQMLBg4IBQcFBhgFAwQDBgMCBgUFAwICAQIKBgECAwIKAQEDBwQICwgJBwUKBQwGAgMFAQECAgEEAggIEw4BBAsCCAkFBAgCBAEBBQMDCQgJEAgQBAgCAQEBAgIHAQIFAwMEBQgICQQDBgMEDgYIDgUKAgEFCwMKCAYCAQICAgIEAQICAQEDBAIGAgQBAgEEAgMDAwoCAgsLBQgPCAwYEQMIAwMGBAQGAwgIBwMFBAIHBgIEAQICAgIDAgECAQEBAQICAQIBAwEBAgECAgMEAwIFAgIKBQMIAwgBBQQDCAQMCAQDBwUeJhMKEwsLAQEDBgMIAgIGDgUFBwQIEQgGBQgHBAYBBQcEBQoDAgQBAgEBAgICAgEBAQICAQPZAwMEAgMEAgsDBg4GDgsEAgQCBAUBAQYHCAkEEAgGCAIDBAMDBQUFBAICAQAAAAACAB7/7wMGAv0C4wNgAAABBgYHBgYHBgYHBgYHBgYHBgYHBgYHBgYHBgYHBwYmIyYmJyYmJyYnJiYnJiYnJiYnJicmJjUmJic2JicmNzYmNTQ2NSY0NzY2NzQ3NiY3Njc0Njc2Njc2Njc2Njc2Njc2Njc2Njc2Njc2Njc2NDc2Njc2Njc2Njc2Njc2Njc2NhcWFxYWFxYWFxYWFxYWFxYXFgYHBhQHBgYHBhQHBgYHFAYVBhQHBgYVBhYVBgYHFBYHBhYVBgYVFBYXFhYXFhY3NjY3NjY3NjY3Njc2Njc2Njc2NjU2Njc2NjU2Njc2NjU0NjU2JyY0JyY2JyY2JyYmJyYmJyYmJyYmJyY0JyYmJycmJicmJiciJicmJicmJicmIicmJicmBicmIyIHBiYHBgYHIgcGBgcGIgcGBgcGBgcGBgcGBgcGBgcGBgcGBgcGBgcGBwYGBwYGBwYUBwYHFgYVBhYHFAYHBgYHBhYXFgYXFBYVFhQXFBYVFhQXFhcWFhcWFhcWFhcWFhcWFhcWFhcWFxYXFhYXFhYXFhcWFhcWMxYWFxYWFxYWFxY3Njc2NzYzNjI3NjY3NjY3Njc2NzYXFhYXFhYXBgYHBgYHBgYHBgYHBgYHBgYHBgYjBiYjBiYnJiYnJiYnJicmJicmJicmJyYnJiYnJiYnJicmJicmJicmBicmJyYmJyYmJyYnJiYnJiYnJiYnJjYnJiYnJiY1JjYnJjYnJjY1NiY1NjcmNjU2NDc2NjU2Njc2Njc2Njc2Njc2Njc2NzY2NzY3NjY3NjY3NjY3Njc2NzY2NzY2NzY2NzY2NzY2NzY2NzYWMzY2FzIWFxYWFxYWFxYWFxYXFhYXFhYXFhcWFhcWFxYWFxYWFxYWFxYWFRYWFxYWFxYWBwYGBwYGBxYGFQYWFQYWFQYUFQYGBwYGBwYGBwYGBwYUBwYGBwYGBwYHBgYHBgYHBgcGBgcGBgciIicGJicmJicmJicmJicmNjc2Njc2Jgc2Njc2NzY2NzY2NzY2NzY2NTY2NyY2NzY2NzY2NzYmNTYmNSY0JyY1JiYnJiInJiYnJiYjBgYHBgYHBiIHBgYHBiMHBgYHBgcGBgcGBgcHBgYHBgYHBhQHBgYHBgYVFBYXFhYXFhYXFhYXFhYXFxYWFxYyFxYWFxYWFzY2AhYJAgIHBgMGAQICBwMDBAIHAwICBAMDBgUPFg4MDAsFCxAICQQCCAELBgMCBAIHAgIEAQICAwMDAQEBAQEEAwMCAgEDAgIBAQMCAgYCAgICAgQCBgYCAgQBAQQCBwICAgYECwoFCQIHBwMLAwIMAwIFBwQNCQkKFg0QDQYCAgUBAQIGAgsRBQkFAgcCAQECAwEBAQECAQEDAQECAgICAgEBAQMBAQQEAQYMCAYNBwQFAwIFAgMFAgcDAgIBBAMCAQICAQIBAgMEAgIGAgICBAEDAQEGAQECBgIEBgUFAgIGCgYLAgsIAhAEBgUHDQcFBgUECgQDBQUNCAUDCAMFCQUKBgQKBQgDBQkCBwQDBQIIAgIFDwYIBQMKBwMDCQMDBAIFBQICCQQGBwMMCAQIAwIDAgICAgQCBQIBAQEBAQICBQEDAQMCAgEBAgEBAQMBAgIFAwECAQIECQUGAgIJBgIFCAQGBQYECwYCBgYLCQcKAQUJBAMJBg0GAhocDgIICQYFBwMBAwUCBAcDBQYHCw0BAwIBAQICBwYDBAcCAwwGCgIBCQgFBAYEDioUCRMFBAoEAgsFBAcFDAoIBgMGCgUVERQRAgQCAgMCBgMCBAICAwIDBAETDwECAQkEAwIDAgQCAgUCAgMBAgECAwQCAgMCAQECAQECAgECAgQBAgEBAQMGBAIIBQQCAwIHBAIEBwcECAYKBQYEDgwGAwoFBQUDCAYPBAUKBQIEBAYFAgoXCwcYBQUSBwwBAQseDAYNCA8LBwcJBQIHAwwKCxULAwgEBwkDBQEJCAIDAgoIBQQGBQUDAgUDBQoFAwMBAQQCAQIBAQMBAgMCAQEFAgEBAQQEAwIDAQYBAgQCAwgFBgICAwMCCAIDBgUFBQgPDgYKBQoMBwkHAwIGBAIEAgICAQIEAQIBZwYLBgQDBgEBBgQBCgYEBQIIAQoCBwEFAQECAQEBAgEBAQEFBQICBAMBBgQBBw8HDA4MCgICCQMCAgYCBwMHCQUDDAoKBwIFAQEGBgIBAgMBAQECBQEDAgEBAgMCAwYCAgECAgMCCAQDAQgFAgcQCAkUCwUFAQYIAQIKBQUIAwIDBQQFBgIJAQICBAIDBgIIDwQDAgEBAgQGAQIIAQsIBQMKBgwFBAkBCQICExgKBgcEDhEKBgIFCwUFBgUECQQMBAMIAgsEBgoFAwcFAgYECwQDBQIEAwQCCQECAgYCBgkCAwEBAwMCAgIBAwIBAgMCBAMBAQMBAgcEAQIEBAIEBgQNCAYBBwsVCQUNBwcNBwgQCAUKBQQGAg0KBQUKBQYNBwUJBQIGAwUIBQUOBwcOBwEBAgEBAgIIBQUJAwUIBAwEAQgECggECgECBgwGAwYEChELDyIOBQkFEAwKBgMHAwELAgIFCwYHBwUDBAIGCgQFAgEIBgIGAgQCAwYFBQIDAgEBAgIFAgEDAQEBAQICAQEBAQIBAQIBAgMBAgYDBgICBgUCAwQDAgUCAgUCAwcDCQYDFggJEQoFCAUFCgUFBgQGAwYNBwYMBQgRChUbDAYOCAIGBAIHAgQFAwgMBgoHAgUDCwQCAwUCBgsHCAMCCAYCBgQDCAEGAwYEAgQDBQcDBAIBAgIBAgMCAQUFAwECAwMGAQIEAQIBAgQCBQYBAgcBAwIGAwcGAwgFAwUHAwgBAQcFAwIFAgcDAQEBAgEBAQIBAQEDBAYBAgIIBA8PDxECBAICBgIGAwIEAgIHAgwBARcWAgcCCwoFAgkFCQUFCQUFBQYEBgUIEgkGBAIJBwIDCwUMBgIFCwYPDQUGBQMHAwoBAg0IBQsLBQIFAwoIAwUKBQQGBgoFBgILCwUDBQMDBQIGAgkCAwYDAQICBAEBAwoEAgQCAgEBAgIBAQIDAQMCAQIDAgIBAQUDBQoEBAYFBQgCBAMFCgIFAg0HBAQHBAkCAQQKBQwXDQgaDggRCQQJBAUHBAMFAwsBAQIMBQYMBQQFAwgUCAYLBwkEAgUIBQgRCAoEBAkFBAoEAwQEAwMFBwEBAQcDBQMCAgQCAwYFBRQICA0HBgskBg0GCAMFAwIGAwIMDAUIAQERGwsICQUOBgIGDggKFAoLBQMFCgQMAwsCAgkBBwIBBgUBCgcFAgEGAgIGAgcJBwYCCgwICQMDBgIKCAEBCAQCAwYDBgkFChgIBg4FCAYGBgsFBQYCAgUCCAcDAQkBBAkCAgICAwgAAv/L//MDQQL2AlACwwAAAQYiBwYGBwcGBgcGBgcWBhUUFxQWFxYWFxYWFxcUFhcWFhcWFhcWFhcWFhcWFxYWFxcWFhcWFhcWFhcWFhcWFxYUFxYWFxYWFxYXFxYUFxYUFxYWFxYWFxYXFhYXFhcWFxYyFxYWFxYWFxY2FwYUIyImIyYGBwYiByIGIyIGBwYmByIGIwYGByImBwYGJyImIyIGIyYGJyInNjY3NjY3Njc2NzY2NzYyNzYWNzY2NzI2NzY3NjYnJjYnJjQnJjQnJiYnJiYnJiYnJiIjJiYjIgYjBgYjIyYHBiYnJgcHBiIjIiYHBgYHBgYHFBYVFAYXFhcGFhUGBhcWFhcWFhcWFhcWFhcWFgcGJiMGIgciBiMmBgciJicmBiciJiMiBiMiNCMGBiMiJiMiBiMGBiMmNjc2NzY3NjY3NjY3NjY3NjY3NjY3NiY3NjYnNjY3NjY3NjY3NjY3NjY3NiY3NzY2NzY2NzY2NzY2JzY2NzY2NTYmJzY2NzY2NzY3NjY3NjQ3NjY3NjY3NjY3NiY3NDY3NjY3NjYnJiYnBiYnJiInIiYHBgYHBgcGFAcGBgcGFBcUBhcUFhcWFxYWFxYWFxY2NzY2NzY2NzY2NzYmJyYGBwYGBwcmBzY3NjM2Njc2Njc2NhcWFhcWFhUGBwYGBwYGBwYzBgYHBiIHBiIHBgYnJiYnJiYnJiYnJiYnJiYnJiY3NjY3NiY3NjY3NjY3NjY3NjY3NjY3NhYzMjY3NhYzMjYzMhYzNhYzMhYzMjYXFjYzMzY2NzYWNzY2NzY2NzYXNhYHJyYmJyYmJyYmJyYnJicmMSYnBgYVBgYHBgYHBgYHBwYHBgYHBgYVBgYHBhQHBgYHBgYHBgYHBgYHBhQHBgYHBgYHFjYXFhYXFjYXMhYzMjYzMhYzMjY3NjY3NiYnNDQnJiYnJiY1NiYnJiYnJyYmJzQmAjwCBgIDCAQKBwsIAgUDAQMCAwECAQIGAgIEAgECBQUCBQQBAwICAwMDBQIEAQUCBAIGAQICBgMDBgQEAwICBAUCBAICAwIFBQIFAQIEAgYGAgkGCAgFCAINBAcEAgUNBQUHBQQJBAkCAwgFCRULBw8IDw0IBAUCCxYKBgwGDhoNBgwGChIJBQcFAwYDDhMIDwoFBgQHDwgFCgwIBQkFAwYCCwMCBwMCBQUCCAMBBAEGAQEEAQMBAgUCAwMCBw0HDAoGBw0HAggEER0UCwYHCwYDERAMCA8HCAwHCBAGAgcBAQMCAQQDAQEBBAIIBQUQBgcFAwcSBwMIAQoHBAUJBQQHBRgkEQoUCgsUCgQHBQQHBAsBBQkFCA0GBQoFAwsFDAkCDAELAQkPBQsGBAMHAwYIBwIIBAUBAQIFAQkIAgICAQQGBQIDAgMEAQICAgcCAwICAgIHAgICBAEFBQQCAwECAgIDAQQDAgMFAgMCBgEECAQCAgICBAECAQICAQsJBgIFAQINBAsVCgseEQgSCAoSCBERCgIJBAMEAQEBBgICBwQGAwUDBg4GBQgKBwIHAgIBAgUNBgsHAwQFAg0JBAEFBwEIBwMDBAUEBgQLDwgEDAMCAgcFBAcECwEJBAIJBQIFBgUEBAUHCgUFCQMGDQUDBwICAgEBAQIBAwEBAQEDDQUCAgMHCwUFBwUPDwYFCwUDBwQPIg0IDwgJEgwEBgMIEQgNHw4DCwQUDQgEBQoFDBYLBAgFBgkDDH0JAwYDAQIBAgICAQQEBAUHBwkDAgUCAgECBAgCCgcBBwQDAQMCAQEBAQcDAwIDAQgMBwIGAgICAQQCAwIBCxgMCA4HBxEJBw4HBwsHBQoFDBgNDh8IAgwFAQYBAQEDAQMBAgEDCQMFAwcC8w4CBQUFCAYOBQUGAwwHAgQKBw0IBg0FDgkFDQgFAggQBgkSCA0MBQYKBQsKBwUDDwYLBgkIAwcKCAkSCQgHAwcCCwsGCQsEBQUKCAcEBwYDBAYEDAgEDgUECQMFAwcCBwECBQICAgEBAQQFAgIBBAEBAQICAQEBAQIBAQEBAQEDAQIBAQMBBgwCAgMGBAEEBwICBgICAgcBAQQFAgUCBgMGDQgKAgIHCQUMBQIFCwUMCQUHAgIDAQMBAQEBAQECAQICAwECAQEDAQkVDAMGBAUHBQkJDQoFCBEHBAsEBAYEBgECAwoFAgEFBgIBAgMBAwECAQEDAQICAQECAwEBAgkBAggBBwEJBgIGAwICAgIECgQICgUIAQECCgUNDwgMAgIKGQsFCggMBQQEBwQMAwUDBQgFDAgFBQwIBRIIAwMFBQgFBQgFBwYDBwkECQUKBQIIEAgFCAQFBwUEBwQCBgMUEQwGDQQFAwMCBQMDAQEBAgcCBQcHAgEIBwILEg0ECAQEDgUDBQkGBAUGBAQCAgIEBgIEAgIGAhAOBQcDAgEDAgYCAgkLCQYCAgIBAgECAQERBQgOChEDAwUFAwgDCQUDAgcBBAEBAgIBCAIFBAMHDggHDgcIEwsLEQkECAUECAMFCwUCBQIGAwICBQICBAEBAQIBAQEBAwEBAQECAQEBAgEBAQECBQQBAQEBAQQC+xUIEAgDBgIHDAUEBg0IDQkCBAQBAgUCAwcFAwoECxMDDQ8HCAIBAwcDAwcDCw8EAwgCFycQBQoFBQgEBAcFCBMJBAMCAQUBAQIBAgIBAQECBQUVIhICBwIMCgUCCwIICAUIEAUJBAcDBgkAAAAAA/+3//ECugMCAbcCSALSAAADJiYnJiYnJjYnJjY3Njc2Njc2Njc2Jjc2NzYWNzY2NzYWNzY3NjI3NjY3FjI3MhcyFjMWFhcyNhcyFhcyFxYWMxYzNhYXMjYzMhY3FjYzMhYXMhYzMjYzMhYzFjYzFhYXFjIXFjIXFhYHFhYXFhYXFxYUFxYWFxYUFxYUFxYWFxYWFxYWBwYWFQYGBwYGBwYHBgcGJgcGBgcGBgcGBgcGIgcGBgcWFhcWFhcWFhcWFxYWFxYWFwYWFxYGFRYGBwYGBwYUFQYUBwYGBwYGBwYGBwYHBgYHBgYHBgYHBgYHJgYHBiIHBgYHBiIHBgYjIgcGJicmJicmJgcGJgciBiMiJgcGBicmNjc2Njc2NzY2NzY2NzY2NTY0NzYmNzQ2NTQmNTQ2JzQmNyYmJyYmJzYyNzYWNzYyNzY2NTQmNTQ2NTYmNTQ2NzYmNSYGJyYiJyYmJyImBwYGBwYGBwYGIwYGBwYGBwYGBwYGFxYWFxYVFjcyNjc2Njc2NicmJiMGBgcGBgcmNCcmNjc2Njc2Njc2FhcWNhcWMhcWFhcUFhUUBhcWBgcGBgcGBgcGJgcGBiMiJiciBicmJhcWBjMWFxYWNxY2MxYXMhYzMjYzMhYzNhYzMjYzFjYzFjY3Fjc2NzYWNzY2NzY2NzY2NzYyNTY2NzY2NzY1Njc2Njc2NzYmNzY2JyYmJyYmJyYmJyYmJyYnJiYnBiYnBiYnJiIjJgYjJgYjJiMmIiMiBicGBgcGBgcGBgcGBgcGBgcUBhUGFAcUBgcHFgYVFhYTFhYXMjYXMhYzNhYzMjYzNhQ3NhY3FhY3FxY3NjM2Nhc2Njc2Njc2Njc2Mjc2Njc2Njc2Njc2Njc3Njc2Njc2JicmNCcmJicmJyYmJyYmJyImJyYmJyYmIyYiJyYGJyYmJyYiJyYmIyIGIyImIyImByImIyIGJwYHBgYHBgYXFBQXFhQVFhYXFjIqAwgEAgUDAwIBBAICAgUCAgICBAIGAQIJAgoCAgkGAwoFAgsIBAgEBAUFBg0IDA4ECAQIDggGDQUNDQcIBAUKBg4EDiQSDRIIDR0LCQoFBAkFCQQDAwYDAwoDCwUCBgwGCBEGCAoCAgcCBQcDAgICBQYBCAICCAEDAQIEAgIDAQIDAQMCBQYEBAQCBAIGBgYCAQMHAgMEAwQIBQgDAQcNBAUPBQ0IBgQIAgwCAgcCAgICAgUBAQEBBAMCAwEBBAICBQICBAQFDggIAgQGAgIEAwYIBQsPBAQFBAMHAwUKBQMJBgUICBMFBRUICxYLHDMcCREICA4HEiMSBw0IBQoDDQkFCQMEAgEBAQECBAEBAgIBBAMCAQQBDBEIDA8IAw0ICQMBCQ8GAQEBAQEBAgEBAQIFBAcIBQMHAw4JBQQIBAUIAwUGBQMFBAEGAgIEAwcKAgEEAwcOEggPCAUEAwIGAQgMBQYJAgQDBQUEAQUCAgYDBAMECBAFBQcEBQMCBQEBAwEBAQUEAgQDBQYIDQgEBQYEAwgFBgsFCAj7CwEBBAoFCQILBwIFBg4ZCgQHAgMGBAoDAggMBQwGAg4JBQkEDAEFBAIHDwUICwMCAQIGAgQDAgIBAgIDAgEBAQMCAQEBAQIDAgQBBgsCAwUDAgUDDwMOEQcEBwILFQsLFwsQFAsHAQMKAQcLBAoTCgMFAgMEAgECAQICAgECAQEDAQEBAwIDBAYUBQcFBAgEAgYEBwICAwYDDAMICwgDBQMUCQcKCAYKBQQIBAgNBgoUCgcDAQMJAgYGAgIEAgIDAgUCAgMDAgIDBAYBBwICDgQDBQMHDwUEBQIIBAILBAIKBwINCgMIDggGDQcGDQYDBwQIDQYEBgELAwIFDQQRDAUHBAEBAgEBAgYFBAgCGgUIBAYGBQcJBRUZCg8NBAkCBQECCwICDAMGAQIHAgIHAQEEBAEBAQMBAgEDAQECAQECAgIBAQICAQEBAQEBAQMBAQIBAwICAQIBAgMFAgYCBQIKBwQHBQoIBgIKBgILBAIHAwEEAwQDCQIFDAkKAgIRDggLBwQIAggIBwEBBwUDAgYDAwUDBwEIAwUFAwIGBQICBQUFAwIGAwEHAgkHBwMHBRI1EwcMBwMHAwoIBQUKBQUIBQcNBgcCAwUCAgQCBAYDCQcGAQQCAgICAwICAgEBAQIBAQEDAQIEAQIBAQIDAgEEAwMHAwsMBg0L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AQEDAQgEAQMCAgUDAQIEAQEBAgUEAgQGBQsBAQQOBgUKBiwUFQwBAwEBAQMCAQENAwcCAgUICgYCEAsDBgMDBgUEBwUEBwQFDQcSJhMIDQcLFQgFDgUIBAMBAgEFAwIBBAECAgQBAgIDAgEDAQUCAgIHAQEDBAMDAQ0CAgQCAgIEAgEBAgEBAQECAgECAgEDAQEDAwICAQIBBAIFCwgQEwgNGwkEBgUFCwUWIg8FBgQDBgMFCwcNBwUDCwQVIQ4FCQUJEQYHCQgHBgMHDAYGCwcIDwkLBgINBwQCAQcGAgYIBAIDAgIGAgQDBgIBAwIDAQICAQEBAgEDAgEBAQQCAgECAQYBAQEBAQECAQEBAQICBgMCBQIECAIJBwIKBgINCQUQBAUKAgUSCA8gDg4MBw8RCQQEBQoBAgMGAgoKAwQLBAkCDQQFKgoEAgQIBQkFBQkFBgoFAwYCFQ4LBQQFAwoBAQQHBQYLBQMGAwUJBgQLBQMHBBAHBQYFBAkCDAcDBAsC+wUHBQwHBAULBgYOBw4bDQkUCAQIBAsZDggNBhEFDQISFgsICQkHAwQHBAMGAwMJBAYGBQsCAwYDAggDAwUEAwUEAgIGAQEBAgECAgEBAQEBAQMHBAICAgMBAgUGBQMCAgsUCxEhEAMFAwMHAwgMBgwFAhITDBgNBQICAgUCAwIKBQgEAwkGAw8LBQoJAg0BAwoDBwMHAgIGDgUDBQIIAQgOCAgQCQgPCA0XDAsDAgQIBQsTDAkGAwgNBwcICR4ODx4PBggEAgYDCg4DBwMLDAUGDAULBQMFBQQHAgIGAgEBAQEBFCYTBg0HBQwFBAgFFSQUCAIFAgYBAgkEAgICAQIBAQIBAwEBAQEBAgEFAgIFCggCAwgDCAsGAgYDBQkFCAMCAwYECwMIBwQDBQQKAwIFCQoFAgcFAgUGAwcECgEGDgcGDAYGDAUEDAUREQgEBgMHAwIKCQUHDAcGDQYFAwECAQECAgEBAQEBAQEBAQICAQEBAgEHAgIBAQICAQICAgEBAQECAgIBBAQBAgICDwMJBQQJBwUCBgQCBQMGBgkEAhABCxQKCAUEDhsQCwQCCAwHDh0LBQsECBILCRMICRIJCxULCiMOBgwGBQwFBQ0FBw0FBQgFBQoDBQYFBgMCCQECBwYCBAICAwYHAwEBAwIBAgEBAQICAgQCAQQBBAIB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Njc2Njc2Njc2Njc2NzY3NjY3Njc2Mjc2NzY3NiY3NjY3NicmJicmJiMiBiMGJiMHBgYHBgYHBgcGBgcGFQYGBwYGBwYGBwYGJyI2NTY0NzQ2NTU0Nic0JjU2Jjc2FhcWNhcyFjMWMhc2Fjc2FxYWFxYyMxY2MzIWNzY3NhY3MjYzMhYXFhUUBhUVFAYVBhYVBhQXBhYXFhUWBhUWFhUGFgcWBhUWBgcVFAYHBgYVBgYHBgYHBgYXBgYHBgcGBgcGJgcGBiMGIgcGIgcGBgcGBgcGBgcGBgcGIgcGBicmIiMmJicmJicmJyYmByYmJyYmJyYmJyYmJyYmJyYnJiYnJiYnJiYnJiYnJicmJicmJicmJicmJjU2JjU0NjU2NDc2Njc2Njc2Njc2Njc2Fjc2MjM2FzIXFhYXFhYXFhYXFhYXFhUWBhUWFgcGBgcGBwYGBwYGBwYiJyIGJyYmJyYmJyYmJyYnNiY1NDY3NjY3NjY3NhYXFhYXFhYXFAYHIicmNCcmJicGBgcWFDcWFhcWFhcWNzY3NjY3NjYnJiYnJiYnJicmJiMmJyYHBgYHBjUGBgcGFxYWFxYWFxYWFxYXFxYVFhYXFhYXFhcWFhcWFhcWFhcWMhcWFhcyNjcyNjMWFhcWMjMWMjc2Njc2Njc2NjcWNjc2Fjc2Njc2Mjc2Njc2Njc2NTY2NzY2NzY0NzY2NzYVNjY3NCY3NyY2NSYmJzU0Jjc3NiY1NjY3NjQnJiY3NDYnBgYHBgcGBgcGBgcGBgcGBwYGBwYGBwYHBgYHBiIHBiMGBgcGJyYmJyYiJyYnJgYnJiYnJiYnJgYnJiInJicmJicnJiYnJiYnJiYnJiYnJiYnJiYnJjYnJiYnJiYnJiYnJiYnJjYnNCYnJjc2NDc2Njc2Njc2NDc2Njc2Njc2NzY0NzYmNzY2NzYmNzY2NzY2NzY3NjY3NjY3NjY3NjY3Njc2Njc2Fjc2Njc2NzY2NzY2NzY2NzY3NhYzNjY3NjYzMhYXMjYXFjIXFhcWFhcWFhcWFhcWFjMWFhcWMxYWFxcWFhcWFhcWFhc2Njc2Njc2Njc3NjY3NjY3NjY3NjY3NjQ3NjY1NjQ3NjYC0wUBAQIBBAICAQECAwEDAQEBAgEBAgEBAQECAQEBAQMBAQICAQMFCgMCBAICCAcDAgECAQIGAQIGAwQEAwkECAICAwYECggGBQMGAwMHAhgPBw0HAwcEBAYFAwkFBAgFCxgMCgICBQwFDAoFCgULFgoEAwIGCQYIAQIDAQIEAwUDBQIEAgIBAgIFBQEBAQEBAQMBAgICAwICBAMDBQICAgICBQMFBAUICAMCAwUDAgYDCA8IBQsGHz0eBwsFBQwGBQoFBQkFBgUJCAgQBwYDAgQBBgIKAQIBAgIGAQMGCxYLCBMKBgwIBQgFEg4cDwkRCQ0DDQsGCQgDAgMKBQMGBAIGBQUDAQIBAgECAQECCRILBQoFBQsFCRAIDx8KFBIGCwYHFAoFCAcDBAQNFgwEAgUJBQgOCAUBAgECAQEBAQECAQIBAgEBAgICAgEBAQEBAQEBAwIFAwIEAQUKBQoGCRAJCAICCQQDAwYDBgMCBgwHBQoGBxMJBw8ICBAJESEVCBQIBgwGBg0GCw0FDAYHDwgFCwMBCAIFCwYKAgIJAQkCAgoDAgIFAgcGAQUFBwkFAgICAgECBAEBAQIBAQQCBQIHAwICAwYJBAILAgUSBwoECQwHBQMLBwMFCwICAgIFAwIBAwEBCgYDCAMFAwMLBQUDBQUKBQQHAwQGBAUEAwwDAQQFAwUIAwMGBQIIAwUHBQwIAQEGCQEDBAUNBgMHAgUEAQUDAgEFDwwHCAUGBQILBQIHAgUHBgMIBQIFCAQKCA4aCAgBAQEFBgECAgIEAgICAgQIBwUDCQQODAgHCQsLBQsIBgkBAgQIBQgGAwMJBQQHBAkTCwUMBgoRCg0QBgwDAgULBQYJBQYLBQUHBAQHAwYJCAwJBAkJAwICBQIEAQUEAgUFBgECAQEBAQECAQEBAwQBAgUCAgEBAgEFAgkGBAUGBAQCAgUCAgQCCwcHAwIHAQILDQMFBQIHAwoGDyESFBIFDAYGCwYIDQMGAgwCAgcKBQgDAgUFAgoBAwUDDAUJBQkWCQMFAwcFAwQJBAgBAggBAQMFAwMJAgQEAgIBAwQBAQEBBQIBAQEDAgEDAgEBAQEBAwIBAgEEAgUBAQIGAgUBAgIEAgIDAQQEAQMCAgICBQUCBQMDCgMCBAIJAQEEBAIGCAUDAggUCw0LBgwBDAICBQwFCxYMCxgIAgYDBAgECgQDCAMCBgIGDQcCBQQCCwUIAwcFAgwEBQMGDQcCAwQGCQUCAwIGBQMLCAICAgMCAQIBAgMCAgIDAwICAQMDGAcGAw4HBAsZDQMGAwgNCQsFAwgRCAUKBgkKAwYECwICBgwGBAgCBgMFCAUECgMLAQgDCAICBQgDAwYDBAgECg0JAQIDBwIGAgIFCwUJCAYJBgkDAgQJBQgKAwUDBwMDBAQLDgEJAwIBAgEEAQEBAQECAQEBAQEBAgIDAgUBCRMLBAQDCRYKCwcEBAUDCAQNDBkNBgwIBgwGCwECGTkdAwYCDAMEBgQFCwcGDAUFCgUIDgcGDQcECAUEBwUCBQIEAwYCAgQCAgIDCAMCAwEHBAkCAwICAwQCBQICBAMBBAYGBg4HBgQMAQkEDgMECgULGQ0fGgMDAgECAgEBAwEEAwIFAwUBBgkEBQMEAwIFCgYDCQMCBgMIAwkRCwMFAwwFCwYIEAgOCgUDBgMBAQECAQIDAwICAgEBAgIBAQICBAIBAgECAQENCgMFAy8QEgkDBgMHBAUECQUKBQgRCQ4eDg0RBAsBAQ4iDw8PHQ4IDwgNEwsFCwYDBAMFCAUMCgMLBAUBAQYCAgEDAQIIAwIEAgMHBAIEAgIBAQICAQEDAQIBAQEFAQIBBAYFAwQDAQIBBAkEBQMCBAEGAwIHBgICBQIKBQQBBwoVCwUHBQMIBA4JBAcDAgMGBQQIAw4MBQMFAwIGAgYGBQMCAwQCAgcDAgEFCQQFBgQCCAQIBQoDAgQHBgcQCAQIBAYCAgUCAgEBAQEDAgICAgMBBREMAggDBQkFCQYCAwYBAQEBAQMCBQwHBAkDBgIIAQIDAgMFBAwHAQYIAwMIAQMEAgMCCAIKDwwFCgYECwMKBgMBAQIBAQMPCwoBBAQFFxMFCAUFCAQIDggLCwoLAQQGBQ0LBAQEBAUCAwICAgEBAQIBAgEBAQEBAwEBAQIEAQMCAgECBAQCAwEBAQEBAwECAgIFAwUIAwgBCQQCAgcCBQMCCAcFDQEPDAkHCwcXBwICBQoFDgYJBwsMAgEDBwQDBQUMBQMMGA0MCgUGAwQEAgIDAgIFAgkEBAQCAgIBBwYCAwIBAgQFCAICAgECAQEBAQQBAQEDAgEDAQIGAQEEAQMBAQMCBgIEAgUMBgIEAgUFAgMKBQoGAggBAQMPBQUJBQoTCAgQCAcHBAMGBSYtBAYEDRIIBQwFBAYEAwcCCAECCAUFBQIHAgIGDQUHBgIDCwUEBQIIAwIGAgIGAwkHBAgEAgUFAgQCCAEBBQICAwYBAwEGBAIEAQEDAQMBAQEBAQICBAICAwICAQEBAgEDAgMFAwEEBQQECAcHAgYCAwEHCgcCBQEDBgYFAwIHCAQWDAUDAwUDAgcCAgYCBAcFCgICBAcFBAkAAAAB/3r/ygLZAuQC3wAAAQYGBwYGBwYGBwYGBwYGBwYGBwYWBwYUFxQUFxYWFxYGFxY2FzY2MzIWFxY2MxYWFzI2NzIWNzYWMzI2FzIWMzI2MzYWMzI2MzYWMzY2NzY3Njc2Fjc0NCcmNDUmJic2JjUmJyYmJyY0JyY1JjQnJiYnJicmJicmJicmJjU2JicmJicmJyYmIyYmJzYXMjc2Njc2Fjc2FjMyNzI2MzMyNhcyNjM2MhcGBwYGBwYGBwYUIwYGBwYGFQYWFQYGBwYHBhUGFhUUBhcUFhUUFAcUBhUGFhUVBhYVFhQXFBYVBhYHFAYHBgYHBhcWFhUUBhcUFhUWFBcWFBcWFhcWNhUWFhcWFxYWFxYXFgYjBiYHBgYHBiYjIgYHBgYnJiInNjc2Njc2Njc2Njc2Njc2NzY2NzY2NzY0NTYmJyYmNTY0JzQmJyY0NTQ2NSYmJyYiIwYmIyYGBwYmIwYmIyIGIwYiByIGIyImIyMmJicmBiMiJgcUBhcWBhcUBhcUFhUUBhUWFhcWFhcWBhUWFhcWFBcWIhUWFhcWFxYWFxYWFxYXFhYXFhYVBiIjIiYjJiYHIgYjBgYHBgYHBgYjIiIHBgYjBiYjBgYnNjY3NjM2Njc2Njc2Njc2Fjc2Njc2Jjc2JjU0NjU0Jjc2Jic0JjU0Nic0JjU2NCciBgciJicmBicmJicmIicmJicmJicmJicmJjc2Jjc2JjcmNic2Njc2Njc2Njc2Njc2MjcyNjMWFhcWFhcWFhcWFhcWFgcGBgcGBgcGJicmNjc2NzIGFRYWFxY2NzY2NzY2JyYmJyYmJyIiBwYHBgYHBgYHBgYHBgcGFRQWFRYXFBQXFhYXFhYXFhYXFhYXFhYzMjcWFjMyNjcyNjc2NjcmNjc0JjU0NjUmJjU0JjUmJjU2IjU2JicmNicnJicmNicmJicmJyYmJyYmJyYnJiYnJiYnJiY3FhYXFhcWNhcWFhcWNjMWNjMyFjc2MgEFCgoCCAcFAgYCAgQDAwwDAwMBBgECBAEBAQEBAgEBAxIEBg0IBAkFCRIIBQYEBQwFAwYCDwgFBAoECBAIBgwGCA4IAgYDAwcDBAYEDQIQBQwIBQEBAQIBAQIBAgEEAQEBBwIBAwECAwQCAwICAQIDAgEDAQMFBQQEAgUDAgEBBQYLBQsWDQkOBwsNCwsPBQkFFwUIBAgCAggPCAQDCA8IBQgFBwIIAQIBAwEBAQMBBgQCAQICAQQBAwECAQQBAQIBAwEEAQEFAQEFAgUBAQEEAQICAQQCBAMEBgUKBQoGAgcMAgoGDiERChULCBMKDhoOCRQJAwYCAQoBBgIIAQEHAQIFCgUQBgMBAgEBAgMBAwEBAQEBAQEBAQQJBQsTCQoKBQkRCQoUCw0IBQUNCAYOBgQHBAUIBBQIEAkIDggHDwgBAgIBAQEBAgEBBAMEBAIEAgEDAQECBQIFBAMGBQUJBAUFAhIKAwYDBQsFDAUFCwUTLhwDBgIJEggIEQkLBAEECQUEBAMDBgMHEAkBCgUHAwcJBgULBQMFAgYCAgIJBAUBAQMCAgICAQIBAQICAgECEiUTEScTCAwHBQ4GBQcDBAYFAggCAgEBAgMBAwUBBAEEAQIBBQIEBQEDAgMCCQQDDBEDAQsCBQcDCQ0FBQcFCAQBAQECAQQCCQ0ICCAFCgEFAQcFAQEDBgsVBgIFAgIBAwgRBQkTCwEMAwUEAgMCBAEBBQICAQMBAQECAQEGAwMGAgMHBQQHAwkCAQMIDA0FBw4IBw4HDxoNAgQBAgIBAwECAwEBAQQBAQIBAgICAwEBAQIBBQoDCwUIBAIIAQQEAgIJAwMGAw8ZDQkHBw4HBQcFCxgMECEOBQsFBgMCzw4HBQINBQIFAgMGAQkNCgsCAQ0EBQwQCg4eERAeEA4hEQIFBQIDAwEBAgIDAQIBAQEDAgIBAwIBAgIBAQEEAQMBAwIDAQEIEAgDCAMCBgMDBwIFCAcMBgYKBRABBAkEDQsFDgkEBwYFCAUKAQEGAwIKDgcHAwIFAgcEBAMBAgMBAQEBAgICAgIBAQECDAIECQMDCQQGAgsJBQUJBQQJBQYNBiEiCAQDBQMHDwoOGw4HDAYFDAYFCgYPCg0GBAYECQ8FCgwFBQgEDAcEDQ0FDgkFCQYEBgIKCQQJDQIEAwMIAQMDBgQHBAgBAgQECwEBAQEBAgEBAQMCAgQCAQMFAgMCAgQCAQMCAQIEAwgIBQkIBgwHDAcDCRMLBgQEBREICBAIEygSBwwHAwIBAgECAQIB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AgYCBQICAgQCAgYCBQgFCgcEBgIDCAUKAwIEEAIHDwgEBwQFCwQEAwQECAQUJBIMBgIDCAUEBAIGAgQFAgQDCAUDAgYCAgMCBAUEAQIBAQECAwECAgECAQEDAQEDAgUGAgIGAgIFAwUMBAkRBwUECAcEBgsLDQoPCQUKBwIFAwICBAMLBAIJBQYEAgECAQEBAgIGAQcCBgUCBwIBCQEIBwIGDAgHBgQKAgIGCgUHAgIFBAICBwcJAgIKBgUNBQUKAggFBQEKAgcBAgMCBAIBAgMICBQIBwgFAgYCDxMFBwYDBAkEAgUDCgQCBAoECRMLAwYEBwcFBAQGAgIDAgICAQMCBAMCBAIBAQIBAgICAQEEAgIBAwIIBgwCBQIFBgQDCAMKEwoEBwUHCwgTBgQJBQgIBQQGCA8IAgUCAgECAwUBAQYGAgIBAQEEAQQBAgMDAgECAQUBAQEBAQIBAQEBAQEBBAIBAQEBAQQHAgECAgMCBAMOBgYHBAgEAgYDDgsFBhUKBAkEAwgIAwUMCQgVCwYNBQULBggPCgcCAhMOCQUMGg0ECAUFCAUECAURAt8MCQYBCQIDAgkGBQgCAgMKBQYNCAgDDBoOGkIeECQTBQwFBgsHCxcMBQcFBgsFBQ4GCA8JDRgNDQwGBAcCBwMDBQIDBgIEBQMKAgIDBgMDBQQCBwIFBgMDAQIBAQYBAQQBAgECAQECAQIBAQECAwUBAQEEAgMDAgUCBwUCBQQMBwUECAUFCAULFAoCBgMCBgMFCQUJGQsECAIDBgMEBgMLAwIDCAQKDAcFCAUFCAQKDwoLCwUDAgIBAQICAgICBQICBgEBBQEBAgcCCAYCCgMFBQ0GCgsFCgUFCwULBQILAgoJCQEBCAEBBgIBAgQCBAEEAQEGCAYDCRAQDBAICgQCBwIEAgQFCQgCCQEBAggCBQMFCAoLCgcGBAICBwUCBAIaIBQJBQMECAUDCAIHAwECBAQBAwMBBAIFBwgHBgYEAgMGAwQIBQQFBAsJBgUVCAUGBAsZCgMFAwcKAwQHBRMYBgUIBQEGAgIDBAUBAQECAQICAwECAQQDBgUDBAMCBgMIBAUDAggNBQYNBwQJBQsICxYMESISBgoFBQoFBQoFFAsTCgcOCAULBQYJBg4OCAUMBQYIAwUDBgYKAQEJAQEHDgcIEggHBwQJAgEBAQcFAgIBAQEBAQEFBQEBAgMBAQEBAQMBAQECAQEBAgMBAQEBAQECAQAAAf/s/wwDJQLsAuwAAAEGBgcGBgcGBgcGBgcGBgcGBgcGBgcGBgcGBgcGBgcGBgcHBiIHBgYHBgYHBgcGBgcGBgcGBgcGBgcGBgcGBgcGFRY2MxYWFxY2MzIWFxYXFhYXFhYXFhQXFhQXFhYXFhcWFhcWFhUWBgcGFgcGBgcHBhQHBgYHBgYHBgcGBgcGBgcGBgcGBwYWBwYGBwYGFRQWFxYWFxYWFxYGFxYWFxYWFxYWFxYWFxYWFxcWMhcWMhcWFjc2NzY0NzY2JyYmJyY1JiYnJiYnJgYnBgYHFAYVFBYXFhYXNjc2Njc2JjcyFBUUBhUGFAcGBgcGJicmJyY0JyY2NzY2NzY2NzY2NzY3NjY3NhYXFhYXFhYXFhYXFhcUBgcGFAcGBgcGBgcGBgcGBwYiBwYjIiYnJiIjJiYnJiInJiMmJicmJicmIicmJicmNSY0JyYmJyYmJyYmJyY0JyYmJyY0JyYmJyY0JyYmNTQ2NTQmJyY3NjY3NjY3NiY3NjY3NjY3NjY3NjY3NiYnJiYnJiI1JiYnJiYnJiYnIiYnBgYHBgYHBgYHBgYHBgYHBgYHBgYHBgcGBgcGBgcGFhUUFhcWBhUUFhUWFhUUBhcUFhUWFhcWFxYWFxYXFxYWFxYWFxYiIwYjBgYHBgYHIiYHIgYHBgYHBgYHBgYHBiIHBgYnNDY3Njc2Njc2Njc2Njc2Njc2Njc2Njc2NDc2Njc2NDU2Jjc0NDc0NjU2JjU2Njc2NjU2Jic0Nj0CNCY1NjY1NiYnNDQnJiYnNDQnJiYnJjQnJicmJyYmJyYmJyYmNzYWNzMWNhcWFjcyMzY2FxY2FwYGBwYHBgYHBgYHBgYHBgcGBwYGBwYWBwYGBwYWBwYGBxUHBgYHFBYXFBYVBhYXFgYXNjc2Njc2NzI2MzY2NzY2NzY2NzY2NzY2NzY3NjU2NDc2Njc2Njc2Njc2Njc2NDc2Njc2Njc2NjUmMSYnJiYnJgYnNhYzFjYXMjYzFjc3MjYzMhYC4AQRCAUMBQYOCAQHBQcEBAMGAwIGAwoIBQQFAgMEAwIGAgkHBAEMEgkHAgIFBAoIBQwMCAQNBQMHAwMFAwMGAg4IDwgEBgQIEAgLEwsKAQMPBggKAwMBBQIHAgQFAwIDAgECAQIBAQEBAQMBAwEBAQEDAQMCBAMBAgECAgIDBwQEAQIBAgEEAgIECAQCAgIEAgECAQEFBQMGBgEIDgYECAUDBgMTCQcECQ0ICikNDQkGAQcHAgIBAggCAgIFBAMDCAMOEgkFAwIEDAYHAwECAgUCBgUBAQICBwgLCwUHAwoBBgECAgYCAwEFCgQCBggHCAcNDQgCBAIGBAIGBgMEAQMCBAECBAICAwIKBwMMBgULBhkWBQgFBQkEBQgEBgkFCQQODAcKAwIDBgICBgIICQEGAgIFBAIGBAIGAQIGAwcCBgICAgICBgECAQEBAgUEAwEBBAEBAgMCAgIDAgECAQIBAQICAggIBQIDAQIJBQIDBgMOFg0LFgsJDgYIBgMEBAIIBQUCBgIHBQMECAUJBAUIAgIBAQQEAgEBAgEBAgECAQEEAgMHAwgWBAUFAwcDAwcDBAoFCgUECQUFBwUGDAYHDAYNGQ0OGAwHDQYFCwUEBQcBCQUDCAQCAgUCAgUDAg4FAgQCAgEBAwEBAQQBAQIBAQEBAQICAQcBAgIBAgEDAgEBAgEBAQICAQIDBwkDBQYCBQgFAggCAg0GFBEjDggNCAgKEB4ODxoLAgIDCQMLBQIMCAQKBgQJAwcBBQIBAgECAQIBAQEBAQMBAQEBAQEBAQEDAgUGAw8MAgcDEwkFBAYCBQQJEQoFCQUODAYJCwUGBAoCAwIFBAMIBAYEAgYCAgUBAgIDBgECAwgEBgEIAgMKFgUDEAUVKhQIFQkJDhoMDgYdMgLoCQMDAgUCAgUCAgICBQEBAQIBAQECBAYDAgECAgYEAgUDCQcCERIICAMDBQcLBwUODAYGCQUCBQICBwICBQIJBAMHAQMBAgMIAgkDBQ0FCA8HBgMCBQYCBwkEBgoECAUDBgIECQUFCAQDBwIPAwgDAwYCChEIDQ4DBwMFCgcLGAwIBAUJBAUHBAUMBwwYCwUKBQcEAgIGAw0MBQwGBAUJBgECAgIGAgUDAgQCAgUFCQkIBQILFBILBQQHAgIKBAEEAgIBAwMQCAYLBQINAwYDBAEHAgUDCwwBCgUFCgQFCgQGBAICBgIDAggFAw8XBgULBQUCBAcGAQQCAwQBAQkJAgYCCAUDCREICgMDCgUKBQIEBwQFCAIJDAIFBQIBBQEBAQEBAQEBBggIBQYDAgIBAgcCCAEFAgEDAwEDBQIKBwQIAwIF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BgcCBQsECAMKBgMCCAgDBAYEBgIBBQUEBwYCBgQCCAICBgMMDQkIBQMFEAUMCgUIAwEICAMIAQ0CBAUDBgMBCQYDBgICBwYBBAEBAgQCBgEBBgIDAgEBAQEBAQEBAQIBAQEBBAEBAgIGAgMBBQIIBgUGAQEGAgEHAQICBQIJCwUIBwcCDhITDQ4hDwQHBAMGBAUIAwUKBQMGAwUDAgEBAgEFAgYCBQgFAwcEEwgHBAgECwIFBwMDAgIBAgIBBgIHBwgLBgMGAgQCBAIMBAIJCQcBBQIBBQEEAgICCQICBQsHBQkFDAYCCAIEBQIIAgQFDAYFBQQQDAcGDggKEwUHBwUFAQYDAgcCAQIBAwICAwYBBQMBERwQBxAIChIKAgkC8gECAgIBAgQBAQQBAgIEAgICAgICBQEBBQEBCAgFAgYCBQMCBgICBQIBBQgEBgsHCAkFBQQCCQQCBAsFBQkFBhAIDwYIBQ4iEBctFgwDBwMICwcDBgQCBgQDBgMIEQkWEwUJBQsIBQYCAQQBAgMGAgQGBgIJBwQCBAIDAwEHBgUCAgICBQEBAQEFAgEBAQEBAgUCAQIEAQMBAQIBAgQJBgMHBAMEBgIEAwIFAgQGAgMDAgQIBAgDAgMJBAYIBAUHCAoECgUDBQQFCQUHBwMNDAURIhIDBwMYGgsEBgILAQkCAQQHBAIGAwgFBwQCBgQPAgMGAwsLAwYGAwIHAwkBAgcNBgcBBwsFAgQHAgQDAgYCAgMFBwICAjYDBgICBQEDAgUIBAYBAQkBAQIFAgcGAQEGCwUTDQoTCSksBQ4CCAwFDRgNDRkNDBwICAQCBQgFBAcCAwcCCAEIBgMFCAMGAQIDCAMGCgYBAggFAgIFAQkBAQMGAgUEAgQCAgEBAgEBBQEBAQIFAgMEAgYCAgMFAgUDBgICBgIFAgEKBAILBAMKAwYDAgUIBQcMBQgFAg0KBQsFAgMJBAMHAwgQCAUHBA0MAgoMBwgPCA8KBQYEAgsHAhELBwoCAgkBAQoEAgIIAQkMBgkBBgEFBQYCAgIBAgECAgEBAQIHAwIBAgUICAoNCAsdCAkDAgMLAwIGAQMEAwIEAwcBAgQCBQsGBw4GBAgEDAICBQICAgoKBQUMBQoBAQQBBwIBCA4JBQoDCwMCBQUCAgQCBgECBgYCAgsmDRQWBgEFAggEAgMGCgQFBQYFAwIG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BwQCCgcCAgICBAIEBQMCBAICBAIDCAMBAwYCAwEDAQECAgUCAwIFAQYCBAEFAwEFBwQCBgEHBQMEAwgCAgQIBQMKBQQHBQoEAggRCgkHBQYEAgcECAICEgoDAgEIBwcBAwEEBQIDCwUGBQIEAgEDAQICAgMBAQEEAgECAQIBAwECAQEBAgECAgMCBQQDAgcEBAIBCQoCBwICCAIJAgUFDAYIBQcKCAUJAgcKBQgUBgQJBQ4EAwcFAw4CBQUCBQYFBAgFCgwHBAMIAQcBBQIGAgEDAgYCAggCAgQBAQEBAQECAQEBAQMBAwICAgICAgYEAgIEAQMDAgcFAgMEAwMGAwICAQYIBAEGCwUIBgMREwUQDwMEAgkHAwQFAgoNAwcHAwWWCBIFAgECAQQBAQECAgIIEg0KDggECAUKEAcCCwQBAgUDBwsPBAQIBQkLBAYEBg4HBwwHBwsGChMKBgMBBQsFDAkDBQQDCAICAQIBBAICAQICBwQGBQUTCAcHCxIJCggCAQIFAQEEAgwFCgIJCAgBCgMJAhcIBAYCBQEBAQIBAwQHCA8MBQoFBwwGBwMBAgEBAgECAQEBAQMGAQEKBQQDBgMEBwQFEAcLEQcKAggEAgYCBAcEBQQCAwMBAQICAQEDAgQCBQEIAwgFCwgFBQUCDwMHAwwNBgoEAwkFDAsDDBUKBQsFBAECAQIBAgQIBAECAgICAwEEAQICAQUKCAcLBgYMBQwOCAcDAQ4IBw4HDAoFCA4GBwICFhoMHBoNGAwIDAcHDggZKxQODQkGAwkGAgoHAwYHBAgJAQ4DAgIIAQQEAgECBAMIAgEEAgQCAgQCAwEBAgMBAQEBAgIBAgECAQEFAwECAQcDAQQDAQQCAgQCBgQCBQIHCAMLBwQEAg4NAwUDAwsFBQwFBQkHBw0ICBULCQsTGQwKEQoDCgMCCQUJDwgIEAgIAQEMBAILAgcCAQsBAgkLBQMFBQkGBAUFCAQDBgoFBAgFBAcDCQQCBw4GBgICBAEBATwHARILCAEBDQwJBwECBQ4FBgQFCgMCBgwHAwYDBQoHEAgKEAgHBQIHDQcFCgIMBwQQBQcFBwsGDx8PCw8HDw8FBQYFBgICDQgDCAUCBAMBBQQCAgcCAgECBAEBAwMCAQECAQQCBwECAQEGAgQCAwkDAgICCAEKBQMDCAIJAQkBCgICBAUECggECxAJCxgLBAkCCQkFBQkFDhoLDRwKEBQJEgkNBQYLBQ8HBQMIAwgEAg0JBQEHAgUPBQcBAgsLAwIBBQIEAQUBAgQNAgQCCAYFBQcEFxUFCwMCBkoFBwoCCQQEBgQMAgEGDAUIBQIBAQEBAQEECxULCAECChEHAggAAAL/x/8lAtcC3QIpAqwAACUGFhcWFhcWFhcWBhcWFhcWFhcWFhcWFhcWFhcWFBcWFhcWFBUWBwYWBxQGFQcGFAcGBhUGBhUWFhcUBhcWFBcWFhcWFhcyFjM2FjMyNjc2NzY3NjY3NiYnJicmJyYnJiYnJgYHBgYXFhY3NjY3FgcGBgcGBgciJyYmJyYmJyYmNTY2NzY3NjY3NhYXFhYXFgYXFhcWFBcWFhUWFBcGFhUGBgcGBgcGBgcGBwYGIyIGIyYGJyYmJyYmJyYiJyYmJyYmJyYnJiYnJiYnJiY3NzY2NzY2NTY0NzY2NzQ2NTQmNTQmJyY1JicmJicmJicmJicmBiciJiMmJicmIicmJgcGFhcWBhcUFhcWFhcWFhcWFhcWFhcWFhUGIgcGBgcGJgciBgcGIgciBiMmBiMGBgcGBicmNjc2Njc2Njc2Nzc2Njc2Nic0JicmNzQ2NTYmNTQmJyY0JzQmJzQ0JyY0NTQ2NTQmNzQ2NzY2NTQnJiYnJjYnJiYnJjYnJjQnJjY1JiYnJjQnJiYnJiYnJiYnJiYnJiInJiYnJyY3NhYXMhYzMjYzMjYXMjYzMhYXFjYXFjc2Fjc2NjcWNjMWFjM2NjMyFhcyNhcyFhcWFhcWFhcWFBcWFxYXFhYXFhYXFhYHFhYVFhYXFhYXFhYXBhYHFhcWFBcWFhUWBhUGFgcGBgcUBgcGFgcGBgcGFAcGBgcGBgcGBgcGBhUGBgcGBwYGBwYGBwYiBwYGBwYmJxYWFxYWFxYWMzMyNjc2Njc2Njc2Nhc2Njc2Njc2Njc2MjU2Njc2NDc2Njc2Njc2JjU0NCcnJiYnNicmNCcmJicmIjUmJicmJicmJicmBicmIicmIicmJgcGJgcGIwYGBwYGBwYGBwYUBwYHBgYVFAYHBhYVBhYVFRQUFxYGFxYWFxYBlwEIBAQIBAIHBAoBAQIIAwgBAQgCAgUGBQMDAgICAQMBAQEBAQIBAgMCAgEDAQEBAQEBAQMDAw4ICBIOCQEBBgcDCBEECgsMAwMMAgIBAQEDAQMEBAYGBA8cCwMFCQQGBAwFAgsBBgMCCgMDBQYEDAYDBAQCBgEFAggMAw0GBg8IDhAICgEBCQUFAgEDAQEBAQEJAwUWDAUNBQQIBQcICgYDBg0FBAcDCRMLCgUCBgkFBQoHBQUDCAMDBgIDBQEBAQMEAQICAQEDAgIBAQMEBAcFCAcIDgkFDQUOHA4CBgMOEggFDAULFgwBAgIGAQMEAgMCAgQMBQQFBQcJBQkECAYCCxwNEhIJBAkFCx0OBAcECAQCCxUKCwcDAgwFCQ4ICQEBCwgPDQMCAQIBBAIGAwMBAwECAQICAQEBAQMBAgECAgICAwICAQEBAwECAQECAgMBAQICAQECBQICBgIFBwUFBwQEDAYNAwILDwEECggDBwUECAUFDQYGDQYMGg0YNRsWGA0aDQgSCAcKBQgNCQcRCAUKBQsGAgIHBAUHAwgHAggBCQYEBAMEAgIDAgIEAgMGAgUCAgQCAgIEAQQCCQMEAQECAQMBAgEBAgECAQMBAQQFAgUDBwICAggDAgICAgQICAUGDwIEBAgEAwcGBAQJBAgR3Q4TCA8NBwgKCA0RIxAFCQUQCQUHEQYCCAMCAQICAwEDAgICAgICBAEBAgMBAgECAgICAgECAQEBAwIDAgMFAwMQBAcHBw8QCAsbCAsLBwkQCQ4ZDQgDCwsIAwEBAQMBAQEIAQEBBAECAgEBAQUCAgYCAgf3BAUCAwUBBAQDBQIBAwYDBgMBAwIBAwgFAwQCAwgEAwUDAggDDw8JGw0EBwQQCBAJCAsLCQ8GBQsGAgYDEBMHBgcDAgQBAQEBBQIIBQgCAwgFBRQFBwUHBggCAwUCBgkGCRsGAQIBBQIBBQIGAwIJBAECAQIDBwwHBQ4HBAYEDAkCCAEBAgICBAcHAgEKBwYGAgMHBQQMBQYLBAUMBQgPBgIFAgICAgIBAQEBAQIBAgECBwEFCAMECwQEBgMIBQcEAwUJCRQTJBEDBQMGEAgTIxIDBwMCBgMHCwcJBgoIBQgFBQsEBwsHAgEBAQICAgIBAQQCCBQKHkMZAgsCBAUCBAQDAwUDBQICBgEDCQEEBAQEAQIBAQICAgEBAQIDAwMDCAYFCA4FBQIBBgMJDSoRBQwDBAgFFg4EBQQFEAUJDQcLEgsCBwMFCQUIEAkCBgMFDAUEBwQKAwIHCAMEAwwMCAUMBQoTCg8bDgsDAgUJBQUKBAMFAgIDAwEDAgIEAQICBQEBBQcGAgEBAgEBAQEFAQIGAQEBAQIBAQMBAgIBAQEBAgECAQIBAQIBBQECBgIBCAYIAgYBAQIGAgIFBAECBAMDAwcFAgUHAwUFBQwKBwkFBAcDBQgFBgwFBwYFCQQCCQMBCwwIDQgECwsFCAwGAwcDAwcEBQwGCAsCAgIEAwICAQECAQEBPwMGAgMEAgIBAwQCAwEFAgICBwIFAwICBwMDBQMMAQkCAgQHAwoHAwsGBAgWCwUWAhAHEQUHBgYOBQIGAwsBBgwFBQsFCAICBQEBAQQCAQIFAgIBAQICBAIDCgQCBQMECQQaEQkVCggRBQsDAgwgDxIFCwUNBgETGA4HAAAAAQAJ/+MCAQMRAn0AAAEWBgcGFgcGBgcGBgcGFAcGBgcGBgcGBgcGBgcGBgciNicmJjUmNCc0NCcmJicmJicmJicmJicmNCcmNCcmJyYmJyYmJyYGJyYmJyYiJyYmJyYmJwYmIyYmJyImBwYGBwYGBwYGBwYWBwYGBwYWFxYGFRYGFQYXFhQXFhYXFhQXFhcWFxYWFxYWFxYWFxYyFxYWFxY2FxY2FxYWFxYXFjYXFhYXFjMWFhcWMhcWFhcWNhcWMhcWFhcWFhcWFxYWFRYWFxYWFQYWFQYGBwYGBwYGBwYGBwYWBwYGBwYGBwYGBwYGBwYGBwcGBwYGBwYGBwYGBwYGBwYGJwYiJiYnJiYnJiYnJiYnJiInJiYnJiYnJicmIicmJicmJyYnJiYnJiYnJjYnJiY1JjY3NjY3NjY3NjY3NjY3NjY3NjY3NjY3NjYzNhYzNjIXFhcWFhcWFhcWFhcWFhUWBwYUFQYGBwYGBwYGBwYmJyYiJyYUJyY0JzQ2NzY2NzYWMwYGBwYGFxY2NzY2NzYmJyYmNSYmJyYmIyIHBwYGBwYGBwYGBwYGBwYGBxQWBxQUFxYVFhQXFhYXFhYXFhY3NjI3NjY3NjI3NjYzNjY3NjY3NzY3NjY3Njc2Njc0JjU0NjU1NDYnJiYnJiY1JiInJicmJiMmJicmJicmIicmJiMmMSYmJyYjJicmBicmJyYmJyY0JyYmJyYmJycmJicmJicmJyYmJyYmJyYiNSYmJyY0NSYmNzY2NzY3NjY3NjU2NzY3NjY3NjY3NjY3NjY3NjY3NhY3NjYzNhYzMjYXMhcWNhcWFxYWFxYWFxYWFxYWFxYWFxYXFjY3NjY3NjY3NjY3NjY3AfsGBQECAQEBAQMBBAIBAgICAgEBAQECAgIEAgQBAgUCAQEBAQEBAQQCAgQCAgUCAwIBAgIDAgwGCQUEBA4FBAYCBQoFBQgEBgwFAwcCBAUCBQ0FDQ4ICA4GBgwEBwUCBQEBAgMBAwECAQEBAgQBBAIBAgICAgIGBgECBQMCBQEIDAcJBwIFCAQGBAICCAUECwYLCwcCAgMHAg4IAwcCBQUBBQkEBQMCBQYCChIIDQ0FBwEEAwIBAQEBAQEBAwIDAwIFCAUFAwIGAQEIAgIJAgECBAMIAwEFBAIJDgYODAYFCQYGDggFEwgMGw0DCQsLAgcIBQQIBQgFAgcFAgIFAwMFAgQGBQIBCAECBAIDAgIEAwUCAQYCAgMDAgQDAgMCAwgCBAgEBAcFAwkDAwYEBwcIDwkDAgcDBhAFDQIJBgIGAgIHAQIBAgICAwcDBQMGBAEGAwQYAwoCAggBCQEBAgIGBQ0LCQIHBQULAhIMCgUJBAUEBAQFAwkEAwkFBQcKCAECDQcEBAcEBwQCAQQBAQEDAwYCBAgFCQsHCREOCBYIBQsHBAkGBw8JBg4GAwcDDBILAgQCBgICBgEDAQQBAQUDBAMHAwEKAQsCAgwLBg4GBQUIAgoDAgwJDQcKBgoFBQgEDAgEBwQMAgMFBQQIAgkLAwUDBwIDAgIBAgICAgMBBQUCAQEBAgIEAgUDAgQCBQIDBgsGAwIGBQIIAgMFCQQLCwcKDAYEBwUFCQUFBwQGCAQIAw4FBQ0FCwoCBwwHBQQEBgYEAwsPGQYJCgYDCwUCBAMHAgMDEQIMBQcPBw0cDQYLBgUMBQoUCwUMBgUKBQoUCwsFAQkFBAYEBAcEAwcDBAcFBQsFAwYECgICBQgEBAUCDAQIAgICBQIEAQECBQECAQIDAgIDAQECAQIBAwIBCAUHBwQKCgYIBAIEBgIPCAUFCAUIAgIMDxALBAMEAwMGAgUIBgMDCQQCBQUCCAUIAgQBAQQCAgEBAQECAgEDAwEBAQECBAEBAQMBAQECBQEBBQEFBwYKEQgMAgoCAgQLBQgQCwgCAgUNBgwGBQsWCAcDAgoEAgoGAgoBAQIJAwcBAQYCAgcHBQcFAgIFAgQFAwIFAQIEAgECAgEEAQICAwIFAQEIAgIGAgIBAwEI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BgcGJhUHBgYHBgYHBgYHBgYHBjEGBgcGBgcGJicmJjcmJicmJjcmJic0JicmJicmJicmNCcmJjU2JjUmJicmJicmJicmJyYmJyYmJyYmJyYmJyYmJyY2JyYmJyYmJyY0JyY0JyYmJyYmJyYmJyYmJyYmJyYiJyYiJyY0JyYmJyYmNzYWNzc2NzYWMxYWFzI3NjYzFjYzNjY3MhY3NhYzNjYzMhY3MjYzMjYzMjYXFhYzMjYXFgYHBgYHBgYHBgYHBgYHBgYHBgcWFhcWBhUWFxYWFxYXFhYXFhYXFhcWFxYWFxYXFhQXFhQXFhYXFhQXFhYXFhYXFhcWFBcWFRYWFzY2NzY2NzY2NzY2NzY2NzY3NjY3NjY3NjY3NiY3NjY3NhU2Njc2Njc2Njc2NzY2NzY2NyY2NyY2Nzc2Jjc2Jjc2NzY2NzY2NzY2NzY2NzY2NyY2NzY2NzY2FxYGBxYHFhYXFhcWFxYWFxYWFxcWFhcWFBcWFhcWFxYGFxYWFxYWFxYWFxYWFxYUFxYWFxYWFxYWFxY2NzY2NzY2NTY3Njc2Njc2Nzc2Njc2Jjc2NjcmNjc2Jjc2Njc2NDc2Jjc2NDc2Njc2NDc2Njc2Njc2Njc2NicmJicmJyYiJyYnJiYnJiYnJiI3NhY3FjY3FjYzMhYzNhY3NhYzMhYzFjcyNhc2NhcWNjMyFjM2NhYWFxY2FzYWA+4TBwsIAgMGBAQGBQoXCwgOBwgNCAMFAwMJBgMCBAECBAEBBgsDBQIEBAQFAQUCAgIBAQEFAQIDAQEFAQECBwIDCAUBAQEBAwECAgUDBgMCAQMFBwICAQICAgIBAgIEBAMCAQIGFgQGAwIEAQICAgIFAwECAwECAQEBAgICBAICBQsIAgQCAgQDBAIBAQEEAgICAgQCAQEBAgICBQUCBAYNBgIBAgMEAgEFAgMCAgUBAgECBAIHBAECAQQCAgECAQQCAwUDAgICAwIBAgUEAgQCAgEEAgECAQMCBgECAgICAgEHAgICAwQCAgECAQQJFwgCBQECAwIFBAIFAQICAQEBAQIHBAEBAgIBAwIEAwECAgIDAgMBAQMCAgICAQICAQEBAQIBAwIBAQIBAgECBAIHAQwHBgUDBQkBAQYDAgUKBQYCAg0IBAkBCAgEBwQBBAoHHwsIBAoGAwcDBgoLEwoKDQcIDQcECAMKBAIECAQFCAUFCAUFDAQGBAUOCAQFCAUCCAMIEgkMEggMCgUMDQYFBwUFBgMBAgMBAQQCAgIDAQIDAgIDAgQCAwICAQIEAQEFBgECAwEBAQEFAgIBAgQCAgEFBwECBQQCBAMEAQIBAgUDAgMCAgUCAwIDCQMDBAMFAgEFAwUEAgECAgQCAgECBAQFAQIDAgIBBQIBBAIDBQEBBQEBAQQDBwIDAQICAwICAQIBAQQCBgIEBwUHAgMEAQIHAQYCAgIDAQUCBgMCAgIDAQEBAQEBAwECAgEBAQEEAgMGBAIEAgIBAQICAgMCAgUCBAIDCQUCAgMCAQQCAgICBwECBQEGBQUDBAECBQQEAQIBAgIBAQIBAQEEAQEBAQIDAgECBQQCBgQCAQECAQEBAgYDCQEDCAMECAcNBwYOCAsKAQIGBAMIAgkCAQQHAwUOBggPCwoIBQgECQ8HFxsQDAUCCA8GDhYXFQgFBwQCCQL6CgcDBQMDAQECAgIFCAUFBgQEBgIGCwcFEQoFDgcFBQIKAgENGhAEDQYHEggFBgUDBQMDBAQKCQQHAgIFAwIFDwcLFgsDBQMCBQMIBwsVCw4NBQkGFBsOCA8ICAUIBQYLBhMWCgcBAwUKBQQGCgQDBg0HDAgFCRMKDhYNBwoHAwYDCwMCBwwHEBAIFCUTBQcFCBQJCRIFCAQKEQgJEwkLBwICBgQGBQgQBwIIDRwPAgYDBgwKBQgECAUFCAUFCAUICAMLCAMCCQQDBQQECAUECAMIDwgFBgQLAgIGDgYEBgkDAg0GAgMGAwkBAgwGBQQCBwIIDQcHDAYLCgcDBw8HAgECAgcCCBEIDA0GCxgMBQoHBwkEER4QBAgFBAUGAwYEDCEQBw8JCBQLCgkGDwgJEwsFCAUFCQYFCwULBgMCBQQIGgkKBQIJAgEJAQEECgQEAgEDAwIDBAMEAgcCBAIBBAUCCgIFAwEBBgECAQEBAQECAQIBAQECAQEBAwEBAgIBAgIDAgECBQIFAgIFBwUJCQUGCAQHCQYDCAIMBRAcFA0GAwgLChILDwIFBgUHDgcLBAcNBg8ICQkIDgUHBgIEBwUCBgMDBgQFDgYLAQcIBAkFCwkEAgsFCxkMBAYCCAsHBAgDBQYDCwUIDggGCwcHAgMDDgIMAQkFAgMEAwIGBAkIBQYDBAMCBgUCBAYDDAgDAgcDAQYHCBIKAgcEAwgEAwgDAwYBBQoFDhEKCgQCAgcECQ4NCAUJCwoOCBEIBg0HDAcDAgUKBQIGAwgEBAcDBQsFCxYLBQsFBw4IBwoGCBoLBw0JDhkLAQ8GBw4HBgYCCgQIBRIQBwsKHg8OBwoJBAsJBAUGBQgCAwQGBAMIBAUHBAUHBQoIBAQHAwoLBxIPCAMEBAsGBQMCAgQBBAIBBAIDAgIDAgQGBAEBAQEBAQICAgEBAQEBAgEDAgIBAQECAQEBAQEBAQECAgIAAf97/9sC4gLuApcAABMGBgcGBgcGBgcGBgcGFhcWFBcWFhcWFhcWFhcWFhcWFhcWFxYWFxYWFxYWFxYWFxYWFxYWFzY2Nzc2NDc2Njc2Njc2Njc2Njc2Njc2Nzc2Njc2NzY2NzY2NzY2NzY2NzYnNCcmJicmJicmJyYiJzY2NzI2MzI2MzYWNzY2NzYWFzYWNzY2NzYyMzYWNzYzFgYHBgYHBgYHBgYHBgcGBgcGBgcGBgcGIwYGBwYGBwYUIwYGBwYGBwYGBwYGBwYGBwYGBwYGBwYGBwYGBwYGBwYGBwYGBwYGBwYGBwYGBwYGBwYWFxYWFxcWFhcWFhcWFBcWFhcWFhcWFhcWFxYXFhYXFhYXFhYXFhYXFhcWFhcWMhcWFhcWFhcWFhcWFhcWFhcWFhcWFhcWFhcUJgciBiMjIgYjIiYjIgYnJgYHBiYHIgcGBgcGJgciBgcGJic2NjU2Njc2NzY2NzY2NyY0JyYmJyYmJyYmJyYmJyYnJicmJyYmJyYmJyYmJyYmJyYnJiYnJicmJicmJwYGBwYGBwYGBwYGBwYHBhQHBgcGBgcGBgcGFQYGBwYGBwYHBgYXFhYXFhcWFhcWFhcGJgcGBiMiJiMiBgcHBiYjBiYjIgYHBgYHIiYHIgYHBiIjBiYjBiIHBgYnNDY3NjI3NjI3NjY3NjY3NjY3NjY3NjY3NjY3NzY2NzY2NzY2NzY3NjY1NjY3NjY3NjY3NjY3NjY3Njc2Njc2Njc2Njc2Njc2Nz4DNzY2NyYmJyY0JyYmJyYmJyY0JyYmJyYnJiYnJyY0IyYmJyY1JiYnJjQnJiYnJiYnJiYnJiYnJiYnJiYnJiInJicmJjU2Njc2FjcyNjMyFjMyNjMyFjMWNjMWNjMzMjYzMzYyFzYWzwEMCAUIBwsGBAMFAgYGAgYCAgcCAgMCBAgEAgYCBAQCCgcDBwQDCQUDBQQDCAMFBgQHAwQDBAIHBQICBgIEAQIGAQIIBwQDBgMFAg4FAwEGAQkGAgUCAgIDAgQDAgQEBAQNCgcXCQ0GDwsDBRYMBQwHBQsFChMLBQkGEC4UCxULBQkFChQMChgOCgUCBwMDBwQNCwUDBwQDCAUMBgoEAwUHAg0BBgQCBg0FCQEECQMLBgQCBQIFBgMCBQMCAwICBwIECAMDBQMGCwQHAgUCAgQBBgQCBQIFAgIBAwIBBAIFBgQIBQYFCAsFBwECBgICAQIHAwIGAQQCBwYCBAcCAwECCAYDCAUHDAQKAwINDQUFBgQLBwUHAwILBgMHBwIHAgEGBgINBAULBRIEBgMCBgMJEwsJAwUFGgYUFQoVCgQKBAIHAg0KBQcDCxQJBAMIAQECBgIEAgcFAwMJAgQCAQYBAQgIAgYDAgMIBQcFAgIHAgUBAQMGAgQCCAEIAQICBgsDAgQFAggOBgUDAQ0IBAIFAgQIBQMGAgYEBAMCAwIGCAQDCQIKBA4DAwYECBACBgQEDAkEAwcDBQsGCwYOBwcNCAgTCQ8aEQsDAgMGAwQIBAoDAgoLBQgOCAUCCAQCCQICAwUDCgICBgsFBAUEBAUDAwUDCwgHAwQFAgMFAwcCBwIHBQEGCAUHCgYHAQIGCwUFAwQHAwgDAgICAgQEAQgBAQoNDQYGDgkEDQUGAQQGAgUHAwcBCAICCAQEAwIIBwEJDQUGBQMCCAIICwQCAQIJBgEKGQsLEwoOCgUDBgUODwUHAQoCCBEIBhAGAgsFBw4HBQwFCxYLBwkFCwULBicECgUHBgLpCAYBAwYCBAYCAwYEDAYECAgCBAYDCQYEBgsFBQkFCQQCDQoFCgUFCwUFCwUFBgUECgUGCAICBAIJAgUCAwQFBwUCBgMCCggEAwYEBQYQBgEBCQELCgQIBQICBwIEBgIPBwgIBwYDAwMCAwQEBAgBAQECAQIBAQEBAgECBQMBAQIBAQEBAQIEBAICAgIFBQICAgIDAwIHAgUEAgMBAgcEAgICBAMEAgIKBQ4MBgQHBgIIBAIIAgIFAgIHAwUJBQQHBAcLBQgJAgIJAQcLBQMLBQcDAQIFAwwIBQQIBQoGCgYJCgUHAgICBgQCBgILAgIHAgMICwYFCAcFBAYCCQkFDAUPCQgFAggFAgIBAgMFAgICAgcDAgUCAQcBAQMDAQoCAQIBAQMBAQIBAQIBAwICAgIBAQMBBAICCQICBQoIBAYIBAECBgQHBgMKCAUFCwgHBgMGAwIJDwQIBwMFEQYIBwQDCAQIAwEEBgYDAwoBBQMCAwYHBwMDBwMMEwoMAgIRDAgDAgUGBg4ICAcECQEKBwMCCQMICggQBQEGAQQBAgMCAwIGBQQCAQIBAgICAgEBAQMBAgEBAQEDAQECAgQBAgUDBQQCBQEFAQIEAQICAQIFAgICAgICAwICAgUFAgIEAgICBgMGAggBAQsEAgoIBQoJBggDAgcMCAUEBgkECwUCAgcCAwICDQELDwsLBg8bDQkPCAsCAQQHBAUJBQkCAQkEAgYJAwYCDAgCCA4HBwQEBwMIAgEICQUCBgILCAULDgkCCQUEBAICAgUJBAMDBQIBAgIBAwIDAwEDAgIBAQQCAwAAAAH/Zv/kAo8C+wH5AAATFgYHBgYHBgYHBiIHBiIHBjEGBgcGBgcGBgcWFhcWFhcWFhcWFhcWFhcWFhcWFxYWFxYXFhYXFhQXFhYXFhYXFjc2Njc2Njc2Njc2Njc2NjU2Njc2Njc2Njc3NjY3NjY3NjY3NjQnJicmJicmJicmJjc2FjcWNjcyFjc2FjM2FjMWNjcyNjMyFjMWNhc2MjMWNjMyNjMWNjM2NhcGBgcGBgcGIgcGBgcGBgcGBgcGBgcGBgcGBgcGBgcGBgcGBgcHBgYHBgYHBgYHBgcGBgcGBgcGBgcGBwYGBwYiBwYGFQYGBwYGBxYGFRQWFxYGFxYWFxQGFxQWFRYGFRQWFxYGFRQGFxYWFxYXFhYXFjIXFhYXFhYXFhYXFjYXFiYHIgcGBgcGJiciJiMiBiMiJiMGBiMmBiciJiMmBicmJicmIicmJiMGJiMiBic2Njc2Njc2NzY2NzY3NjY3NjQ1NCY1JjY3NjY3NjQ3NiY3NSY2NTQmNzYmNTYmNTQ2JzQmNSY0JyYmJyYnJiYnJiYnJiYnJicmNCcmJyYmJyYmJyYmJyYmJyYmJyYmJyYmJyYmJyYnJiYnJiYnJjQnJiYnJiYnJicmJicmJicmJicmIicmIjU0NjIWMzIyMzI2MzI2MxY2Nzc2Njc2Mjc2Njc2FjcyNjMyNjM2Njc2FrYDAQICBgICBQIDBgIIAwEJDAcECggCBwIBAQcEBgMCAgMCBwEBAgUCBAQCBAICBAIBBgICAgcBCAUEBAcEDgkDCQMECQUCBAIECAIDBAUGBAYLBgcKBg0EBAUBBgMCAgIFCAkCBQUFBA0DCAUCAgsFAxMGAgYDDQsFAgsCBQgFBQcECA8IChAGBQsFBAwFBQcEBgUECxsPAgcFBAgFCgQCCgICBAgECA8IBAgFCA4IAwYDBw0HBwMEBwMCEQYDAgoIBAIDAggCAgQCCBAIAgMCCAYGBQIDAgEEBAMCAgIGAgIDAgEEAQEBAgEBAQMCAwQBAQEBAQECBAEEAgIEBgMCCwYEDR4PCQQDCQECAwYCBwQFBwULGAsKBgIDBwQGAwIIDwgNGw4DBwMFBwQGCgYFDQYGCwULAQECCAELBgUHBgMLBAQJBQQGBgwCAgIBAQQCAwEBAQICAQEBAgIEAgICAQECAQICBQMEAgYBAgIGAwIEAgkCCgIJAgUCAgMHAgQGBQcEAgYHAgIFAgUEAgIHAwUCBgEBAgYCCAEDCgYEBwUIBggEAwsJBgQIBAcFAg4NCAoJAwIYAwsHBQwIBA0hChMJEQgFCAQFBwQHDgcDBwMDBwIFBwQFCgL7BgYCAgIBAgMCAQIGAggGBAIIBQIJAQILEggLBwIBBwIJAwIECgUIAwIIAgQGBQEIAgQECgIBCQ4FBQYFBQkDCAUFCgUCBgIFBAMHAgIIBgQHDggGDgcNAwcCAwkDAQoECA0CCAIFBgMEBQIGBQUIBAEBBQEBAQMCAQIBAQEBAgEEAwIBAQIBAQEDBQQDAgIBAgUBBQIBAgICAwcDAgICAwsEAgECBAsHBQMCBQQCDwgEAgwKBQMEAwkEAgQCCRAIAgUCBg0IBwQIAgoJBQIEAwMGBAoRCQgQCg8OBgUIBQQHBQYMBgUNBQUKBgUNBgUJBRQmFggLBwoFBwEHBQIGBwUDAgEDAQINAwECAQMBAQQBAQMBAQIBAQICAQEBAgYCAgEBAgEBAwUIBAMFAQIIAwIDAgIEBAYEAgkDBg8ICA4IBAUEAgsFDQwIIQUIBA0aDgwCAgUNAwMKBQMGBAQIAgUHBAYFCAYCAwYDAgQCCQIHAwILBAUFAwcFAwUOBwgDAwwFAwMHAwoEAgQJBQoBBwMCAgUDCAEBAwQCAgYCAgQCAwEDBwICAQMEAQUFBAMBAQIBAQICAgMCAQIBBAEBAQEBAQEDAQIBAAH/7P/zAmgDKwILAAABBgcGBgcGBgcG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ogIGAgIBAgIEAQECAQYBAgECAQMBAQIBBgICAgQDBwMFAwIKCwcBCgMFBAMJAg4JBQwJBQgCAgkSDAsSCAgBBgMHAgIFAgkGAgIIBAUCAgICAgICBAEDAgEDAQIBAgEBAQECAQEBAQMCAQEFBQMEAgICBgMBAgMCBwQCBQcEBQkGCBMKCxAHAwYECBEIBQ0HBgcFCwcLAQMIBAgFCAIFAwYBBgkGGiYXCRUNBAcBBgMFBQkDBgQDCAoJBQMHAgICAQEBAgECAQEBAQECAQICAgYBAQECAQQBAgQBAQEEBQEHAgIFCgoIAwweDgQJAwIIAgEHBQMLCA4MBgsXDAQHBQoEBQcEESJSAQMBCQgNCgIFBwIFAwEGCwMECQMDCQILCgQHEwUFAwIBAgkCAwUECgMFAwoDDQ8HAwUCDgoEAwcCBAUCBAYCCAECCAECBQcFBQgDBQECAgQCAQECAQEEAQQBAQEDAQQBAQICAwEGCAIFAgsEAgUMBQcDDwMFBgQHAwsGBAQHAgsCBQICCggCCwkFAwcEBgEBBQEBAQIFAgICCgIEBgoGAgYIBQgBAQUOCAIGBAMIAgUKAwIBAgUFAgMCAQwGBxYMBQ0FBQsCAQIBAQYDAgMCBQMCjBAOCAgOCAMIDiAQBg4JAxUFCxUKCBAIDQkFAgYDBQMCAgcEBgUJAgwKBgIBCQECCQIFAQkHAgMCAgQBAQICAwIKBQcGAQgCAgYBAgoGBQUMBQQFAwoFBgUIBAINBAgGAhILBwcNCAULBgUKBQkDAgcQCAQIBBESDAcDBwMIAgEDBwIFBQMFAwMGAgIHAwQDAQIBAgIHAgIEAwQIBQMEBwUICQkGAhMhFAoIAgMCAgQBAgUFAgEFAQgDBAQDBAMIBQMGAwMLBQUKBQQIAwsCCxsMGBYuFwMFAwQHAgcFAw8JCAwHBAcDAwYEDQYLBgUGBAoWDAoSCgsVCA0NBQQCBQEDAQQGAwECAgIFBQQBAQEBBAIBAQEBAQEDAQIF/iMFBgcLBwIBBQIDCAMMAg0JAgoHAgUDAQQBAwUCBAwHCwgFBQUFBxgGCgQECwQDAwYDCAoDBAECBQQBAQEBAQQCBAICBAIBBAQEBwoHDAkFAwYDAgcECBkIDBoJCw8GBRQCDgwGAggPBgkGAgwGBAgCBwECAwICAQMBAwkFAwMKBQMDBAIIAgMDAQgG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NCcmJicmNicmJicmJicmJicnJiYnJiYnJiYnJiYnIiYCNgkFEgsBAQoIBQIFBAgIAgYDBgoCAQEBAQEBAgEBAQECAgsEAQECAgEDAgEDAQEBAQMDAQEBAgIBAQgDBgYCAgQCBAgFAgQCBQsFDQkFCAkJBQsFCgsEBwUFDQYECAUGEAcZCBIJCA8IDgYHBAIHAQICBQIDAgEEBgICAgUEAQEBAQgCBgoIDAcFDQoFBgwHBxMGBQ8FDA4HBgYCAgIEBAIBAQMCCQICBgIFAwkJBAgRBQUQAgICAQEEAwQDAwIJBQUIBQUEBgEBBAUDAQUEBgcCAgIBAQcEChAKBAUCCwEBAgIJCgMJBQcIBgULBwQMBQYKBwcEAQECAgEBBAEBAQECBAMEAgIGAwgDAgUHBQsJBAgQCAUGAwUNBQcMBQUIBAgGAwkJBAUOBg4EBQIHAwMCAwMCBQECAgECAgEBAgEBAQEBAQICAQMEAggEAgQCAwcIAgQCAwYCBQMJAQIJCAQQEw0JDQgPDwUCCAIKBAIJAQkGAwQGBAcLCAIGAwYDAwYDAgIBAQECAQMBBAEEAgEBAQEGAgMEAQIGAQINEgsHBAIDBgIIAgIGCgUDBgQCBQQIBAMGAwQIBAULCAIFBAQNBAsECAQCAwUCBgMCBQMCCgYDBQUCAwEBAQIBAQEBAQEBBQgMGgwIDwgGDAYIDQcGDAcHDv7RBwoCBgwFAwcDBAkDCgIHBAEHAgUJBAICAgIEAQIBAQEBAQEBAgEBAQMCAQEBAgEBAQUCAgYCAggDBgoFCgMIDwUKBwgGDAQGCwUMDAYDBAMGBAYFAgUJAwcCAgECAgEBAQECAgEFAgIGAggJBgwEBwMGAQECBQIFCgQHCwIACQYCCQYCAQMEAgIEAgUEAgMCBRQHAwgDBAUCBgwIBQkFDyEQCREIFisRDgkFChMOHxEFCgUFCQUFCwUFCAUTKhUFCgULFAsFBwUFDQUJBAICBQIECAQCBAIEBgUJBAMFCAICBAMEBwIEAgIEAwIBAQICAgEEAgIFBAkFBQYDBgECAgMCCQICBgwIBQoRDg0bDgUIBQsSCwUUBgYEAgUCAQECAQIBAQYDBxEKCQkFBA0EBAgHCAIDBQILBAIFAggDBwYCAgQDAw0FAg4EDBQICgIDAgEBAgIHFQgECgECCAUFCQMCCQUEEAUFCQMKCwkHBgUNBQQNDQ0GAgMDBAoCAgIBAQEBAggBCgoEBgQGCwgLDwQEBwUHDAgOCgYGBAIDCQQHAQEGAwIFAQIBAgEDAQEBAQQCAwQCBAgEBAkFDAMCAgcGBg4HBQYIFwsIEAsIAwUIBQcLCAcHAwsWCwsUChYpFAEHAwsJBAYEAw0KAgQCCAYCAQIGAQEFBgIGBQEFAgMEAgIBAgYCAgYFBwMDBQMGDQQEBwQGCwUKBAILAgIHEQYQEwoFBwUDBwMaEQIHAg4HBQMGAwwHBAYDAggCAgsUCAQDAgIBAgUBAQIHAgICAQIBBAEBAgEBAQMCAgEKAgQCAgMFAgcEAwgDAgkIBQkDBQwGAgoFBAUDAwcDAwcDBgsFCAMBAgIBAQEBAwEBAScBAgECAQMCAgICBwgBAQoCDQ4HAwgEBAYEBQsFChIKEA4ICA4IBwwFBAYFBAkFBAcFBAkFCgkFDAoDCwIGBQQHAQMBBAUDBwMFCQMIDQcDCAQJAggIBAcPBwkJBAoFDBwLBAYFBw8HBQgFBQkFBQ8HDAQIAwcDAQQIBAUFBQQAAAH/xv9gAigClwHkAAADFjYXMhYzFjYXFjYXMhY3MjYzFjYzFjYXFgYHBhYHBhQHFAYVBhYVFAYHFBYVFBYVFAYVBhYVNjY3NjY3NjY3NjY3NjY3Fjc2NjMyNjcWNjMyFjMyFhcWFhcWFhcWMxYWFxYWFxYUFxYWFxYWFxYWBwYGBwYGBxQGFRYGFQYUFQYGBxQGFRYGFRQxFgYXFAYHBhQHBhYXFhYXFhQXFhYXFhcWFhcWFjM2Njc2NicmNicmJicmJgcGBhUGFhcyNhcWBwYGBwYmJyYmJyYmJyYmJzY3FhYXFhYXFhQXFhYXFBYVFAYXBiIVBgYHBgYHBgYHIiYnJgYnJiYHJiInJiYnJiYnJiYnJicmJic0JicmJyY0NSYmJyY2NTYmNTQ3NjY1NSY2NzQmNSY3NCY1NDY3JjU0NicmJicmJicmJicmJicmIicmJiMmBgcGBgcGBgcGBgcGBgcGFgcUBgcGBhcWFhcWFhcWFhcUFxYXFhYXFhYXFhYHFCYjIgYnIiYjIgYHBgYjBiYjBjQjBgYnNjY3Njc2Njc2Njc2Njc2Njc2Njc2JjU0Nic0JjU0NjcmNzQmNzY2NyYmJyY0JyYnJjYnJiYnNiYnNDQnJiYnJiY1JiYnJgYnJiYnJiYnJicmJiMmBicmJjYGCwUEBgUIDQgGBwYIFgkKBgMKBwUNDQUBBQICAQEDAQIBAQIBAgICAQEFBQMDBwIICwUFCgUFCQMHCgYIBwoIBQYOAwIHBQYOBwYNCAsHBQcDBQMCAgQCAgICAwIBAQECAwEBAgECAQICAQEBAgEBAgEDAgEBAQEBAQEBAgECAQEBBgICCwsCBgMCCwUHDQUKDAIEAQEGBQIGDwcDAwILCAcJBgMGAgICBxIGBQUCAgECAgMBBRQIDgcPEAUCAgICAQICAQQDBAkEAgQDBQgKBAYFBAcEBAYDBwQBAwYDBgQCAwUCDAQCBQQJAgEGAgEBAQEBAQIDAQEBBQEBAwMDAQIDAQIBBQIDBAICBgQDBwQFDAcQBwUPIQsEBwQDBQQDDQUECAQGAQECAQUBAgEDAQIDAgEBAQEBBQEBAQMGAgUKAwsEBAYFCBYLBw8HCBMMCA8ICwEIDggJDwYEBwgBAgoRCAgDAgMDAQMCAQgEAgEBAwEBAgEBAQMBAQIBAgIBAgIDAgIDAgEBAQEBBAMCAwULBQcCAgUGBgIGBAUOAwcCBQgFAgQClwICAQQCAgIBAQEDAgIBAwECBQsUCwkFBQYGAwQFAgQGAwMGAgMHBQgWCwoUCwsXDAEJAwMGBQQLBQIGAgIDBQEDAgQEAQEDAQEBAgYCBwMBCAYCAgIEAwMOCAcMBQcMCAoTDAUMBgkUCwsCAgwGBQYNBxQaDgMFAwkJAwsCDwUIDwkLFgwLGAwDBgMDBwIJBAINBQEDAgIEAQcEBw4SDQYCBwcDBQYFBQMCCxIEBwIGBgMFAgUDAgIEBAMGBAIHAyAOAQEBBgUGAgYEBgsJAwYDBQ0ICgEIBgMCBQIFBgECAQEBAQECAQIBAQUCAwECAgYCBgYDCAIHCAcIDQUGBgYRCAsUCwYLBRoeBxIHCw4LBwUNBxESBAcEBQsFFQ4JDwgIDwgOCwcCBAICBAECAgQCAQIFAgYDAwcCCw8JBxAHDQkFAgcEFC8ZCA4IDiEPBAgDCwQIBwQIAwgNBQgHBQUCAQEDAgICBgECAQEBAgMOBAQBBQMCAQUFBwcCAgYBAggCAhAyEwsVCQMGAwMIBQcGAwYCBQkFBwYFCA8KExwaMxkNGAsGBgMFBwUGEAcDBQQEBgMHAQEDBQIBAgICBAECAgECAgsA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AgIHBAcCBQMHDQYFCAoHAgcCAgECBQ0FDAcDBAUCDQoDAQYGAQgHAwMEBQQGBQoPCAQMAwICBwUEBwQLAQkEAgoGBQYFBAQFBwoFBQkDBg0FAwcCAgIBAQECAQMBAQEBAw0FAgIDBwsFBQcFDw8GBQsFAwcEDyINCA8ICRIMBAYDCBEIDwsGBQUEAwYBAgECAQMDAQIBAgMWCAMHAgIFBQ0DBAsFBQoFBgkFBQsFCQgkBwYDAwsFBQkDCBUEAwIBBAEECQcGDQUEDwYKDAUBBAIB+RUhEQwGCwYCAwgNCQIEBAECBQIDBwUDCgQLEwMNDwcIAgEDBwMDBwMLDwQDCAIXJxAFCgUFCAQEBwUIEwkEAwIBBQEBAgECAgEBAQIFBRUiEgIHAgwKBQILAggIBQgQBQkEBwMGCQFiCRAIBBkGBAkFCAEHCQIEAQEBAgEBAQECBQQBAQEBAQQCAQ4CBQUFCAYOBAUHAwwGAgUKBw0IBg0FDgkFDQgFAggQBgkSCA0MBQYKBQsKBwUDDwYLBQoIAwcKCAkSCAUGBQMGAwsLBgkLBAMFAgoIBwQHBgMEBgQMCAQOBQQJAwUDBgECBwECBQICAgEBAQQFAgIBBAEBAQICAQEBAQIBAQEBAQECAgEBAwEGDAICAwYEAQQHAQECBgIFAwIDAgUCBQIGAwYNCAsBAgcKBQsFAgULBQwJBQYDAgMBAwEBAQEBAQECAgMBAgEBAwEJFQwDBgQFBwUJCQ0KBQgRBwQLBAQGBAYBAgMKBQIBBQYCAQIDAQMBAgEBAwECAgEBAgMBAQIJAQIIAQgJBQMGAwICAgIECgQICgUJAQIKBQ0PCAwCAgoZCwUKCAwFBQMHBAwDBQMFCAUMCAYEDAgFEggDAwUFCAUFCAUHBgMHCQQJBQoFAggQCAUIBAUHBQQHBAMIFRAMBg0EBQMDAgUDAwEBAQIHAgUHBwIBCAcCCxINBAgEBA4FAwUJBgMGBgQEAgICBAYCBAICBgIQDgUHAwECAwIGAgIKCgkBBQICAgECAQIBAREFCA4KEQMDBgQDCAMJBQMCBgIEAQECAgEIAgUEAwcOCAcOBwgTDAsQCQQIBQQIAwULBQIFAwUDAgIFAgIEAQEBAgEBAQECAwEBAQQEBAcDAwUCAwkEBQcEBQYFBQcFCBEGAgYBAQIDAQEDAgEBAQIIAwUFGQQGAQIBAQIBAg4FCAECBwkGBQoCAgcEAgQKBgkPCQABAB7+8wKEAwgC7AAABRY2FxYWFxYWFxcWFhcUFgcGBgcGBgcGIgcGBgcGBgcGIicmJicmIicmJicmJicmNjMyFhcWFhcWFx4CMjc2Njc2Njc2JjU2JicmJicmJicmJicmBgciByIHBgYnNDY3NjY1NjY3NjY3NDY1JiYnJiInJiYnJiYnJiYnJiYnJiYnJiYnJiYnJiYnJiYnJiYnJiYnJjQnJjQ1JiYnJiYnJjQnJjQ1JiY3NDQ3NDY1NiY1NzY2NzY2NzY2NzY2NzY2NzY2NzY2NzY2NzY3NjY1Njc2NDc2Njc2Njc2NzYWNzY2NzY2NzY2NzY2NzI2FzY2NzY2NzI2MzIWFxY2MzIXFhY3FhcWNhcWMhcWNhcWFhcWFxYWFxYWFxYWMzI2NzY2NzY3NjY3NjY3NjQ3NjQ3NhQHBgYHFBYHFAYHBgYHBgYHBhYHBgYVBgcGFhUGBgcGFgcGBgcGFgcGMQYHBgYHBgYHBgYjBhQjBgYHBgYjBiciJicmJicmMSYmJyYmJyYmJyYmJyYmJyY3NDY3NjQ3NjY3NjY3Njc2Njc2NhcWFhcWBgcGBgcGIgcGBicmJyYmNzYWFxYWFxYWFxYWNzY2NzY2NTY0JyYmJyYnJgYHBgYHBgcGBhUWIhcUFhcWFxYWFxYWNzc2Njc2Njc2Njc2Njc2NzY2NzY2NzYmJyYmJyYmJyYmJyYmJyYmJyYmJyYmJyYmJyYmJyYmIwYmIyYGBwYHBgYHBgYHBgYHBgYjBgYHBgYHBgYHBgYHBgYHBhYHBgYVFBYVFAYHBgYXFBQXFgYVFhYXFhQXFBYHBhQVFAYVFhYHBgYVFgYVFBcWFhcWFhcWFxYWFxYWFxYUFxYWFxYWFxYyFxYWFxYXFhYXFxYWFxYWNzY2NzY2NxY2NzYyNzY2NzY2NzYWNzY3NjY3NjY3NzY2NzYWNzY2NzY2Nzc2Njc2FhcWFxYGBwYGBwYGBwYGBwcGBgcGBgcGBgcGIgcGBgcGIgcGBgcGBgFODBgLCQ8HBgICBgICBAIEAQQBAgYCAwgFBA4GDAgFBiAIChoFDAYCBwgFBQICCQsGAwwECgUCBwgEERIRBAMGBAMWAgIBAwICBQICBwsFBgIICQcECgQICgQEBAUBBAEBBQEBAwEGBAcEBQgFBAYECA4HCgoIDg8ICA0FCwEBCAICDAYDBQUCAgMBAgMCAgEDBAIBAwIBAQEBAgECAQIBAQECAgEDBQMCBwIDAgEBAgICAwIDAwECAQEFAQUCAwMFAQMIAwkUCAgHBwECCg4IBQoEAwYCAwUDBwkFCRQKBAsHBQcFBg4HDQcEBwoMBQEHBAMHAwcCAggDAQIDAgYDCQUCBAcDCgkEBQYFAwoFBQQCAgICBQICAgUDBwEBBAEBAQIBAgIBAgIBAQEBBgEGAwMBAQIBBQEBAQICAQEBCAUFAwUFBAkEBwYCCgEKBwQFEQYKCwMFBAIHAwoOBAUCBQECAQIEAQICAgEFAgMCBQEFCAQHBwMGCQYOCAsfDgQDAQEBAwIFBAIIBBAXDQQCAQEDBQQCAgUDAgMCBAUIBAQCAgIBAgMGAgUHDR0GBAQEBQQBAgECAQMCBQgDAwUJEg8RBAcFCQMCBAYDBQoFBQMCAgECAgIDBAMBAwIDCwYFCwUCBQICBgMPDQYFCQUNCQQRHA4DBwMKCAUFCAUGCBIRCgUJBAMHAwMFBQIHBAIFAgIDAgQHBAQHBAEDAQMBAQEBAQIBAgMBAgMBAQECAQECAQMBAwEBAgUCAQECBAIBBAIBAgEDAgICCAIBCwECBgMBAgUCBQUEBgUKAwkFBwYHCAsHCw0DCQYFBAgEBAgFEA8JCAICDQcFBgQECQQSAgMDBwIBAwYCBQUCBgIBAwQFAwoDAgkEAwYEBw0GBgYEFQcLBQcOCAoKBQsIBAUFAwQHBAUNBwgQaAEDAwMEBQcBBAwECQMKGA4DCQMDCQQJBQQEAwUBAQEBAQgCBgEFCAUGAQIKDwMCBAQCBQICAwMBAgMBBAkFBwMCDgkFCwYCAQIBAQECAgIBAQIBAQIHBQgLAQICBgIFCgMDBgQCBAEBAQICAgMGAgQFBQoQBwcLBwQCAQIDAggHBAcOBQIFAwULBQQFAw4HAgsDAgsCAgQIBAUHBBAZEQgPBgMFAwgMBA4JBgQKFAsIFAsJBgQDCwUFBwUIBQIDCAMMAwoBAgkDBwICBQ0ICAwJAQYFAQEIBwQCBQMCBQICBgIFAwYFBQIBAQIBAQEDAgICBAcCAgEBBQEFAQECBgIEAwoCAgUEAgcJBwILEwsKBAcFBAsGBAUHAwQFAQINBQ4PDAYNBQULBQscCw0GAwQHBAwFAhIW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BwYGBwYGBwYjDgMBBg0XCwoPBgYCAgYCAgUCBQEEAQIGAgMIBAQPBg8JBx8ICxkFCAMLAQIFBwUGAgIJCwcDCwQKBQIICAQQEhEEAwYFAxUCAgEDAgIFAgIGCwYGAggIBwQLBAMLAwQEBAUBBAEBBAEBAwEGFhMLCwMCBgICBgMKBgYJAQICAwICAgIEAQUEAgMCAQIBAwEBAQMBAQMBAQIBBQUBAwYHAgICBgQKFgkDBgQMBwQFCAUEBwQKEwgFDAcNHgoKDgkCCQQCDA0FCgQCDRAFAgUDBwIBBQQBAwECAgIIAwIFAwQCAQMDAgUMBwUBAwIBAQYEAgUDAgIFBAICAgIDAQEBAQIDAgIFBgIVFw0OCBUICwgGAwIFAwULBQIGAgcBBgQCAQIIBgQDBgICAgIFAgICAgMFAQEGAwMDBgICAgIFAwQCAgkDCAgNBQ4IBwwHCAwHBg4GCgYEBAUEBAcEBwoHAggEBQIFBgIFBQICBgIGAgIDBAECBQoGBwMBAwUDFA4LAwIECAUECAQECgMKCQUhAQMDAgQFBwEEDQQIAwoYDgMJAwQJAwkFBAQDBwEBAQEJAgQEAQECCAQGAQILDwMCBAQCBQICBAMBAgMBBQkFBwICDwkFCwUCAQIBAQECAwMBAQEBAQECCAUICwEBAgYCBQsDBAYDAwMECAMCAQICBgMMBwsMBwQCBgQDBwMJAQwIBQkDAwYDAwYDBAYECAICAwUDAgcDFRkMEB0LDgsFAwoFFhYPAgQDCAUCAgICAgMBAwECAgYBAgYDBAYDBAUDAgQGAwcBAQISBwQJBAkEAg0CAQgCAwcCCgMNGw4PDQYKEQgVJxQLCgcEAgoDCAUJCwUIEAkFBQYJBQMDBwMDBgMDCAQIBwULBgQBAgIEBgUDAgIEAgYLBwMHAw0CDAgEBwUQFgwJEgsXFwYNBwcOBwgFBwMCCgwFBQcCBgIDBQMLBQcDBQIEAQEBAQEBAQEBBAECAgICAgMDBhAFBwwFCgIIBQsCCAMIBQQLBAYGBwUCBw0ICQEBAgYCCgMCAgEBAQECAQEBBQsMDAAA//8AJAAEAa4C2QImAFsAAAAGAKBc9wAA//8AJAAEAa4C2QImAFsAAAAGAFZS9wAA//8AJAAEAbEC0gImAFsAAAAGAOJS9wAA//8AJAAEAa4CsAImAFsAAAAGAKFc7QAA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AwIDBQQCBwIBAQEDBgIJHhAaDwkEAgcDAgMCBAEDAgIBAQQCAgIFAQICBAEGCAQEBgMHDggKEQsIAgcBBwIHAgMDAQMDAQEBAQEBAQQBAQkKAgIFBQUDBQcCCgUCBwEBBAoEBQIEAgEEAwMBBAIEAgEBAQMBAQIBBgIDBQIEAgoHAgIKAQMLBAUIBAYLBgkPCQkRBQUIBAkHBAQIBQUEAwQLBAkGAQkIAgQBAgIEAwQBBwcCBQEBAQMCAgECAQFrAgwDDAICCAUDCAEBBwUBAQEDAQIGAgUBCAcGAgYCAwMDDBcLDQECAQIFAgINAQICAQIDBAQCBwIHBQQFCwIFBQI6BgQCCwQCBwMFCgUGDggODQgKBgIEBwIFCAIBAgIFBgECAgQCBQsIBQ4IAwkECBENBw4ECQQJAgICAwIDAgEIAgIEAgIIAgYBAQUCAQMGAgkCBg0GBAYECAIJBAcFBQkGAwUDBhEIBAgGBgsPBw0CAwUCCAEIAQIDAgICBQQEAgIGAgQGDAcDAwUDBQQCCAgJBgMFCgQJDgUFDAUHAwIJCQUDBQIDBAQFAwIBAwMCAwQBBAECAQIDAQMEAgkIAggDAgYHAQ4KBQUFAgMJBQUIBQUIBQcRBgwDAwYDBQcECAMCBw4MAgcCAgoDCBEJCA8JBQgECBEICw0GBQkHBwILBwoHDAwGAwYEBgsFCQMGCQUEBwUKBgQEBgQHDAcKGAsIAgEJBAkCAwkFAwYGCwcFAwkDBQYFCgQCDggHAgMFAgYCAgQFCAQDBgMBBQcGCQEHAQIKCQQGCAUIBwsEBAkHBQsBAQMJAwQFBAwHBAIFAggHAgcBAQMFAwMBAgICAQEFBQIFCAUDBwICCQUECAQJCAEGCAUPDwgFDQYLBAIMEggMDAcFCAQECAUDBv7QAggFAQIHBgIJAQwGBAIHBAsLBQYIBQgGBQ0GBAgCAwQCCxULBQQDBwIGBAsKCgIKBgsFCg4IBQwECgkDBwoHAggAAQASAPgAvwGhAD8AABMWFhcWFBcWBhUUBgcGFAcGFAcGBgcGBicmJicmIicmJicmJicmJjc2Njc2MzY2NzYzNjY3NjY3NhcWMhcXFhanAw8DAQEBAQEFBQEIAQkGBgoeEgoEAwYFAQMGBAYHBAQJBAEGAwcBAwQEBwMKBQMECgYGDgkHBAwJBAGLCwoIAgcDBgwI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JyYmJyYnJicnJiYnJicmJicmNCcmJyYnJjQnJjY1NjY3NjY3NjY3NjY3NjY3NjY3NjY3NzY2NzY0NzY0NzY2NzY2NzY3NjI3NjY3Njc2Njc2Njc2NzYzNjYzNhY3Njc2MjM2MjMyFzI2FzIWFxYWFxYWByYjJiYjJiYjIgYHBiYHBgcGBwYiBwYGBwYGBwYGBwYGBwYGBwYGBwYGBwYGBwYGBwYHBhUGBgcGBgcGBgcGFAcGFgcGBwYGFxYWFxYUFxQWFRYWFxYWFRYXFhUWNRYWFxYWFxYWFxYWMxYWFxYWFxcWFxYXFhYXFhYXFjYXMhYzNjYjNhY3NjY3NjY3NjYzNjc2Njc2Fjc2Njc2NzY2NzY2NzY3NzY2NzY1NjY3NjY3NTY2NTQ2NTY2NTQmNTQ2NSY0JyYmNyYmJyYxJjQnJiYnJiYnJiYnJiY1JiYnJjUmJycmJicmJicmJhcXFAYHBgYHBhQHBgYHBhQHBjEGFAcGJicmJicmJicmJicmIicmJyYmJyYmJyYmJwYmBwYHBjEGBgcGBgcGBgcGBwYUBwYUBwcGBgcGBxYGFRYWBxUWFhcWFhcWFhcWFhcWFhcWFjMWNjcWNzI2NzY2NzY3Njc2Njc2Njc2JjM2Njc2NjU2NjU2FhcWFgcGBgcGBwYGBwYGBwYGBwYiBwYxBgYHBgYHBgYHBiIHBgYnJiYnJiMmJyYmJycmJyYmJyYnJiYnJiYnJjc2NTY2NSY2NTY2NzY1Njc2MTY2NzY0NzY2NzYxNjYzJjY3Njc2Jj8CNjY3NzYzFhcWFhcWFhcWNjc2Njc2NjcB2AMIBAkJBgkLBgkFAgIFAgcFBAMCAgICAgIDAgUBAQMDAgQDAgIFBgIDAgMFBAICBAIGAQEEAwIHAQIDAwYBAQYBAgIHAgYBAgcCCQgGBQoECBAIDQcFBQgFCgwCBQoFBAgEBAkFCgUOEAoGBAUGAwwMBgQHBQMHAwIEAgQIBwIBCgQCCQYDBgECBQYHAggIBgMEAQUEAgECAgEDAQEBAwIBBAIBAwIEAQICAwIDCQEHAgICAwIICAICBgEHAgQDAgYKCAcBCgIBCgMCBggDBQMJEwsKBAoCBAcDBgwGCA0MCwYFCgMGCQgOBwQIBQkDAgMFJgoHAgUEBQwGBQoHChMIEAYLBwcHAwUHBA4GAwUHBQIHAgUFAgUCAgIHAgcDAgcEAgYBBwcCAgIEAwICAgUBBQEBAwIDAgMBBAICAQIEAQIBAwcDBQgGAgIFBQQFBAIHAgICCQIFBQQJDQYGBAYNBQcFAw4IBQUJBQsBAQYEAwUHBQUJBQwBAQsFAwYCCQQBBQsECAEMCQUFBwQGBAcEAgIEAgECAgMBAQEBAQECAQICAQIBBQICBwECBgQEBQECAgQCBAEDBAIGBwIJAwMCBwIBAwcaAwICAgICAQECAgIBAQQCBAYBAgEEAgQBAgIFAgcCAgcBAwQCCQQCCgkDAggEBwQHAgQCAgUCAQEBAgMGAQUBBAQCAgECAQEBAQEBAQICBQQIAwICBgIJAgQFBwIEBgMLAQQGAwYIBQkBAwUKBQIHAgIHAQEEAwIFAgYDCAcCAgECCQoGBQMDBQQDBAMIBQMGAgEJBAgEAwUDAggECQMDCBMHBQgGCQMGBQQGAg4GBAYCAQYFAQMBAgMBAgIBAQIBAgEBAQQCAQMEAQIHAQQCAQYEAQQBAgEHAgcBARAQBQMDDgkIEAUHDAYGAgIFGgQGBwIEBQUC2AUGBQgMCw0OBwwJBAMEAwwJBQYEAgUHBQUHBAsBCQgFCwQCDAIXKRQFCwYKAgsOAwMNBAoBAQQFAggEAwUCBwEIBAQDBQQEAgYBBwcDAwUFAgcCBQECAQIBAwEBAQIBAgEBAgECAwMFAgIDAgcFBAIEAgICAgQCAgIGBQEJAgIHCAMDAgIHBgsGCQsLBQgCBwoFAwYDBwUGBQIHAwwJBhIdDggPBgkGBAcNBQgNCAgEAgIEAwkLBAIIAgEFAgEBBQIGCgUHAQYBBwQBAgICAgIEBwICAQIBAgEBAgEEAgEDAwEEAQMEAgICFQQBAgEBAgEBAQICAQIBBAIBAgEFAgEDBwEEBAIDBgIEBAIDBQMJBAIKCQQKAQkDCAgFBAYEBAkECQUCCQIBCQINIQwFCQUHDAYECAIOBgMDCAIMBgoCCQEGBQIGBwIEBQEIAwQFAwQGAgcHAgMCAgUDAwIBBQEBAgEBAQECAgICAgUCBAIDBAIBAggBAgQFBAcBCggFBAsFCAkJDAcECwIEBwUFCgURAwUDBwoFBgsFBQkFBQsFAwcDAwcEBQ8HDAMIBA0LBQkEAgMIAgcCAQQEAgoBCAMJAgUCBQECAgI9EAUKBQYOCAIHAwUMBQUIBQsDBwEDBwQD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BAEBAQUEBAsFAAAAAAL/rf/VA4cDCwNXA6YAAAEWBgcGBwYHBgYVBhUHBgYHBhUWBhUGFhUGFAcGFgcUBwYHBgYHBjEGJicmJicmJjU0NjU0NCcmJicmJicmJyYmJyYmByYmJwYiJyYGIwYGBwYiByIGIyYGBwYmBwYGBwYHBgYHBhYXFQYGFRQGFRYGFRYGFRUGBhUUFhcUBhcWFhc2Njc2MjcyNjc2NjM2Fjc2Njc2MTY2JyYmJyYmJyYiJyYmBwYGBwYGBwYUFxY2NzY0NxYGBwYGBwYHBiYHBicmJicmNSY2NzY3NjY3NjY3NjY3NjI3NjYzNhYzNhYXFhYXFhYXFhQXFxYWFxYGBwYGBwYGBwYGBwYGIxY2MxYWMxYXFjIXFhcWFwYWFRQHFBQHFgcGBgcGBgcGBgcGIgciBiMiJicmJicmIyYmJyYmNTQ3NjY3NjIzNhcWFwYmJyImBwYHFhYXFhYXFhY3NjY3NjY3NjY1JicmJicmBicmJicmJicGIicmJiMmJiMmIgciBiMGBgcGFhUGFhUWBhUWFBcWFgcWFxYWFxY2FxYWFxYyFxYyMzI2MzI2NxY2MzY2NzY2NzY2NzY2NzY2Nzc2Njc2NjU2NDc2NzY2MzIWFQYGFRQGBwYGFRQWFRQXBhYXFgYXFhYVFgYXFhYVBiYjJiYnJiYnJicmJiciIiciBgciJiMGBiMmJgcGBgciIyImIwYGIyImIyIGByMiBwYiIwYGJzY2NzY2MzY2NzY2NzY1JiY1NDYnJjQnNCYnJjY1JiYnNCY1JjYnJgYHJhQjIiYjBiYjBgcmIgcGBwYGBwYUBwYGBwYiBwcGFAcGBgcGBgcGBwYXFhYXFhYXFhYXFhYXFhYHBiYHIgYHBgYjIiYjIgYnIiYjIgYjBiYnIgciJiMiBgciJgcGBicmNjc2Njc2Njc2Njc2NzY2NzY2Nzc2Mjc2NzYxNjc2Njc2Njc3Njc2Njc2Njc2NzY2NzY0NzY2NzYmNzY2NzY3Njc2NzY2NzY0MzY3NjY3NjY3NjY3NjY3NjY3NjY3Njc2NzY2NzY3NiYnJiYnJiYjJhYXFhYXFjIXFhYzNhYXFjYzFjYzMjYXMhYXMjYXMhYzNxY2MxYWNzYWMzY2NzMyNjM2FjM2NjcWNjM2Njc2Mjc2Njc2Mjc2NjcFBhQHBgYHBgYHBhYHBgYHBgYHBgYHBgYHBgYHBgYHBgcGBgcGBgcGBgcGBgcWNjcWNjcyNzYWNzY0JzQ0JyY0NTQ0NzY2NzQ2JzY0NQYGA38IAgECAQEFAQIBBwMDAQIBAgEBAQIEAQICBAEDAQIEDQEBBAIBAQMBAQIFAwQNCAcFBQYFBQ4FCB0ODAsFCAIBCQcFBQkHBQYGCQcCAgYEChAIBgICAgEDAgEBAgEBAgEBAQICAQEBAQQBECgVCA4HBgwFDQQDCRAFCAECBQoEAQEIBgMGBAMJBQgPCwoGBwQGAgICChYGAwYHAQEBAgIEDgUPCAYGCAYEBwEFAwUCBgICBAsGBAcCCAMCAgYEBAcECA0IAwUDBQYCBwIHCAkCAgQFAgICAwwCCQICDwsICgIBCAEBCwgHAgEGAgsFAwMEAQECAgQEBQcFDgcFBAgFBAcEBQsHAgYDBwUIBAIIBAUCAwMPCQcSCggBCQkFBQkDCQQBCAQECAQLFQwFDgMCAQICAwMBAgQEBwcEDgcEBQYEBAkECgMCCAcBBRIKBAgFCRQKAQQBAgEDAQEBAgECEAoJBAQIBQcMBwMHAgwUDAYMBQkGBA8MBw4WCgQEAwcEAwYDAQIBAgYCAgIFAgECCAECAQYFAQEDAgQCBAECAQUCAQEBAQICAgIBAg0CBAcMBQUHBAsBAwoGBxMHCBEICxQLChMKDhkNBQkECwUCBgQEBwQFBwQJEQgMDQgCBwMFCgUDBAIFAwIBBAIEBQIDAQQCAgIBAgECAgECAQIBAQEPIBEIAwQHBAgCAgUICQwFGhgFBgQFAQYCAgQBAQwEAgsLBQQCAgUBAQICBQIDCAMJEwsKDwUGCwEHDQYJFAoFCQUDBwUDBgIDBgIDBwMLEgoGCAwWCwgSCAwTCgsGBAEGAwwHBQMHAwYLBgoNAgUDAgQDDAYCAgoIBQYECQYDBAMCCQQGBQIBAgQDBgECAgMHAQUDAQQBAgIKAwcDBQENDwECAgMDAQkFAQICAwEFBQUGBQICBgMFBgIFBQMEBgEDAgUCBgUGAgQLCAsGEgUOGwsFDAYEBwMMBgILGAsJBgIFCAUFCwcDBQQEBQUUCgUDExYKBwkFBQkFDQkGAwMFAwUJBQcJBAUKBQUIBQoTCQQGBAgJBf4nBAEIAQEFBAIHAQICBAIEBgcCCgIEBQIEAwEIAgIDAwUCAQcBAQYGBAQHAggTBwkVCiYSCQ8HAgEBAgEBAgEBAQIDBQMLBgsGBQcOEQIGAwQHEAoEAgoGBwcDBQsFBQkFDA0GBQgPAQ0IBQ0EBQQIGg4IDgcDBwMECAQOHA4FBAMCAwIDAgEBAQMBAQEBAQICAQICAQEBAgECAgEFBAUGBwURCwwJBRcHDAgLCAQEDgULCwgQCgcDAwYDBQgECBAIBAECAQEDAgECAgEFCwMCCw8UCwYIBQQIAwEBAQMCAQUJBgwJCAoHAgIFBA4BAQ0EBgsDBgcCAQICBAYCAw8BCA8HCAQJAwIECQMDAgIHAQECAQEBAQMCAgICAwMEAgIJDxILCxELBQkEBwsJBgIBBQUHAQMCBQYHAQYCCQIFDAUGCgQIBQUICgsIAwgECAUBAQECBQIBAQIDCAMDDAYFCQ0GCgIEAgkEBAkBAQEBBA0FAgICAQIDCAUCDQYDCAMFCQIRAgUFBAUBAgYBAQECAQEBAQICAQEBAQEBAwsTCw0GBAUKBREmDAkXDBIFAgQBAQEBAgMCAQEBAQQBAQEBBwMECQUREAcLBQIFCQUSBwwGCQEBBgcEDgMFDw0FBw0JDSQOBhUKBQcECQgJDQcJBgMJCwYLFwoGCQUGBgMKBQQFAggBAgcBAQIBAgEBAQMBAQEBAgEDAQQBAgECBAMJBgIDBQUHBAYLCAoLEg8IBw8GBRAGBQwGCgMCDQwIAgYEBw4HAgMCAgMDAgIBAgEBAgQKEgoJBQILBQIJARgJBQIPEQkHBAMIDQYHBQwFBQgFAgoEBAECAgUIBQEBAQEBAwMCAQICAQYBAgMCAQECAQMEBQYDCAUCAgMCBAgFCgUCBAMCBAIHBwIHDAsHBg4JBQcDAw8KCgwBAgMGBAkBBAcFCgECCQMCCQkEBAcFBwYIAxwdAgYEBAYPDgYGAwMFAggNCAsMBQULBgkIBAkNDQYIBgILBxAYDAgGAwgHDwIBAgMCAQIBAgECAQIBAQEBAQMBAQECAQECAQEBAQEBAQEDAQEBAwEBAgEDAQEBAgYCAgIEAQKeBwIBCgMBBgUEBwMCAwUDBg0FCgsJAwgDCAICCgUECgQKAQILAgIMDQcHDggBAQEBAgEFAgQCDhsOBQsFEiQTCBEICA0IBBcBBw4HAgcAAAAABAAe/6oC1QM7AKcBEAGnAxcAAAEGBwYGBwYGBwYGBwYGBwYGBwYGBwcGBgcGBgcHBgYHBgYHBgYHBwYUBwYGBwYGBwYGBxYXFhYXFhYXFhcWFhcWFhcWNjcWNjc2Njc2Njc2Fjc2Njc2NDM2NzY2NzY3NjY3NjY3NjQ3NjQ3NjY3NjY3NiY3NjQ3NjY3NjQ1NjY3NiY3NjY3NiY1NiYnJjYnJjQnJjY1JjQnJiYnJjYnJiYnJicmJicmJwc2Njc2Njc0NicmJicmJyYGBwYUBwYGFxYWFwYGJiYnJiYnJjY3NjY3NjY3NjY3FhYXFjIXFjMWFhc2NjcmIyYGBwcGBgcGBgcGBgcGBgcGBgcGFhcWFhcWFhUWFhcWFhc2Njc2Njc2NwM2Njc2Njc2Njc2Njc2Njc2Njc2Njc2Njc2NjcGBiMiJicmJicmNCcmJicmJicmJjU0NjU0JjUmNzY2NzY2NzY2NzY2NzYyNyYmJyYmBwYiBwYHBgYHBiMGJgcGBgcHBhYHBgYHBgYHBgYHBgcGBhUUBgcGBgcGBhcUFhcWFBcWFhcWFhcWFhcWMhUWFhcWFhcWFhcWFhcHBiciBgcGIgciBic2Njc2Njc2Njc2Njc2Njc2NyYmJyYnJicmJyYnJiYnJiYnJiYnJiYnJiYnJiYnJiYnJicmNCcmJicmNicmJjUmJicmJjc0NDc2Jjc2NDc2Njc0NjU2NDc2Njc2NTYmNzY3Njc2Njc3NjE2NzY0NzY1NjY3NjY3NjU2Njc2NzI2NzY2NzY0MzY3NjY3NjY3FjYzMhYzMjYzNjIXFjYXFhYXFhYXFhcWFhcWNhcWNhcWFzY2NzY2NzYzNjY3NjY3NjY3NjY3NhY3NjIzNjYXFgYHBgcGBgcGBgcGBgcGBgcGBgcGBgcWFxYWFxYWFxYWFxQWFxYWFxYWFxYWFxYWFxYXFhcWBgcUFAcHFBQHBgYHBhYHBgYHBhYHBgYHBgcGBwYGBwYUBwYGBwYGBwYHBgYjBgYHBgYHBgYHBwYGBwYGBwYiBwYGIyYmJyYmJyYiJyYmJyY2IycmJicmJiMGBgcGBgcGBgIfBwEEBwMFCAQFCAUECAQDBwMDBAQMBAYFBAcFCwUFAgkHBwMHAwYCAgMGAwcCAgcDAg0BCQUEBwYCBgQCCAICBgMMDQkIBAQFEAUMCgUIAwEICAMIAQ0CBAUDCAIJBgMGAgIHAQUBBAEBAgQCBgEBBgIDAgEBAQEBAQEBAQIBAQEBBAEBAgIGAgMBBQIIBgUGAQEGAgEGBAIFAg8KdgIDAgQFAgEBAQYCBwcICwYMAQICBAIMBAIJCQcBBQIBBQEEAgICCQICBQsHBQkFDAYCCAIEAwIGCQUQDQ4hDw8DBgQFCAMFCgUDBgMFAwIBAQIBBQIGAgUIBQQGBBMIBwQIBAsCsQcOCA0aCwIBAgICAgMFAgUIAgIGAwIDAgUMBgkOCAoTBQcHBQUBBgMCBQMBAQICAgIDBgEBBAMBERwQCA8IChIKAgkFCA4KECEOBgcLFgwGBAcCAQMFAwkIAQEFCgQKCAMFBgURBwEBAgECAQEBAwEEAgMBAgMCAgECAwsDBQIIBwMGCAUGBwIFCwUXCQcFBgUCGQIFDAQFCAMCBAICBQMCBwIDBAUFAgUKBQQIDAMEBgYFBQUDAgUCBAYFCAECAgMCBAICAgUCAgMCAgICAQIBAgMDAwEBAgMCAQYCAwMBAQIBAgEBAQIBAgMBAQUBAgMCAwIFBQIGBgEHCAEBBQkHCQkJBQcDBQYEBgQCCgIJBQkSCwkPBwUHBQQHBAMHAwUOBQoHBAsLBQUKBQgEBAYEBgICCgQCDgcCBQMHAQIEAQQCAQMCAQUDAQIBBAMGBQcbBgYRAwECAQIEBwwHBgQCAwcDAgECAgICAgYCDgMKBwQGDQcJCgUJAgcCAgIGAwIEAgMJAwMDAgECAQECAwEBAwIBAQEBAgEBAQECBwMICgYHCggEBgEFAgIDBgMECAcBAQ4LBQMGBAoCAQoKCwYDCAULCgUIGQ8PDQYEBwUDBwMIDQgKAQIMBgICCQEBBwQDAwgEBwkCYxEDBgwFCREKCBEJChEKCA4IBgwHGAkSCAgPCBYNCQQPEwkFEAYLAwcEBg0HDAgEDAsFCwIEBgIFBAIEAgIBAQIBAQUBAQIBAQEFAgMEAgYCAgMFAgUDBgICBgIGAgoEAgsEAwoCAQYDAgUIBQYNBQgFAg0KBQsFAgMJBAMHAwgQCAUHBA0MAgoMBwgPCA8KBgUEAgsHAxALBwoCAgkBAQoGAggBDQ5rBAYECAgFBQkFBAkDDAICBQIFAwIECgUFDAUKAQEEAQcCAQgOCQUKAwsDAgUFAgIEAgYBBgUCAhIXCgkCAgIDAQICAQEBAgcDAgECBQgICg0ICx0ICQMCAwsDAgYBAwQDAgQDBwH+lQ8cDhYrFwMHAwIGAgYNBQwPBQgMBwMGAwwZDgQGCgQFBQYFAwIGBAMICAMSDQYFCwUGCwUQCwkCAgQCAhMMBQIFAQICBQECAgYCAgQDBAUIBAcKAQECBQIHBgEBBgsFDQ0GChMJKSwFDgIIDAUNGA0NGQ0MHAgIBAIFCAUEBwIDBwIIAQgGAwUIAwYBAgMIA9cDAgMBAQECBRAJBQUMBQUMBQUIBQYNBgsEAwYDAwQGAgQDBAUEBgIDAwIECAQIAwMCCQQGCAQFBwgIAwQJBQMFBAUJBQcHAw0MBREiEgMHAxgaCwQGAgkBAgkCAQQHBAIGAwgFBwQCCAIHAwoGAwsLAwYGAwIHAwkBAgcNBgcBBwsFAgQHAgQDAgYCAgMFBwICAgQBAgICAQIEAQEEAQICBAICAgICAgUBAQUBAQcDBgoGCQUDCggEAgsEAgwCAgULBQIEAgMBAQUIAQIDCAwWCwoIBQULBgMHAwMFAwQIBAgCCQgEBgsHCAkFBQQCCQQCBAsFBQkFBhAIDwYIBQ4iEBctFgwDBwMICwYEBgQCBgQDBgMIEQkWEwsICwgFBgIBBAECAwYCBAYGAgkHBAIEAgMDAQcGBQICAgIFAQEBAQUCAQEBAQECBQIBAgQBAwEBAgUMBgcPCQwZAAACAAkASwHLAhkAXQEOAAAlFhQVFBYHBiMGJiciBiMmJicmBiMiJiMiBiMmIyYGIyMGBicmBiMmBgcGBgciJiMiBiMGJyYmJyYmNzY2MxY2FxYWMzI2MzIWMzI2MzIWNzY2NzI2NzI2MzYWMzY2JxY2NzY2NzI2NzYyNzIyNzY2FxYGFQYWFRQGFwYmJwYmIyIGIyImKwIGJiMiBiMiJgcGFBcWFBUWFBcWFhcWFhcGIgcGBic2Njc1NDY3NjQ1NjYnJgYHIiIHBgYjBiIHBgYHJjYnJiYnJiY3NhYXFjYXMhYXFhYzMhYzFjIzMjIXFjYzNiYnNCY1NDYnJiYnJiYnNjY3NjYzNhY3FhQHFAYHFAYHBgYHBgYHBhQHFAYBnAgBAgUIBwsFBQsGDBcNBQgFAwcCAggCCwEHCAMNDQwIDQwHEBQKBgwGBAgEBAcFFxUCAQEBAwIDBAULFw0MFg0FCQULEwoFCgYSKBQKEQgHDwYIEgYIAQIKDpYGEwcTJBQGCQUFCwUHCwUIDwgCBAECAQEQEwsMDAYFCggFCgUODgkGBQIHBAULBQIBAQUBAQIBAwkDBw8ICx8LAQYBAQEBAQQCFjQXCREIAwYDBAcDCA8IBAEBBQEBAQIDBQgFBQsHDQ4HBQwFCgYDBQsHBQ0FBxQIAgEBAgEBBAECAQEBCR4LCQICAwYCBwIEAQEBAgIBAgEBAwEBmA4aCQUJAwQBBAECAQQBAQIBAQEBAwEBAQEEAQIBAQIBAQICAgYNBwYXBQEFBAMBAQQBAgEDAgECAQEBAgICAwLwAgIBAgIDAgECAQEBBgEFCwUEBgQDEQIEAgEBAgEBAgECAQEOGw8ECAULBQMFBQULEgkCAQEGBRAOCAsGDAcGDAUMGQ4CBQEBAQICAQIFAQMIBAsVBQgGAgEDAQEBAQIBAQECAQEBAwYLBwsGAg4RBw0NCAYMBwMCAgIBAQECCAwCAwcDEAoFBAcFDgcFDAgFBQcAAgAJAEsBpQHxAF0BLQAAJRYUFRQWBwYjBiYnIgYjJiYnJgYjIiYjIgYjJiMmBiMjBgYnJgYjJgYHBgYHIiYjIgYjBicmJicmJjc2NjMWNhcWFjMyNjMyFjMyNjMyFjc2NjcyNjcyNjM2FjM2NicWNhcWFxYWFxYWFxYWFxYWFxYWFxYxFhYzFhYzFhYXFhYXFgYXFgYHFAYHFBYHBhYHJiYnJiYnJiYnJiYnJicmJicmJicmJicmIicmBicmJicmJyYnJiInJiYjJicmJicmJiMmJic2NzY2NzY2NzY2NzY2NzY2NzY2NzY2NzY2NzY2NzY3NjY3NjYzNzY2NzY3NjY3NjY3NjY3NjY3FgYVFhYVBgYHBgYHBgcGBwYHBgYjBiIHBgYHBgYHBgYHBgcGIwYGBwYGBwYHBgYHFhcBnAgBAgUIBwsFBQsGDBcNBQgFAwcCAggCCwEHCAMNDQwIDQwHEBQKBgwGBAgEBAcFFxUCAQEBAwIDBAULFw0MFg0FCQULEwoFCgYSKBQKEQgHDwYIEgYIAQIKDucLAQELCgIKAwsDAgUKBwsNBQkFBAsICQIGBwIGGggDCAQEAwIBAgECAQQBBQEEDQgHAwwFBAsFCxULBwQQCwcRDwcIEQgMAwIHBAIDCAMIBAMKCAUDCgIBBQkDBQMLAQEDDwIJBAIHAgUHBQIHAgUHBQQJBQUIBQgPCAcJBQUHBQgDBgYCAgYCFQgPCQsJBg8IBAgDCQ8ICgYDDgQCBQEGAgIIAxUNBQgMAggFAgcCAgoGAgUIBQQIBQwECgEKAgIJBAIMDgsNBAcNmA4aCQUJAwQBBAECAQQBAQIBAQEBAwEBAQEEAQIBAQIBAQICAgYNBwYXBQEFBAMBAQQBAgEDAgECAQEBAgICAwK9BQEBAwQBAgEFAQECAwIFAgIDAgIEAgMCAgIMAgEBAgELAgwBAgsCAgMGAgcCAQUEAQMFAgQEAgUJBAMCBQgCBgUEBQQEBQEEAQEBBAICAgECBAEFAwEDAQMBAwEBAgEKAgECAQIEAgEBAQIDAgIDAgIDAgMGAwQEAgIDAgIBAwEBAgMHAwcDAwMCBwICAgIDBwMGAQECBAIKCQQLFAICAQEGAwICAgECAQMBBAEBAQICAgECBAEEAwEBAwIBAwcEBQIEAgAAAgAJAEsBpQHmAF0BHAAAJRYUFRQWBwYjBiYnIgYjJiYnJgYjIiYjIgYjJiMmBiMjBgYnJgYjJgYHBgYHIiYjIgYjBicmJicmJjc2NjMWNhcWFjMyNjMyFjMyNjMyFjc2NjcyNjcyNjM2FjM2Nic2NyYmJyYmJyYnJiInJiYnJiYnJiYnJjUmIicmJyYjJicmJicmIicmJjUmNic2JjcWMxYWFxYWFxYWFxYWFxYWFxYWFxYyFxYXFhcWFhcWFhcWFxYWFxYWFxYWFxYXFhcGBgcHBgYHBgYHBgYVBgYHBgYHBgcGBgcGFAcGBwYGBwYGBwYGBwYjBgYHBgYHBgYHBgYHBjQnJjY1JjYnJjQ3NiY3Njc2Njc3NjY3NjI3NjY3NjY3Njc2MzY2PwIBnAgBAgUIBwsFBQsGDBcNBQgFAwcCAggCCwEHCAMNDQwIDQwHEBQKBgwGBAgEBAcFFxUCAQEBAwIDBAULFw0MFg0FCQULEwoFCgYSKBQKEQgHDwYIEgYIAQIKDosMBwMNBAwOBQoBCwQCDAYCCggEBAgFCwkBAgsCCAQPAggNBQ0HAgEFAQQCAwMEEAMQDgYGBwQIDQcEBQQODggFCwULBQIHCAgIBAkFCg4ICgYFCQQEBwUPCAQNBAcDBw0DDAQEBAQEBAcGDAICAwcCAwgDCAILAg0DCBAIBw0IDwwGCgQQEwsECwMGCwQFCQMMAQMDBAIBAwIBAgMECggZBQwECgIKAQEHBQMKDAQUCAsBBgkCDxKYDhoJBQkDBAEEAQIBBAEBAgEBAQEDAQEBAQQBAgEBAgEBAgICBg0HBhcFAQUEAwEBBAECAQMCAQIBAQECAgIDArsCBAIFAgQFAgQBBQEFAQEEAgECAgEDAQIBAgEDBQEDAgIEAgITAw0JAwgEAgMHBwIEAQIDBgICAgIEBgMCAwEHAQMCAwUCBAEFBgMDBAICAgIEAgUDAgUCAgMFAQIDAgICAQIBBAEBBAEBAQECAQICBAECAQEEAgMGBAMGAwUHAgUICAUCAwIEBQMBBQICAgEJBgIIBQIHBgICCwECAgIKAgMCAwEEAQICAQQCAgYEBAMCAQYGAAAB//YAEQIHAsIB9wAAAQYGBwYGBwYHBiIHBgYHBiIVBgYHBgYHBgYHBgYHBgYHBgcGBgcGBgcGBgcGBgcGBgcGBwYWBxY2MxY2MxY3MzIWMxY2FxQGBwYGBwYjBiMGBgcGIgcGBgcWFhcyFjMyNjcyMjcyNjM2NhcWBgcGBgcGFhUUFhUWBhcWFhcWBhcWFhcWFhcWFhcWFhcWFxYWFxcWJhcmBiciJiMiBiMiJiMmIgcGBgcjIgYnNDM2Njc2Fjc2Njc2Njc2NzYmNzYmNzQ2NTQmNSY2NzQ2JwYGByImIyIGIyYmByYiNzY2NzY2NzY2MzY3NjI3NjY3JjY1IiYjBiYnJgYjIiYjIiYnJiYnNhY3Njc2Njc2MzYUMzY2NzYWNzYmJyY2JyY1JiYnJiYnJiYnJiYnJyYmJyYnJjUmJjUnJjUmJicmJicmJicmIicmJyYnNCY1JiYnJiYnJiYnJiYnNjI3NhYzFjYzMhYzFjYzMxYWNxY2NzIWNzI2MxY0MxYGFQYGBwYGBwYGBxQWFxYXFAYVFBYXFhYXFhYXFhcWFhcWFhcWFhUWFxYWFxYWFxYXNjc2NzY0NzY3NjY3NjY3NjY3NjY3NjQ3NjY3NjY3Njc2NicmJicmJicGJicmJicmJjU2Fjc2FjM2FjMWNjMWFhcWNjczFjIXMxY2MzIWMzI2AgcKBQMIDwgKBAYGAgsGAwMCAgQEBQQFAQUCBgQCAwcEBQQDBQQFAwIDAgEJCAUFCgUGAgECAQgNCwcCAgsIEwQJAw8OCQoEBg4IDAIDCAMGAwMIBAkTCgMDAgQIBQcGBAkSCAMHBA8NBgIHAhwwHgICAgEBAgEDAQECAQQCAgIEAgMKBAMJBAUFBAgCCgkHARcpFAQIBAIHAgQGBAsXCw0aDhIECQQKAgYDAgcCCAYECwoFCQIBAQEBAwICAgEBAQEBCxUKBAcEAwcCCA0HBwYBDgsHBgQCAwUDDQYMCQQDBgQBAwUMBwwHBAUIBQoSCggOCAMJAgMCAgcQFBYLCgEJAgQGBAcNBgkDAgEBAwUHAQEECQMDBwMJBgMGBgEBBQgGAwIHBgcDAQUBAgIEBAUCAQYDAwQFBwcCAgUCBQgFBQgBAwYFBgUCCA0GAwcDAwYDHAcPBgsYCwgOCAMGAwkCAwMFCgUHEQcNBgECAQQBAQUCAwIBAgECAwMDAgICBQIEAQkFBgEBBQEBDAoIAgQEBwEKBAIDAQQFBAMHAgMIAwUBAgUCAwQDBAIBBQIBBQIGCwQHDgUOCQQDCQEHAgUIBQQFAwUNBgYPBg4JBR8FDgcLBwQCBQkFBQoCuQkBAgQGBAQDBwIKBwYJAQUKBAUKAgUJBQoHBQUKBQYIBg0ICAgEBwECDw8HBw4IBQUFCgUCAgEBAQIBBAEBDAEBAQICBAEBAwEBAQMEAg4gDwECAQECAgICAwUCBhIDBAkDDAgDBQkFBQgFBQkEDAkEBAUDBREDAwQCAgMDAgIGCAEFAQIBAgEBAQICBQMCAwoCBAIBAQEDBgIGCgUJBQUOBwkRCQQFAwMGAwUMBgUJBQECAQICAQEDBQMJAgIBAQEBAQQCBAEBAgERFxEBAQIBAQEBAQEBAQMJAQEEAgcEAwIBAQECAQIBAgkNBwQMBQkCCAECBwcFCAgEDAUECgYDAQkJCAIHAQIKCQELAwIHBwMFBgUJAgcDBgMEAwQIAwICAwICAwICAwUCAQEDAgMCAQIBAgMDAgECAgMCAQsEAQEDAgIDAgcGBQMHAwgEAwYCBw8HDAICAwUEBQcJAwMCCQQJAgEPBwcDAQYDAQoFBAcCBgcCAg0IBQQCBQoFBAcFBgsHCQQCBQkFBQgGDQIDDQcEBQQCAwQBBQIEAQIBAwUFAQIBAQEDAQMCAQEBAgEBAQIBAQMAAAEACv85AiMB2AGEAAA3FBYVFAYXFB4CFRQWFxYGFxYWFxYUFxYUFRYWFwYmBwYGByYiByIGJyY2NTQmNTQ2NTY2NSY2NTQmNTYmNyY2NTQmNTQ+AjU2Jjc0NjcmNjc0NSY2NyY2NzY0NyY1NiYnNDYnJjYnJiY1JjQnJiYnJiYnJiYnIicmJjU2FjM2Njc2NjMWNjM2MjMyFhcGBgcGBwcGBgcGBgcGBgcGFBUGBhUWBxQWFQYGBxUWBhcWFhcWFhcWFxYjFhYXFjIXFhYzFhYzMjI3NjY3NjY3Njc3Njc2Njc2Njc2Jjc2Njc2NDc2NjU2JjUmNSY2NTQmNTQ2JyY1NiY1NiY1JjYnJiYnJiYnJiY1NhY3NjYzNjI3MxY2FwYGBwYGBwYHBgYHBhQHBhUGBwYGBwYWBwYGBwYXFhYXFhYXFhcWFhcWFhcWFxY2FxY2FwYmIyIiBwYmBwYGJyYmNSY2NSYmJzQnJiYnBgYHBgYHBgYHBgcGBgcGIgcGBgciJicmIicmJicmJyYmJyaIAQEBAQEBAQECAQIBAgMCAQMBAwEFEgoCBwIOCAQCBgQDAwEBAQEBAQIBAQQBAgEBAgEBAwIBAQEBAQEBAQECAgEBAgEBAQECAwEBAQEBAQYNCAMFAwMIAwUKAwYECgUNCAUGDQgJAQIFEAQdMxoDCgQGBAsGBwIIAgIDBAECAgIBAQIBAQEBAQEBAQICBwIDBQoBAgcDCAICCgEBCxUGAgcCBQ4FAgcCCAISBAQIBAIDAgEBAQIFAQIEAQEBAQICAQIBAQICAQEBAQECAQEGAgUBAgYJCBIKAwcDBAcEHgoVCQIBAQQCAgUFBQUCAQIGBgEDAQMCAgIBBQECAgEEAgQIBAYCBRIIBQwGCgwLBQQKCAEOGgsJEQgMBgILFw4DAgEBAQIBAgIDAgQBAgYGBQsNBQkGBQkHDAgFCA0ICBIHAwUDAgUDCQoIAwMGIgMGAwYLBggEAgQJCA8JCwsLBQwFBAgGCwgECA0IBwECAQEBAgIDAgUHBAQGBAIGAwUMCAgCAgUNBRMOCQoDAgIHAwkGAwUJBw4IDQkFBw0CCwYKEQoSLRIHEAgIBBMRCAULCRIWCwMFAwYOBQgGAwIBAgIEBAQCAwQDAgICAQEBAQIBAgUFAwIEBggIBwUKCAcKDgcFCwUFCQULCwgQCQcMBzMJEQoOCwQFBQUHBQoCAwIFAQYDBAsBBAQCAQQCBQIPAgcLBQMJAQEDCAQLBgQQEwgHCgkLAQEKAwcNBgcNBgsSCgYFCQICBwICBg4HBAUDCAIBCAoFBAIBAQIBAQEDAQkEAgMIAgsFDAsFAwcDCgMIBQkcDQgWCwsUDQgHBw4GFC0VCQQHCAUDBQIDAwMBAgUBBQsBAgIBAQIMAQwMBQQHBAMFBAgEBQsFAggEBQsGDQsHAwUCBgIDAQIEAQQCAQEBAwIDBQQCAgQAAgAf/+wCIgLHAVwCdwAAEyY0JzYmNzY2NzY2NzYWNzY2NzY2NzY2NzYyNzI2MxYWFxYyFxY2FzIWFzIXFhcWFhcWFxYWFxYWFxYXFhYXFhYXFhYXFjIXFhcWFhcWBhcWFhcWFh8DFgYVFgYVBgYHFgYHBgYHBgYHBgYHBgYHBgYHBgcGBgcGBgcGBgcGBwYGBwYHBgYHBgYHBgYHBgYHBgYHBgYHBgYHBgYHBiYHIgYjJgYjJiYnJiYnJgYnJyYmJyYmJyYmJyYmJyY0JyY2NSc0NjUmNjU0Jjc2Njc2Njc2Njc2Njc2Njc2Njc2Njc2Njc2Njc2Mjc3NjY3NjY3NjY3NjI3NjY3MjY3MjYzFxYWFxYWFxYXFhYXFhcWFhcXFjQ1NjY1JjY1JyY2JyYmJyYmJyYmJyYnJiI1JiYnJiYnJyYmJyYiJyYmJyYmJyYnJiMmIiciJgciByIGBwYHBgYHBhYHBgYHBgYBNjY3BgYHBgYHBgYHBgcGBiMiJiMjJiYnJicmJyYnJiYnJjYnJjY3NjY3Njc2Njc3NjY3NzY2NzYyNzIyFxYyFxYWFQYGBwYGBwcGBgcGBgcGBicmJjU2NhcWNhc2Njc2JyYmIyIGBwYGBwYGBwYUFxYXFhYXFhYXFhYXFhYXFjI3NjY3NjY3NjY3NjU2Njc2Jjc2NjU0JjU2JjUmJicmJicmJicmJicmJicmJyImIwYmIyYjIyIGBwYGBwYHBgYHBgYHBgYHBgYHBhQHBgYHBgYHBgYHBgcGFRQWFRYUFxYXFhYXFhYXFhcWMhcWFjcWFhcWFjM2FjcyNjc2Mjc2Njc2Njc2MzY3NjY3NjY3NjY3NjY3NjY3NjY3fgICAgECAgYDAwUDCgIBCwoDDQwJBAkDDwgIBQkDBQgFBQsGCwYDBQkFCAMPCgkDAgsDAwYDBQMEBAYECAIGBgIHBwQGAQECAQMBAgQBAQMCAQICAQMDAgEBAQIBAgYCBwICAQIFAgECAQICCAIDAwUIAwIIAgICAQUDAQcDAggFCQQDBQIJAQEHAwIECQUFCAQDBgMQFAsRHw4HBgUDBwQPEwoGBQUKBgQIAQEKCAsBBAQCBAQCBgcCAQEBAQIBAgMBAQEEAgIEAQQDAgQFAwIFAgQDAQUHBQUIBQQGAwUCAQgICQQFCAUFBgQCBwMWEAgHDQYEBwMLESEMCQYCBAYGCwUOAgQIAQcIAQEBAQICAQEBAwICAQIDBgMCBAUCBQUCBwICDwQGBAkFAgYGAgUDAg0DDgQEBwMHDQcECAQbBAcEAgkECQEBCQYFCxEBCAIDAQUDAgkNBg0HBAkHBwoGBwMCCwgLBgMIAwkBBAMEAQEBAQEFAwIEAwYCAwcEDAgFAgoGDQcFBgQHCgUFAgIEAgEBAQUGAgwCBAMCCAYFBwUECQIHAgUOBQIIAwsEAgUJDRUIBQcEAwICAwEBAwMDAQMDAgIGAwkFAgUICQ4YDgUJBQIJBAICBQICAgEBAgIDAQECAQUDAwIFAgUIBAYRCAMIBAYDCgIDCgELChkLBQoGDgcMCQUGDAYDCAMGBQICAgIHAgMEAwEDAQEBAQEBAQMBAwkCBQoEBgcIAgECBAQGEwkPBgQLAQIEBwQEBQUFCAQECAMIAQcECQYECgECAwcDAwYCAgMCAgMCAkYCCgIFCQUFCgUFCwIJAgIGCQIHBwQCBAIDAQIBAgEBAQQCAQIBAQMGBQMBCAICAQICAgMDBAIGAwYGAgsNBwsBDAEFCgYJAQINBwQFCQUVDh0MAwIMDQcNGQoJFAkHDAgLBgIFCwUGDQYIEAcNBQUOAgIGAgQHAgkDAgcECgIEAgIIAwEEBAIDBQMEBwQCAQIKBAIFBwEBAgEDAQEBAQEDAgIFAQEFCQMHAQcCBgYEEw8KBQoFBQQCIAMGAxEUCAMGAwQLBgUQAgcEAwUOBQIEAwcDAQYMAwUJBgQIAwcBCQYFAgIDAgIEAgIBCgIBAQECAQECBQQCAQIEAgYCBgICBQMcAQoFCQgFDQ0FEAYGAgUHBAUHBQwNCAoHDAEJAwIJBgISBAcDBQEFAQEEAgEGAQMCAQEBAgIFAQICBQIIAQEMEgoCAv5LAxAFAwQCBQkDBgYCAgICAgIBBQIECAYKBgUGCAQCBwMQEwgDBAMIBAQIBQwFAQEFAgEBAQECBQMKBwMCBgMPBQYMAgUCAQICAgQCBAEFBAIBAQkFBAICEg0HAgIEBAcFBgMECxYJCQcKAQIHAQECAwIJAQECAwURCAYMBQgLBgYGBQQGBQsGBQcDAwUDCQcDBAcEDQgC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CAcGCAYCBQICBAYDBAEFAwIEAgMBAQEC/vUCAwIEAQEBAgEEAgIIAgIPAg4PBwsHCAECBwIMEAUECgMDBwMGBQIOAwgCAgcBAQIEAgQBAQIBAQICAgUCBAkEAgYDCgcIBAcEDxEOFw0LBwMBCgUHCgMDaQUHBQgOBgQBAQIBAgICAQMCAgIBAgcQCAULBAECAQEBAgEBAQECAQMBAQEBAQECAgAAAwAj/+QC4wIIAg8CaALIAAAlBiYnBiYjBiMiJiciBiMiJgcGBiMiJiMiBiMiJgcGBgcGJgcGFBcWFhcWFhcWFhcWFhcWFxYWFxYyFxYWFxYWMzYWNzYyNzY2NzY2NzY2NzY1NjI1NjU0JjU0JjU2FxYWFxYWMxYWFxYGBwYHBgYHBgYHBgYHBgYHBiIHBgYHBiYjJiYnJiYnJiYjJiYnJiYnJiYnBwYGBwYGBwYHBgcGBgcGBiMGIgciBiMGJyImJyYjJiYnJiInJiYnJiYnJiYnJiYnJiYnJiYnJiY1JjY3NiY3NjY3NjY3NjY3NjI3NjY3NjI3NjY3NjYzNhY3NjY3MjI3NjI3NjY3NjY3NiY1NDYnNCYnJiYnJiYnIiYnJiYnJiYHIgYHBiIHBgcGBgcGBwYGBwYGBwYGBwYGFxYWFxYWFxYXFhYXFjIXFjY3NiI3NjY3NjY1JicmJgcGIgcGBgcWFhcGJicmNjc2Njc2FhcWFhcWFhcUBgcGBgcGBgcGBgcGBgciJiMjJiYnJicmJicmNicmJjc2Jjc2NDc2NDc2Njc2Njc2NzY0MzY2NzY2NzY2NzY2NzYWNzY3MhYXMhYXFhYzFxYWFxYWFxYWFxYXFhYXFhYXNjY3Njc2Njc2Njc2NzY3Njc2NzY2NzY2NzYyNzY2NzI3NjY3NjIzNhYzFhYXFhYXFhYXFhYXFhYXFhYXFhQXFhYXFBYVFAYnNCYnJiY1JicmJyYmIwYjBgYHBgYHBgYHBgYHBgYHBgYHBiIHBgcGFBUGBgcGBgcGFAcGFgcGBhcWNhcyFjcyNjMyFjM2FjMWNjMyNjc2MjcyNjM2Fjc0NgUGBgcGBwYiBwYGBwYGBwYHBiIHBgYnBgYHBgYHBgYHBhQHBgYVFhYVBhYVFhQXFhcWFBcWFxYWMzI2FzY2NzY2NzY2NzY2NzYWNzY2NzY2NzY2NyY0JyY0NSYmNSY2NwLeBQsGCxIHCAYFCAQIDggTNRgFCQUFCQQFBwUFDAUFCwUFDAYDAQECAgIEAgIBAgMJAwkFBQsFBQQEAwcFER8LCwgECwUCBAcDBgoFCAQFBgECBAEBCgIEBgQJAwIFCgYCBgICAgIHAgIBAgsOBAgLBwYDAgQPBwsVDRg4FwgGBQcJBQoSBgIEAgMHAggIAwIJFQsDCAUHAwoFDAQCBAcDAwYCCw0GCgUECAIGAgQHBQsWCQIEAgUBAgcDAgQCAgYBAgEDAgICAgEFAgcECAYCCQkEBgQCAgUDBgQCBQ4ICAIBBQgECBEJBQkFDAICDA8HCxgLAgECAQMFBgYCBAYDBgkFBQcFBA4IBQkFBQoFCAMODAYKAgsFAgYCAgMGBAQOAQEIBQIFAwYDAgoEAwUHCgkFBgEBBQcCAgMDBwUICAgHAgYCBQMPBQcPBxENBAYNCAgQCAUIAwQDAwECAgMCAwUIAgcEBw4HAwcEDggSCQgJDQIDBwEBBAYCAwIBBQEFAQgEBAoLAwoFCwEJCwUDBgQLDwYCBwIECAUECgcOBgQJBQsCAg8MCAULBwMFCAUDAwQFAwIDAQQBAQMBBQQCBAECCAECBgYDBQMFBgMKBAIFAwILCAQFCAQFAwYPBwgHBAgOCAsPCgIGAgwJAggDBQgKAwEBBQICAgNgBwQEAwYBCwIJDwULBgYKCAUJBQQFAwwGAwIHAwUDAgQCAQcBBgIDAQMFAwQBBQEBAwgCDRoMBQgEBQkFAwcDCwECBQQCCg8IBg8HAwcECBIIBf7NBAgGBAgIBQMFBwQDBwILAQgIAgsTCQULBAsKBQIGAQIBAQMBBAEBAQIHCAYCDAMFBwQIDAcHFAcECAMFCwUIAQIIAgECAwMGAwIFCwECAQQCAgEBAeYCBAEBAQICAQEDAgEDAQEBAQEDAQEBAgwZDgwZCw0HAwQIAwcLBwcIAQUCBAEBAQIBAgIBAQUBAgUCAwYECAgBCgEJAg0FBQwGAgYDCQUCBAIFAwIBAgcJBgoFBQgFAgUDEg8JBAoFBQECBQICAgECBQEBAwQGCxINAQYCBQ0FCAcFAwsYCwMGBgQCBgIFAwIBAwICAQEBAQMBAQIDEQcBBQIDAwIHBAIGCQUOBgYLCQMLGAsIDAYLDwgIBQILBQIFAQIEAgQBAgUDAgIBAQECBQIBBAEEAwQFDQcLHA4HDAYKFAcEAgICAwQGAgICAgIDAQQBAQECAQYFAgMCBwQCBgECAwYFBh4JBQwDAgICBgIBBAICAgIFBwkBBQ0DBA4CBgICBgMFAgQMBAUDBQ8BBhEZCwIJAQEGAgIBAgIHAgoQCAcIBQgHBQIDAgMIAQEBBgICBAUBAwgCAQYJCAYHAgkEAgoFAgwIBQ0HBwUGAwIFAwMCBgIDBAIBAgEBAQEBAgEBAgEDAwYGBgMGBQIEBwYDCAgYCwcQCQEIAgsBBAgEBwYCCgEEBggDBQYCBwMIAQIFAQgEAwMBAwEBAQMCAQIDCAYCBQIGDAUPEQUbKBQHDwcQEwwFBgQFCJAOHwwKAwEKAQUBBQECAgMBBQcDBAYCCAYDAwUDCgICCQEJAgkEAQMGAgYLBQYEAgcDAggPCgICAQMBAgEBAQECAQEBAQICAwQYNkADAwMCBgMCAgMCAgECBwEJAQcCBAMHAgYHBQMHBQMEBQUSBggNBwoFAwUNAhQMBwICBwECAgYBBQUDAgMCAgoEBAICBwEBAgQCBAMCBQsECgYDCAgECxcLFyQTAAAAAAQAHv/HAcoCRwBsALsBAgH5AAABBgYHBgcGBgcGBgcGBgcGBgcGBgcGBgcGBgcGBgcGBgcGBgcGFAcGBgcGBwYGBxYzFhYXFjIXFjMWFjc2Nhc2Njc2Njc2Njc2Njc2Njc2NzY2NzY2NTY2NzY0NzYmJyYnJiY1JiYnJiYnJiYnBzY2NzY2NzY3JicmJiMmBgcGFhYGByYmJyYmNzY3NhYXNjY3NjQ3JjQjJicmJicmJicmBiMiBgcGBgcGBwYUBwYWBxQGFRYWFxYWFxY2Nwc2NzY2NzY3NjY3NjY3Njc2NwYmJyYGJyYmJyYiJyYmJyYmJyYmJyYmJwYGBwYGBwYGBwYUFQYGFxQWFRYWFxYXFhQXFhYXFQYiIyYGByIGIiIjBgYnNjY3NjY3NjY3NjY3NjY3NjQ3NicmBicmJicmJyYmJyYmJyYmJyYmJyY2JycmJicmNCcmJicmNjc2Njc2NDc2Njc2Njc2Njc2Njc2Njc2NzY2NzY2NzY2FxY2MxYWFxYWMxY2MxYWFxYWFzc2NzY2NTY2NTY2NzY0NzcyNjIyMzY2FwYGBwYGBwYGBwYHBgYHBhYXFhYXFhYXFhYXFhYXFhYXFhYXFhYHFhQHBgYHBgYHBgYHBgYHBgYHBgYHBgYHBgYHBhQHBgYHBgcGBgcGBgcGBiMGJgciBiciJyYmJyYmJwYGBwcGBgFeAwUCBwQDBgMCBAICAwICBAIDBAMCBwICBAIDAgIGBQQCBQMFAgIDAgYBBAIBCQEDCQIEBgIGBQUNBQgMBwIKAgcDAQQIBAYEAgMFAgIEBAMBBAMEBQICAQUEAgcIAwIDBAMCBQIDBAJdAwcEAwUBAwMCAwMOBQYNAgECAgMGAwUDBQYBAQkTLAoCBwMBAgoBCwMECAMIDwUFBAQLBAMKAwEKBAcBBAEBAQIPBAYJBQ4TCV4DBAgRCAUDAgICBAQCAwQKBA0IBQQJAgIFAggCAQQCAgcLBAIBAgMFAwIFAgUGAwIDAQIBAwIFBQECBQEKAgkHAgQGAgMFAwEMDgwBAwgDBAUCAgECAgMCAgMCAwMCBAIBBQgCAQIDAgYDAwQDAgUCAgEBAwICBAEBBgIEAgEBAQMCAwUDAgEDBQEHBgQIAwMFBgICBAICBgIHAwkXCAcRCQ8KCQEKAQgFAgQKBQQGAwUJBQUMBggDAgMCAgIDAgECBAsBDQ8NAgQMAgICAQUHBQQCAgYDBQIBAQICAwgDAwICBQMCAgMCBAEBBQgDAgMDAQICAwMFBQICAgECBQICAgIGCAQCAgICBAIFAQQKBQMGAgoFCwwGBAcDAwwFBQcDAgoJEQgFCgYFAgILAwYBjQULBQ0MBwsHBwkFBQgFBAgFBgwGBQwFBQgCCQYECg4FBAsFCQYCBQgFCwYIBQIJAwUBBQEFAgMBAQcBBAUCBAUCBggFCgYEBgcCBAYIAgILAgIOCwUGDAYSDAkWEgsBAQsSCgUNBQoHBTcGDwgHBwMLAwcDAwQBAwcFDAwJAgIIBAcICxEHBAMLBg8HAwYCBQIDAQEDAgMGAQEBAgIEAwIGBggIAgYHBQUHBBEbCwQKBAkEBdIHBxAeEA0EBAcFCQoECQkTCgQCAQEBAQEEAgUBCAQCDRILCgMCCxcLBAcEChMKBQoFBg4IEy4UBxAEFRcIDAEIAwIFBQKzAQECAQEBAQMLBgQEBwUEBwQDBgMFCQQGBAIMBQYBAQIFAgQDAgYCAwUCAgYDBAUFBwYCFQoVDQMHAgcSCBkmEAgLBgoFAg4OCAsGAwgFBAMIAgIBAgYCCQ0IBAQCBQYBAQMBAgEBAgEBAQICAgMCDgkECAIC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NyYmJyYmJyYmByIGIyImBwYGByIHIgcGIgcWBhcWFhcWFBcWFhUWBhcWFxYWFxYWFxYWMxY2NzY2NzY2MzY2NzYmNzY2NzY2NzY2NzY2NzY2NTY2NzY2NzY3NjQ3FgYVFhYVFRYWFxYUFxYWFxYWFxYGFxYWFxYVFgcGJicmBicmMSYmJyYmIyYGJyYmJyYGByImByYGByIGIwYmIwYiBwYGBwYGBwYiIwYGBzQ2JwYUBwYGBwYGBwYGBwYGBwYGBwYGJyImIyIGIyImJyYmJyYnJgYnJiYnJiYnJiYnJiYnJiYnJicmJicmJyYmJyY0IyYmJyYmNSY0JyYmNSY0JyYmJyY1JjY1NCY1JjQnJiYnNiYnJjQ1NiY1NiY3NjQ3NTQ2NzQ3JjY3NjY3NjY3NjY3NjY3NjQ3NjY3NjY3NjY3NjY3NjY3NjY3NjY3NjY3Njc2Mjc2Njc2Njc2Mjc2NhcyMhcyFhcWFhcWFhcWFhcWFhc2JjUmNTYyMxYWFxY2FxY2FxY3FhYzFxYzFjYXMhYXMhYzMjYzMhYXFjIzMzI2NzIWNzI2MzYWNzY2NzY3NjY3NjY3BSYmJyYmJyYmJyYmJyYjJiYjBiYHBgYHBgYHBgYHBgcGBgcGBgcGIgcGBgcGFAcGIwYGBwYUBwYGBwYGBwYHBgcGBwYGBwYGBwYGBwYGBwYUBxQGFRQWFxYUFxYWFxYWFxYWFxYXFhYXFhQXFhQXFhYXFhYXFhYXFhYXFhcWFhcWFxYWFxYWFxY2MzY2NzY2NzYyNzY2NzY3Njc2NzY0NzYyNzY2NzY2NyY2NyY2NTQmNTQ2NSY2JzUmNjU0JjU1JiYnNCY1NDYnJiYnJiYnJiYnBAkIBwICBAQCAgIFAQICAwICAgICAwEFAQECBgIBAwMCBgEEBQEBAwICAwEDBAMCAwECAQMEAwUBAQIEAQkKBAoGAwYDBQgFAwgCAg0FBxAGCg8KAwgDBgYCFQkUJhEFAQIBAQEBAgEBAQECAQECBQcFAwkFCxgOESEQBQsFBQgECwICBwEBAQUCAQQCBgIFDAcJBwQVBQwFCQUCBwUBAgQCAwgNEQkEBQQMAwIJBAQDBwMEBQIKEAgGDgIEAgIEBQoHBAkCAQUFAw0LBgkOBwYNBggPCAECAQIEAQIBAwECAQECAwECAQICCgIIBwQECQUEBAoEBgQFCgICBAIKAwMDAgIEAgYBAgoCAgcCBg8ICA8FBQwDAgYBAQEBAQIBAgILCwsFCwkGAwgHBQEKAgsCAwUEBgUFEQYLBAEEBwQGAwECCAUEBgcLDA4FDAUFDAUFCwcHBAcEEhEGAgIBAQIBAQIBAgIBAgIHDx0OChMLCBULCRIIDRYLDAQCCxcLBwECBQICBAMEAQYCBAIBAQMCAgICBwIDAwEFCgQBAwECAQECAwEBAgECBAIDAQQCAgMBCQEGBQsFDBEdDgYMBRAlCwQHBQoVCwsSBwkTCQoBAQUMBQUIBQYMBwwHBAUMBQ4dDwEBCAIHEQkDBgQEBgQFCAUJDwYLGxMDBgQDBgIDBQMJCQUMCgcCAgIIBAYIBQgFAwMHAgwJBQYDBQcFCAUGBAIFAQQFBAUCAgIFAwQBAgMCBQECAgEBAQEDAgIBAQEBAwECAQEDAQUCAwECAQIEBAEEAgIFAQIFAQYEAgYEAgUKBQYKBQUGBQgXDgUJBQQGBAkGAgkFBQcFCBAJAgYFCBQLBw8IBAkFBgwFDAoFBAMCCgoGAwEGAgYDAwUDCwkFCwsFDQsHBAIQDAIGDgcLFwsDBgMDBgQCBwQKGQsjDQcDBQgEBAgECBAGChELBwQLEwkECAT9zAkIBQIFAwIIBAQHBAUKBQYECwwGAwgEBAYFCBMFBQcDBgQDBgIIAQEFCQQIAQUBBwICBwECAgIEAgEDAgEEAgECAwECAgEFAwIBAQEBAQIBAQECAgMBAwUBAgMCAgECAwECAgICAgcEAwQCBgMCAwQCEg0FBQQGCQMFAwMFAwkUCwsXDgIIAgcCAQYEAgMEBgMHBAYBBAMBAwMCDg4HAgIBAQIBAgIBAQECAQEDAQEBAgEFAgIEAgQIAgMSBA8FAwgGBAUIBAcFAwMMBQQFAwUKBQ0PCA4aDgULBRUYCQIJAQEIAgQHBAgEAg0RBQQJAgcEBgwHCwYCBQoFDAgFAgIBAwEBAQEDAQEBAQEDAgEDAQEBAgMECQgOIBAECAULFw0HDQcGDQYWLRcCAgMCAQEBAQECAgEEAgECAQkCAggCAgYEDQcDBwYIBwcFAgcCBQsCAQMBAQYCBQECBwUEBgoEBwUCBgIBAQECBQMJAwIBAQICAQQCChgOBAYFBgkECAQBBwEBBAEDAgEBAQMCAwMECwICBgMFCQkFDgUICQUECAMEBwQF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CQUFCQUKGQsQCQQCCAICBQICBwcFCwIGBgMHAgICAQEBAQEBBAECAgMBAgIEDQUSFQcLDQEBDwgFBQMPBwgIBQQHAgQCAQECAgEBAQEBBAIBAgIGAQIEAgQCAgcDBAQCBwkDAgsLBgcTBwcDBQkFAgUDBAgEBAYCBwwFCBgKCwEKBQICAwIHAwICBQEBAgIBAgIBAQYGAwYEAgEHAQIGCAQJBQsUEQgPCAQGAgcBAQIJAgMGAgIDAQUCBwIJBAcMBQMEBQgHAwoFBQkBAQIBAQIFBwIMCwYFAgULCggEBAIFAQQBAQIBBwoFAgkKBwQQCwQGBgEBAQEEAwEBAQECAQECBwEIBQQIBAUIBQkECQcFEQoFCQoECQEDBQQDBQMBBQICAwICBQMCAQIBBAICAQMGAgQFAgIJAwUIDh8QCwEBFhEHBwUMEQUJBgoEAgoMBQwaDgEDAwECAgECAQQBAgEBAgICAQIBAgIHAwUCAQICAwIFAgMKBRcHAgIBAQIBAgMCAQECBQEBCwMGBgMDBgIDCwQJCwYFCwYFCQUGDAUDBwMOBAoGCgYCBQkFDQYEBAgFAgUDCwQEAwcEAgMCAgQBAQEBAgEBAQECBQUKBgUGBRMTCwUIBAoVCRAMDQgEAgQJBQgQCA4NBQ0HCwQCAgQBAgIBAwEFAQUDAgINAwUCDAoFCQUNCwgRJw4QDggFCgUFCQUIEAgHDgcHCwcFAQEDAgIGCAQCAQICAQQBAQIBAQEPFwwJDwoIAwoBBBAGCw0GCwgIDwkCCAQGBAMGBAYDAwYDCQEICAUFCAYCAwIDAgICAwEBBAEEAQMCAgcGCAIKBgMCBQIODAUFDAUSAhIEBQsGBQ0FEBAIDAcBAgwDCAUCBgIGCgUCBgQDAQIHAQEDBwUECgQEDwgEDAcMAwwGBAYEAgECAgEDBgUECQQEBgQDBwIFAwMCCAwHDwcCCgMJBgQHBAURBgkCAgcIAgEEAgIIBAoNBAMHAw4HBQgOCAUJBQUJBQQIAwkOCAYCAgECBgEBAwIBBwoEBwcFDAYFBggIAQEMCAIHCgkSCwUHBQIPAwoDCA4JDhUMAwEBAgECAgECAgEBAgIBAgEBAgQFBAUKBQUKDiMRCBAICA0IBQsGCBUJCRMIBQoFCQECBQICBAIDBQMAAf////EB8gLJAbcAAAEWFhcWFxYGFRUUFgcU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ADIAMAAxADIAIABiAHkAIABGAG8AbgB0ACAARABpAG4AZQByACwAIABJAG4AYwAgAEQAQgBBACAATgBlAGEAcABvAGwAaQB0AGEAbgAgACgAZABpAG4AZQByAEAAZgBvAG4AdABkAGkAbgBlAHIALgBjAG8AbQApACAAdwBpAHQAaAAgAFIAZQBzAGUAdgBlAGQAIABGAG8AbgB0ACAATgBhAG0AZQAgACIARwByAGkAZgBmAHkAIgBHAHIAaQBmAGYAeQBSAGUAZwB1AGwAYQByAEYAbwBuAHQARABpAG4AZQByACwASQBuAGMARABCAEEATgBlAGEAcABvAGwAaQB0AGEAbgA6ACAARwByAGkAZgBmAHkAOgAgADIAMAAxADIAVgBlAHIAcwBpAG8AbgAgADEALgAwADAAMABHAHIAaQBmAGYAeQAtAFIAZQBnAHUAbABhAHIARwByAGkAZgBmAHkAIABpAHMAIABhACAAdAByAGEAZABlAG0AYQByAGsAIABvAGYAIABGAG8AbgB0ACAARABpAG4AZQByACwAIABJAG4AYwAgAEQAQgBBACAATgBlAGEAcABvAGwAaQB0AGEAbgAuAEYAbwBuAHQAIABEAGkAbgBlAHIALAAgAEkAbgBjACAARABCAEEAIABOAGUAYQBwAG8AbABpAHQAYQBuAFMAcQB1AGkAZABoAHQAdABwADoALwAvAHcAdwB3AC4AZgBvAG4AdABiAHIAbwBzAC4AYwBvAG0ALwBmAG8AdQBuAGQAcgBpAGUAcwAvAG4AZQBhAHAAbwBsAGkAdABhAG4AaAB0AHQAcAA6AC8ALwB3AHcAdwAuAHMAcQB1AGkAZABhAHIAdAAuAGMAbwBtAFQAaABpAHMAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlACAAaQBzACAAbABpAGMAZQBuAHMAZQBkACAAdQBuAGQAZQByACAAdABoAGUAIABTAEkATAAgAE8AcABlAG4AIABGAG8AbgB0ACAATABpAGMAZQBuAHMAZQAsAA0AVgBlAHIAcwBpAG8AbgAgADEALgAxAC4AIABUAGgAaQBzACAAbABpAGMAZQBuAHMAZQAgAGkAcwAgAGEAdgBhAGkAbABhAGIAbABlACAAdwBpAHQAaAAgAGEAIABGAEEAUQAgAGEAdAA6AA0AaAB0AHQAcAA6AC8ALwBzAGMAcgBpAHAAdABzAC4AcwBpAGwALgBvAHIAZwAvAE8ARgBMAGgAdAB0AHAAOgAvAC8AcwBjAHIAaQBwAHQAcwAuAHMAaQBsAC4AbwByAGcALwBPAEYATAACAAAAAAAA/7MAMwAAAAAAAAAAAAAAAAAAAAAAAAAAAQIAAADpAOoA4gDjAOQA5QDrAOwA7QDuAOYA5wD0APUA8QD2APMA8gDoAO8A8AADAAQABQAGAAcACAAJAAoACwAMAA0ADgAPABAAEQASABMAFAAVABYAFwAYABkAGgAbABwAHQAeAB8AIAAhACIAIwAkACUAJgAnACgAKQAqACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADoAOwA8AD0APgA/AEAAQQBCAEMARABFAEYARwBIAEkASgBLAEwATQBOAE8AUABRAFIAUwBUAFUAVgBXAFgAWQBaAFsAXABdAF4AXwBgAGEAYgBjAGQAZQBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQByAHMAdAB1AHYAdwB4AHkAegB7AHwAfQB+AH8AgACBAIIAgwCEAIUAhgCHAIgAiQCKAIsAjACNAI4AjwCQAJEAkwCUAJUAlgCXAJgAnQCeAKAAoQCiAKMApACmAKcAqQCqAKsBAgCtAK4ArwCwALEAsgCzALQAtQC2ALcAuAC5ALoAuwC8AQMAvgC/AMAAwQDCAQQAxADFAMYAxwDIAMkAygDLAMwAzQDOAM8A0ADRANMA1ADVANYA1wDYANkBBQDbANwA3QDeAN8A4ADhAL0BBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoHdW5pMDBBMARFdXJvDnBlcmlvZGNlbnRlcmVkBm1hY3JvbglzZnRoeXBoZW4IZG90bGVzc2oCSUoCaWoEaGJhcgZJdGlsZGUGaXRpbGRlC0pjaXJjdW1mbGV4C2pjaXJjdW1mbGV4C2NvbW1hYWNjZW50DGtjb21tYWFjY2VudAxrZ3JlZW5sYW5kaWMMUmNvbW1hYWNjZW50DHJjb21tYWFjY2VudARMZG90Cmxkb3RhY2NlbnQGTmFjdXRlBm5hY3V0ZQZSYWN1dGUGUmNhcm9uBnJjYXJvbgABAAH//wAP"

/***/ }),

/***/ "./node_modules/base64-loader/index.js!./node_modules/scratch-render-fonts/src/Knewave.ttf":
/*!****************************************************************************************!*\
  !*** ./node_modules/base64-loader!./node_modules/scratch-render-fonts/src/Knewave.ttf ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "AAEAAAANAIAAAwBQRkZUTXHtxcEAAK5cAAAAHE9TLzKEKKb2AAABWAAAAGBjbWFw7NujXwAABQwAAAIqZ2FzcP//AAMAAK5UAAAACGdseWY+O5L/AAAI5AAAnSxoZWFk+ta4swAAANwAAAA2aGhlYQZ2AcUAAAEUAAAAJGhtdHjAjxGEAAABuAAAA1RrZXJuCK4GkQAAphAAAAGSbG9jYXytpEgAAAc4AAABrG1heHABHgCuAAABOAAAACBuYW1lwbSE0AAAp6QAAATRcG9zdPMzPkEAAKx4AAAB2QABAAAAAgAAT7CXrF8PPPUACwPoAAAAAMw585wAAAAAzDmBJP74/o0ESwSBAAAACAACAAAAAAAAAAEAAAMw/rcAAAPa/vj+XgRLAAEAAAAAAAAAAAAAAAAAAADVAAEAAADVAKsABwAAAAAAAgAAAAEAAQAAAEAAAAAAAAAAAwIhAZAABQAEAooCWAAAAEsCigJYAAABXgAyAUEAAAIACAYAAAACAAMAAAADAAAAAAAAAAAAAAAAcHlycwBAAA0iEgMw/rcAAAPoAAAAAAABAAAAAAIXAx8AAAAgAAEBOAAAAAAAAAFNAAAAAAAAAakAAAGpAAABfP/3AdQBBgNLAB4CWQAFA9oAUALSABYBBAEZARcADgG1/24COACbAfsAKgEq//ACVgBsAPX/+gJB/7kCpwAwAZr//wIr//ACX///AnAAKgJl//YCUAASAi7//wKc//8CZQBqAV0AQwFdAEsCRAAmAkEAGALzAD0CRABhAzkADAI+/98CU//7AkcAKQJcAAcCFgAEAbL/4gKJAAwCVv/PAXn/7gI7//ECTf/jAd3//wK9/+cCgP/rArEAKgJo/+QC3gBFAlD/7AIy/+4CAAA/ArcANgINAFQDDwA4AmL/2wH1//8COwAHAiL/wAJBAKICK//kAiUAeQNL/64BJADIAiIADAIcAAIBxwAXAigABAHsAAsBvgAwAij/rQJZ//gBS//wAXD++AHm/+oBMP/yAwn/4QKW/+8CFgAeAlb/jQJK//EBl//3AgT/3wG+ACUCaAAPAgcAIQLPAAEB3f/uAg4AJgIQ//cCBAAxAa8ADQJQAA4B2gBDAXwAKgH1AAwCTf/dAfX/yQH+AMgDbQBTAucAOQPXADAB2gB7AUsAwgD1ADMBnf/KAU0AlwMMAAwCRAATAj7/3wI+/98CPv/fAj7/3wI+/98CPv/fA1f/3QJH/9gCFgAEAhYABAIWAAQCFgAEAV3/7gFd/+4BXf/uAV3/7gKl/8wCgP/rAokAKgKJACoCiQAqAokAKgKJACoCfQAWAokAKQKJADYCiQA2AokANgKJADYB9f//A0v/4gLS//kCIgAMAiIADAI7AAwCKAAMAiIADAIQAAwDMAAKAbj/sgHUAAsB1AALAdQACwHUAAsBLf/3AS3/9gEt//YBLf/2AqUAEQKM/+8CCgAeAgoAHgIKAB4CCgAeAgoAHgJ3ADUCCgAcAmgADwJoAA8CaAAPAmgADwJNACYCHP9gAk0AJgPLACkDRQAcAkr/7gIW/98B9f//AjsABQIQ//gBzgASAbgAegG4AOACDQB7APUAggHgAHsB1/+/AYsAfgHUAQgCdwA1AvAANAD5AGIA+QCCASr/8gHUAGQB2gDfAccABAGU/+4BQv+uAbIAcQLM//kBtQBBAeYADQJB/7kCjP+LAjIArAJWAGwAAAADAAAAAwAAABwAAQAAAAABJAADAAEAAAAcAAQBCAAAAD4AIAAEAB4AAAANAH4AowClAKkAqwCuALAAtAC4ALsA/wFTAWEBeAF+AZICxwLdIBQgGiAeICIgJiA6IEQgrCEiIhL//wAAAAAADQAgAKEApQCoAKsArgCwALQAtwC6AL8BUgFgAXgBfQGSAsYC2CATIBggHCAgICYgOSBEIKwhIiIS//8AA//3/+X/w//C/8D/v/+9/7z/uf+3/7b/s/9h/1X/P/87/yj99f3l4LDgreCs4KvgqOCW4I3gJt+x3sIAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBgAAAwAAAAAAAAABAgAAAAQAAAAAAAAAAAAAAAAAAAABAAAFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiYwB3eHp8hImPlJOVl5aYmpybnZ6gn6GipKalp6morayur8tsZWYAzQCSa2nTbWgAeYsAAAAAZwAAAAAAAABwAJmrcmQAALoAAGpxzgBzdoiztMPEyMnFxqoAsrfR0s/QAADMbsfKAHV9dH57gIGCf4aHAIWNjowAu8EAvb6/b8LAvAAAAAAAAAAAAAAAAAAAAAAAWACeAV4B4AKYAxwDQgN4A7IEIASYBNIFCAUuBW4FzAYWBnAGygc2B6QH+ghECK4JCAk+CYwJ0gocCnYK2AtiC7gMKAyEDNANNg2MDeYOWg6KDsoPNg+GD/gQTBCOEN4RThGwEgYSShKWEtITOBOwFAAUVhSsFPAVShWSFcoV8BZAFpoW1Bc6F4gX2hhEGKYY6Bk0GZ4Z3BpMGqYa7htQG6Ab1BwaHH4cxh0KHWodvB4aHmAe0B8OH4IfviAUIIIhBiGIIbwiaCL4I+4kKCRKJHIkxiUMJXol2iZOJr4nSifgKGIo8CmGKhoqniseK7osTCycLOYtTC2oLgouni8AL1wv1DBWMMQxIDGKMfYyXjLiM1wzxjQ6NL41LjWYNiA2sDcuN7Y4MDisORg5gDoEOn46zjsYO3472jxgPPo9Yj3EPkI+yj9AP5Q/+kBiQMRBREG6QjJCqEMyQ7pEOETERUBFukZSRtRHMkdwR6xH6kgGSEZImkjiSR5JSkmCSaxJ1EoKSl5KuEsES2pL4EwMTFRMnkzmTTBN6k5kTpYAAv/3/4oCWwMxACYANwAAAQcWFxYGBwYHBgc1BgcOAgc1BwYjIiY3PgI3Njc+ATc2MzIHFAEjDgEjIiYnJjY3NjMyFgcUAkwBAwQFAQcVECUGSFQZEiYSAhg/JzQLDywbIjAFJI0rIiA5A/6FARJPKyQzAQEpHi4lJzIBAugDEAQDBgcgFC8LAWuxNCU7EgEBIx8ZM2gzPlgKQ7oRDiUS/OIoKiAdHzEIDBYXDAAAAAACAQYB3wLMAywAFQArAAABFT4BMzIWBwYHDgIPAQYjIjc2NzYHNyY3PgEzMhYXDgIHBgc1BwYjIiYCCglFKCAsAgIHBBwVFxsYJS0MBAQB9gEKAgReMRomBAIQFgMRBTEYIxQVAsABNDkqJBYTGDQbHB8iOhkyH38DIiZOcTEuDiEjBykIATkgHAAAAAIAHv/rA84DFQB9AIMAAAEWNzYXFh0BFgcOASciJiMiBiIGIyInBwYjIiY3NTY3JiMiBwYrAQcGBwYjIjc2NwcGBwYmNzQ3PgI/ATY3BiMiJzMmNyM2PwE2Nz4BMzIWBwYHNwc3Njc2NxU+ATMyFxYHBgcGBx8BFhcWFxYHFgcOAQciIwcGJwYHBgcyJQc2PwICyg4UHQkDFQECOSoGGQYHGQwXBxUeLxsZFBgEBQYSDxAgEB0kFSYOGyAnBA0WHggUEBQBKwwTCREfDCgcHDIYARcsAUlRFCgYHVkqJjACAg8BP10MARYGGXc8FhAlAQIUCSkhDh8PAg0SFw0CASYcAQEBFrERBhEKJf7rSWIuFxsBNQQCAgoDFREVGCArBAEBAQJiFxgYARweAgIBHzEtGCUrPAYEAQERDRoeCgkDAwcnbAQOFiAkEyxjKy41KiMaHwFcGRoCIxoBPz4ECR8TFyU6BAQKDwQIDyIcHR4vCAECDhgHEhVNgRcIMTcAAAEABf87AzADnQBaAAABPgEzMhYHBgc1DgEHFzIeAx8BIxYVFA4BBxUGBw4DBwYeAw4CDwEOAQ8BDgEjIic0NjU3LgE3PgE7ATIWMzI3IzY3NC4DNzQ3PgQ/AT4BAhMWXy4jLQECBwQpIh8JERQLFQEJAQ0YJQ0FRyFjPDACASAuLh8EMHRNGgYPAyEOQR0cDQEZPjwCA0E+HgQRBSgbAWsBJjc1JAMJDzo7UTMgDQQFA2AbIhcVEAwCBD8eBQUNBxEBCA0JBw4dFgs/EAYCARwfDSAiJzlAWWUaHwYYBCsiMh4CBgGBCEQuNSkBCBsPBBQhLkwuGR0xUDAnEAg1EQ0AAAAAAwBQ/6wESwNFAFkAbwB9AAAlNycHBg8CMwYjIicmNz4BNzY3Nj8BJwYjIiYnNT4BNzM3MjM2MzIXFgcWFxU/ATY3NicmNz4BMzIWBzcOAg8CFzYzMhcWDgEHBgcGJyImIy4BJzY3NDclNzY3ByIHIgYjDwIOBBYXFjYBBwYHFQYVBhcyNjcHBgH2CQYokC4ZFAEuKiQHFAIBOyoOERY+lwQsKjJMBwWEVgMDAwE7JB8bNQ4RAx0pQhMFCAUBGWAyNDgPAR9iT0JJDgYbF0dFKQZOMjVyEA4CCwI+QwcCDwcBOgMEBSoECgIRAwoDEQ0NHQ4MBgsdYf6wAiArAQQHL08KFhSsEgcliiYSFR0bBRMZUCQKExwyfgkUOy4hYnQNARYNGCsYIRogK0cSBREMAScsLisBMmtFNz0MCAk8KGxzJCMRAwMCDDE1IBkCDQkHBhUMAgMHAgkIChYSFhUJF1EBiQEfDQMCARINNS4GBQADABb/kAMnAyEAPQBMAFgAAAUXNjMyFw4BIyIuAScGIyInLgE3NjcjPgI3PgE3NjMyFgcOAQcUBhUGHgEXPgIzMhcyNjIWFQYHBgcWFyUnDgIVBhYzMjYzLgIBNiYjIgYHFBc+AgJ2BxgJCwEEbS0ZHRUHgGIKDFZWBAMhARlhTzwGe1M8UTpKAwOGhwIBCRADCSMdFAcFCiQeFwQVP0MDD/7dChYVEQEiGgYhEQMUEAEuAgwJGFEFBBA6KQoDBgcYSh0vCE8CDUpAM0otXjoof7srJDI1PbFRAwwDHDlCFAgpFAQYCggRHGs6BSfSAxYWHQ0ZGwMKIzABzgkKTiMRCxAiJwAAAAABARkCBwHyA0IAFQAAARU+ATMyFgcUBw4CDwEGIyI3Njc2ATEJRSggKwIJAxsVFxwZJCsLAwQBAtUBNDopJBMYFzMbHCEhORA6HwAAAQAO/2ICqwNEACEAADc+BDMyFzYzMhYHBgcOAgcGBwYXFhUOAQciLgE3NiMkYWFiTRsRDC4/IC4BAiRyoo0qEgMCBgMCGCAnLw0DA8t5zYReKA02GRIXFEiW45E9PDA4GxIWEwNDYD5DAAAAAf9u/1ICIQNNACQAAAczPgM3PgEzMhYHFAcGBwYHBgIHDgYmJwYjIiY3Nl4BWpZiPw4MUywlLwMDAg0GAxqxZxQcKyEoIB8YCB4aExUBBEg7t9PVakFQNjMOEBAxGguE/rVyFh8vHyQTDgMKEhUQKQAAAAABAJsA1gNwA1kASAAAASM2MzIeAQcOAQcGBxYXFgcGIyInJicPAQYVBgcGIyImNzY/AQcuATc2PwEnJicmNz4BMzIXNjMyFhc2NzYzMhYHBgc1Bgc2NwLKAQ8fGTQsAwRXK6MyXjcCAQMZIiQoNwgIAxMNJDIrPAUEJAo9HjgCBIIWHDwCOAYCFAsFCB86KUMIS1wXHhIXAwEIMhorLQKyAQgaExYqBycXY1gJAxEaGisUFAkBRg4kMSUfMxgOARQRGzoLChUBESkPFgk8MClyZRsUEQ0MAUw8EgcAAQAqAJMCdQLKAE0AAAEHDgIHBgcGIyImNzY3PgE/AScmIyYnJi8BJicmNzQ3NjIeARcWFzY3Jjc+ARc2FgcXHgIVBgcGBwYHMjYzNjcjNhYHBgcGDwEiBwYBcAIdLRgTDBEeFhwjAQISBAwCDgUFAgYCBwYQJRIMATUIEhErFAogPxkCBBtUKCQuDwkBBAMRPC8JAgkBDQFVEwEeOAECKxpSQAEDFgFMAkRHEQUCCAwfGxchCBcDGgEBBAcEDwkTDxALFRICAwYCAwJtOAkWHiUCBRgcDAIHBQEeRTYMCAwBCAMDFRAQEwIWEAEHAAAAA//w/1UBBABkAB0AHwAjAAA3NhYXFhUUBwYHBiMiJyY3NTY3FTcnIycXJyY1PgEPATcnFCOKJUERAwIPN01DIRYFDAUkCwgBEgECBQJINAUIAQJgBCQiBg4JDiwnSxYPFgEMKAEOChIEBw4PJSuDAgIBAQABAGwA+AKSAa8AIAAAJSIGLgI3Nj8BNjcjNjMyFzYzNhYHBgc3Bgc1BgcGIyIBGgQxLDAdAQI+FB58ARhDKhUSFTJFAQItAQoUHA1Laxr6AgEGFBAaFwJBEAIBBQIiHSAkAQQKAQwEGAAAAAAB//r/jADYAEMAFAAAFyMmNz4BNzYXMhcUFxYVDgEHBi8BIgEnAwFVLBseAgIFFwJEKR8YD20UISNJCgUIAQICFx4iPwwIBAIAAAAAAf+5/zEDOgNLACUAAAE2Nz4BNzMeARcGBwYHFgcGBwYHBgcCBzUGIyImNzY3PgI3NjcB9jsfAjw2BjA4CAMlBQIFIDtaChZMoeFmCwwVIgECGS52VUiBOwKJVCIYKgoDHScWJQQCHyIwYgwYU8b+7mUBDCYcIR9LpW1anlEAAAACADD/qAMBAx8AKQA7AAABPgEzMhceAQcGBzYzMgcOAQcOAicGBwYPAgYVBwYjIiYnJjc2Nz4BNw4BBzIzNzY3Njc2JwcmBwYHAScjkUIlHRsLAwMBIxRMBQRPNyl2Wg8TEhMaBQECIAk0JEIMEQMBDiZg/j50CgEFBHNcQAICDAUFChcfAp8xTw0NDAsMDw19U9JLS4dEAwMGBQEEAQEBCRkdGjs8KDicyhdb/mABhqh3PBgMBgcBFikAAAH///+QAj8DHAAtAAABMhYXBgceAQcUDwEOAQ8BDgEPAQYHFQYjIiY3ND4BPwEVNjcuATc+Ajc+AgHuIy0BByEBCwEDMwtEEBYLYxMSLyYcNRolAQgPAg9PbScqAQEsRgsWVkoDHCMhGC0GIQsHCUkRYxslE6MiJ2Q4AicYFQsaIAYrAdHkBiYUGiIdCA9VMAAAAAAB//D/nwLuAycAPQAAASMOASMiJjc2NxU+ATMyFgcOAwcGDwE2MzIWBw4BBw4BIyI3NDY1NCY3Nj8BPgE3PgY3DgMBpgEOWjAnLwEBDFSqcUpwBAImSDUqO6smORdKRAECLiAYnVKfAwcQAQJlIwpdGQpHIDwhJxQDFCIOEgIiHyYbGg4YAXN9UT8kU1k7KjyFHQUaHCBRFRQaKQUUBAkfDSteHwlXFQk8HTopNzQbExwKFQAB////rwLvAyUAOgAAEyY3Njc+AjcOAiMiNzY3PgE/ATY3MhYHBgcGDwEeAQcGBw4BIyImNz4BMzIXMhYzMjc+ATc2KwEi9BoCAj4QeFgQIk4uDS8DAisOJRkhaD40RgMDNS9gIDUwAgVgOOBiRUUCAUEgCwsLLAguTCJMAQIkEEkBHggVKDAPWlMkCBcNOTQJAywFDCcBQjZBUDg8FAY6LWV7R1EsKCVEBgUjD0oYGQAAAAACACr/kALXAysAPABHAAAFDgEjIic0NjUuATc+AT8BByIGJyImNzY3PgE3NjMyFwcWFQ4CDwEOAQcWMzI2MzIHDgQHBg8BBgcTJwYHFDMyNjc+AQFtFD0hOBUOBiwBAzcWFiQJJwovOgIBU3WlfCc0UggDDwEhKwYlCBwJBAcROAYIAgIRIR04EgI0JhMLBAe/BAwJSRQMShEvMDgELQMGDAsFehsoAgUBPiUoVniQUhs7CQ0UETI1ClERQRMBEBcuNRUEAQMGbVIqEQHlBpcWChUEH3QAAAAB//b/uQLzAwgATAAAAT4BMzIWBxQGFQYWFQ4CIyImIwYPAhc+ATMyHgIHBgcOASMiLgE3PgEzMhYzMjY3PgI1NiMiBiMiJicmPgE3JjU0PgE3JjU+AQGoF8YtHiMBAQECCEtOKAosDhsuLB0IDU8sLkEgDQECOD/maDRRPAICNC4PSxEnRCYBDwwCIBF7HhgxChFGeRECCA4CAQJNAvMBFAcIAQYBBRQFKjUQBCM1MzAFEBQbLi8ZL2ZxfBExJiIzDigxAxcYCiEoFw8ZfaYhAgIEDBADAgYmJAAAAgAS/7YCywMZACgANwAAASM2MzIWBxQHNQYVBhYVBgc1Bg8BNQYHFzYzMhYHFAcOAQcuATc2NxIDFzY3NiY1NDcmIyIGBwYCVgESDhomAQIGASACLBMxGIKGB0FGNEsECTbFdlxaBAMjtwgwXQIBEAYIBCViAgIDFAUSDQIGAQwDDBoHEBcBBhcMATu5BzJWPxoYjJUCB1tMPGABl/3DAlQlCxkHCQgCZisWAAH///+hAxIDFwAvAAABNy4BLwEiJjU+ATc+Az8BNjMyFwcWBwYHMw4CBw4FIyImNz4BNzYSNwGxISmbHBENEQNFMDJlMWIGEC8JLAcOOgMCIgFMq8dAByUNHhQeECMzAQE3BjP0TAInIgMCAQQUDiJLAwMMCBEBAgcqHRMrHSJDyftIByYMGQkIGx0TOgk5AXJOAAAD////owMfAykAIwAwAEQAAAEyHgIXMj4BMzIWBwYHHgEHDgMHBiMiNzY3IzcmNz4BMwM2NTYnBw4BBwYWMzITJyYjIgYHBhcVNjc2NzY1NicuAQJhERYhFgUECgcBJSAGFd4dGgYMSlxYIUQpwBgWqQFNOwsO3G/HBgUeHhg3AwIxHinGAwQRGkoGBAsRETomBQEGAQYDKQMLHBcCAUEwm4MYVyw6aEQrBQiynF4pXkZopf1kDgofOgoLMRAZJQH3BBJQLBwUEA8LKC4HBAUWAwsAAAIAav+qAukDGgAsADkAAAUHDgEjIiY3NDcVNzY3BicuATc2Nz4BFzIWMx4FBxQHBhYXFgcUBwYCEzY0JzUmBgcUFxY2NwFLARZJIx4lARANaExKJjxBAwMjRuVxAgsDFRgsGhwNAQgIBAsQAQY52kAKEjJrAxQdUxsfARkdGBkTHgEPiFMSBghVPjo+faELAQICBwkNFA0KEBcNCw4UCBak/rYB5A4aBQIGaysZBQo4PgAAAAIAQwBNAc4CAgASACEAAAE1DgEjIiY3Nj8BFTYzMhYHFA8BFQ4BIyI3Njc2MzIWBwYBuRZRKyo1AQIJAy5iLDsBDn4QajVPBQRCRzgaIAECAZkBGx4dHBETBgE/IBsRE98EMkEnJS4xEREMAAIASwAKAdACDQARADIAAAE3DgEjIiY3NDcVPgEyFgcGDwEXHgEVBwYHBiMiJjc0PgM/AQYjIi8BMyY3PgEzMhYBugEWUiorNQIPFk9WOwECC34BChMCBUJPQxQoAQYMCRMFFwgFCQgJAQUBAlY0Fh0BowEbHh4dDRsBHyEhHBQPuAEEFQkkJzJLEhMECxAMFgYdAwwLFAonKgwAAAEAJgA6AvwCXgAsAAABNzYzMhYHFAcGBzUGDwEGFQYeARcVDgEHLgQnPgE3NCc+AjcHPgMCXBEYDCRHAg4DQlefbQEBRnEgAScXD2lrclMMARYBBQUsTAgBI4ZQcwJWBAQqHg4TLSMBJzQkAgQQMEQdBhclBAUSFydGLgQhCgoIFCMnBQEQQSUtAAAAAgAYAJICoAIaABwAMQAANyMGIyImNz4FNz4BMzIWBw4IEzY3HgEHDgErASImIwYjIiY3PgE3agEGCSAiAgEbNjNXNjAleRAdHgEBFSgvQjtPO07vhE8tLwECSz4dBRUELoI+SQEBTUuTAR8WFSEVDQkDAgILFhEUIhgSDAcFAwQBZx0CBSEVHSwBNB0aHycQAAAAAAEAPQBBAzwCegA5AAABNycuAScuBjc2Nwc2NyM2MzIXIxcWBw4BBxQHBgc3Bgc1BgciBiMGBAcnJjc0NzYlPgI3AfBALgc1DgUdERsQEAgBAlgBCCsBJBs7KwEKwAQBGQYBAhABFSguawIEAjz+nUUDBAEqOgEVBQUHAwEiECAFJQkDEgsSDxISCTE5AQMRCi0Inj8LGA0GBBweAR0WAQ8RAQlVAwsQCQwpNUUBAQIBAAAAAAIAYf+dAt0DPwAvAD8AAAEWFQ4EBw4BIyIuATc+Az8BDgEHDgEHNQYjIiY3PgE3PgEzMhYHDgEHHgEBDgEjIiY3PgMzMhYHBgLcAQJCW1tDAwNVJxAPAQECTV1YCQIFQSkOHRAwGRgwAgI0HD+vRDNNAgELAQEP/kYcSyEZHgEBHysfCyAyAQICfwcNLWdaUUIRJDURDw8sfm14JBIDOhkJFwgBFCglJmAVMEQlJwsxCgYf/WYoKRkXHSkRBxgSCgAAAAACAAz/oAPEAwwAUgBcAAAlJjcGIyImNzY3PgEzMhcWFRQHMwYVFBcWBwYHBhUGFz4BNzYmIyIHDgEHDgEHBhYXHgEVBhUGFhUOASMiJjc2Ejc+ATMyFxYHDgEHDgEjIiY3NicXNjcjNyYnIgYBvgQEMCAyNAIFUDijNioRAQMBCA0LAQIgKgEpPT4EBE1CHi9NeFQhQgMCOD8fFAIBDwFYOVd8BAbEh1rCWHNNLwYEamkrdTQpMAECXQcpRQEkCgkrVIMOFCExLElfPGEhAQIFBA4HDAUXHDYdLRMVExhwOU1pDxlVVyN+NjBCCAQQDQoGCCAGFiJVV3UBSmxJTEIoZlvfcS8zIR8KYwUSQSAMAkwAAAAC/9//uALNAwQAKgAzAAABNzYzMhYHFAcWFwYCDwEGBwYjIiY3NDY/AQ4BDwEOAQcGIyImNz4BNxI3Awc3Nj8BJwcGAggZMBciMwETHgYkjCoKCwQhMB0xARoEDhQoEhMULghYTBcjAQIyE+z2kFNeIxgdCDUQAuUKFR0YDxcQI17+b2oWHgoeFxQJQRQvBRMMDAsFBnseHSFsIAGCxP51igNwQ1MEPh4AAAAAA//7/8AC+gMNACYAOQBKAAAXIiYnBiMiJjc2NyY1NDcSNz4BMzIXMx4BBw4BBxYfARYOAyMiJzYzNz4FNzYmIyIGDwEGEzMOAQc3PgM3NiYnBiMizRULCygrJS8BAw8BA5SeMoNAPy4CITMCA4laAyAYGAQ7Xo5LCg8VGAcHHB4hGhMBARUTDT0TFx/yASEiFjsbIzEbAQEZEQgNGzELARstJiEZAgUGCAGPqzc6HBVVKkKMNAMRDg5SaWFCYgIBAgcMExkkFRIPDAExQwHnHTg3FQkPGyMUChQJBwAAAAABACn/xQMSAvwAPgAAJTMGIyImNzYSNjc2MzIXIx4BBwYHDgEjIiY3NDY3NiMGDwEOAgcOAhYzMjYzMhYHDgEVBhYVFA4FAb8Bc2NZaAUHjbZRV1ILFgFBPwIFLhZVJhoYAQ0BARUYChATFiwbNzsEKhodQhgTJwEBDAEZBAkIDQkPAj1TYIMBC7AdKQIJRDZATiQqFRQGJAwdAgUICg4mHjx9SicnDhEIIQcJDwUECQkICgYLAAAAAgAH/7MC0AMBABwAMAAAAQ4BIyInBiMiJjc1PgI3PgQ3NjMyFxYHBgEHNzY3IzY3NiYnDgIPAg4CApo7+3MQFyU7KDsCFk+GEQENCA4QCTBOcW8wBQP+Nw44lzABIQMCLTIQGBYHLSkDCAwBPH7WBDk8KghnvO8jBCUVIBgJLIg7UkT+5jEeUWI6MSo8JRoyNA5ZXw4WHwABAAT/tgLjAwYARAAAATMeAQcOAQcOAQ8BBg8BFjI2MzIVFAcGBzMOBAcOAQcGMzI3FhUUBhUGFxYVDgEHMwYjIiMGNzQ3NhI3PgE3NjMyAq8BGhkCAlc6OjASBiUQDBMkQAoRBCpKAQ0TBw0VFRg+AQFcGkIOBAIVAgFIKAFbRgMHqAQCHIB0DBoXwGcRAwIBGRQqVwkOFRYHKyYaCAkKAghWGAMEAwICAR1gExAIBg0CDwQRCgIEEUAOFwJEAwaTAQOmEWYLRQAAAAAB/+L/xQK/AwcAOQAANwcOASMiJjc0NzYSNz4BNz4CNz4BMzIWBw4BBzMGIyImIyIHBgc3MzIWBwYHDgQPAQYHDgKQAQ89IB0kAQkRyhkxLR8bNSIdEW4VHyACAmI+ASgUEAsBChUnM2gFFhgBAhQTDwcWSEAmMgQCCAwHAR8iGxkIFiwBoj1hPhAODwQCARIgGC9xFgwMK0YrCBsSFgkIFBARDwZGUgkCFR8AAQAM/78DGwL8ADsAAAEWBwYHDgEjIiY3JyYjIgYHBgcGFjMyNj8BJwYjBicuAjU+ATMyBw4BBw4DIyImNzYSNz4BNzYzMgL3JAMDIhJBIhceAQUPGzauIyIBAz4oNm0OAwUWEhYdBhcLAoZCagUCMR8aQ2aBQW9dBQWZa0dqVyUwUwLRI0E3QiIjEg4WFoxCQhkoKkEZBAgLARsFCwsIKTVQKGQhGzdAKFtacQEeYD08FgoAAf/P/64DRgMSAE4AACUPAgYHDgEjIiY3NDc+Bj8BPgEzMgcUBzMGBzIWMzI2MzIXNzQ3FTY3Njc2Nx4BBwYPAQIDDgMHNQ4BIiY3Njc+ATcPAQ4BARcKTBccCA5DIx4lAQYZLjMgOhZECB4NdjU2AwoBRl0CCAEUTRYOBwoCTRUpNBkjHCMBAgkfsXkKGhQZCAwxMiABAgYVhAMdEQ4/6w2ALzgMGh0YFgUSPWxqQ2oneQ41LkEkCRZ+lQERARICAgGyJEcSCQEBFBMPEDj+v/7SGRoEDhABDxMUFQ0OP+0HBwgHFQAAAAH/7v/QAjsDCgAbAAABIwYCBw4DIyI3Njc2EjY3PgI3NjMyFgcGAigBV9QZDS00IRBWAgEiHIVxJxYvKRAXKhUbAQICqqn+bDAkMRIGKxhCMQD/zDcfFBAaJRcWFQAAAAH/8f+fAysDGgApAAABPgE3PgEzMhYHBgcOBwcGIyImNz4BMzIXDgEHFjMyPwEjNzYBuh1TDhlsLh4iAQIOE0YuSz1XUmg2GTdCQQMDUDshBgMPAgcIDBgLAQhyAZo3vx4uPhwcFSIljFyIXm5LQhIMND48ZhsQRxEKEgcGgQAAAf/j/7EC5gMfAEYAAAE2MzIXPgEzMhYHBg8BDgIHNQcGBzUHFz4CMzIfARYHDgEHDgEHFx4BHwEWFQ4BIy4CJw8BBgcGIyImNzY/ATY3PgIBQRMXBwkVNEEoMwECCxcHDhEGFVQLBQUkeVwVCxoJDwIBEw5OlVgBMUMGBwcBJSMUWl4cHhErIBsjGykKBkEPMVoLLiICyB8DIRoVGRQSGgcTHggBHnQQAQYIElE4DQQEIhc0DFJPEwsFdz0yKgoTGAJYVwEsHUwjEBEROIoebr4YbUMAAAAAAf///8YCVwL9ADYAADc0JzMmNTYSNzY3Bz4BMzIWBwYHNQ4CBwYVBhcyNjMyFxQGBwYWFQYHBiMiBiMiJisBBiMiJgsKAQMBuk1WBQEObzIhJgECAh5xrDkBAQMRZBkUFAEBASECECxiCigMCUAYDwgRHiIFFxYICSEBUW6DCQEfMBobEAcBS6vrWgICBAUaCgIGAQ8mDREXPwICARoAAAL/5//NA3EDBQBJAEwAAAEyFxYOAQcUBwYHFz4CNyM2MzIWBxQHAgMOASMiJjc+ATU/AT4HNycOAg8BBiMiNS4DNScOASMiJjc2Ez4BNzYXJxQB1CMcBAIIDwEDJQgxP2guASQuHCEBAZCHDkIkHSQBAQESAQEEBgcICQgKBAofKRMTCiAGIwQGAgEJQFhKHykBBLceXCU2nAIC6g8UFAwODAZAWQU+TGQbExgZCgX+TP7/Gx8VEwEGAUUCAgoNERMVFRYKBCIiCQYDBAsQEQMLDgOXZRkXQAFxPI0lThADAwAAAAH/6//WA00C6AA1AAATMz4BMzIXFgcGBxc+ATc+ATMyFgcUBwYUBgcGAgYHBiMGJy4BNicOAg8BDgEjIiY3NDc2Es0BJXAzFxMbBQIDCAlkER92MhUaAQgIDBYqlHcWQyEIHRgJCwoqOBUQERFHIRMXAQcXiwH2TYMPf1AxFwIQmCU6Qw4MBQ4IKDsdOf7r1QkiAQQCg4AiVWIdEhMeIg4MCQtTATwAAAIAKv+yAxQDCwAaACUAAAE2MzIXNjMyFxQfARYHBgIHBiMiJjc2NxU+AQM2EjcADwEWFzc2AYFJTR4aJSlAJAcECAIGeEymq2tiBAeLJG4XVYYM/vkyAwkcEhcCwTMKIT0CHBchJ2b+/2PVelOP4AE2fP2oVAEgev7xpRM+DQ0QAAAAAAL/5P+tAwcDGQAlADMAAAEOASMiJwYHNQYjIiY3NDcVNjc+ATc+ATc+BjMyFgcOAQUXPgI3NDY1Bg8BDgECfC2COj0lLxs6ZSs5AgJwYCcfIklANgYkDB0PFxQLQU8EBFH+uAU8VSUDAT4pDg01ASI5RixhWgFoKCUDCgHxnEEtKlw9HQMTBg4ECAJaS03EMwcNYHNAAggCVEMXF1MAAAADAEX/XwOBA0IALQAvAEgAAAEGBxcUFhUGBw4BFRQWBw4BIyInIi8BBiMiJjc2Nz4CNzYzMhc3NjMyFgcOAQMvARU2NzYnBiMiJwYHDgEHBhcmNz4BMzIXNgLXR1kKAQM1AQMIAQEqHCUTAwwQMCVXfgUDHhlVhklhPA4GFiRLVE8FBFzaAShmBgIEOjwSBy0jNnMDAzkCAQNHLisdIgEDYEkQAgcCMRkCBgEPMA0fIiE7Lg5oXTpTWKuXGy0BBi5eVljZ/uwCygGdcx4bIgIjKTvARD8aIw80MhgsAAAAAAL/7P/JAv8DDAApAD8AABcGIyImPwE2GgE3PgEzMhYHDgIHFzUeAgcOASMiJicGIyIuAicGBwEHDgIPARc3PgI3NDY3NCYjIgczpxRKJjcBAwWi2EAmlhRBPwIEWZpWCwY4GwEBMhcKGQwSDhoiDhcOOgsBJQQPEwsEMAYfKB8qEhUBDA0XHQEGMR4ZDDMBPAE8IhEiRztIpowXFwELZEQbGicYBQUvPUsTaBUCEQMXHhQGWwUUFBEuJQgjCgkRHwAAAAAB/+7/xQMDAwoAOgAAFyMiJjc+ATMyFjMyNzY3NicuATc0Nz4BNzYzMhceBR8BFgcOAQcGByYjIgYHBh4CBw4EmA5GVgICMCMTWRQWD2ECASoyMwMIGmk+dF0cLwcPCQ4GDwIJDwIBLRsCYyIMOjIDASUtJAICH0NahjtBLyI4EgYfJRgmLlE0FB1Wdh43BwEFBQoEDgEIExIYJQI6DQIoNxArKEcoHUtWRy8AAQA//7EC/wMPACsAABcGIyImNzY3Njc+ATc2NwYjIiY3PgE3PgEzMhYHBgcOAwcOAQ8BDgPqKzQjKQECEyAqMh83CQUSCSAnAQInKzz8VRwuAQIcDhcPIBcPPwUzE1s4Rw9AGxsZJkpjdEBkEQkCGxgjMh8iQyQVFBAIKSchAwgGCV4kqGd7AAEANv/QA3YDFQAyAAABMhYHDgIHBjMyEjc+AzMyFzYzMhYHFQ4BAgcOASMiJjc0NyMOASMiJjc+Azc2AakZIgIBWWIJAg8eyWERDiAfEQ4QICYXGgEDaKE4CE8pHxgCAgoFZSZRXQQDLE88LD8C/ycaGZm9QRcBC5EbFigRCCAZGAgUx/63lCQvGh4GDCQnWE47jpxoSHQAAQBU/9EDHQL9ACQAAAEVFgcGBxY7ATY/ATYzMhYHBgcGAA8BDgIjIiY3NhI3PgEzMgFYCgUFGAoRBS6mFSdCKEMCAzJM/uw7BxYiOBw7KQIXUg8FQiAjAtUCH0FseBNQ5h4tJCgoLFz+gkoJHSMfLB5zAcxQHCcAAQA4/9QEBwMQAEQAAAEGDwEzDgEHDgMHBiMiJi8BBwYHMyMiJzYTNxU+ATMyFgcUBw4BBw4BBwYzMjc2NzYzMhYHBhQHFxIzMhYzNjc2MzIEBwMFCQEeYw0daUNqNi06HCwICi5TJwEMTQcWVyIcUiUSFwECCBkFARABAgcFBiY8FxgkLgIBAQiiIwIHAxQPPzxVAsIJBw8hlxIpnWKAMisbGEckSQQ2vwEQawFMShUQBAoyZyAFPQsLBTdAEUYsAw0DAwE1AQMLKwAAAf/b/68DYQMfAFIAACUnDgIHNwYjIicXJjc+ATc+Bz8BNjcuATc2NyY1PgEzMh4EFBUXNyY1PgEzMhYHFAc3DgEHNQ4BBx4BBxQHBiYHFhUOASMiJyYBNwkWSToiAS4qFRUBGAIBJAwCAwQICxMYJhY2RAwRDAMCCwEBWCIJDQgFAgECigIDjkEnNAIIASTdBg9EEwMqAwIKLgUBAR8VEhE1jAIYYD4UARYGAQ0hHEAKAQMECgwXGywZM0EJRE0uL0ICBh5GDRwbKhssB0CSCgUxUx0dCxUBNMYGAQ1QEynjPAsUFAEMAgULDgYtAAAAAf///6cC4gMNADMAAAEXFhc/ATY3BzYzMhYHDgIHDgIHFzIeARUUBzMGIyImNzY3Nj8BBiMiNzQ3Njc+ATMyAY0DBAkJLGs/ARccFx0BAj9vCRyPWCkIAgYEDgE/VC9CAQIFG2RYAgQcBAQOEgdYJSICthciYwk1gykBChMWJGJ+DCa7gkwGCxIIDQ44JRsMCTWHdgEtChafUCpOAAAAAAEAB/+3AuADFQA6AAAlFzIWBw4CIyIuBDc+Aj8BPgE/ATY3BiMiLgI3PgIzMhcjFhcHFx4DBxQHDgQHFAFxbx4bAQNsmFUfFjkZIQ0BARUTJQ1D5TkFDBo3KxkjMBgBAniYQhkMARkMBBAOCBIFAQIPV2ZjQgGBDBQTMUcfAQQLEyEXHC4YKw9M0DwGDSoLAwsdFixLJQEHEBcEBAINGBMGDj2KdGZMEAsAAAAB/8D/SALcA1gANwAAAQcGDwEGBwYCBzYzMhYHBgcmIyIGIyIuATc2NzYSNzY3PgEzMh4BNzI2MzIWBw4DIwcGBzcHAhMZMBIRDyYfaR4wMS48AgRdFhwonCEbICIBAzUh3zEjBQtZKRM3JQIHMAsjJwEBER4VESYzCAEUArsNTCkuJ1ZI/uxFBy4bNxoDFQMXFiwZVgINjWcHHx4LCwECEyATGQoCAwMIARIAAQCi/v8B2AOBACsAAAEVHgEfARYSBxYVDgEjIicmAi8BLgQnMyY1NjcmNz4BMzIWBxQHFBYVAYoDBAEEBD4CAQI9HxgDJUgRCgIKBgsMCAEEAg4JAQE4JDFUAQUCAwIBE04JNzr97JwIDis2EIACE1IrCTAYJyEQCRIVEh8RIyQ1IQgKAwgBAAH/5P86AvwDbwA9AAABPwE0PwEGIyInLgg1NjcHNjsBMjYzMhYHBgcGHwEVAgMGBzUOAgc1BiMiJzMmNT4CPwE2NwHAEiQDAhsdKCsIHhAYDREICQMCOQFHWSgicxYhIgECBQETEp7bDQgOERwPQ3J2EwEDATdBHBwsTgIsMl8CBg0FBQEDAgMDBQcIDAcfKwEYCREWDw4KDg4B/tb+KBsZASUoKQcBGScIBhQcCgMEMqoAAAEAeQGRAnYDZQAuAAABMwYjIiYiBiMiJjc2NzY3PgI/ATYzMhcnFgcUBxUHFhcWBwYHIic0NjcmLwEGAVsBOC4DCQQIAio5AQEUmYUCBAYCAj40MhMBAwEcAg4CDwEEQDsNBgECGg42Ae4dAQEkHRIelVgCAwQBASsjAQgHFBcIDktlSB1BDB8HGwkYPSA5AAH/rv9RAyAAGwAiAAAlIx4BBw4BBw4BIyInIyIEBy4BNz4BNyY1PgEzMh4BFTYzMgLuARccAgIuKg07EgYOiUD+8IMkKAEBNCoCAik3KHJQMiV3AwYoGRstCQIOAgkDBxwPFSwQDgUcGAYHAgIAAAABAMgCmwGaA3gAFQAAEzc+ATMyFwYHDgEjIi8BJjUnLgEnFcgBAkErVA8IDAgXHxQSAwgJDTMDAyMBKSs0D0AzJwoMAwQSEzgFAQAAAgAM/9ECVQHlACIAMwAAARYXFhUUMzYzMgcGAgcOASMiJj8BJw4BIyImNz4BNz4BMzIDMj4HPwEOAQcGFgHPQgoCCg4BHwIIWwQDMyAcJgEDCBNnQENHBAItITnZSAflCRISDRAJEAUQAQ9HcQQBHgHjDRUGBwoCQTH+5Q0YGxMQCgUbJTE5KoAxSoX+ZgUOCxkNIAojAiAcTx4PGwAAAAIAAv/OAksDLgAyAD0AABczBiMiJjc2NzYSNjMyFz4BMhYHFA4EDwEGBxc3NjMyFgcOAiMiJxQOBjcGBz4CNzYmIyJtAQcLKy8CAg83kpQpBA0MJigaAQYFDAYRAhdHRAYNQEQzNAIDX48/LjAFBQ0HEgYWkhcKFjZHAwELCx8xASkjHBmWATThBRseIBoJEw0WCRkDInN4BQcnLy5Grn8xBwwJCgUIAgjAKzIUNVQTDRsAAAEAF//KAjAB7QAkAAABFgcOAQcOAgcGBwYVBhYzMjYzMhYHFAcOASMiJjc+AzMyAfs1AgIsFwgbFBNpOAIBKCIEEQMcHgEPKIlCN0YDBEpynlAaAeoFLh02ARATBQMNeQYEFyUBEg8NDzE1UEVEjnNJAAAAAgAE/8YDFQMdADQAQwAAATc2MzIWBzY/AT4BNzYyFgcGFQYWFRQHBgIGBw4BIyIuAzUmNTQ+ATUOASMiJjc+AwMXFjMyNj8CJiMiBgcGARsBHCMcKAEQESIhYiIcPCoBAwESAiqegxgHQyYHExIPCQYCAhoqHkZOAwIpRGoMAgkLEhYVFwcPDiE3AgIBlwEQIBobKUtJrBwPHxMSAQsfBwQEXv775FMaJQMFBgUCBQYCDBIHHxkrNh1hamH+ywIEHSgsEwlDJBEAAAAAAgAL/8kCJwHpACoAMwAAJRUOAQceATMyNjMyFx4DOwEyHgIHDgEjIiY3PgE3PgEzMgcGBzUOASc2IyIGBzMyNgFsDXcmARkMElsUFRIDBQYEBAEBBQUDAQKjWl5MAwRCL0iOYG4FAgsfQVABEyE6FQQmV5EBBhgDERMgEAoLBAEEBg0JJzFCPzuINVBXYRsnAU9FfglBME8AAAAAAQAw/58C3wMRADUAABc1PgE3LgInIyImNz4BNyM3Nj8BPgEzMgcOASMiJw4BBzY3FgcGBw4BDwEOAgcGIyImNzY4A0YDAhgJDwQMDgEBIB4BcB9mETGJNnYDAjQgFwYDWCoVMwgBAiEbMTUcElhDCygsGB8BAhYCGfENAgwWCREMEyQKIlV/FTdBYSIxGx5qGwQCBw0mFyAZDQYivokEMh4WDQAC/63+vQJQAc4ANwBGAAABHgIXPgE3HgIGFQYCDwEOASMiJxcnJjc+ATMyFjMyPwE+AzcnBiMiJiMuATc+ATc+ATMyAzc2JiMiBgcGFjMyPgIBuAwMCgQIMhAUEgIFBW4tFESwXy4oAQg6AgIhGAguEB0yFRowLhkUCC1SBB4OLCkDAzQpNYI7IS0BARwKJWQBAQ4JHjMaJgHFBRMjCQweAQITECcGUP7xRR5ldgsBBB8rGCkSFwoMJzkiHgYsAQFFNzh+MD5B/voDCAxhFwkJGx0zAAH/+P/QAnQDKQA/AAABBw4BBzY3FTcjNjMyFgcGBwYHFBcGIyImLwE2JjU2Nw4BBw4BIgczBwYjIiY3Njc2Ej8BJjU+ATMyFhcGBwYHAX8UAyIGGBcTAUhCJUQCAh8hAwILMyI9CAYBAQITOk0lDQsVDQEJLSknNgECBT7IQzgBAkwuICwBFlUZRwGWJQdHEREXARQ/OyYgSktCGxA3LBUNDS8IKTAbPzwhDwgDHC8iDQybAWJQRAYKJCoYFSmHKI4AAAAC//D/ogIEAs4AGQAnAAATNT4BMhYHFAc1AgcOAwcGIyImNzY3NhIBDgEiJjc+ATc2MzIeAdsNP0ApAQGSJBMmGR4JDCIbJgEBDhOQAWACRkgmAQEzLRYCGh0GAbEBFxkYFQYEAf7obTEvAQQMFCEfFR5EARYBMSAwGhQWLAwCEhEAAAAC/vj+4AInAtUAJAAwAAA3Njc2NzYzMhUGFgcCBwYjIiY3PgEzMhc1HgIfATY/ATY3NjcTPgEzMhYHDgEjIiaPLR4oOhwhGwEiAv+wMjlEXQIBNiQPIAsIBQIRCggXGSdAHvYBRyQhLgICPCEkOMVnKDYcFA4bFx395EsWPS4aSg8BCBAYBg8CBxcjQ2xCAegiOzAgJzArAAH/6v+tAjcDNQBFAAABNjIWBwYVBxcWBx0BDgIHPwE2MzIWFQYHMwcOAQcUFyMWFxYXFgcOASMiJxUmJwc3BiMiNzQ+AT8BJjc2NzY3PgE3PgEBYx1QOgEBEQkOAQE6aSYlLkYYGSoUdwEYUCQCBgEIGj4SDAEBIiATGjpISAEVMDkCECQSAhkCAhwXHA1HDRdoAxkcNycCBB8NFAoFAg9MhToICg8gGhxHDTYaCAcDBgocGBETGSkKASBmlAEgOgofSi4IEiUiHgcMIo0gNssAAAAAAf/y/7UCLQMuACcAABcOASMiNzQuAjc0PwESEzQ+BDMyFxQGFQYWBxQHNwIDDgOVGDwUFwELDgwBCSCswAwLFRQdDw0PAQEfAQIBoJIMHxAZHRMbFgoKAQgJBxZMAYoA/wEQDhQOCgQBBQENLg8DBgH++f7MGUkgJQAAAAH/4f+8A0sCBABMAAATNz4BMhYXNjMyFzY3FhcjFgcGAgcGIyImIyIHBiMiJjc0NzY3Jw4BDwEGIyInFSY3NjcHDgEHNQ4EIyImNzQ3NhI3PgQzMtsHBi04KgNZPSYUQkFDHgEeAgNtJQ4PBA8DDAUWKB8tAQk1aAgXawgNM0EnCgMBAhsDITUlBRQXJjwnICwBAhKGFgcSCgwMBgIBsgMSFh4eQSI0EAIbICRG/uE6EQQQFyEaDQ92swUXjQoRVCQBEAYfTQMWREABBikjJhcMDgIEMgEPOA0hFBQJAAAAAf/v/7sC1wHiAD4AABM2MzIXNjMyBxQHPgEzMhYHBgc1BgcGIyImNzQ/AT4INTQjIg4DBw4BJgYHDgEjIi4CNzYSviYLAwclFyECAiqsQjozAwRDChllaxYcAQY6BREIDQcJBQUDEA8qOipNEAsRCAkEBz8lCxsgFgEDsAGELwUOLAsIJj82MU56AQ8qnw4OBAxrCR8PGQ0UCw4KBRQeRDRoFQ4MAQgLERUECBIMMwFKAAAAAgAe/8UCTgHlABwAMAAAEzYzMhYzNjMyNjMyFgcOAQcGByIjIi4DNz4BFycGKwEOAgcUHgM6ATMyPgHhDxEGFAciPQknCE5HBARrUkNeAgUjJ0AhGAIEfM4GGhAGAkYwAgEEBAkEDQMrQBwBqggDMgROQ1PHQS8EAg4aNida3aMFBwM5PR0FCAQDATtLAAAAAv+N/rIClgH5AC4APwAAARc+ATMyFgcGBw4GBwYjIicOAwcGIyImNz4BNzY3IzY3Iz4BNzY3Nhc2BwYPAQ4BBzMOAQcWFz4BASsYMG9KOjADAxMPEiciNzhNKiQgPQkKKxkoEygmIB8CASY0JwEBKw4BCCkMPRkcvQJ7AQETAwsEAQccBgkFQnIBnAY3LEI0Mi8lK1A1RzIwEA01E1QyQxkVLBkdVWBIAkceEU8YdhwYeS6AAQEgBhIHCzEMCRAxhgAAAAL/8f68AqIB1wAoADMAABM+ATMyFzYzMhYHBhUGAgc2MzIWBw4BBzMGIyImNz4BPwEGIyImNz4BFzY3DgEHBgcGMzLHN4gyOgVSFBgtAQNIri4yGRAPAQJfNwEgFDlKAgMXGhQXZj8yAwV5eEojRjslDwECHBsBfyQwMjYnFwUCif7WaBUPDSZuFwk7KzE8KCEkMjRnyfEmcQggNBoUFwAB//f/vgIOAgUAHwAAEzc+ATMyBxQHPgEzMhUUBxYHDgEHBgMOASMiJjc+AoI5FkAcGQIGH3MdEQkZAgI5MWpvEWAqGRwBATNSASF+JSgaBhIZMg0IDgUcHTsMIP7kKDsYGBlzngAAAAH/3/+kAjMB+QAtAAAFBiMiJjc+ATMyFjMyNjsBMjcmJy4CNzY3PgEzMhYHDgEHDgMHFgcGBwYHAWNef0ZhAgEXEAIJAhMdDCKXDw0mHB8ZAQINCdNnLx4CAS8oJigGCgptBAMZAkkZQzYtFBoBMyYQEg0WLB8fFkFmJh0ZLAsHCQUHA1ZXLDAfLgAAAQAl/6sCZgM/AD8AAAEjBg8BBg8BNjceAwcOAQ8BBg8BBgIHDgIHLgE3Njc2NyIGBy4BNzY3Iz4BPwE2Mzc2Nz4CNzYzMhYHFAJgARgURwsFEignBSEUEgECIRcZUhkIDMgnBwwUBx4yAQICK3AhHA4PEwECMwEtJyAPBA8NP0IODiIVChAaLgEC4i4dag0EEQkEAQMDEA4WKQEGEwEHFf56MwkHBgMDGBIKBZP1DAECGBIoFgsRCAQDIJ5IFgoJDA0qHQwAAAABAA//0wLvAfcALwAANzY3NjMyFgcGBwYHPgI/AjY7ATI2MzIWBxQHBgIHNQYjIiY3NDcnBiMiJjc2NRMaqyorHykBAg1CTzZcKyoxKQ4qDRQ6CxclAgQwphMwSSEqAQgGY1A2RwICQ6TPISIaFRVLqh5RNDdDMxoRHxIIB0r+tyEBMRkUCwsGRzMxBgUAAAABACH/vQKXAhcAKgAAAQ4BBz4BNzY3NjMyFgcUBxYVBgcCBw4BIyInJicVJjU2Nz4BPwE+ATMyFgEuAxQEDDMERSJPVBIXAQoZAiXYHyyALhgORhACAzoKFAgKAjMsHSMBvx64MhNSBnApXA0OCRIUFRgj/uwkMFgNCTMBBxM5rhlDFB4iPBkAAQAB/9QDQwIEAEEAAAEHDgIVFDMyNjc1NDc+ATMyFhc1FhUGAgcOASMiNzQ3Jw4BIyI3Njc+Ajc+ATMyFgcUBgc2PwE2PwE2MzIVBwYCIhoBCQUCCn0CAQItIy8tDwEDnT4dXi6CBgMJJIZMQwIPJBExLQUKKBMkHAIFAUczChkHESMMGwIBAXNQAhANBgKOHgkEAiEsFioBAwcv/upQISeUBRsCTXM1Pk0jdXEMDxJQLAcfCEsSAwgBAgUQBQUAAf/u/7sCXwH6ADUAAAE+ATMyFgcOAQcWBw4BBxQXDgEjIiYvAQ8BDgMHNQYjIiY1PgM3JjQnJjc+ATMyFx4BAYsXbxIZIwEBiTUBAgEKAQQBQiMfDwcEOx8DEQwWDRsYFyICNDpbEQgGIQECWyElGQ4kAY4XVSIaGJIqDSUcagwhCRQXIT0kOx8DEwsPBgEJIg0eUDtYEhJWEQoYKzcXCTkAAAABACb+vQKiAc4APQAAEyY3PgEzMhYXDgEHPgI3NjMyFjMyNzYzMhYHBgcGDwEWBxQHDgIHBiMiJjc2PwE2PwEnBiMiJjc+ATc0ZwEBASQaIkIMAmAEKUdHFjwdCD8MCwQbERklAQEka5MUJgEMLTgRCB89IDkBAi4UKRARBTYiJTcDAjsCAXUGBh4dLSMdtSwXXXYaVw4DEBwVExdj8SAbIxAVIDsgF00zISE7Gz0VGgYaLzMqyyYRAAAAAAH/9/+4Am0B/gAuAAAlFzYzMhYHBg8BBgciJjc+BDc1JjUmJy4DNz4CNzIWMzI2MzIHDgEHBgEiAxEZKz4BARUiyGo1IQICOlBQOAEBEQYOJRAMAQKFok4IDRUCCgIWAgIwIo5iCQUlIRcgBiIBFBwlVEhANA0CAgEDBAYJBQ4NLEYjBC0BHiBTFnkAAQAx/2wCxAM/AEoAAAE+ATMyFgcGBzMHIgcOAgcOAQcWFRQGDwEGBzMGBwYeAgcGBzUHMwYjIicuATc2PwEHNz4BNzYnIiY3PgE7ATY3IxUiLgE3PgEByBBXLSo+AQI9AREEBSIbERMxQD0NGwEBBCQBIgIBJS4lAQIGBgExRDwgIkYBAjQFAhUVLQECEg1EAQEzFAfJDQoBAwEBAyEDDw8hJhQgGwUBHFBUGD8zEwcGAygOCCFAPB0XLiAsFRALAggsEhNpICVLCAMbG0wWFQodDQ8VIl0BKjMWLjYAAAABAA3/eAIwA3sAJgAAAT4CNz4BMzIHBh4CFQYHNQYHAgMHDgQjIic2Jjc0NxUSEwFJDgwXDhk+FBUBAQ0QDQIGAiOaugwCFAwVGA4FEgEjAQKElwLDJx4qDhgjGQoKAQoLDhIBBWH+R/7UDwMcDBQIBBM2EQMGAQEHAY0AAQAO/2QCaANCAE8AAAUOASMiJjc2Nwc3Njc2NDU+AzcmNz4EPwEmNzQ2NTQvAT0BJy4BNzQ/ATYzMhYzHgIHBg8BBgcUFzIWFQYHMwYjBgc2Mh4BBw4BAQwSYyIqPQECOgEbKAQBAjRUUC4sAQEGCwgSAxYBAQgIEBknMAEFCDJOByAJLTgRAgMZDz8CEwxIAhYBGhy8FAMCBwcCAiJiEycoEx0fAQciOwkkCSxKMSALHC4MGR8TJgcvBwYKGwYODQsBARYCHhsIDQgxBApBSCg8IxZcIhYKHggMDg0tSAYiRCQrPAAAAAEAQwELAhoB+gAlAAABLgIjIgcOAiMiJjc+ATcjNzYzMhcWFzY/ATYzMgcGBw4BIyIBPQkaHhADCAczIQwWIQECNCgBKDUcNgUDIBwcKhoPFwIBPCo1HA0BEQIgHQIFKRUsEx5FGRcdNR4mAQ0iDyEjKCchAAAAAAIAKv9pAo4DEAAmADcAABc3JicmNjc2NzY3FTY3PgI3FTc2MzIWBw4CBwYHDgEHBiMiNzQBMz4BMzIWFxYGBwYjIiY3NDkBAwQFAQcVECUGSFQZEiYSAhg/JzQLDywbIjAFJI0rIiA5AwF7ARJPKyQzAQEpHi4lJzIBTgMQBAMGByAULwsBa7E0JTsSAQEjHxkzaDM+WApDuhEOJRIDHigqIB0fMQgMFhcMAAABAAz/ZwInAoMATAAAATc+BTMeAgcUDgEPAR4BFzIWBw4BIyInDgMHDgMHBhUGFjMyNjMyFgcUBwYHFBYVBiMiJwYjIjU2PwE0PwEmNz4BNzYBfRUDEgcPCg0HCSoZAQ8cAzUEGwYbHAIBIhMHBAcSHA4SJTYiDwkCASkhBRAEHB0BDz10AUAzCAcNCAoBCAMIBTcFBqRzLQI+FAMSBgwFBQYIDRAIExoDOQEDASwTGSoCERcNBAUJHCUXEgYDFyYBEg4ND0wWAQkCVwMHEw8ZDQYXFChXYuAvTgAAAf/d/5QDVQNZAF4AAAEnFhUOAQ8BIiMHFhUGBwYrAwYVBzUGBxc2MzIXJxYVDgEHJiMiBiMiJzMmNzY0NyY3Njc2NwYjIiczLgE3NjcHNjc+BDMyFgcOASMiJzQmNwYHPgQzMgJvARwCMigQAQQEAQNzEyQBBw8FCiwpSjQqTSkBIQEtIRQcNu00JRsBOgIBAQQBA4M2LCQZDh4BFR4BAhgBQWMVMU5ZekRPcgQBPig3GzgBeVMHKBMgGQwfAc4BExcSLA8GAQQILwQBBQMXAXU8BAUTARgWESIJBDcIEygCBwEKBjYTIK8CAgQTDBARARkeQ3iCXTxOSSgtKAgdDFexAg4GCAQAAf/J/6cC4gMNAFkAADcGIyImNz4BPwEiJzMuATc+AT8BNjc+ATMyHwEeAhc/ATY3BzYzMhYHDgIPAR4BBw4BIyInBz4BMzIHDgEPAQYHFzIeARUUBzMGIyImNzQ+BzcjBgwhJwECiFsqIhwBISkBASUjKQoVB1glIwMDAgQFAQksaz8BGRoYHAECP24JHjc2AQJSORYUQhFDDEMCAU09XDILCQIGBA4BP1QuPwEEBwcNCRAJEQR7ARkRISIFNwIFFwwLHQgJi1crTisXDy06Dwk1gykBChMWJWF/CygEGA8WIwNZAQYeFi0JBFEWBQsSCA0OOCceBQ0QDhMOFwwYBQAAAAACAMgCXQJuAxkADgAfAAATIyY3PgEzMhYHDgEjIic3IyY3PgEzMh8BFgcOASMiJ+sCIQICXSYbHAIBViQEDtgCIAICXygFDg4VAgJZJgcLAmIRGyVAIBQjPwIMEyEsTgUGGBwqSwMAAAYAU///A7EC8gAZADcAZQBpAG0AcgAAARUCISImIyImJxUmNzY3PgE3NjMyFhcWBwYBMhYzMj4CNzY1NiYnNScOASMiJiMiBgc1BhUGFgEeAQcUBxcOASMiJwYPAQ4CFQYWMz4BNx4BBxQHNwYPAQYnIiY3NDcVPgEzMhcnFA8CFzcnFzY1IgODZv5xBxsIWJwXBgIEIxliMrllcpQ6KgME/f0CCwNDiWdKDQUDISgIDTIvCTQNXtkWCQN2AU4cHwECBApAIBgwExEEAxEJASAcAyIIFR0BAwEVGQ8zMjxWAwkdpUwiXQQBbQUIBFUGEQMBXwH+oQFiPgEiMUJtQo0dZStBLlNG/rcBQmJtLRQUM1kVAgcWEQbBagEWFkJRAYkFFBMDCgEtLxgLFQgGFhELExABDgEBDQ4FCAEYCAgZAUA1DRkBUH1JBgQB5QcGBTAIEAMAAAAAAgA5ACsDNAJjADIAZQAAATc2MzIWBxQHFA4BBzMHDgMHBhUGHgEXBiMiLgInNDY3NCY1Pgg/ATYlNzYzMhYHBgcOBw8BDgQVBh4BFw4BBy4EJzI+ATU2JzY/AT4DAXMJCQcSHwELDBsHAQwPOCIxFgEBIzYOBTwWNjoqAw8BAQEDBgUJBQwFDQENawHfChAHFSMBAgoBChYQJRAtCxcYAxcQEwsBKj8PAhsOCEA+Qi0DAQcJAgMKQBAHZypRAjQDAyEZEBMKDxQHCAsoGB8MAgQOKzwXKxEiQSoCGw0CCgMFCQoICgYLBAsBC15jAwQmIBQVDRkZFBkMGQYMDAIKCAsKBBIzRBsaKwQEERkoSTASGQkJCCU1DQVRHTQAAAAABwAw/6UECgMZADgAXACPAJcAogCmAKoAAAE2NzY3Izc+CDMyFgcGBw4BDwEzBgcGIyInLgEnLgM3NDY3Pgg3PgI3IgcOAgcGFyMXFjMyPwEjNj8BIz4DNzYmJyIGIyImIyITFQYHFxYXNRYHBgczBiMiLwEzJyMnJi8BDgEjIiYnNjc0Nwc+AT8BPgEzMhcnHgEHDgEPARc0JjUnIhMHBgc2NyM+ATc0AycHFyc3JwcBNiI/ExABPQYqCyINHBEZFwyMtQkDFCBaWxkBNLVhYoI3BzcHAxEIBwEFAQEFCQYQBxMFFQETPS7vAgE6f2oEAzYBBixSQmYUAUsUJgEjHS8WAwMsKQcPBAgcB21FHScWBgIaAQEnAQoEFgoCAQYCCgcIDxFIHxolAwMRDgEBBQEBLr1IKRgBHxQCA0SlBAwDBAFnBDs1IA4BGzsBdw0BBQYHAggCSh8nFwwfAxUFEQQLAwYBx6NBOFprTBUtKBYtCCoTBysWIg4HJw0KFRoSHw4jCSQCIEcsBgEZaqBNTC8FJx0GExQjIB9BTTNAbiAEAf65AQ8JIQgCAR4YFw4CDwILDQgNFR0sGRchKBErAQMNAwFYjQoBEzMlKGGdCQMBAwEGATsBLlAGCg0zGBT+yBkVCQgIAgYAAAAAAgB7Ai0CUQNvABMAIgAAEzY3NjcyFxYHBgcGIyInJjc+ATcXJzI3BgcmIwYHBhYzMjb8LyMdJFkbTgMFWEZ+aSkgAwI/KLEBAgMhGh4OGQIBFxAfOANEFQQNBQ4pTE8+MisZLi5fEHkECAcCAxgZDhAsAAABAMIClgHEA2QAEgAAATM2MzIWBwYHBiMiNTY3FTc+AQFRAQ8XHy0BAh5+QSICCwcOVwNdBxcVGCFpFxEQAQcrWgAAAAIAMwC6ARMBbwATABYAADcjJjc+ATMyHwEWMxcWBw4BIyInNycWXQIoAgNtLwwSAQEBBBoCAmMsCA+QBAHAFSEsTQYBAQMYHStKA6kBAQAAAf/K/swBXQA3ADgAAAMjLgE3NDY1PgIzMhcjFhc2OwE+ATc0JyMiLgE3NjcVPgEzMgcUDwEXDwEWHwEeAwcGBwYjIg4CERUBCAoSJxsNDwECDgMJBj9IAQwSHiolAQINEjoaEQIGBgYPDhgSJBQPFwgBBIlEYiP+0wIaGQYZAhYaFQ8DCgEDFw8JCQUWFBMYARw0EgkMBwYJFgUFDQcHERYQU0YjAAAAAgCXAhcB7gNoAB8ALQAAATY3MzIWBw4BBw4BIyoCLgUnMycmNz4BNyM2FzU0NwYHJiMGBwYzMjYBMC48Gh4cAgNENSFUIAEMAwsFCQUHBQIBBQQCAlspAQw3BxQWCRQjAQIUEjUDOBwUJh4udTAdHQEBAwQGCAUJCw8ukhgGgAIDDAoEAioTFC8AAAACAAwAUgMxAnAAIwBIAAABNycuAjc+ATMyFxQeBAcOARUHDgIPAQ4BBzQmNzY3JTcnLgI3PgEzMhceAQcGDwEdAQYPAQYHNQYjIicuASc2PwE2ASEnGgVFIQECVSwfHBkUHBMOAQEXAQczLiAQK9onAgEP8gFzIxcBQBsBAkwjHBUSSwIBDgcQaAskPz4NCgUBGQEGBQkuASgPHgZINBggYSoBJB4xKSwQCyIBESk4EwgECFAEAxwGUlgCDBwBQC0VH1EjFIchEBELBAdUFwIIHwEeBQgUBAwFDzUAAgAT/2ACjwMCAC8APwAANyY1PgQ3PgEzMh4BBw4DDwE+ATc+ATcVNjMyFgcOAQcOASMiJjc+ATcuAQE+ATMyFgcOAyMiJjc2FAECQltbQwMDVScQDwEBAk1dWAkCBUEpDh0QMBkYMAICNBw/r0QzTQIBCwEBDwG6HEshGR4BAR8rHwsgMgECIAcNLWdaUUIRJDURDw8sfm14JBIDOhkJFwgBFCglJmAVMEQlJwsxCgYfApooKRkXHSkRBxgSCgAAA//f/7gDFAQZACoAMwBJAAABNzYzMhYHFAcWFwYCDwEGBwYjIiY3NDY/AQ4BDwEOAQcGIyImNz4BNxI3Awc3Nj8BJwcGEzc+ATMyFwYHDgEjIi8BJjUnLgEnFQIIGTAXIjMBEx4GJIwqCgsEITAdMQEaBA4UKBITFC4IWEwXIwECMhPs9pBTXiMYHQg1ELMBAkErVA8IDAgXHxQSAwgJDTMDAuUKFR0YDxcQI17+b2oWHgoeFxQJQRQvBRMMDAsFBnseHSFsIAGCxP51igNwQ1MEPh4CQgEpKzQPQDMnCgwDBBITOAUBAAP/3/+4A1QELwAqADMARgAAATc2MzIWBxQHFhcGAg8BBgcGIyImNzQ2PwEOAQ8BDgEHBiMiJjc+ATcSNwMHNzY/AScHBgEzNjMyFgcGBwYjIjU2NxU3PgECCBkwFyIzARMeBiSMKgoLBCEwHTEBGgQOFCgSExQuCFhMFyMBAjIT7PaQU14jGB0INRABUgEPFx8tAQIefkEiAgsHDlcC5QoVHRgPFxAjXv5vahYeCh4XFAlBFC8FEwwMCwUGex4dIWwgAYLE/nWKA3BDUwQ+HgKmBxcVGCFpFxEQAQcrWgAAA//f/7gDfARfACoAMwBaAAABNzYzMhYHFAcWFwYCDwEGBwYjIiY3NDY/AQ4BDwEOAQcGIyImNz4BNxI3Awc3Nj8BJwcGEwYjIiY3NDc2Nz4BNyM2MzIXFAYPARYHBgcWBw4BIyInNjc0LwEGAggZMBciMwETHgYkjCoKCwQhMB0xARoEDhQoEhMULghYTBcjAQIyE+z2kFNeIxgdCDUQ8UY8DREBFohuAgcCAUQsDAkQCAgBAgEIAwECLi4OBAQHCQk4AuUKFR0YDxcQI17+b2oWHgoeFxQJQRQvBRMMDAsFBnseHSFsIAGCxP51igNwQ1MEPh4BuTIKCQ8chFUCBAI3CQQcDA0MGxkyFRUfPggLEBsbFzkAAAP/3/+4A28D3gAqADMAYgAAATc2MzIWBxQHFhcGAg8BBgcGIyImNzQ2PwEOAQ8BDgEHBiMiJjc+ATcSNwMHNzY/AScHBgEuASMiDwEGIyInFyY3PgE/AiM2MzIWBxQGFRQfARYXNj8BIzYzMhUGBw4BIyICCBkwFyIzARMeBiSMKgoLBCEwHTEBGgQOFCgSExQuCFhMFyMBAjIT7PaQU14jGB0INRABJwcoEAQIICwSBAIBHQEBOSkGHAErGxEWAQMCAgYIHBUJASsXCQI4JigTCgLlChUdGA8XECNe/m9qFh4KHhcUCUEULwUTDAwLBQZ7Hh0hbCABgsT+dYoDcENTBD4eAbABJgIWIQEBExEYPxcCEhgQEQIHAQMEDBUMBQgGIg8cJh8XAAAAAAT/3/+4A3wD3gAqADMAQgBTAAABNzYzMhYHFAcWFwYCDwEGBwYjIiY3NDY/AQ4BDwEOAQcGIyImNz4BNxI3Awc3Nj8BJwcGEyMmNz4BMzIWBw4BIyInNyMmNz4BMzIfARYHDgEjIicCCBkwFyIzARMeBiSMKgoLBCEwHTEBGgQOFCgSExQuCFhMFyMBAjIT7PaQU14jGB0INRBqAiECAl0mGxwCAVYkBA7YAiACAl8oBQ4OFQICWSYHCwLlChUdGA8XECNe/m9qFh4KHhcUCUEULwUTDAwLBQZ7Hh0hbCABgsT+dYoDcENTBD4eAaURGyVAIBQjPwIMEyEsTgYFGBwqSwMABP/f/7gDzARTACoAMwBJAFgAAAE3NjMyFgcUBxYXBgIPAQYHBiMiJjc0Nj8BDgEPAQ4BBwYjIiY3PgE3EjcDBzc2PwEnBwYTNjc+ARcWBwYHDgEnJicuAScmNz4BFyc3BgcmIyImIw4BFxY2AggZMBciMwETHgYkjCoKCwQhMB0xARoEDhQoEhMULghYTBcjAQIyE+z2kFNeIxgdCDUQsDJYJWwkTgMFWCd8NCklCSMFIAMBJ/IBBSEaDA4DDQISDA8dVQLlChUdGA8XECNe/m9qFh4KHhcUCUEULwUTDAwLBQZ7Hh0hbCABgsT+dYoDcENTBD4eAoYqDBAFESlMTz4cGAMDBgMZBRkuJEpKBAgHAgIBEioMES8AAAAC/93/uAQ2AxUAXABlAAABMx4BBw4BBw4BBzUHBg8BFjMyNjMyFRQGBwYHMw4EBwYHBjMyNxYHFAYVFBYVDgEHMwYjIicGIyImNzQ2PwEOAQ8BDgEHBiMiJjc+ATcSNwc3NjMyFhc2MzIBBzc2PwEnBwYEAgEbGAICVzo8LhACLQ8KERMSQAoSAwEtSAEOFAYNFBVVAQFbGkIRAgQVAUcpAVlJFToaGB4wARoEDhQoExIULghYTBckAQI0Euz2ARk0Ex0xBqxrEP2WVF8jGB0JNBoDEQEYFSlXCRAUFgEDMSUaCAkKAQcCVRkDBQICAQFvIg8IBg8EDwMGFAQRQA4YBAoXFAlBFC8FEwwMCwUGex8cIXAcAYLEAQoVGhQ//kaKA3BDUwQ+MgAAAAAB/9j+jQMVAvwAZwAAAyMuATc+ATU+AjMyFyMXNjsBPgE3NicjIi4CNzY3LgE3PgM3NjMyFyMWBwYHDgEjIiY3NDY3NiMiDwEzDgIHDgIWMzI2MzIeARUOARUGFhUOAQ8BNQceAR8BHgEHBgcGIyIBARAWAQEIDBAnHAsRAQ8KBQM/RwECDhUVICIRAQIrP0EEBVZ7ijxYUQoYAoMFBS0XVSYaGAENAQEVDBUTAhMWLBs3OwQqGhxEFwoXGAEMARkCuVEJDA8qDAwiHwEFiENjJf6UAhsaBhkBFxcWDw4CAxcPCQkDCRMPJSsTS0xkz591FSkCEnE9USUpFRQGJAwdBwgKDiYePH1KJycEDgwHIggJDwUjUwIPARICDgIECx4eU0UjAAAAAAIABP+2AuMEHABEAFoAAAEzHgEHDgEHDgEPAQYPARYyNjMyFRQHBgczDgQHDgEHBjMyNxYVFAYVBhcWFQ4BBzMGIyIjBjc0NzYSNz4BNzYzMic3PgEzMhcGBw4BIyIvASY1Jy4BJxUCrwEaGQICVzo6MBIGJRAMEyRAChEEKkoBDRMHDRUVGD4BAVwaQg4EAhUCAUgoAVtGAweoBAIcgHQMGhfAZxGeAQJBK1QPCAwIFx8UEgMICQ0zAwMCARkUKlcJDhUWBysmGggJCgIIVhgDBAMCAgEdYBMQCAYNAg8EEQoCBBFADhcCRAMGkwEDphFmC0XBASkrNA9AMycKDAMEEhM4BQEAAAIABP+2AwAEIABEAFcAAAEzHgEHDgEHDgEPAQYPARYyNjMyFRQHBgczDgQHDgEHBjMyNxYVFAYVBhcWFQ4BBzMGIyIjBjc0NzYSNz4BNzYzMgMzNjMyFgcGBwYjIjU2NxU3PgECrwEaGQICVzo6MBIGJRAMEyRAChEEKkoBDRMHDRUVGD4BAVwaQg4EAhUCAUgoAVtGAweoBAIcgHQMGhfAZxECAQ8XHy0BAh5+QSICCwcOVwMCARkUKlcJDhUWBysmGggJCgIIVhgDBAMCAgEdYBMQCAYNAg8EEQoCBBFADhcCRAMGkwEDphFmC0UBEwcXFRghaRcREAEHK1oAAAACAAT/tgNGBGoARABrAAABMx4BBw4BBw4BDwEGDwEWMjYzMhUUBwYHMw4EBw4BBwYzMjcWFRQGFQYXFhUOAQczBiMiIwY3NDc2Ejc+ATc2MzInBiMiJjc0NzY3PgE3IzYzMhcUBg8BFgcGBxYHDgEjIic2NzQvAQYCrwEaGQICVzo6MBIGJRAMEyRAChEEKkoBDRMHDRUVGD4BAVwaQg4EAhUCAUgoAVtGAweoBAIcgHQMGhfAZxFFRjwNEQEWiG4CBwIBRCwMCRAICAECAQgDAQIuLg4EBAcJCTgDAgEZFCpXCQ4VFgcrJhoICQoCCFYYAwQDAgIBHWATEAgGDQIPBBEKAgQRQA4XAkQDBpMBA6YRZgtFQDIKCQ8chFUCBAI3CQQcDQwMGxkyFRUfPggLEBsbFzkAAAADAAT/tgNJA9oARABTAGQAAAEzHgEHDgEHDgEPAQYPARYyNjMyFRQHBgczDgQHDgEHBjMyNxYVFAYVBhcWFQ4BBzMGIyIjBjc0NzYSNz4BNzYzMicjJjc+ATMyFgcOASMiJzcjJjc+ATMyHwEWBw4BIyInAq8BGhkCAlc6OjASBiUQDBMkQAoRBCpKAQ0TBw0VFRg+AQFcGkIOBAIVAgFIKAFbRgMHqAQCHIB0DBoXwGcRyQIhAgJdJhscAgFWJAQO2AIgAgJfKAUODhUCAlkmCAoDAgEZFCpXCQ4VFgcrJhoICQoCCFYYAwQDAgIBHWATEAgGDQIPBBEKAgQRQA4XAkQDBpMBA6YRZgtFHREbJUAgFCM/AgwTISxOBgUYHCpLAwAAAv/u/9ACpgQnABsAMQAAASMGAgcOAyMiNzY3NhI2Nz4CNzYzMhYHBgM3PgEzMhcGBw4BIyIvASY1Jy4BJxUCKAFX1BkNLTQhEFYCASIchXEnFi8pEBcqFRsBAmQBAkErVA8IDAgXHxQSAwgJDTMDAqqp/mwwJDESBisYQjEA/8w3HxQQGiUXFhUBCgEpKzQPQDMnCgwDBBITOAUBAAAAAAL/7v/QAuoEKQAbAC4AAAEjBgIHDgMjIjc2NzYSNjc+Ajc2MzIWBwYTMzYzMhYHBgcGIyI1NjcVNz4BAigBV9QZDS00IRBWAgEiHIVxJxYvKRAXKhUbAQI/AQ8XHy0BAh5+QSICCwcOVwKqqf5sMCQxEgYrGEIxAP/MNx8UEBolFxYVAVoHFxUYIWkXERABBytaAAAC/+7/0ALrBE8AGwBCAAABIwYCBw4DIyI3Njc2EjY3PgI3NjMyFgcGJwYjIiY3NDc2Nz4BNyM2MzIXFAYPARYHBgcWBw4BIyInNjc0LwEGAigBV9QZDS00IRBWAgEiHIVxJxYvKRAXKhUbAQJJRjwNEQEWiG4CBwIBRCwMCRAICAECAQgDAQIuLg4EBAcJCTgCqqn+bDAkMRIGKxhCMQD/zDcfFBAaJRcWFWMyCgkPHIRVAgQCNwkEHAwNDBsZMhUVHz4IChEbGxc5AAAD/+7/0AMBA9sAGwAqADsAAAEjBgIHDgMjIjc2NzYSNjc+Ajc2MzIWBwYnIyY3PgEzMhYHDgEjIic3IyY3PgEzMh8BFgcOASMiJwIoAVfUGQ0tNCEQVgIBIhyFcScWLykQFyoVGwECugIhAgJdJhscAgFWJAQO2AIgAgJfKAUODhUCAlkmCAoCqqn+bDAkMRIGKxhCMQD/zDcfFBAaJRcWFVwRGyVAIBQjPwIMEyEsTgUGGBwqSwMAAv/M/7MDCgMBACcAPgAAPwEiJjc2PwE+ATM3IzY3PgMzMhcWBwYHDgEjIicGIyImNzY3JiMFBz4BNzYmJwYPAR4BBwYHNw4BDwEOARoBIywBAj8TDmJIDQE5IQUiLEkfbnIwBQMuOv1zEhQkPSg6AQ0xOiQBFw5yqgUCLDIcEhQfIwECLAEHSRANAhbuAhYQGxcCHzMYX0YJXioXiDpVSGZ+1gQ5PypSgAJiMTmqVSpBJC0tLQgeFCAjAQIfAyEMNAAAAAL/6//WA00DvQA1AGQAABMzPgEzMhcWBwYHFz4BNz4BMzIWBxQHBhQGBwYCBgcGIwYnLgE2Jw4CDwEOASMiJjc0NzYSAS4BIyIPAQYjIicXJjc+AT8CIzYzMhYHFAYVFB8BFhc2PwEjNjMyFQYHDgEjIs0BJXAzFxMbBQIDCAlkER92MhUaAQgIDBYqlHcWQyEIHRgJCwoqOBUQERFHIRMXAQcXiwHyBygQBAggLBIEAgEdAQE5KQYcASsbERYBAwICBggcFQkBKxcJAjgmKBMKAfZNgw9/UDEXAhCYJTpDDgwFDggoOx05/uvVCSIBBAKDgCJVYh0SEx4iDgwJC1MBPAF+ASYCFiEBARMRGD8XAhIYEBECBwEDBAwVDAUIBiIPHCYfFwAAAwAq/7IDOQQZABoAJQA7AAABNjMyFzYzMhcUHwEWBwYCBwYjIiY3NjcVPgEDNhI3AA8BFhc3NgE3PgEzMhcGBw4BIyIvASY1Jy4BJxUBgUlNHholKUAkBwQIAgZ4TKara2IEB4skbhdVhgz++TIDCRwSFwEzAQJBK1QPCAwIFx8UEgMICQ0zAwLBMwohPQIcFyEnZv7/Y9V6U4/gATZ8/ahUASB6/vGlEz4NDRADhAEpKzQPQDMnCgwDBBITOAUBAAAAAAMAKv+yA4oEKAAaACUAOAAAATYzMhc2MzIXFB8BFgcGAgcGIyImNzY3FT4BAzYSNwAPARYXNzYBMzYzMhYHBgcGIyI1NjcVNz4BAYFJTR4aJSlAJAcECAIGeEymq2tiBAeLJG4XVYYM/vkyAwkcEhcB4wEPFx8tAQIefkEiAgsHDlcCwTMKIT0CHBchJ2b+/2PVelOP4AE2fP2oVAEgev7xpRM+DQ0QA+EHFxUYIWkXERABBytaAAADACr/sgN6BGEAGgAlAEwAAAE2MzIXNjMyFxQfARYHBgIHBiMiJjc2NxU+AQM2EjcADwEWFzc2AQYjIiY3NDc2Nz4BNyM2MzIXFAYPARYHBgcWBw4BIyInNjc0LwEGAYFJTR4aJSlAJAcECAIGeEymq2tiBAeLJG4XVYYM/vkyAwkcEhcBSkY8DREBFohuAgcCAUQsDAkQCAgBAgEIAwECLi4OBAMICQk4AsEzCiE9AhwXISdm/v9j1XpTj+ABNnz9qFQBIHr+8aUTPg0NEAL9MgoJDxyEVQIEAjcJBBwMDQwbGTIVFR8+CAoRGxsXOQADACr/sgN2A+QAGgAlAFQAAAE2MzIXNjMyFxQfARYHBgIHBiMiJjc2NxU+AQM2EjcADwEWFzc2AS4BIyIPAQYjIicXJjc+AT8CIzYzMhYHFAYVFB8BFhc2PwEjNjMyFQYHDgEjIgGBSU0eGiUpQCQHBAgCBnhMpqtrYgQHiyRuF1WGDP75MgMJHBIXAYkHKBAECCAsEgQCAR0BATkpBhwBKxsRFgEDAgIGCBwVCQErFwkCOCYoEwoCwTMKIT0CHBchJ2b+/2PVelOP4AE2fP2oVAEgev7xpRM+DQ0QAvgBJgIWIQEBExEYPxcCEhgQEQIHAQMEDBUMBQgGIg8cJh8XAAAAAAQAKv+yA40D6gAaACUANABFAAABNjMyFzYzMhcUHwEWBwYCBwYjIiY3NjcVPgEDNhI3AA8BFhc3NhMjJjc+ATMyFgcOASMiJzcjJjc+ATMyHwEWBw4BIyInAYFJTR4aJSlAJAcECAIGeEymq2tiBAeLJG4XVYYM/vkyAwkcEhfWAiECAl0mGxwCAVYkBA7YAiACAl8oBQ4OFQICWSYICgLBMwohPQIcFyEnZv7/Y9V6U4/gATZ8/ahUASB6/vGlEz4NDRAC8xEbJUAgFCM/AgwTISxOBgUYHCpLAwABABYAjQMQAnUAPAAAATM2MzIeAQcOAQcWBhcOASMiJicVJicHBg8BDgQjIicuATc0Nwc2Ny4BJy4BNxU2PwEjNjMyFhc2NwJvATgVDSAmAQGiQgcJDQNPLiYWEAQFFgclFgQaEyMuHTMBEA8BDgGYXgsGDBYWAQUMEgFGOydlBi4tAlQhBRgVE34kHqoEEhEaNQEQDQ8DGxADFwwRCRIECgkMGQGVLw9KDwUPDAERDAwkMyQeFQAAAwAp/3gDQgNXADAANwBDAAABNjMyFzY7ATY3Izc2MzIHBhU1BgcGBxcWBwYCBwYjIicHBiMiNzY3FTcmNzY3FT4BFwYHFzY3BgM+ATcnDgEHFhc3NgGBSU0eGiQtCxdCAwYaCBkBAQQmAhIKCAIGeEymqjQsMgwOEgICIgc+BQeKJW5Pey8IjJRhgzduJwgZvTQOCREXAsEzCiAmIAEGIQIFARQqFhcsISdm/v9j1RI9DxsfLAEJN2KN4gE3fI2jqQS/wQ7+EjavXQUg+T8PBA0QAAACADb/0AN2BAYAMgBIAAABMhYHDgIHBjMyEjc+AzMyFzYzMhYHFQ4BAgcOASMiJjc0NyMOASMiJjc+Azc2PwE+ATMyFwYHDgEjIi8BJjUnLgEnFQGpGSICAVliCQIPHslhEQ4gHxEOECAmFxoBA2ihOAhPKR8YAgIKBWUmUV0EAyxPPCw/yAECQStUDwgMCBcfFBIDCAkNMwMC/ycaGZm9QRcBC5EbFigRCCAZGAgUx/63lCQvGh4GDCQnWE47jpxoSHSyASkrNA9AMycKDAMEEhM4BQEAAAACADb/0AN2A/IAMgBFAAABMhYHDgIHBjMyEjc+AzMyFzYzMhYHFQ4BAgcOASMiJjc0NyMOASMiJjc+Azc2JTM2MzIWBwYHBiMiNTY3FTc+AQGpGSICAVliCQIPHslhEQ4gHxEOECAmFxoBA2ihOAhPKR8YAgIKBWUmUV0EAyxPPCw/AVoBDxcfLQECHn5BIgILBw5XAv8nGhmZvUEXAQuRGxYoEQggGRgIFMf+t5QkLxoeBgwkJ1hOO46caEh07AcXFRghaRcREAEHK1oAAAAAAgA2/9ADigRqADIAWQAAATIWBw4CBwYzMhI3PgMzMhc2MzIWBxUOAQIHDgEjIiY3NDcjDgEjIiY3PgM3NiUGIyImNzQ3Njc+ATcjNjMyFxQGDwEWBwYHFgcOASMiJzY3NC8BBgGpGSICAVliCQIPHslhEQ4gHxEOECAmFxoBA2ihOAhPKR8YAgIKBWUmUV0EAyxPPCw/AS9GPA0RARaIbgIHAgFELAwJEAgIAQIBCAMBAi4uDgQDCAkJOAL/JxoZmb1BFwELkRsWKBEIIBkYCBTH/reUJC8aHgYMJCdYTjuOnGhIdEcyCgkPHIRVAgQCNwkEHA0MDBsZMhUVHz4ICxAbGxc5AAAAAwA2/9ADhAPzADIAQQBSAAABMhYHDgIHBjMyEjc+AzMyFzYzMhYHFQ4BAgcOASMiJjc0NyMOASMiJjc+Azc2NyMmNz4BMzIWBw4BIyInNyMmNz4BMzIfARYHDgEjIicBqRkiAgFZYgkCDx7JYREOIB8RDhAgJhcaAQNooTgITykfGAICCgVlJlFdBAMsTzwsP6ICIQICXSYbHAIBViQEDtgCIAICXygFDg4VAgJZJgcLAv8nGhmZvUEXAQuRGxYoEQggGRgIFMf+t5QkLxoeBgwkJ1hOO46caEh0PREbJUAgFCM/AgwTISxOBQYYHCpLAwAAAAL///+nAuID8gAzAEYAAAEXFhc/ATY3BzYzMhYHDgIHDgIHFzIeARUUBzMGIyImNzY3Nj8BBiMiNzQ3Njc+ATMyEzM2MzIWBwYHBiMiNTY3FTc+AQGNAwQJCSxrPwEXHBcdAQI/bwkcj1gpCAIGBA4BP1QvQgECBRtkWAIEHAQEDhIHWCUivQEPFx8tAQIefkEiAgsHDlcCthciYwk1gykBChMWJGJ+DCa7gkwGCxIIDQ44JRsMCTWHdgEtChafUCpOAQoHFxUYIWkXERABBytaAAAAAv/i/vADUANpADoATgAAATM2NxU3NT4BPwE2MzIXNRQGFQYHFhUOAgc3NjMyFgcOAQcGIyIGIyInBgcGIyImNzY3PgESNyM+ARMnBiMiJiMOAQ8BFxYXMhYzMj4BAcMBBgIEAjQwBiIPOhQBASEDASI6DiwYGmZcAwV8ZllyFlgVDxZmUQsVFyMBAhIvgKErAQ05kgcBBAo+Dg0vFkgHEAMEHwk0VikC7w8CAQYFFjETAQQzAQEEARUuEgISM0gVAgNQR1W/PjMFAq1xECUeHCF2+AEdVBh1/qMFARkIPxaCCxsGAlpqAAH/+f+JAzIDGABZAAAXBiMiJjc0NzY/ATY/AQc2MzIXNyM3PgEzMh8BHgQHDgEPARYHDgIjIiY3NjcHPgEzFhc2NzYnJjc2NyMyNzM+ATc0Njc2JiczIyIGBzUHBg8BBg8BBsEyQSYvAgQ+TicvOj0BJDgUFxIBHRpOIQgOExYXJhMOAQRELQktBARip1oqNAMCCwEdNykcC1MEAxU6AwJAAQEBATU9DwcBARQNAQUlZCgBChIVNxoRSEUyKikMFFmpV1xudgEzDhAbFx0CBAUHEhgqHESEJAs1UVS1fzQuGh8BJhwGBlFXJyYXKigYAR1DOgQYBwsJAWc3AQILHTWHNyq+AAAAAAMADP/RAmIC8AAiADMASQAAARYXFhUUMzYzMgcGAgcOASMiJj8BJw4BIyImNz4BNz4BMzIDMj4HPwEOAQcGFhM3PgEzMhcGBw4BIyIvASY1Jy4BJxUBz0IKAgoOAR8CCFsEAzMgHCYBAwgTZ0BDRwQCLSE52UgH5QkSEg0QCRAFEAEPR3EEAR7LAQJBK1QPCAwIFx8UEgMICQ0zAwHjDRUGBwoCQTH+5Q0YGxMQCgUbJTE5KoAxSoX+ZgUOCxkNIAojAiAcTx4PGwJQASkrNA9AMycKDAMEEhM4BQEAAAAAAwAM/9ECqQLuACIAMwBGAAABFhcWFRQzNjMyBwYCBw4BIyImPwEnDgEjIiY3PgE3PgEzMgMyPgc/AQ4BBwYWATM2MzIWBwYHBiMiNTY3FTc+AQHPQgoCCg4BHwIIWwQDMyAcJgEDCBNnQENHBAItITnZSAflCRISDRAJEAUQAQ9HcQQBHgFxAQ8XHy0BAh5+QSICCwcOVwHjDRUGBwoCQTH+5Q0YGxMQCgUbJTE5KoAxSoX+ZgUOCxkNIAojAiAcTx4PGwKcBxcVGCFpFxEQAQcrWgADAAz/0QLJA1cAIgAzAFoAAAEWFxYVFDM2MzIHBgIHDgEjIiY/AScOASMiJjc+ATc+ATMyAzI+Bz8BDgEHBhYBBiMiJjc0NzY3PgE3IzYzMhcUBg8BFgcGBxYHDgEjIic2NzQvAQYBz0IKAgoOAR8CCFsEAzMgHCYBAwgTZ0BDRwQCLSE52UgH5QkSEg0QCRAFEAEPR3EEAR4BCEY8DREBFohuAgcCAUQsDAkQCAgBAgEIAwECLi4OBAMICQk4AeMNFQYHCgJBMf7lDRgbExAKBRslMTkqgDFKhf5mBQ4LGQ0gCiMCIBxPHg8bAegyCgkPHIRVAgQCNwkEHAwNDBsZMhUVHz4ICxAbGxc5AAAAAAMADP/RAs8DBAAiADMAYgAAARYXFhUUMzYzMgcGAgcOASMiJj8BJw4BIyImNz4BNz4BMzIDMj4HPwEOAQcGFgEuASMiDwEGIyInFyY3PgE/AiM2MzIWBxQGFRQfARYXNj8BIzYzMhUGBw4BIyIBz0IKAgoOAR8CCFsEAzMgHCYBAwgTZ0BDRwQCLSE52UgH5QkSEg0QCRAFEAEPR3EEAR4BUQcoEAQIICwSBAIBHQEBOSkGHAErGxEWAQMCAgYIHBUJASsXCQI4JigTCgHjDRUGBwoCQTH+5Q0YGxMQCgUbJTE5KoAxSoX+ZgUOCxkNIAojAiAcTx4PGwINASYCFiEBARMRGD8XAhIYEBECBwEDBAwVDAUIBiIPHCYfFwAAAAQADP/RAsIC3QAiADMAQgBTAAABFhcWFRQzNjMyBwYCBw4BIyImPwEnDgEjIiY3PgE3PgEzMgMyPgc/AQ4BBwYWEyMmNz4BMzIWBw4BIyInNyMmNz4BMzIfARYHDgEjIicBz0IKAgoOAR8CCFsEAzMgHCYBAwgTZ0BDRwQCLSE52UgH5QkSEg0QCRAFEAEPR3EEAR56AiECAl0mGxwCAVYkBA7YAiACAl8oBQ4OFQICWSYHCwHjDRUGBwoCQTH+5Q0YGxMQCgUbJTE5KoAxSoX+ZgUOCxkNIAojAiAcTx4PGwHbERslQCAUIz8CDBMhLE4FBhgcKksDAAAAAAQADP/RAwMDVgAiADMASQBYAAABFhcWFRQzNjMyBwYCBw4BIyImPwEnDgEjIiY3PgE3PgEzMgMyPgc/AQ4BBwYWEzY3PgEXFgcGBw4BJyYnLgEnJjc+ARcnNwYHJiMiJiMOARcWNgHPQgoCCg4BHwIIWwQDMyAcJgEDCBNnQENHBAItITnZSAflCRISDRAJEAUQAQ9HcQQBHrEyWCVsJE4DBVgnfDQpJQkjBSADASfyAQUhGgwOAw0CEgwPHVUB4w0VBgcKAkEx/uUNGBsTEAoFGyUxOSqAMUqF/mYFDgsZDSAKIwIgHE8eDxsCwCoMEAURKUxPPhwYAwMGAxkFGS4kSkoECAcCAgESKgwRLwAAAwAK/7kDZwHlADwASABSAAAlFQ4BBx4BMzI2MzIXHgI7ATIeAgcOASMiJj8BDgEjIiY3PgE3PgEzMhcWBxQzNjMyFzYzMhYHBgcOAQUyPgI/AQ4BBwYWJScmIyIHMzI2NwKuDXcmARoMFFkTFREECAUFAQEFBAMBAqFbRmADAhhsPERHBAIuITnZSCQiHgEKDgEHClVgMDwDAgwcRf3mFCUhEwwOR3AEAR4B4wQKBT01BCZZAoABBhcDEhIgEQwMAQQGDgknMDAbEx0pMTorfzBKhQ4NFgoCBzQsNB4lTEhXGzUmHSAcUB0PG9gFAnJPGQAAAAH/sv61AjAB7QBVAAADIyY3ND4BNRU+AzMyHwE2Mz4BNzYnIyImNzY3FTcuATc+AjMyFgcOAQcOAgcOAwcOARUGFjMyNjMyFgcUBw4BDwEeARcjFx4CBwYHBiMiKgEjAwECCggVHBMJEA4IBzg/AQEMEyoyAQIaDCcsAgV4x2s3MAECLBcJGhUTJDkoDw0BAQEpIQQRBBwdAQ8keD8VDCUNAQoVFBABA3k4Wxz+uwQrAwYJAgEUDxoJDQ0CAxUNCAgQGRgfARAPTDVbuHsZHR01AhATBQMFHTIZGQIGAhclARIPDQ8uNAQgAQwDAwcLGRJIPx4AAAAAAwAL/8kCVAMgACoAMwBJAAAlFQ4BBx4BMzI2MzIXHgM7ATIeAgcOASMiJjc+ATc+ATMyBwYHNQ4BJzYjIgYHMzI2Ezc+ATMyFwYHDgEjIi8BJjUnLgEnFQFsDXcmARkMElsUFRIDBQYEBAEBBQUDAQKjWl5MAwRCL0iOYG4FAgsfQVABEyE6FQQmVx4BAkErVA8IDAgXHxQSAwgJDTMDkQEGGAMREyAQCgsEAQQGDQknMUI/O4g1UFdhGycBT0V+CUEwTwGzASkrNA9AMycKDAMEEhM4BQEAAwAL/8kCigMJACoAMwBGAAAlFQ4BBx4BMzI2MzIXHgM7ATIeAgcOASMiJjc+ATc+ATMyBwYHNQ4BJzYjIgYHMzI2EzM2MzIWBwYHBiMiNTY3FTc+AQFsDXcmARkMElsUFRIDBQYEBAEBBQUDAQKjWl5MAwRCL0iOYG4FAgsfQVABEyE6FQQmV7MBDxcfLQECHn5BIgILBw5XkQEGGAMREyAQCgsEAQQGDQknMUI/O4g1UFdhGycBT0V+CUEwTwHqBxcVGCFpFxEQAQcrWgAAAAMAC//JArIDTQAqADMAWgAAJRUOAQceATMyNjMyFx4DOwEyHgIHDgEjIiY3PgE3PgEzMgcGBzUOASc2IyIGBzMyNhMGIyImNzQ3Njc+ATcjNjMyFxQGDwEWBwYHFgcOASMiJzY3NC8BBgFsDXcmARkMElsUFRIDBQYEBAEBBQUDAQKjWl5MAwRCL0iOYG4FAgsfQVABEyE6FQQmV1JGPA0RARaIbgIHAgFELAwJEAgIAQIBCAMBAi4uDgQDCAkJOJEBBhgDERMgEAoLBAEEBg0JJzFCPzuINVBXYRsnAU9FfglBME8BETIKCQ8chFUCBAI3CQQcDA0MGxkyFRUfPggLEBsbFzkAAAQAC//JArYC3AAqADMAQgBTAAAlFQ4BBx4BMzI2MzIXHgM7ATIeAgcOASMiJjc+ATc+ATMyBwYHNQ4BJzYjIgYHMzI2AyMmNz4BMzIWBw4BIyInNyMmNz4BMzIfARYHDgEjIicBbA13JgEZDBJbFBUSAwUGBAQBAQUFAwECo1peTAMEQi9IjmBuBQILH0FQARMhOhUEJlcxAiECAl0mGxwCAVYkBA7YAiACAl8oBQ4OFQICWSYHC5EBBhgDERMgEAoLBAEEBg0JJzFCPzuINVBXYRsnAU9FfglBME8BDREbJUAgFCM/AgwTISxOBgUYHCpLAwAC//f/pwIZAxAAHAAyAAATNT4BMzIWBxQHNQcCBw4CIgYHBiMiJjc0NzYSEzc+ATMyFwYHDgEjIi8BJjUnLgEnFeUNPyEfKQEBFYcZCBUXFRgKCB8gOgIUHImVAQJBK1QPCAwIFx8UEgMICQ0zAwGxARcZGBUGBAEp/vxOKSwJCQ8UKiAXG0cBCwFGASkrNA9AMycKDAMEEhM4BQEAAAAAAv/2/6cCOwLwABsALgAAEzU+ATIWBxQHNQcGBw4CIgYHBiMiJjc0NzYSATM2MzIWBwYHBiMiNTY3FTc+AeQOP0ApAQEWdCsJFRYVGAoIHyE6AhUciAEXAQ8XHy0BAh5+QSICCwcOVwGxARcZGBUGBAEp1X0pLAkJDxQqIBcbRwELAXQHFxUYIWkXERABBytaAAAAAAL/9v+nAl0DUAAcAEMAABM1PgEzMhYHFAc1BwYHDgIiBgcGIyImNzQ3NhI3BiMiJjc0NzY3PgE3IzYzMhcUBg8BFgcGBxYHDgEjIic2NzQvAQbkDj4hICkBARZ0KwkVFhUYCggfIToCFRyIsEY8DREBFohuAgcCAUQsDAkQCAgBAgEIAwECLi4OBAMICQk4AbEBFxkYFQYEASnVfSksCQkPFCogFxtHAQu3MgoJDxyEVQIEAjcJBBwNDAwbGTIVFR8+CAsQGxsXOQAAAAP/9v+nAngC8QAbACoAOwAAEzU+ATMyFgcUBzUHAgcOASYGBwYjIiY3NDc2EjcjJjc+ATMyFgcOASMiJzcjJjc+ATMyHwEWBw4BIyIn5A0/IR8pAQEVhRsKHBghCwkeIToCFCCFRAIhAgJdJhscAgFWJAQO2AIgAgJfKAUODhUCAlkmBwsBsQEXGRcVBwQBKf8AUjIsAggSFCogFxtMAQbFERslQCAUIz8CDBMhLE4FBhgcKksDAAADABH/cQMDAs8APQBQAFYAAAE3JicGByY1Nj8BNj8BJjc2Nx4CFwYHBhU7ATc2MzIWBwYHJx4BBwYHDgEHIiY3JicVJjc+ATc2PwE+AgM2NyMGBw4DBwYXNRcWMzI2AzciBzM2AfQGHxBmJwMBPgYGExBbAQI1EyM3EQECAQIJE18rHD8BAlkRJg4FDFlM/2MNPwEjHxQDBIJZXloRBxYTYGkRCysWKGRjRQIDIAYLFy5tBwEJAQQEAaIHOREuAQIDDjgFCAwMOSIYDQELFgYCAQEBCz0yHDMiCT9eY9xOQ1UCNg4TMAEoMk6aKicQAgEDAv64Z38CAwYjNU0qKS0BCAoyAZALDAEAAAAAAv/v/7sC1wLdAD4AbQAAEzYzMhc2MzIHFAc+ATMyFgcGBzUGBwYjIiY3ND8BPgg1NCMiDgMHDgEmBgcOASMiLgI3NhIlLgEjIg8BBiMiJxcmNz4BPwIjNjMyFgcUBhUUHwEWFzY/ASM2MzIVBgcOASMiviYLAwclFyECAiqsQjozAwRDChllaxYcAQY6BREIDQcJBQUDEA8qOipNEAsRCAkEBz8lCxsgFgEDsAFhBygQBAggLBIEAgEdAQE5KQYcASsbERYBAwICBggcFQkBKxcJAjgmKBMKAYQvBQ4sCwgmPzYxTnoBDyqfDg4EDGsJHw8ZDRQLDgoFFB5ENGgVDgwBCAsRFQQIEgwzAUrPASYCFiEBARMRGD8XAhIYEBECBwEDBAwVDAUIBiIPHCYfFwAAAAADAB7/xQJlAxEAHAAwAEYAABM2MzIWMzYzMjYzMhYHDgEHBgciIyIuAzc+ARcnBisBDgIHFB4DOgEzMj4BEzc+ATMyFwYHDgEjIi8BJjUnLgEnFeEPEQYUByI9CScITkcEBGtSQ14CBSMnQCEYAgR8zgYaEAYCRjACAQQECQQNAytAHCgBAkErVA8IDAgXHxQSAwgJDTMDAaoIAzIETkNTx0EvBAIOGjYnWt2jBQcDOT0dBQgEAwE7SwICASkrNA9AMycKDAMEEhM4BQEAAAAAAwAe/8UCjAMAABwAMABDAAATNjMyFjM2MzI2MzIWBw4BBwYHIiMiLgM3PgEXJwYrAQ4CBxQeAzoBMzI+ARMzNjMyFgcGBwYjIjU2NxU3PgHhDxEGFAciPQknCE5HBARrUkNeAgUjJ0AhGAIEfM4GGhAGAkYwAgEEBAkEDQMrQByuAQ8XHy0BAh5+QSICCwcOVwGqCAMyBE5DU8dBLwQCDho2J1rdowUHAzk9HQUIBAMBO0sCPwcXFRghaRcREAEHK1oAAAMAHv/FAq0DWgAcADAAVwAAEzYzMhYzNjMyNjMyFgcOAQcGByIjIi4DNz4BFycGKwEOAgcUHgM6ATMyPgETBiMiJjc0NzY3PgE3IzYzMhcUBg8BFgcGBxYHDgEjIic2NzQvAQbhDxEGFAciPQknCE5HBARrUkNeAgUjJ0AhGAIEfM4GGhAGAkYwAgEEBAkEDQMrQBxGRjwNEQEWiG4CBwIBRCwMCRAICAECAQgDAQIuLg4EAwgJCTgBqggDMgROQ1PHQS8EAg4aNida3aMFBwM5PR0FCAQDATtLAXwyCgkPHIRVAgQCNwkEHA0MDBsZMhUVHz4ICxAbGxc5AAMAHv/FArIC7wAcADAAXwAAEzYzMhYzNjMyNjMyFgcOAQcGByIjIi4DNz4BFycGKwEOAgcUHgM6ATMyPgETLgEjIg8BBiMiJxcmNz4BPwIjNjMyFgcUBhUUHwEWFzY/ASM2MzIVBgcOASMi4Q8RBhQHIj0JJwhORwQEa1JDXgIFIydAIRgCBHzOBhoQBgJGMAIBBAQJBA0DK0AcjgcoEAQIICwSBAIBHQEBOSkGHAErGxEWAQMCAgYIHBUJASsXCQI4JigTCgGqCAMyBE5DU8dBLwQCDho2J1rdowUHAzk9HQUIBAMBO0sBiQEmAhYhAQETERg/FwISGBARAgcBAwQMFQwFCAYiDxwmHxcAAAAABAAe/8UCzALxABwAMAA/AFAAABM2MzIWMzYzMjYzMhYHDgEHBgciIyIuAzc+ARcnBisBDgIHFB4DOgEzMj4BAyMmNz4BMzIWBw4BIyInNyMmNz4BMzIfARYHDgEjIifhDxEGFAciPQknCE5HBARrUkNeAgUjJ0AhGAIEfM4GGhAGAkYwAgEEBAkEDQMrQBwiAiECAl0mGxwCAVYkBA7YAiACAl8oBQ4OFQICWSYHCwGqCAMyBE5DU8dBLwQCDho2J1rdowUHAzk9HQUIBAMBO0sBgBEbJUAgFCM/AgwTISxOBQYYHCpLAwAAAAADADUATgKqAmYAGgAoADUAABM3IiY3Nj8BPgEzMhc2MzIWBw4BBwYjIiYjIjcnJjc+ATMyFgcOASMiAy4BNz4BNxYHDgEHInoCHygBAh8ZCZGVMhkWGT9SAQI1MGKHJYUdDe4BHQICTyETGwEBSh8MWxYUAgFBIycCAjocBgECAhoTFRICMRsBBR4dFC8VFgPkAg4YIDYcEh42/moBFBAkPwQOHh86BQADABz/kgJvAg0AMAA3AEMAABM2MzIWMzYzMjYzMhc2NyMzNjMeAhUGBxUGBxYHDgMiJwcGIyImNzY/ASY3PgEXNCcHMjY3BwYHBhc2NycGBzUG4Q8PBxQIIj0JJAgiHA84AQEBARIRDwMeBAwPAwM3WYaSJjYHBwgLAQEQECgEBHz7Bbs8ewntBgEBBhh9BwMeXgGqCAMyBAkiDgEBAw8QDxkGDwsgMTiHelIINQcNCw4YGCg+WdyVAQ/KfDg0FgsPHhuMBwIPASkAAAACAA//0wLvAyMALwBFAAA3Njc2MzIWBwYHBgc+Aj8CNjsBMjYzMhYHFAcGAgc1BiMiJjc0NycGIyImNzY1ATc+ATMyFwYHDgEjIi8BJjUnLgEnFRMaqyorHykBAg1CTzZcKyoxKQ4qDRQ6CxclAgQwphMwSSEqAQgGY1A2RwICAaEBAkErVA8IDAgXHxQSAwgJDTMDQ6TPISIaFRVLqh5RNDdDMxoRHxIIB0r+tyEBMRkUCwsGRzMxBgUCigEpKzQPQDMnCgwDBBITOAUBAAAAAgAP/9MC7wMMAC8AQgAANzY3NjMyFgcGBwYHPgI/AjY7ATI2MzIWBxQHBgIHNQYjIiY3NDcnBiMiJjc2NQEzNjMyFgcGBwYjIjU2NxU3PgETGqsqKx8pAQINQk82XCsqMSkOKg0UOgsXJQIEMKYTMEkhKgEIBmNQNkcCAgI+AQ8XHy0BAh5+QSICCwcOV0OkzyEiGhUVS6oeUTQ3QzMaER8SCAdK/rchATEZFAsLBkczMQYFAsEHFxUYIWkXERABBytaAAIAD//TAwkDVgAvAFYAADc2NzYzMhYHBgcGBz4CPwI2OwEyNjMyFgcUBwYCBzUGIyImNzQ3JwYjIiY3NjUBBiMiJjc0NzY3PgE3IzYzMhcUBg8BFgcGBxYHDgEjIic2NzQvAQYTGqsqKx8pAQINQk82XCsqMSkOKg0UOgsXJQIEMKYTMEkhKgEIBmNQNkcCAgH6RjwNEQEWiG4CBwIBRCwMCRAICAECAQgDAQIuLg4EBAcJCThDpM8hIhoVFUuqHlE0N0MzGhEfEggHSv63IQExGRQLCwZHMzEGBQHuMgoJDxyEVQIEAjcJBBwNDAwbGTIVFR8+CAoRGxsXOQAAAAADAA//0wMJAvcALwA+AE8AADc2NzYzMhYHBgcGBz4CPwI2OwEyNjMyFgcUBwYCBzUGIyImNzQ3JwYjIiY3NjUBIyY3PgEzMhYHDgEjIic3IyY3PgEzMh8BFgcOASMiJxMaqyorHykBAg1CTzZcKyoxKQ4qDRQ6CxclAgQwphMwSSEqAQgGY1A2RwICAXMCIQICXSYbHAIBViQEDtgCIAICXygFDg4VAgJZJggKQ6TPISIaFRVLqh5RNDdDMxoRHxIIB0r+tyEBMRkUCwsGRzMxBgUB/BEbJUAgFCM/AgwTISxOBQYYHCpLAwAAAAIAJv69AqIC0AA9AFAAABMmNz4BMzIWFw4BBz4CNzYzMhYzMjc2MzIWBwYHBg8BFgcUBw4CBwYjIiY3Nj8BNj8BJwYjIiY3PgE3NAEzNjMyFgcGBwYjIjU2NxU3PgFnAQEBJBoiQgwCYAQpR0cWPB0IPwwLBBsRGSUBASRrkxQmAQwtOBEIHz0gOQECLhQpEBEFNiIlNwMCOwIBrAEPFx8tAQIefkEiAgsHDlcBdQYGHh0tIx21LBdddhpXDgMQHBUTF2PxIBsjEBUgOyAXTTMhITsbPRUaBhovMyrLJhEBWwcXFRghaRcREAEHK1oAAAL/YP7QAkwDLgBDAE4AABcVDwEWFQYPATcGIyInFyY1NDcVNyY1NjcVNj8BPgE/ATYSMzIXPgEyFgcGDwEGBxc3NhcyFgcOAiMiJw4BDwI1BhMzBgc+ATc2JiMiSgEHAQJUBgEtFS0ZAQERBggCCCM6EggZBhda4joEDAwnKBoBAi4YPE4GDEc+MzQCA2ibRDIuBBEEChAarwEZCiVuBAELDB7CAgQOAwUjIwQBCR8BAggPFwEICg8RCwEpZR4NMwwr6wGTBRseHxkkQiJhigUHKQIvLkWsfC4ILAgVLQFDAUArMiF0Gw0bAAAAAwAm/r0CuALHAD0ATABdAAATJjc+ATMyFhcOAQc+Ajc2MzIWMzI3NjMyFgcGBwYPARYHFAcOAgcGIyImNzY/ATY/AScGIyImNz4BNzQ3IyY3PgEzMhYHDgEjIic3IyY3PgEzMh8BFgcOASMiJ2cBAQEkGiJCDAJgBClHRxY8HQg/DAsEGxEZJQEBJGuTFCYBDC04EQgfPSA5AQIuFCkQEQU2IiU3AwI7As0CIQICXSYbHAIBViQEDtgCIAICXygFDg4VAgJZJgcLAXUGBh4dLSMdtSwXXXYaVw4DEBwVExdj8SAbIxAVIDsgF00zISE7Gz0VGgYaLzMqyyYRohEbJUAgFCM/AgwTISxOBQYYHCpLAwAAAgAp/7IESwMLAFIAXQAAATMeAQcOAQcOAQc1BwYPARYzMjYzMhUUBwYHMw4DBw4BBwYzMjcWFRQGFQYWFQ4BBzMGIyoCLgQnBiMiJjc2NxU+ATMyFzYzMhc2MzIBNhI3AA8BFhc3NgQXARoZAgJXOjowEQYpDQsRExJAChIELEkBEBQIGBoZPQEBXBpCDwQBFgFIKQFZSAIcDBwRGhIUCDpPa2IEB4tHtVseGiUoOSeTWRD9Q1WGDP75MgMJHBIXAwIBGRQqVwkOFRYBCDAhGggJCgIIVhgDBgIDASBeEw8IBg4CDwQHFAQRQA8XAQIEBwkGI3pTj+ABbZoKITUw/UFUASB6/vGlEz4NDRAAAAADABz/xgNpAekAOwBOAFkAACUVDgEHHgEzMjYzMhceAjsBMh4CBw4BIyInBgciLgQ3PgIzMhYzNjMyNjMyFzYzMgcGBzUOASUnBisBDgIHFB4COgEzMj4BJScmIyIPATI2NzYCrg54JQIZCxNcExQSBAgFBgEBBQQDAQKjWlspOFQgHDwfJQ4CA0pqKwYUByE+CSYIWiZfZW4FAgseQv52BxgRBgI/OAIDBAoFDgMrQBwBPQQKBDQxCidYAQGRAQYYAxETIBANDAEEBg0JJzEiIQQBBhEdMSFAqXwDMgQ5PWEbJwFPRS4FBwMxQyAGCAQCO0t6BAJYGk4bAQAC/+7/xQNwBG0AOgBhAAAXIyImNz4BMzIWMzI3Njc2Jy4BNzQ3PgE3NjMyFx4FHwEWBw4BBwYHJiMiBgcGHgIHDgQBIzY7AjIWBwYHNQYPAQYjIicXJjU2NyYnJjc2NzIXFAYVFh8BNpgORlYCAjAjE1kUFg9hAgEqMjMDCBppPnRdHC8HDwkOBg8CCQ8CAS0bAmMiDDoyAwElLSQCAh9DWoYB8AElIQoJHCcBAQ1tWwwoKCENAQICFQYGDAICKygJAwESCjY7QS8iOBIGHyUYJi5RNBQdVnYeNwcBBQUKBA4BCBMSGCUCOg0CKDcQKyhHKB1LVkcvBGcTFxQQEgFpPQkdGAEGAxEQBoMyFS8GFgUVARkmGTYAAv/f/6QDJQNZAC0AVAAABQYjIiY3PgEzMhYzMjY7ATI3JicuAjc2Nz4BMzIWBw4BBw4DBxYHBgcGBwEjNjsCMhYHBgc1Bg8BBiMiJxcmNTY3JicmNzY3MhcUBhUWHwE2AWNef0ZhAgEXEAIJAhMdDCKXDw0mHB8ZAQINCdNnLx4CAS8oJigGCgptBAMZAkkBFwElIQoJHCcBAQ1tWwwoKCENAQICFQYGDAICKygJAwESCjYZQzYtFBoBMyYQEg0WLB8fFkFmJh0ZLAsHCQUHA1ZXLDAfLgMnExcUEBIBaT0JHRgBBgMREAaDMhUvBhYFFQEZJhk2AAAD////pwL+A+AAMwBCAFEAAAEXFhc/ATY3BzYzMhYHDgIHDgIHFzIeARUUBzMGIyImNzY3Nj8BBiMiNzQ3Njc+ATMyLwEmNz4BMzIWBw4BIyInNyY3PgEzMhcWBw4BIyInAY0DBAkJLGs/ARccFx0BAj10BhuRVykIAgYEDgFAUy9CAQIFG2RYAgQcBAQOEgdYJSINAiECAlwkHB0BAlYkAw7WIQICXicQDxgBAlgnCgUCthciYwk1gykBChMVJV+FCCW9gUwGCxIIDQ44JRsMCTWHdgEtChafUCpOSAEQHCFEIBUjPwIMFCArTwcaHCtKAQAAAwAF/7cDhASBADgAPABkAAAlFzYHDgEHBiMiJy4BNzY3PgE/ATY3NjcVNzY3BiMiJy4BNzY3PgEzMhcjFhcHHwEWBw4DBw4BFyMVMxMjNhc2FgcUBzUGDwEGBwYnJj8BNSY1Jjc2NzYXFA4BFTUGFRYfATYBcW47AgJAKWCRNCorLgICAwgcJQ01im02BQwZNSwxLRIVAQIgMqxUGgwBGAwEERQgCww9Yj4zOCSHCQn8ASonIC0BDm1cCiYRMxQDFgELDQECLigJAQICAw4MKIEMASgfRAwoBgYkKxYMGicqDzyBZDkCBg4pCwwFHRMfGy40AQcQFwQFDz4xbnZENTo2FAsDzBYDAhgWDhMBajwHGwIJHRkQCAU7QzUSLQcCFwIFCAIBBgYWJB0pAAAAAAL/+P+4AxgDdgAvAFUAACUXNjMyFgcGDwEGIyInJjU+Ajc+AScmJyYnLgE3PgE3NjcyFx4CNzYWBw4BBwYTIzYXNhYHFAc1BgciBwYHBicmPwEmNSY3Njc2FxQGFQYVFh8BNgEhAxIZKz4BARYh5U5MBgICSkQ3KyYEEQYLFBgYAQIuJm+yCQQCBhENDg0BAjEig+cBKicgLgEPZmIBECIQMhcDFwQODAECLSYMAgIBEgouYgkFJSEXIAYjFwcSJ2I8LCInDQMEBQMEFA8VMxE2ChEKCwgCAhAQIFMWcAJ2FwMCGRUMFgFjRAoYAgcbFhQNO0QtGy0GBBkBDAEIBRQsGTAAAQAS/5EC+gMoAD4AABc1PgE3JicmKwEiJjc0PwE2PwE+ATc+ATMyFx4BBxQHDgEHDgEHFBc2NxYVBg8BDgMPAQ4CBwYjIiY3NhkCawcFBAwKDBA7AiM3SAobF2spLqs5OAUCHgECEzktLKcCAmspEwEKCQocMRskNAtrSwsnKB4pAgIWAhTjIQUKBCcbFA0EBQkWQ6IkKFUwFBgMCQYrJQwMdSQDBiMCDAkHEhETGhMHCAwV0ogELikbDgABAHoBzQIWAyMAJgAAAQYjIiY3NDc2Nz4BNyM2MzIXFAYPARYHBgcWBw4BIyInNjc0LwEGARpGPA0RARaIbgIHAgFELAwJEAgIAQIBCAMBAi4uDgQEBwkJOAH/MgoJDxyEVQIEAjcJBBwMDQwbGTIVFR8+CAsQGxsXOQAAAQDgAhMCQwNZACYAAAEjNjsCMhYHBgc1Bg8BBiMiJxcmNTY3JicmNzY3MhcUBhUWHwE2AagBJSEKCRwnAQENbVsMKCghDQECAhUGBgwCAisoCQMBEgo2AxgTFxQQEgFpPQkdGAEGAxEQBoMyFS8GFgUVARkmGTYAAQB7AmoCjAONACYAABMmNjc2MzIXFhcGBxYXMjc2NzY3BzYzMhYXBgcGBwYjIiYnMyY3No8GKiwYGSsxEQECAwgRORYLCSURARsXEhoED1kuOzY4RW4VAQoBAwMgJDYMBx4UIRwFEAwLBwgjDAEMFBFFKy4TETMyHCMZAAEAggJWAWIDDAAOAAATJjc+ATMyFgcOASMiLwGpJwICcSsZJwECYywFEg4CXhMhKVEnGipLBAIAAgB7AisCUQNyABUAJAAAEzY3PgEXFgcGBw4BJyYnLgEnJjc+ARcnNwYHJiMiJiMOARcWNsQyWCVsJE4DBVgnfDQpJQkjBSADASfyAQUhGgwOAw0CEgwPHVUDJyoMEAURKUxPPhwYAwMGAxkFGS4kSkoECAcCAgESKgwRLwAAAAAB/7/+mQGZAFUANgAAFwYWPwE+AT8BNjMyFgcUDwEGBzUGBzUHBiMiJy4BNzQ3PgE/ATY3NjMyFgcOAQc2NQcOAQcOAXELGBIRDk4RFSgHHikCExQQCxguA09VSzoSEgIFE0RKHk8gKCgTGQEBOSMDDQ4kCAY4nRYUAQEELgUGCx4VEx0QFAsBGBgBAyccCTIfDhJMSRsKGSwnDhIfURYBAgYHEwQDFgABAH4CegICAzgALwAAAS4BIyIPAQYjIicXJjc+ATc2MTcjNjMyFgcUBhUUHwEWFzY/ASM2MzIVBgcOASMiAUkHKBAECCAsEgQCAR0BATkpBhwBKxsRFgEDAgIGCBwVCQErFwkCOCYoEwoCjAEmAhYhAQETERg/FwISGBARAgcBAwQMFQwFCAYiDxwmHxcAAAACAQgB3wLMAywAEgAkAAABFT4BMzIWBwYPAQYjIjc0Nz4BByc+ATMyFhcGBzUHBiMiJjc0AgoJRSggLAIFUBsYJSYDAgQH9wgEXjEaJgQOMzEYIxEUAQLAATQ5KiROXh8iKwkGGWOOSE5xMS4sXgE5IBQVCQAAAAABADUBAQKqAaoAGgAAEzciJjc2PwE+ATMyFzYzMhYHDgEHBiMiJiMiegIfKAECHxkJkZUyGRYZP1IBAjUwYoclhR0NAQICGhMVEgIxGwEFHh0ULxUWAwAAAQA0APIDOQGwACIAAD8BIyImNzY/AT4EPwE+ATM2MzIWBwYHBgcOAwcOAXwFCR8lAQIeGgIWGDMeIhsf9jIbMTVEAQItDBAXZrZSZxtb8gIYEhUSBBAYDg0FBQQDCwgdGRojBAsQFgsCAwEFAAAAAAEAYgG2AXAC/QAYAAABDgEHDgEjIj8BPgE/ASM3PgQzMgcUAWkDLA0aUiE+AwMJITc0AQ0FFQoSEQkXAQLJBqMOKjJMEh8rNTILBBMHCwQZCwAAAAEAggHgAY4DMQAXAAATPgE3NCc1PgEzMhYHDgEPAQ4CIyI1NooaFwIBGlMjHCYBAThKKREQGg4WBwIXQW0EAQMDLDUjHiBQTycQDgwdGAAAAv/y/1UBBgBhAB4AIAAANxcWFwYVBwYHDgEjIiY3Nj8BJwYjIi4BNT4BMzIXNxcH7wMLCAECBz8gTiIUJgEBMQsKAQECCggCVDYoKAQWAUQGFQgBBCMsLSEqEhIOPg0MAQ4YCioqJAMeAQAAAwBkAbYCOwMPABYAMQA1AAABNQYWBgcOASMiJjc+AT8BNjMyBxQHBjcXDgEHNQ4BIyImNzQ+ATc2Nz4DMzIHFAYXNQcXATACAwgLGkYeHCACATVOLiIeGAEHIvEBDQoLDzwfGiQBCAsBCzwFGg8aDRwBAwIBAQIkAQYGDgsjJyklJUBKLhwZBBc8VQElXBMBFxoUEwcTFwQnNgUbDQweAgsDAgIBAAAAAgDfAe8CvQMuABwAPAAAASM+ATc2MzIWBxQGFTcGBwYPATMPATMGIyImNzQnNTY3NTQ+ATcVNjc2MzIWBxQHFQ4CBw4DIiY3NAGvASUdEz0/HCIBAgE1AQkpJQEUIAEdHw0PAcEZAgECAQMGIkMdJQELAxwXGQgbERoaEQECKT5oHEMjIQQNAwFSAQolIhAaGg0NCTMCRC8IAQYGBAEHAS4WFA4PAhUrFhUGGg0MDQ0EAAAAAgAE/1QBxwChABgAMQAAJRU+ATMyFgcOAQcOBiMiNzQ3PgEHNyY3PgEzMhcHFxUHFw4BBzUHBiMiJjc0AQYLQychKwIDLCcCEgYQCQ4OCCQDAQQH9gEKAgRdMT4GEQEBAQ8gAjEYJQ8TATUBNDkpJDJPLgMVBhAFCQMrCQYYZJEDIiVOcl4bAgICARhNBAE5IBQVCQAAAAAB/+7/eAIzA3sARQAAEzciJjc2PwE2NzY/AT4CNz4BMzIHBh4CFQYHNQYPATI2MzIWBwYHBgc1BgcGBzUHDgQjIic2JjU2NRU2NyImKwE5ASIqAQI/ExVvERceDQ4WDhk+FBYBAQ0PDQIGCSciBhwEL0QCAiMIGTtNUWwMAhQMFRgOBRIBIgJCSgciByEBVQIaEx4YAjESNj1RJCMoDhgjGQsJAQoLDhIBF4dyAyceHCMCDAEcBt2vAQ8DHAwUCAQUNhEGAgGG8gEAAAAB/67/cAIoA3sATwAANQYjIiY3Njc2NyInMy4BNzY/Aj4DNz4BMzIVHgE2FgcGBw4BBzceAQcOAQciJwYHPgEzMhYHDgEHBgcGBzUHFA4EIyInNiY/AQYFDB8iAQS9IgcYFgEeIwEDhBkhCRcNGA8aOxQWAg4OCwEDAwgvEC0wMAIBSj4kBSkYD08PGxwBAkc4LjM9JQsUBhQPFwwLCgEgAUQfcgEfFksYWxcCBhsRNh8GYxlQKTAOGiQbCggBCwwVCRibMQQDIBYcLAMIbjYCDBYRGz4QCQd9QgEQARsIFggIAxM6E6QCAAAAAAEAcQD/AeECIwAZAAABFgcGDwEGBxQGBw4BIyImNz4BNT4BMzIWMwG2KwICNAEICAMDAUcxQ2UCARIWhEsLLgsCGBokNiIBEAcDKw4WGS0qCzQDRUYLAAAD//n/jgK4AEEADwAeAC0AABcjJjc+ATMyFxYHDgEjIic3Jjc+ATMyFgcOASMiLwElNSY3PgEzMhYHDgEjIiYgASYDAm0rFg4eAQNjLAQQ+SsCAmwrICYBAmMrBRAPAQoeAgFMIBQeAQFHHgQSbRQhKVAHIRgrSAISER0jRiMWJT8CAhkCDBYZMBcQGi8DAAABAEEAKwIQAmMAMgAAATc2MzIWBwYHDg0VBh4BFw4BBy4FJzI+ATU2JzY/AT4DAbYLEAYVJAEBDAEKFBMhFSgRKAgVERMLASlAEAIcDggwMTwvIQMBBwkCAwlBEAhnK1ACXAMEJiASFw0ZGRQXDxYKFAQKCQoKBBEyRhsaKwQEDg8eJ0EoEhkJCQgjNw0GUB4zAAAAAQANAFIB7gJwACwAAAE3Jy4BJxcmNT4BNxU2MzIXHgEHBgc3BxUGBzcGBzcGBzMHDgEHNCY3NDc2NwEiJxoGUA8BBgIzKRURIhgYUwICAgEVAQ0BDxwBKi8BCivaJwIBGyi/ASgPHgdbFgEQDxxKFgEKKhmaJgwGAR4GGSQBGxMBFQoCCFAEAhoGESIzRwAAAf+5/zEDOgNLACwAAAE1Nz4BNxU3PgE3Mx4BFwYHBgcWBwYHBgcGBwIHNQYjIiY3Njc+Ajc2PwE2Aj8BAgQCCAI8NgYwOAgDJQUCBSA7WgoWTKHhZgsMFSIBAhkudlVIgTskKgLrAQICBQMCCRgqCgMdJxYlBAIfIjBiDBhTxv7uZQEMJhwhH0ulbVqeUTA/AAAAAAL/i//CAzMDGQCBAIYAAAEyHgMVDgMHBg8BBjMyPgE3PgMzMhYHBgc3BiMiJy4BJzcOASMuATc2PwE2NwYjBwYjIiY3ND4HPwE+ATc+ATc2MzIHDgEjIiYjBxcjFhcjFjMyNjMyFQYWMhUUBxYHDgEjIicrASIGIyInBgc+AjcWFzMyFhcnFTMWAmsBCgQGAgEtTE4uEwlABkcNHi8OBx4UIRITGAEDAQFimF4lOEYEARGBIRQcAQLMJRAoDwUiMAUZKQEHDA0VDxkPGAUpBAkQKGpsYHWGAwJ9QgIIAnUBAQsGAQgKCEYUKgEVFQENAgFXNBcUHBEKKgoOGB0TEUk5GDAlAQEPGwMBAQEzAQIDCAUXJBYPBwMBCo4IEQQFFg0MDw4NBAF/HRdcOxYBCgQTCyocBTdOBQQFDxIGCwoHBwUGAwUBCAEFA2J3Kyo+KUkBOggCAQMGCxUMBQMDFhIkKwYBAi4oAxELAgMTAwYDAgEAAAMArAIFAsYDIAAmAE8AUwAAEwYjIjU0Nz4DNyIHKwEiJjc+ATMyFhcGBzMOAiMiJiMiDwEGJTIfARQWFQYPAQYHFzYzMhUGBwYjIiYnNjcnDgEjIicOASMiJjc2NzYXJxUW7xIRIAwNGwsUDwEHBgQODAEBdEoLFAEHAwEGDRYTAQMBCgUJUgENCQ8CAQEIAQIOCVU1FzQ0CSUHDwEODggXFRAVBRslHw0QAQFFPVcDAQIZFA8EFho4FCIXAQgJFywKBgcBAhgVAQYOiNUDBQECAQIGEwogBF8PlVYRCgklGQUVCSQ3KAcGFntmBAQDAQAAAAABAGwA+AKSAa0AHwAAPwEiJjc2PwE2NyM2MzIXNjMyFgcGBzcGBzUGIyImIwa6BSYtAQI+FB58ARhDKhUSFTNEAQItAQoUWoUcbBoD+gIWERoXAkEQAgEFIB0gJAEECgEoBAIAAAABAAABjgABAEABgAAGAAAADABY//8ADABZADIAJgAM/8oAJwAM/9kAKQAM/6oAKQA0ACcAKgAM/+EAKwA5AC8ALAAM/8oALQAM//AALgAM/+kAMAAM/9EAMQAM/7kAMQA+//AAMgAM/8kANAAM/6sANAAsABgANAA1/9kANAA3//EANQAM/8kANgAM/+EANwAM/9kANwAmABcANwAsAB8AOQAm/9EAOQAt/+gAOQBG/6oAOQBI/+AAOQBJ/9kAOQBK/7kAOQBM/8EAOQBN/9kAOQBO/+gAOQBT/8EAOQBU/7kAOQBa/6oAOQBe/8EAOgAM/9EAOgAo/9kAOwAMABgAPAAm/9EARgAM/5oARwAM/5MASAAM/4MASgAM/5MASwAMACcATAAM/3sATQAM/4MAUAAM/4sAUgAM/5MAUwAM/5wAVAAM/3sAVABV/+kAVQAM/6IAVgAM/7IAVwAM/7oAWAAM/4MAWQAMAAgAWgAM/7IAWwAM/9EAXAAM/8EAXQAM/8kAXgBR//gAXwAM/8IAAAAAAB4BbgABAAAAAAAAADcAcAABAAAAAAABAAcAuAABAAAAAAACAAcA0AABAAAAAAADABkBDAABAAAAAAAEAAcBNgABAAAAAAAFAA0BWgABAAAAAAAGAAcBeAABAAAAAAAHACYBzgABAAAAAAAIAAsCDQABAAAAAAAJAAsCMQABAAAAAAAKADcCrQABAAAAAAALAA4DAwABAAAAAAAMAA4DMAABAAAAAAANAAMDRwABAAAAAAASAAcDWwADAAEECQAAAG4AAAADAAEECQABAA4AqAADAAEECQACAA4AwAADAAEECQADADIA2AADAAEECQAEAA4BJgADAAEECQAFABoBPgADAAEECQAGAA4BaAADAAEECQAHAEwBgAADAAEECQAIABYB9QADAAEECQAJABYCGQADAAEECQAKAG4CPQADAAEECQALABwC5QADAAEECQAMABwDEgADAAEECQANAAYDPwADAAEECQASAA4DSwBDAG8AcAB5AHIAaQBnAGgAdAAgACgAYwApACAAMgAwADEAMQAgAGIAeQAgAFQAeQBsAGUAcgAgAEYAaQBuAGMAawAuACAAQQBsAGwAIAByAGkAZwBoAHQAcwAgAHIAZQBzAGUAcgB2AGUAZAAuAABDb3B5cmlnaHQgKGMpIDIwMTEgYnkgVHlsZXIgRmluY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuAABLAG4AZQB3AGEAdgBlAABLbmV3YXZlAABSAGUAZwB1AGwAYQByAABSZWd1bGFyAABUAHkAbABlAHIARgBpAG4AYwBrADoAIABLAG4AZQB3AGEAdgBlADoAIAAyADAAMQAxAABUeWxlckZpbmNrOiBLbmV3YXZlOiAyMDExAABLAG4AZQB3AGEAdgBlAABLbmV3YXZlAABWAGUAcgBzAGkAbwBuACAAMgAuADAAMAAwAABWZXJzaW9uIDIuMDAwAABLAG4AZQB3AGEAdgBlAABLbmV3YXZlAABLAG4AZQB3AGEAdgBlACAAaQBzACAAYQAgAHQAcgBhAGQAZQBtAGEAcgBrACAAbwBmACAAVAB5AGwAZQByACAARgBpAG4AYwBrAC4AAEtuZXdhdmUgaXMgYSB0cmFkZW1hcmsgb2YgVHlsZXIgRmluY2suAABUAHkAbABlAHIAIABGAGkAbgBjAGsAAFR5bGVyIEZpbmNrAABUAHkAbABlAHIAIABGAGkAbgBjAGsAAFR5bGVyIEZpbmNrAABDAG8AcAB5AHIAaQBnAGgAdAAgACgAYwApACAAMgAwADEAMQAgAGIAeQAgAFQAeQBsAGUAcgAgAEYAaQBuAGMAawAuACAAQQBsAGwAIAByAGkAZwBoAHQAcwAgAHIAZQBzAGUAcgB2AGUAZAAuAABDb3B5cmlnaHQgKGMpIDIwMTEgYnkgVHlsZXIgRmluY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuAAB3AHcAdwAuAHMAdQByAHMAbAB5AC4AYwBvAG0AAHd3dy5zdXJzbHkuY29tAAB3AHcAdwAuAHMAdQByAHMAbAB5AC4AYwBvAG0AAHd3dy5zdXJzbHkuY29tAABPAEYATAAAT0ZMAABLAG4AZQB3AGEAdgBlAABLbmV3YXZlAAAAAAACAAAAAAAA/7UAMgAAAAAAAAAAAAAAAAAAAAAAAAAAANUAAAABAAIBAgEDAAMABAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwAPQA+AD8AQABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQCjAIQAhQCWAI4AiwCpAIoAgwCNAMMA3gCeAKoAogCtAMkAxwCuAGIAYwCQAGQAywBlAMgAygDPAMwAzQDOAOkAZgDTANAA0QCvAGcA8ACRANYA1ADVAGgA6wDtAIkAagBpAGsAbQBsAG4AoABvAHEAcAByAHMAdQB0AHYAdwDqAHgAegB5AHsAfQB8ALgAoQB/AH4AgACBAOwA7gC6ALAAsQDkAOUAuwDmAOcApgDYAOEA2wDcAN0A4ADZAN8AsgCzALYAtwDEALQAtQDFAIIAwgCHAKsAvgC/ALwBBACMAO8ETlVMTAJDUgRFdXJvAAAAAAAAAf//AAIAAAABAAAAANl6UQAAAAAAzDnznAAAAADMOYEk"

/***/ }),

/***/ "./node_modules/base64-loader/index.js!./node_modules/scratch-render-fonts/src/NotoSans-Medium.ttf":
/*!************************************************************************************************!*\
  !*** ./node_modules/base64-loader!./node_modules/scratch-render-fonts/src/NotoSans-Medium.ttf ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "AAEAAAASAQAABAAgR0RFRvDX3ecAAAEsAAAFwEdQT1MvEF4NAAAG7AAA6sZHU1VCRDfqagAA8bQAABaAT1MvMmx0h2AAAQg0AAAAYFRURkG4URjDAAbmAAAAAf9jbWFwwp/+5AABCJQAAAouY3Z0IH+0EkYABtYcAAABdGZwZ206KI58AAbXkAAADW1nYXNwAAAAEAAG1hQAAAAIZ2x5Zi0YCicAARLEAATOUGhlYWQQlAHGAAXhFAAAADZoaGVhDLIUJwAF4UwAAAAkaG10eHvlIUEABeFwAAAynGxvY2Ed1/m0AAYUDAAAMrxtYXhwD5AQAwAGRsgAAAAgbmFtZaT1yjEABkboAAAGlHBvc3Sx9QeqAAZNfAAAiJVwcmVwNpqJYAAG5QAAAAD9AAEAAgAOAAADWgAAA6wAAgCMACQAPQABAEQAXQABAIIAmAABAJoAuAABALoBSQABAVUBVQABAVcCAAABAhcCFwABAiACIAABAigCKAABAj0CPQABAkACQAABAkICRQABAkcCSgABAkwCaQABAm4CcQABAnUDVQABA2AEhQABBKIEpgABBMEEwQADBMUExwABBMkEzAABBM4FEQABBRUFFQABBRgFVgABBVwFXAABBWMFZAABBWYFaQABBWsFcAABBXQFdAABBYcFlQABBZcG6wABBu4G7gABBvEHFwABBxoHJgABB0AHRAABB0gHSAABB1wHcQABB4UHiAADB4kHqwABB8QH0wABB9YH2wABB98H3wABB+MH5AABB+kH7AABB+4H9gABB/kH+QABCAUIBQABCAoICwABCA0IDgABCBAIEgABCBUIFgABCBsIPAABCEYIRwABCEwITwABCFEIUgABCFQIVQABCFgIWQABCFwIXAABCF4IXwABCGQIZwABCGkIaQABCHQIewABCH0IhQABCIYIjAACCI0JDgABCRAJEwABCRYJGQABCRwJHAABCSoJMQABCTMJMwABCT0JSwABCU4JTwABCVYJVgABCVwJXwABCWMJYwABCWUJZQABCW8JbwABCXIJcgABCXQJeAABCXoJfgABCYwJjQABCZcJmAABCZwJnAABCawJrQABCa8JrwABCbEJsQABCbMJswABCbcJtwABCboJugABCbwJvAABCcMJxQABCdYJ1gABCd4J5gABCegJ6QABCesJ7AABCsgKyAABCtYK1gABCtgK3wABCuIK4wABCuoK6wABCu8K7wABC4ALgAABC4ELiwADC4wLjAABC40LoAADC6ELogABC6MLswADC7gL3QADC94L3wABC+AL4QADC+IL4gABC+YL6gABC+sL7AADC+0L7QABC+4L7gADC+8MBAABDAYMDwABDBIMKQABDCwMLQABDC8MMQABDDIMMgADDDoMPAABDD4MPwABDEAMQQADDEIMRgABDEcMRwADDEgMSAABDEsMUwADDFUMVQABDFYMVgADDFcMXAABDGAMYAABDGMMYwABDGYMcwADDHQMdAABDHUMhwADDIgMiAABDIoMigABDJAMkQABABIABwAkACwANAA0AEIAQgBKAAEABwDzAPQIhwiICIkIigi/AAEABAABAVMAAQAEAAEBAgACAAYACgABATsAAQJ3AAEABAABAS0AAQAEAAEBIwABAAQAAAAUAAAA2AAAAPoAAAG4AAIAIAIoAigAAAuWC5kAAQucC7IABQu4C7sAHAvCC8QAIAvIC8kAIwvOC9EAJQvUC9UAKQvXC9cAKwvaC9oALAvdC90ALQvhC+EALgvrC+sALwvwC/AAMAv3C/wAMQv/DAQANwwGDA0APQwQDCYARQwoDCkAXAwsDC0AXgwvDDEAYAwzDDkAYww8DDwAagxJDEkAawxODE4AbAxVDFwAbQxgDGAAdQxmDG0AdgxvDHMAfgx1DHcAgwx5DIAAhgyCDIcAjgABAA8Lswu0C7ULtgu3DAYMDAwcDD0MbQxxDHYMegx+DIMAAgAfAVMBVAAABMEEwQACBuwG7AADBu4G8AAEBvsG/QAHBwgHCgAKBxgHGgANByUHJgAQB1YHVgASB4UHiAATCt4K3gAXC4ELlAAYC7wLwQAsC8ULxwAyC8sLzQA1C9IL0gA4C9YL1gA5C9gL2QA6C9sL3AA8C94L4AA+C+IL6gBBC+wL7wBKC/EL9gBOC/0L/gBUDAAMDwBWDBIMMQBmDDoMOwCGDD4MSACIDEsMTQCTDE8MYgCWDGYMhwCqAAEALAuVC5oLmwvTDAEMAgwEDAYMBwwJDAoMCwwMDA0MHAweDB8MIQwnDCgMKQxYDGsMbQxvDHAMcQxyDHUMdgx3DHkMegx8DH0Mfgx/DIAMggyDDIQMhQyGDIcAAQAAAAoANABuAARERkxUABpjeXJsABpncmVrABpsYXRuABoABAAAAAD//wADAAAAAQACAANrZXJuABRtYXJrABpta21rAC4AAAABAAAAAAAIAAEAAgADAAQABQAGAAcACAAAAAQACQAKAAsADAANABxv7pEglsC+1NFS0wLTytWC2Bbd8N6Q6MoAAgAIAAIAChumAAEDVgAEAAABpg/6BqYP+giGEAwP9BAMFpYJfBdmFrIWpAb0B64XZgloFrIJNBayB9wIRhb0D+oP6hdmFtwJcgiGCHQW7hbuFu4IhgiQECoQMAjiFpYWlhaWFpYWlhaWFqQXZhakFqQWpBakFrIWshayFrIWshayFrIW3Ak0Fu4W7haWFpYJQhdmF2YXZhdmFrIJXhayFqQWpBakFqQWpAlYF2YJaAloCWgJXgloCWgWshayFrIWpBb0FvQW9A/qFu4W3BbuFtwJcglyCXIWlhakFrIXFBdGFyIXYBcUCXwKaBcUCZIXRgrYFxQJ5BdGFzQKIgpoFyIKggrYCt4XYBciFw4XDg3gC1gNDg0kDXIN4A3mFMoUlg60FQgUvBSWDr4UyhaMFQgVCBDSFJYUyhS8DwQVCBaMFowUnBScEMwQzBDMEMwUyg/qFu4P6hbuD+oW7hbcFu4P9A/0D/QP+g/6EAwP+g/6EAwQKhAwF2AQRhciFpYWvBbGEMwUlhSWEFwUlhBcEGIUvBS8FJYWjBDMENIU5BDYEXIU9hScFPYVCBUIFQgWjBTkEYwSNhKcFJYUyhLWEtYU9haMFowS8BOaFQgT6BZ2FowWjBaMFJYUlhUIFJwUohS8FLwUvBTKFOQU9hUIFRIVEhaMFRIVEhUYFXoVyBZ2FowWlhaWFpYWlhaWFpYWlhaWFpYWlhaWFpYWpBakFqQWpBakFqQWpBakFrIWshayFrIWshayFrIWvBa8FrwWvBa8FsYWxhbGFsYWxhbcFu4W3BbuFtwW7hb0FyIXIhcOFw4XDhcOFw4XDhcOFw4XFBcUFxQXFBcUFxQXFBcUF0YXRhdGF0YXRhdGFyIXIhciFyIXYBdgF2AXYBdgF2AXYBdgFw4XDhcOFw4XDhcOFw4XDhcOFw4XDhcOFw4XDhcOFw4XDhcUFxQXFBcUFyIXIhciFyIXNBdGF0YXYBdgF2YXZhdmF2YXZhdmF2YXZhdmF2YXZhdwF4YXhheGF4YXhheGGLAYsBiwGLAXjBfWF9YX1hiwGLAYsBiwGLAYsBiwGLAYsBiwGLAX4BguGLAYthleGQwZXhleGV4ZbBm+Gb4Zvhm+Gb4ZyBouGi4aLhouGi4aPBpGGmQaqhq0G1oAAQGmAAUACQAKAAsADwAQABEAJAAlACYAJwAoACkAKgAuAC8AMgAzADQANQA2ADcAOQA6ADsAPAA9AD4ARgBZAFoAXABeAGMAbQB9AIEAggCDAIQAhQCGAIcAiACJAIoAiwCMAI0AkgCUAJUAlgCXAJgAmgCfAKAAvwDBAMIAxADGAMgAygDMAM4A0ADRANIA1ADWANgA2gDcAPAA9wD6APwA/gD/AQABAgENAQ8BEQETASMBJQEnATUBNgE3ATgBOQE6ATwBPgFCAUQBRgFVAVoBWwFcAV4BXwFgAWEBYwFlAWcBaAFrAWwBbgFvAXABcQFyAXMBdAF1AXcBeAF9AX8BggGEAYYBhwGJAZMBnQGeAZ8BpgGnAakBqgGsAa0BrwGzAbkBugG7AbwBvQG+Ab8BwgHLAdAB4wHlAfEB8gH3AfkB+gH7AfwB/QH+Af8CAAIBAgICAwIFAgYCBwIJAgoCCwITAhQCIAI/AkACRAJHAkkCUwJUAlYCVwJYAlkCYAJkAmYCcAJ1AngCeQJ7An0CfgJ/AoICgwKFAocCiQKLAo0CjwKQApECkwKVApcCmQKbAp0CnwKjAqQCqgKsAq0CrgKyArYCuQK7AsUCyALJAtcC2QLbAt8C4wLlAucC6wLtAu8C8QLzAvUC9gL3AvkC+wL9Av8DAQMDAwUDBwMJAwsDDQMPAxEDEwMVAxcDGQMbAx0DHwMhAyMDKQMrAy0DLwMxAzMDNQM3AzkDOwM9Az8DRQNHA0kDSwNNA08DUANRA1IDUwNUA2AEygTLBj4GPwZABkEGQgZDBkQGRQZGBkcGSAZJBkoGSwZMBk0GgAaBBoIGgwaEBoUGjgaPBpAGkQaaBpsGnAadBp4GnwagBqEGogajBrAGsQayBrMGtAa1BrYGtwbgBuEG4gbjBuQG5QbmBucG6AbpBuoHEwcUBxUHFgcXByAHIQciByMIjQiOCI8IkAiRCJIIkwiUCJUIlgiXCJoImwicCJ0IngifCKAIoQiiCKMIpAivCMcIyAjKCNQI1QjWCNcI2AjZCNoI2wjcCN0I3gjgCOEI4gjtCO4I7wjwCPEI8gj+CP8JAAkBCQIJAwkE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/+ICiv/sApX/4gKW/+wCl//sApn/7AKd/+ICnv/sAp//2AKg/+wCof/YAqL/7AK0/9gCtf/sAt3/2ALe/+wC7f/iAu7/4gLv/+IC8P/iAvf/4gL4/+wABgAF/+IACv/iAgb/4gIK/+IC7v/sAvD/7AAqAAX/sAAK/7ABnP/OAaIAMgGl/84Bu/+mAcD/xAHD/84B2//YAeD/7AHj/9gCBv+wAgr/sAJg/8QCZP+6Amb/ugKJ/84Civ/YApX/pgKW/9gCl//OApn/zgKd/84Cnv/YAp//xAKg/+wCof/EAqL/7AKl/+ICpv/sAqf/4gKo/+wCtP/EArX/7ALd/8QC3v/sAu3/pgLu/9gC7/+mAvD/2AL3/84C+P/YABkABf+6AAr/ugHb/84B4P/sAeP/zgIG/7oCCv+6AlH/7AJl/+wCZ//sAm//7AKK/84Clv/OApj/7AKa/+wCnv/OAqD/7AKi/+wCpv/sAqj/7AK1/+wC3v/sAu7/ugLw/7oC+P/OAA4BnP/sAaX/7AG7/+IBw//sAmT/9gJm//YCif/sApX/4gKX//YCmf/2Ap3/7ALt/+wC7//sAvf/7AAGAb3/4gHo/+wB7f/YAlv/7AJh/+wC+f/2ACoABf/iAAr/4gGc/+wBpf/sAbv/xAHA/9gBw//sAdv/7AHc//YB4P/2AeP/7AH1//YCBv/iAgr/4gJg/9gCZP/iAmb/4gKJ/+wCiv/sApX/xAKW/+wCl//OApn/zgKd/+wCnv/sAp//2AKg//YCof/YAqL/9gK0/9gCtf/2Atj/9gLa//YC3P/2At3/2ALe//YC7f/YAu7/7ALv/9gC8P/sAvf/7AL4/+wAEwAF/84ACv/OAdv/7AHc/+wB4//sAfX/7AIG/84CCv/OAor/7AKW/+wCmP/sApr/7AKe/+wC2P/sAtr/7ALc/+wC7v/YAvD/2AL4/+wAKwAF/+IACv/iAaIAMgG7/+wBvf/sAcD/2AHb/+IB4P/sAeP/4gIG/+ICCv/iAlH/9gJg/9gCZP/sAmX/9gJm/+wCZ//2Am//9gKK/+IClf/sApb/4gKX/+wCmP/2Apn/7AKa//YCnv/iAp//2AKg/+wCof/YAqL/7AKl/84Cpv/sAqf/zgKo/+wCtP/YArX/7ALd/9gC3v/sAu3/2ALu/84C7//YAvD/zgL4/+IAAQG9/+wAAQHo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AFkAUgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/8QAAAAAAAAAAAAAAAAAAAAA/9gAAP/i//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/ugAAAAAAAAAAAAD/2AAA/7oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAAAAD/9gAAAAAAAAAAAAAAAAAAAAD/9gAAAAAAAAAAAAAAAAAAAAAAAP/YAAAAAAAAAAAAAP/iAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7P/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/7oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2/+wAAAAAAAAAAAAA/+z/9v/s//YAAAAAAAAAAAAAAAAAAAAAAAAAAP/YAAAAAAAA/+z/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAP/2//YAAAAAAAAAAAAA/+IAAAAAAAAAAAAA/+IAAAAAAAAAAAAAAAAAAAAA/84AAP/OAAAAMgAA/+L/4gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/9gAAAAA/+IAAP/Y/8QAAAAAAAAAAAAAAAD/xAAAAAD/zgAAAAAAAAAAAAAAAAAA/8QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4v+wAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/9j/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/nAAD/zgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAA/9gAAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAA/+wAAAAA/84AAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/84AAAAA/+z/7P/i/87/xP/EAAAAAAAAAAAAAAAAAAAAAAAA/+IAAP/OAAAAAAAAAAD/4gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/OAAD/xAAAAAAAAAAAAAAAAAAA/+z/7AAAAAD/9v/YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/i/7AAAAAA/7oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/zgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAP/EAAAAAAAAAAAAAAAA/84AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/E/+wAAAAAAAD/ugAAAAAAAAAAAAAAAAAAAAAAAAAAADIAAAAAAAAAAAAA/7oAAP/i/+wAAAAAAAAAAAAA/+z/zgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyAAAAAAAAABQAAAAAAAAAAAAAAAAAMgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/8QAAAAAAAAAAP/i/9j/9v+6/8T/2AAAAAAAAAA8AAAAAP/sAAAAAP/OAAD/ugAAAAoAAAAAAAD/7P/EABQAAAAAABQAAAAAAAAAAAAAAAAAAP/i/+wAAAAAAAAAAAAA/7oAFP+6AAAAAAAAAAAAAP/iAAAAAAAAAAD/4gAAAAAAAP+6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/7AAAP+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMgAAAAAAAAAUAAAAAAAAAAAAAAAAACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAA/84AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/Y/+IAAAAAAAAAAAAAAAAAAAAA/+wAAAAA/8QAAAAAAAAAAAAA/84AAAAAAAD/7AAA/+IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/84AAAAAAAAAAAAAAAD/ugAAAAAAAP/sAAAAAAAAAAAAAAAAAAD/7P/EAAAAAAAAAAD/2P+w/84AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/E/87/2P/sAAD/ugAAAAAAAAAAAAD/7AAAAAAAAP/YAAAAAAAAAAD/zgAA/7oAAP+6/87/2AAAAAAAAAAA/+L/xAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAP/E/84AAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAD/7P/sAAD/7AAAAAAAAAAAAAAAAAAAAAAAAP/YAAAAAAAAAAAAAP/i/84AAAAAAAAAAP/s/87/2AAAAAAAAAAAAAD/zgAAAAAAAAAA/+wAAAAAAAD/9v/2/+z/9v/YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/YAAAAAAAAAAD/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAD/zgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2/+IAAAAA/8QAAAAAAAD/7AAAAAAAAP/2AAD/4gAA/+IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPAAAAAAAAAAAAAAAAAAAAAAARgAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAABGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAAABGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+IAAAAAAAAAAAAAAAAAAAAA/+wAAP/E/+IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAD/xAAA/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+z/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAD/4gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+z/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/zgAAAAAAAAAAAAD/zgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAA/+wAAAAA/+wAAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAA//b/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAA/87/zgAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/7oAAAAAAAAAAAAA/+L/ugAA//YAAP/OAAD/xP/YAAAAAAAAAAAAAP+6AAAAAAAAAAD/ugAAAAD/7P/s/87/sP/E/7oAAAAAAAAAAAAAAAD/7AAAAAD/4gAA/7oAAAAAAAAAAP/YAAAAAAAAAAAAAAAAAAAAAAAA/+z/4gAAAAAAAAAA/7oAAP/EAAAAAAAAAAAAAAAUAAD/7P/YAAAAAP/s/8QAAP/YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+L/xAAAAAD/pgAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAP/iAAAAAAAA/+IAAAAA/9j/4gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAP/i/+IAAAAAAAAAAAAAAAAAAAAA/84AAAAAAAAAAAAA/+z/4gAAAAAAAAAAAAD/2P/iAAAAAAAAAAAAAP+6AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/84AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAAAAAAAP/s/84AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/zgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+IAAAAAAAD/7AAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAP/EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAP/YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/2AAAAAAAAAAAAAAAAAAAAAD/zgAAAAD/9gAAAAAAAP/sAAD/zgAAAAAAAAAA//YAAAAAAAAAAAAA/8QAAAAA/84AAAAA/7r/sAAA/8T/xP/Y/+wAAAAAAAAAAAAAAAAAAP/EAAAAAAAAAAD/ugAAAAAAAAAAAAD/zgAAAAAAAAAAAAAAAAAA/87/ugAAAAAAAP/EAAD/xP/EAAAAAAAAAAAAAP+6AAD/2AAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//b/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAD/4gAAAAAAAAAAAAAAAP/YAAAAAAAA/+wAAAAAAAAAAAAAAAAAAP/s/84AAAAAAAAAAAAAAAD/2AAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/87/zgAA/+wAAP/EAAAAAAAAAAAAAAAAAAAAAAAA/+wAFAAAAAAAAP/sAAD/zgAA/+L/7AAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/87/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/OAAD/ugAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+z/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAAAAAAAAAAAAD/9v/2AAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4gAAAAAAAAAAAAAAAP/OAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAA/84AAAAAAAAAAAAA/9j/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/8T/2AAAAAAAAP/EAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAP/sAAD/2P/2/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/OAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4v/iAAAAAAAAAAAAAAAAAAAAAP/sAAAAAP+6AAAAAAAAAAAAAP/EAAAAAAAA/+wAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAA/+z/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/9gAAAAAAAAAAAAAAAD/zgAAAAAAAAAAAAD/4v/iAAAAAAAAAAAAAP/YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7P+wAAAAAAAAAAAAAP/Y/+wAAP/i/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAA/8QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+IAAAAAAAAAAAAA//YAAAAA//b/4gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/iAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAAAAAAAABGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/87/7AAAAAAAAAAAAAD/xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/34AAAAAAAAAAP/OAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/2AAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/fgAAAAAAAAAAAAAAAP/OAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/84AAAAAAAAAAAAAAAAAAAAAAAAAAAAA/8QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP9+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAAAAD/sAAA/+IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAP/sAAAAAAAA/+wAAAAAAAD/zgAAAAAAAAAAAAAAAAAAAAD/ugAA/7oAAAAeAAD/zv/OAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/zgAAAAD/2AAA/87/xAAAAAAAAAAAAAAAAP+wAAAAAP/OAAAAAAAAAAD/2AAAAAD/ugAA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AT4APQFCAUIAAwFDAUMAAgFEAUQABQFGAUYABAFVAVUACQFZAVkACgFaAVoAFwFbAVsADgFcAVwAEAFdAV0ADAFeAV4ACQFgAWAAVwFhAWEACQFlAWUAFwFmAWYACgFnAWcAVgFoAWgACQFsAWwAFwFuAW4AVAFwAXAAVwFxAXEADgFzAXMAVgF1AXUAEAF2AXYACgF3AXcADgF4AXgAFQF6AXoAFAF7AXsAAQF9AX0AFQF/AX8ATwGDAYMAFAGFAYUAAQGJAYkATwGLAYsAGAGNAY0AGAGPAY8AWAGSAZIAGAGWAZYADAGYAZgAGAGcAZwAJgGdAZ0AJQGeAZ4AMQGjAaUAJgGmAaYAGQGnAacAHwGpAakAMwGrAasAMgGsAawAJQGtAa0AEgGvAa8AGQGwAbAAMgGzAbMAGQG3AbcADQG5AbkAUwG6AboAMQG7AbsAJQG8AbwAHwG+Ab4AGQG/Ab8AEgHCAcIAEgHDAcMAJgHFAcUAJgHGAccADQHJAckAQgHMAcwAHgHNAc0AEQHOAc4AHQHPAc8AGgHTAdMAGgHXAdcABgHZAdkABgHbAdsAHgHcAdwAHAHdAd0ABgHeAd4AGgHfAd8AEQHiAeIAEQHjAeMAJAHlAeUAJAHmAecABgHpAekAHQHqAeoAUgHrAesAHgHxAfIAJAHzAfMAUgH0AfQAGgH1AfUAHAH3AfcAJQH4AfgAHgH5AfkAJwH6AfoACwH7AfsAJwH8AfwACwH9Af0AJwH+Af4ACwH/Af8AGwIAAgAACwIBAgMAOwIFAgYAIQIHAgcAPAIJAgoAIQILAgsAPAITAhMATgIUAhQATQIgAiAAEAJAAkAADgJDAkMAAgJEAkQAAwJFAkUAAgJHAkcAKQJIAkgAIgJJAkkAKAJKAkoAIAJOAk4AHQJQAlAADQJRAlEAOAJSAlIASwJTAlMAJAJUAlQAMQJWAlYAMwJXAlcASgJYAlgAMwJZAlkASgJaAloASQJcAlwASQJeAl4AMgJhAmEABgJiAmIADQJjAmMABgJkAmQAHwJlAmUAOAJmAmYAHwJnAmcAOAJoAmkAHAJqAmoADQJrAmsABgJsAmwADQJtAm0ABgJuAm4ADQJvAm8AOAJwAnAAMQJ1AnUAEgJ2AnYAEQJ3AncASwJ4AngAJAJ5AnkAUwJ6AnoABgJ7AnsAPgJ8AnwASAJ/An8ANwKAAoAALwKBAoEAMgKDAoMANwKEAoQALwKFAoUAGQKGAoYAGgKHAocAGQKIAogAGgKJAokAGQKKAooAGgKLAosAEgKMAowAEQKNAo0APgKOAo4AHgKSApIABgKTApMAMQKVApUAJQKWApYAHgKXApcARwKYApgARgKZApkARwKaApoARgKbApsANwKcApwALwKdAp0AEgKeAp4AEQKfAp8AEgKgAqAAEQKlAqUARQKmAqYAHQKnAqcARQKoAqgAHQKqAqoAGQKrAqsAGgKuAq4AEgKvAq8AEQKyArIAEgKzArMAEQK2ArYAEgK3ArcAEQK5ArkAMwK6AroAQgK7ArsAMwK8ArwAQgK+Ar4AHQLAAsAAHQLBAsEADQLCAsIABgLDAsMADQLEAsQABgLFAsUAGQLGAsYAGgLHAscAMgLPAs8ADQLQAtAABgLRAtEADQLSAtIABgLTAtMADQLUAtQABgLVAtUADQLWAtYABgLXAtcAHwLYAtgAHALZAtkAHwLaAtoAHALbAtsAHwLcAtwAHALfAt8AJQLgAuAAHgLjAuMAPgLkAuQASALlAuUANwLmAuYALwLnAucAGQLoAugALwLrAusANgLsAuwALgLtAu0ANgLuAu4ALgLvAu8AEgLwAvAAEQLxAvEANgLyAvIALgLzAvMANgL0AvQALgL4AvgALgL7AvsAEgL8AvwAEQL9Av0AAwL+Av4AAgL/Av8AAwMAAwAAAgMBAwEAAwMCAwIAAgMDAwMAAwMEAwQAAgMFAwUAAwMGAwYAAgMHAwcAAwMIAwgAAgMJAwkAAwMKAwoAAgMLAwsAAwMMAwwAAgMNAw0AAwMOAw4AAgMPAw8AAwMQAxAAAgMRAxEAAwMSAxIAAgMTAxMAAwMUAxQAAgMVAxUABQMXAxcABQMZAxkABQMbAxsABQMdAx0ABQMfAx8ABQMhAyEABQMjAyMABQMpAykABAMrAysABAMtAy0ABAMvAy8ABAMxAzEABAMzAzMABAM1AzUABAM3AzcAKQM4AzgAIgM5AzkAKQM6AzoAIgM7AzsAKQM8AzwAIgM9Az0AKQM+Az4AIgM/Az8AKQNAA0AAIgNBA0EADwNDA0MADwNFA0UAKANGA0YAIANHA0cAKANIA0gAIANJA0kAKANKA0oAIANLA0sAKANMA0wAIANNA00AKANOA04AIANPA08AGwNQA1AACwNRA1EAGwNSA1IACwNTA1MAGwNUA1QACwNgA2AANANhA2EAMATKBMsADgY+Bj8AFQZABkUABwZGBk0ACQZaBlsAFAZqBmsAAQZsBnEADAZyBnkACgZ6BnsAGAaABoUAFwaOBpEADgaaBqEAEAaiBqMAFQamBqcAFAaoBqkAAQaqBqsAGAawBrEAFQayBrcABwa4Br8AAQbABsEAFAbIBs8AAQbYBt8AAQbgBuEABwbiBuQAFQblBuYABwbnBuoACQbrBusAAQbxBvMAFAb6BvoAAQb+BwMADAcEBwcACgcPBxAAGAcTBxYADgcXBxcAVAcgByEAFwciByMAEAckByQAAQiGCIYAUAiNCJcAFgibCKAAIwihCKQACAjFCMYATAjHCMgAQAjJCMkAPwjKCMoAQAjLCMwAPwjUCN4ACAjiCOIACAjuCO4AOQjwCPIAOQjzCP0AEwj/CQMALQkFCQkALAkKCQ0ANQqlCqUAQQqnCqcAQQquCq4AQQACAgwABQAFADoACgAKADoADAAMAD8ADwAPACwAEAAQADsAEQARACwAJAAkAAkAJgAmAAUAKgAqAAUAMgAyAAUANAA0AAUANwA3ADIAOAA4AAwAOQA6ACIAPAA8ABkAPQA9AD0AQABAAD8ARABEAAcARQBFABQARgBIAAEASQBJABsASgBKACoASwBLABQATgBPABQAUABRAAYAUgBSAAEAUwBTAAYAVABUAAEAVQBVAAYAVgBWADkAVwBXACgAWABYAAYAWQBcABAAXQBdADUAYABgAD8AbQBtAEwAfQB9AEsAggCHAAkAiACIAFEAiQCJAAUAlACYAAUAmgCaAAUAmwCeAAwAnwCfABkAogCiAAEAowCoAAcAqQCtAAEAtAC4AAEAugC6AAEAuwC+AAYAvwC/ABAAwADAABQAwQDBABAAwgDCAAkAwwDDAAcAxADEAAkAxQDFAAcAxgDGAAkAxwDHAAcAyADIAAUAyQDJAAEAygDKAAUAywDLAAEAzADMAAUAzQDNAAEAzgDOAAUAzwDPAAEA0QDRAAEA0wDTAAEA1QDVAAEA1wDXAAEA2QDZAAEA2wDbAAEA3QDdAAEA3gDeAAUA3wDfACoA4ADgAAUA4QDhACoA4gDiAAUA4wDjACoA5ADkAAUA5QDlACoA5wDnABQA+AD4ABQA+QD5AAYA+wD7ABQA/QD9ABQA/wD/ABQBAQEBABQBBQEFAAYBBwEHAAYBDAEMAAYBDQENAAUBDgEOAAEBDwEPAAUBEAEQAAEBEQERAAUBEgESAAEBEwETAAUBFAEUAAEBFgEWAAYBGAEYAAYBHAEcADkBIAEgADkBIwEjADIBJAEkACgBJQElADIBJgEmACgBJwEnADIBKAEoACgBKQEpAAwBKgEqAAYBKwErAAwBLAEsAAYBLQEtAAwBLgEuAAYBLwEvAAwBMAEwAAYBMQExAAwBMgEyAAYBMwEzAAwBNAE0AAYBNQE1ACIBNgE2ABABNwE3ABkBOAE4ABABOQE5ABkBOgE6AD0BOwE7ADUBPAE8AD0BPQE9ADUBPgE+AD0BPwE/ADUBQgFCAAkBQwFDAAcBRAFEAFEBRQFFAAcBRgFGAAUBRwFHAAEBSQFJADkBXQFdAA8BXgFeADMBYQFhADMBZQFlAFABaAFoADMBbAFsAFABcQFxACMBdwF3ACMBeAF4AAsBeQF5ACsBegF6ABIBewF7ACkBfAF8AAIBfQF9AAsBfwF/AE0BgQGBACsBgwGDABIBhQGFACkBhgGGABIBiAGIABIBiQGJAE0BiwGLAAsBjAGMAEkBjQGNAD4BjgGPAAsBkAGQAEkBkQGRAAIBkgGSAAsBlAGVAAIBlgGWAA8BlwGXAAIBmAGYAAsBmQGaAAIBnAGcAB8BngGeAA4BowGjAB4BpQGlAB8BpwGnADABqQGpADEBrQGtAB4BrwGvABgBsAGwACEBtAG0AB4BtwG3AA4BugG6AA4BuwG7AE4BvAG8ADABvgG+ABgBwAHAACABwwHDAB8BxgHGACEByQHJAB0BywHMAAMBzQHNABcBzgHOAAoBzwHPABYB0AHQAC8B0QHTAAMB1AHUABcB1QHWAAMB1wHXAAoB2AHZAAMB2gHaAAoB2wHbABwB3AHcAC4B3QHdAAoB3gHeABYB3wHfAAMB4AHgAC0B4QHiAAMB4wHjABwB5AHlAAMB5gHmAC8B5wHnAAMB6QHpAAoB6gHqADwB6wHrAAMB7AHsAAoB8QHxABcB8gHyAAMB8wHzADwB9AH0AAMB9QH1AC4B9gH2AAMB+AH4AAMB+QH5ACIB+gH6ABAB+wH7ACIB/AH8ABAB/QH9ACIB/gH+ABAB/wH/ABkCAQIDADsCBgIGADoCBwIHACwCCgIKADoCCwILACwCDwIPACwCEwITAEwCFAIUAEsCQAJAACMCQwJDAAYCRAJEAAkCRQJFAAcCRwJHAAUCSAJIAAECSQJJAAwCSgJKAAYCTgJOAAoCTwJPAAMCUAJQAA4CUQJRADcCUgJSACcCVQJVAAMCVgJWADECVwJXABcCWQJZAAMCXQJdAAMCXgJeACECYAJgACACYgJiAA4CYwJjAAoCZAJkAEgCZQJlADcCZgJmAEgCZwJnADcCaAJoAA4CaQJpAAoCagJqAA4CawJrAAoCbAJsAA4CbQJtAAoCbgJuAA4CbwJvADcCcAJwAA4CcQJxAAoCdgJ2AAMCdwJ3ACcCeAJ4ADwCegJ6AAMCewJ7ACcCfgJ+AAMCfwJ/ABgCgAKAABYCgQKBACECggKCAC8ChAKEAAMChgKGAAMChwKHACcCiAKIADwCiQKJAB8CigKKABwCjAKMAAMCjgKOAAMCkAKQAAMCkQKRAA4CkgKSAAoCkwKTAA4ClAKUAAoClQKVAE4ClgKWABwClwKXAEcCmAKYAEYCmQKZAEcCmgKaAEYCmwKbABgCnAKcABYCnQKdAB8CngKeABwCnwKfACACoAKgAC0CoQKhACACogKiAC0CpAKkAAMCpQKlAEUCpgKmAEQCpwKnAEUCqAKoAEQCqgKqABgCqwKrABYCrQKtAAMCrgKuAB4CrwKvABcCsQKxAAMCswKzAAMCtAK0ACACtQK1AC0CtwK3AAMCuQK5ADECugK6AB0CuwK7ADECvAK8AB0CvQK9ADECvgK+AB0CwALAAAoCwQLBAEMCwgLCAB0CwwLDAEMCxALEAB0CxQLFABgCxgLGABYCxwLHACECyALIAC8CzALMAAMCzgLOAAMCzwLPAA4C0ALQAAoC0QLRAA4C0gLSAAoC0wLTAA4C1ALUAAoC1QLVACEC1gLWAC8C1wLXADAC2ALYAC4C2QLZADAC2gLaAC4C2wLbADAC3ALcAC4C3QLdACAC3gLeAC0C4ALgAAMC4gLiAAMC4wLjACcC5QLlABgC5gLmABYC5wLnABgC6ALoABYC6QLpAEIC6gLqAAoC6wLrAEIC7ALsAAoC7QLtAEEC7gLuAEAC7wLvAEEC8ALwAEAC8QLxAB4C8gLyABcC9AL0AAMC9QL1AA4C9gL2AAoC9wL3AB8C+AL4ABwC+gL6AAoC+wL7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G1wPUBPQG8ga0huwD1YPXBrSG7Aa0huwGtIbsBrwG84PYhNYGvAbzhquGkgZZF/gYARf4GAEX+BgBBm+G7YekhvUD2gPbh6SG9Qa9hziGvYc4g90E44a9hziD3oPgF9AXy5fQF8uHBYbCBwWGwgcFhsIHBYbCBwWGwgPhhv+F+QZpkwoGAhMKBsgGAIbIBgCGyAYAhtKD4wdtBu8GmwUfh0wHKwPkg+YD54PpBfkEiAachl2GZQdhF9SEzobMhrSGwgbIBrqX+AZgh3YHCgdJBrwG8hf4BwWHp5HYF9ATCgSyBysGjAduhmCTCgenhyaGWQdhBo8Hp5IJhvaYAQcmg+2GWQbCB2EG8hfQB02R2YPqmAED7AZjg+2EiAUYBo8D7weDhsaGaYdhBo8YAQaPBmmGwgPwhsyHbQa9hmCGYIdwBmyExwPwhp4QOIPyF9SHhQdchsyHSobCBR+X84duh26GngdHh0kGupf4BwWHp4a6l9AQOISyBysER4RWg/OD9QP2hQMD+AemA/mFHIbvF/OE74P8h2cGyAdMF/yHcwdzBxqHZZIJhPKYAQd6huYHeQazBgIFE4dxg/sEWAdbB1sEwQa2BsgGswdihKGGyAZZA/yHJQc4h6MGzgbXBgUD/gbzhxqGAgP/hAEEy4X5BmmF+QZphfkGaZMKBgIFkYduhtcHSQbthAKEBAdMF/OGuobCBsIHbobIB3MF+QQXhAWHXIQHBAiECgTvhAuEDQQOkDiG4YQQBBGEEwaMBsaHTAcrF9SGipfUhoqEFIQWBfkEF4b8hBkEGoQcB14GyAVyBukHBwTNBB2EHwQghCIEI4QlBCaEKAaeBxqGngbyBFaE8oQphCsHWATyhCyELgRABPKEL4QxBDKENBMKBJETCgSRBDWENwQ4hDoEO4Q9BFaHCgRWh3qEPoRABEGEQwZghR+HTAREhEYER4RJBEqETARNhE8EUIRSBFOEVQZgl9SG7xfUhu8GmwUfhsIGyASPhssEj4bLBR+HTBfzl/yGYgTsh26Hcwduh3MX+BgBB0wHKwdMBysHpgazEDiGAhA4hgIQOIYCBFaEWARZhFsFAwa2BFyEXgRfhGEHKwdxh4UG6oZmhg+GD4RihGQEZYRnBmUEaIRqBGuFHIRtBG6YAQcmhHAEcYRzBHSX1IbvF9SG7xfUhu8X1IbvF9SG7wRzBHSX1IbvF9SG7xfUhu8X1IbvBHMEdISAhf2GwgbIBsIGyAbCBsgGwgbIBsIGyAbCBsgEgIX9hmCGzgR2BHeEeQR6l/gYARf4GAEX+BgBF/gYARf4GAEEeQR6hquGngarhp4Gq4aeBquGngR8BH2EfwSAhwWGwgSCBMEEggTBBIIEwQSCBMEEg4SFBIaGAhMKBgITCgYCBIgHg4SJh4UHWAeFB4UHXIVyBrMGuod5BIsGjAeFB4UEjISOBI+X84SRBrYErAYbhJKGYId6hvIGzhfQF9qElAZZB0wE/QSVhJcG6QSYhJoHOJHYBJuE5oSdBJ6Hg4duhKATCgeDhu8GyYZiBmIE7ITshKGE8Rf8hKMFtwSkh1gEpgSnhLUEtoS4BKkEqoSsBK2ErwSwl9SG7wZghs4X+BgBBwWGwgcFhsIHBYbCBwWGwgcFhsIX1IbvF9SG7wabBR+EsgbpBquG8Id2BvIEs4cxBLOHMQZiBOyEtQS2hLgGq4bwhMcEuYa8BvOX1IbvF9SG7wbCBsgGwgbIBmCGzgZghs4X+BgBF/gYAQekhvUHpIb1BwWGwgcFhsIEuwS8hrqHeoS+BL+EwRfzhMKExBfUhu8FtwW4l/gYARf4GAEX+BgBF/gYARMKBgIExYZcB1mExwTIl9SGuoTKBrSX0ATjhOmEy4TNBM6HBYcKBsIE0ATRhuYE0wbpB6SG9RMKBgIG7weFB4UHhQZ7hwcG6QeFBssGywcmmAEG5gbpBvCE8QTUhz0E1gbzhlkHowdhF64Ge4TXhuYE2QYbhNqE2oZZBlkE3AcrBN2Gq4UTh2EHYQTfBN8E3wTghOIG7wbvBOOG5gbmBuYG5gTlBOaGwgVyBvOHPQZphboE6ATphOsE7ITshPcE9wT3BO4X+ATvmAEE8QTyhuYE9AT1hukE9wT3BPiE+gT7hP0E/oUABQGFAwa8BQSHC4UGBQYFB4WRhtuFDwV/hQkFSwUKhQwFDYUPBZSFEIVXBuMHeQbjBRIFE5IJhmOHhQUVBtEFFoUYBRmHC4UbBRyGY4d5BtcHTAclBrMHp4bpBrqSooUeBmOGnga6hp4GuQbnhfkGaYcHBq6FH4deBzWGyAbIB1aHNwUhBSKGvYcfBSQHeoUlhzWHCgcKBwoG7ZHZj+eG84UqBsyGzIdWh6eHCga2BScHNYcFhgCG4wUohSoFKgUrhS0FLoUuhTAFmoUxhTMFNIU2BTeFOQVShTqFXQVdBTwFPYeqhT8FQIVCBUOFRQVFBXUFRoVIBUmHagVLBUyFTgV8hU+FUQeUBYWFUoVUECCFkYVVhVcFmoV1BViFWgVbhV0FXoWIhWAFYYVjB4mFZIVmBWeFaQVqhWwFbYbzhW8FcJeuB2EG5gVyBuSG6pfZBvCFc4bmBXUFdoV4BYiFeYV7BY0FfIV+BzoFf4WBBYEFjQWNBYKFhAWEBYWFhYWHBYiFigWLhY0FjoWahZAHqoWRhZMFlIWWBZeFmQWah1yG5IWcBZ2FnwWghb6FogWjhuqFpQWmhagFqYWrBayFrgWvhsIGyAbCBsgFsQWyhbQFtYW3BbiFuhfZBquG8Ia6h3qFu4W9BrqHeoW+hsUFwAXBhcMFxIZghs4HdgbyBcYFx4XJBcqFzAXNhcwFzYXPBdCF0gXTh0kG7YXVBdaGvAbzhdgF2YXbBdyF3gXfl/gYARf4GAEX+BgBF/gYAQenhuYHp4bmB6SG9QXhBeKF4QXiheQF5Ya9hziF5wXohr2HOIa9hziF5wXol9AXy4XqBeuF7QXuhfAF8YcFhsIHBYbCBfMF9IcFhsIHBYbCB14HNYX2BfeF+QZphfqF/AcrB3GHKwdxkwoGAgbIBgCF/YX/BsgGAId6l8uGaYYCBu8G0oenh6eHp4enh6eHp4enh6eX1JfUhgOGD4YIBgUGBoYIByaHJocmhyaHJocmkwiTCIYJhgsGDIYOBlkGWQZZBlkGWQZZBlkGWQYPh1sGEQYShhQGFYYXBhiHYQdhB2EHYQdhB2EHYQdhGAEHC4ZmhhoGG4YdEqKSopgBGAEYARgBGAEYAQachh6GIAYhhiMGJIaPBo8GjwaPBo8GjwaPBo8GcQYmBieGKQZphmmGaYZphmmGaYZphmmGZQYqhiwGLYYvBjCGMgYzh6eHp4cmhyaGWQZZB2EHYRgBGAEGjwaPBmmGaYZUhlSGVIZUhlSGVIZUhlSGNQY2hjgGOYY7Bl8GPIY+BlkGWQZZBlkGWQZZBlkGWQY/hkEGQoZEBkWGSIZHBkiGawZrBmsGawZrBmsGawZrBkoGS4ZNBk0GToZQBlGGUwenh6eGVIZUhlSHp4ZUl9SX1IZWF9SGV4ZZBlkGWQZZBlkGWoZcBl2HWwZfB2EHYQdhB2EHYQdhBmCGYIdEhmIGjwaPBo8GjwZjhmOGjwaPEwoTCgZlBmaGaAZrBmsGawZphmsGbIZuBm+GcQZyhnQGdYZ3BniGegbthnuGzIbsBsyHp4dNhn0GfoaABoGGgwaEhoYGh4aJBoqGlQaMBz0HBAdWho2Hp4enh6eHp4enh6eHp4enh2EHYQdhB2EHYQdhB2EHYQaPBo8GjwaPBo8GjwaPBo8HYQdhB2EHYQaPBo8GjwaPBpCGkgaThpUGloaYBpmGmwachp4HGoafhqEGooakBqWGpwaohqoGq4atBq6HbQawB4UGsYazB3YHdgd2BrSX+Bf4B6eGtga3hrkGuQenh50GvAa6h3YGvAa9hr8X85D3BsCX1IbCBsOHBYbFBsaHLIbOBtcYAQbIF/yGyYbLBsyGzgbPhtcG0QbShtKHKwbUBtWG1wbXBtuG1wbYhtoHOgbbht0G3obgBuGG4wbyBvIG8gbsBuSG5gbnhueHNYbpBukG6obsBu2G84bvBvOYAQbwhvIG84b1BziSCZLJhwuG9ob4BvmG+wb8hv4G/4cBBziHBAcEBwQHBAcEBwQHBAcChwQHBAcEBwWHBYcHBwoHCgcKBwiHCgcKBwuHC4cLhwuHDQcNBw0HDQcNBw0HDQcNBw0HDocQBxMHEwcTBxGHEwenmAEHp4cXhxeHF4cXhxeHF4cXhxSHF4cWBxeHGQcZBxqHHAc3BzcHNwcdhzcHHwcgh1yHXIdchyIHI4dch1yHXIdch1yHXIdch1yHXIdch1yHXJIJhyUHJocoBz0HPQc9BymS25LbktuHLhLbhy+HKwcsktuS24cuBy+YARgBGAEYARgBGAEYARgBBzEYARgBBzKHNAc0BzQHNAc0BzWHNwc3BzcHNwc3BziHOIc4hziHOgc7hz0Hp5EBhz6HQAdBh0MHRIdGB0qHR4dJF/gX+AdKh0wHTYdPB1CHUgdTh1UHVodYB1mHWwemB1yHXgdfh2EHYodkB2cHZZIJh2cHaIdqB2uHbQduh3AHfwdxh3MHdJKqF9SX84d2B3eHeQd6l9kYAQenh3wHfYd/B4CHggeCB4OHhQeGh4gHiYeLB4yHjgePh5EHkoeUB5WHlweYh5oHm4edEqEHnoegB6GHowekh6YHp4epB6qHrAetgABAUr/HgABAY7/IwABAXcAAAABAUL/PAABAAL/UAABAU//IwABAS7/IwABAIj/IwABAYT/IwABAVH/IwABAIf/IwABAQT/EAABARr/IwABAN7/IwABAXD/HgABAR7/EAABAQT/IwABAPP/IwABAVAAAAABAYsAAAABAPL/QAABAVYAAAABAPT/QAABAXX/EAABAXwAAAABAXD/PgABAg0AAAABAhQAAAABAV8AAAABAUAAAAABAhEAAAABAT//QwABAN8AAAABAbsAAAABAUD/RAABAREAAAABAUr+6QABAR/+6QABAVIAAAABApAAAAABAhcAAAABAV0AAAABAloAAAABAggAAAABAXgAAAABAiEAAAABASz/JgABAP//NAABAnH/EAABAi//EAABAZkAAAABAPv/EAABAYj/PgABAVP/RAABAVL/BgABARX/CwABAdf/PgABAaT/RAABAS//HgABAP//HgABAVz/PgABASf/QwABAXv/PgABAUP/RAABAiH/BgABAbX/CwABAXP/HgABARz/HgABARr/PgABAPn/RAABAU3/PgABASH/QwABAbn/PgABAXT/RAABAW//PgABAUb/QwABAfsAAAABAYYAAAABAfv/PgABAYb/RAABAWX/BgABASb/CwABAXn/PgABATv/RAABAXP/BgABAT3/CwABAYn/PgABAVf/RAABAWH/PgABATn/QwABAdz/PgABAZP/RAABAWEAAAABATkAAAABAQ7/PgABAN//RAABAQ3/LgABAOL/MQABAUv/LgABASH/MQABAZ4AAAABAUf/PgABAR//RAABAfQAAAABAgAAAAABAdAAAAABAYIAAAABAWwAAAABAVQAAAABAXT/LgABATn/MQABAUr/RgABAR//RgABALH/RgABAIr/RgABAYr/RgABATD/RgABAY7/RgABAT3/RgABAXD/RgABAS3/RgABAZYAAAABAZb/RgABAV7/RgABAST/RgABAToAAAABAN7/EAABAW4AAAABATD/IQABAQoAAAABAX4AAAABAQj/EAABANQAAAABAYT/EAABAbP/EAABAWAAAAABAT3/nAABARMAAAABALz/EAABASYAAAABAMAAAAABAW8AAAABAR0AAAABAO0AAAABAKIAAAABAQL//wABAIkAAAABAhr/PAABAjL/EAABASn/EAABAwn/PAABAyH/EAABAo//EAABAZoAAAABAYr/HgABA/8AAAABA9EAAAABA2AAAAABAU3/EAABASX/jAABAPT/UgABAXb/EAABAbH/lwABAV4AAAABASz/LgABAO7/MQABAMcAAAABAeUAAAABAeX/EAABARz/MAABAOUAAAABAOIAAAABAUgAAAABASz/MAABAJL/PAABAYH/EAABAQf/EQABATv/IwABALcAAAABAVj/EAABAdv/EAABAUkAAAABAbEAAAABANX/EAABALUAAAABALX/EAABAPP/EAABAMD/hwABAMD/EAABAPsAAAABAO7/EAABART/qQABAQX/EAABAPH/EQABASgAAAABASMAAAABAUMAAAABARj/IwABAOAAAAABAN0AAAABAswAAAABAsX/EAABAsz/qQABAiIAAAABAV//EAABApD/9gABAkz/EAABAbQAAAABAQMAAAABAT7/EAABAM4BHwABAIoAjwABAQYBHwABAEIAjwABAKsAkAABAFgBHwABALEBHwABASz/9gABAXj/EAABAPT/MwABAO//EAABAPkAAAABARX/EAABAQL/EAABAUQAAAABAXn/EAABAbgAAAABAI7/MwABAOL/bwABAXIAAAABAT8AAAABATb/hQABAOcAAAABAP4AAAABANcBHwABASUBHwABANEBHwABAN8BHwABAK0BHwABAQMBHwABAPEBHwABAHMBHwABAAEAtQABANoBHwABASYBHwABAQABHwABAOMBHwABANsBHwABALcBHwABAO8BHwABAS4BHwABALsBHwABAR4BHwABANMBHwABAMABHwABALoBHwABAKQBHwABAKEBHwABAF0ApAABALYBHwABAMUBHwABAIEBHwABAFkAjwABAJABHwABATUBHwABAKoBHwABAKUBHwABAPwBHwABAK0AjwABAPIAjwABALcAjwABAFr/oAABAMT/oAABAKr/oAABAPz/oAABAK3/EAABAMb/EAABAPL/EAABALf/EAABAUMDCwABANIBHwABATUAAAABARj/MQABAMoBHwABALkBHwABAK8BHwABAKYBHwABAGgBHwABAMIAjwABAM0AmgABAIoBHwABAGwBHwABAJIBHwABATUAjwABAM0AjwABANYBHwABAMYBHwABAPQAjwABAJ4AjwABAFgAjwABAH0AjwABAMkBHwABAM0BHwABAKsBHwABAJ4BHwABAJoAjwABALMA6wABAKoAjwABAMQBHwABAUL/RgABAUX/RgABAUL/ZQABAUX/ZQABARz/EAABAVcAAAABAVf/RgABASf/RgABAVf/ZQABASf/ZQABAVf/EAABASf/EAABAVf/OAABASf/OAABAS3/OAABASz/OAABAS3/PgABASz/PwABAS3/EAABASz/EAABAQgAAAABAXP/RgABATz/RgABAXP/EAABAXP/PgABATz/PgABALH/QQABAIr/QQABAU//RgABARj/RgABAU//ZAABARj/XwABAS7/RgABAIj/RgABAS7/awABAIj/aQABAS7/OAABAIj/OAABAcX/RgABAd7/RgABAYT/RgABATv/RgABAYT/XAABATv/WgABAYT/OAABATv/OAABAVH/RgABAIf/RgABAVH/YQABAIf/ZwABAQT/RgABAPP/RgABARr/RgABAN7/RgABARr/awABAN7/ZAABARr/OAABAN7/MQABAXD/OAABAS3/MQABATP/RgABAQX/RgABAdEAAAABAdH/RgABAZP/RgABASz/RgABAPT/RgABAPQAAAABAGb/EAABAcIAAAABAawAAAABAacAAAABAaoAAAABAh4AAAABAhkAAAABAg8AAAABAg4AAAABAcYAAAABAlsAAAABAlkAAAABAmQAAAABAlgAAAABAmIAAAABAl4AAAABAboAAAABAdsAAAABAdQAAAABAdIAAAABAm4AAAABAmwAAAABAjsAAAABAjwAAAABAkgAAAABAl8AAAABAncAAAABAckAAAABAmkAAAABAmcAAAABAj8AAAABAkQAAAABAjIAAAABAk8AAAABA1wAAAABA1cAAAABA8wAAAABA9QAAAABA70AAAABA8AAAAABA8MAAAABBBwAAAABBBcAAAABBLYAAAABBLUAAAABBLIAAAABBLEAAAABBKkAAAABBCUAAAABBDIAAAABBMgAAAABBKMAAAABBKsAAAABBJAAAAABBJgAAAABATL/HgABAUwAAAABA2MAAAABATv/EAABAXsAAAABAXkAAAABAcgAAAABA8EAAAABALEAAAABASUAAAABATH/EAABAbkAAAABAccAAAABAYwAAAABAZMAAAABAZP/HgABAd0AAAABAa4AAAABAdcAAAABAbIAAAABA+QAAAABALv/oAABAMP/oAABAMX/oAABALH/oAABALr/oAABAMYAAAABAR//MAABAN7/MAABAYf/PgABATz/QwABAU//PgABARj/QwABAR//PgABAO7/QwABAYEAAAABAQ8AAAABAZ0AAAABAXUAAAABATgAAAABAW//PAABAYT/PAABAWoAAAABAeQAAAABAaAAAAABAZwAAAABAZ//EAABAcMAAAABAbwAAAABAT0AAAABAgn/BgABAaL/CwABAiv/BgABAbz/CwABAXX/PgABATz/RAABAX7/PgABAU7/RAABAY4AAAABAcf/OwABAWsAAAABAXEAAAABAwcAAAABAPoAAAABAS4AAAABAZAAAAABAjgAAAABAYn/VgABAXMAAAABAYQAAAABAQQAAAABAeYAAAABARkCygABAS0AAAABALH/HgABATz/EAABAYj/EAABASwAAAABAO4AAAABAR4AAAABAQwAAAABAIwAAAABAIz/HgABAQ4AAAABAKwAAAABABH/EAABANYAAAABABr/EAABAFv/oAABAIj/MQABABEAjwABAIz/QQABAIz/RgABAnUAAAABAoEAAAABAPUAAAABAUUAAAABAIj/EAABAeT/EAABATf/EAABAScAAAABAIgAAAABAd4AAAABAR8AAAABASr/EAABARgAAAABATsAAAABAIcAAAABAQr/EAABAR//HgABASz/HgABAI//EAABAUf/EAABAIr/HgABAS3/HgABATQAAAABARL/HgABARIAAAABAXAAAAABAQ0AAAABATb/EAABATYAAAABASkAAAABAPgAAAABAPj/HgABANgAAAABAUv/IwABAUsAAAABARf/XQABAJr/HgABAJoAAAABAH3/XQABARYAAAABARb/IwABAPf/IwABAOEAAAABAXoAAAABAUL/IwABAUL/XAABAPwAAAABAP0AAAABAUL/dwABAQf/IwABATEAAAABAOgAAAABAOb/EAABAOb/IwABATD/HgABAQYAAAABAY0AAAABAQUAAAABAPcAAAABAPMAAAABAFoBHwABADIBdAABAQcAAAABAXH/KQABAsb/PgABAWf/OwABAXT/OwABASAAAAABAXj/PgABAWgAAAABAcUAAAABAWX/PgABAYkAAAABAT3/EAABAlf/QwABATX/QwABATr/QwABARsAAAABAS//EAABAOkAAAABAXYAAAABAMsAAAABAcwAAAABAUIAAAABATMAAAABAPIAAAABANUAAAABAagAAAABAUn/QwABASsAAAABAS//QwABAOQBHwABAMMBHwABAOQAAAABAUcAAAABAYgAAAABAAL/PAABARAAAAABAU0AAAABAT//9gABAU8AAAABAZgAAAABARwAAAABATwAAAABAgUAAAABANkAAAABAMwAAAABAd4CIgABAekCHAABARr/EAABATcAAAABAM7/oAABALb/oAABAFj/oAABATf/oAABAM3/oAABAFn/EAABAJ7/oAABAJD/oAABAPMBHwABATcBHwABAI0BHwABAIABHwABAX8CygABAOoAAAABAUUCywABAOoCygABA6gBaQABAucAAAABAnIAAAABAIoAAAABAVEAAAABAUEAAAABATIAAAABAJgCFwABAMcBHwABAYACygABAjMAAAAEAAAAAQAIAAFM3gAMAAFNBAIWAAEBAwAnACsALwAyADcARwBLAE8AUgBXAJQAlQCWAJcAmAC0ALUAtgC3ALgA0ADRAOYA5wD6APsA/AD9AP4A/wEAAQEBDQEOAQ8BEAERARIBIwEkASUBJgEoAVgBWgFkAWUBbAFwAYsBmAG2AbcBuwHXAmkCpALPAtAC6gMpAyoDKwMsAy0DLgMvAzADMQMyAzMDNAM1AzYDYANhA6EDogOjA6QDpQOmA64DrwPGA8cDyAPJA8wDzQPOA+ED4gPjA+QD7wPwA/sD/AP9A/4D/wQABAEEAgQNBA4EMgRUBGUEfQSjBP0FHAUgBSQFKAUsBTQFPgVDBW0FjwW0BbUFtgW3BbgFuQW6BbsFvAW9BcwFzQXOBc8F0AXRBdIF0wXUBdUF4AXhBeIF4wXkBeUF5gXnBfQF9QX2BfcF+AX5BfoF+wYSBhMGFAYVBhYGFwYYBhkGOAY5BmIGYwZkBmUGZgZnBmgGaQZ6BnsGfAZ9Bn4GfwaABoEGggaDBoQGhQaqBqsGyAbJBsoGywbMBs0GzgbPBvgG+Qb6ByAHIQdCB2MHZQffB+QH7gfvB/AIBQgRCBYIHwhHCFEIUghkCGUIggiICIoIiwiMCKEIowi1CLcIxwjICMkIygjLCNQI1QjWCNcI2AjZCNoI2wjeCO4I8AjxCPIJLgmtCboJvAnfCeEJ5gnrCtYK2QvKAQMCXALaA3ZANALyAxYexEAWQEZABEA0QDRANEA0QDRARkBGQEZARkBGAlwDFgLaHsQDdkAWA3ZAFgN2QBYDdkAWQDRARkA0QEZANEBGAvJABALyQARABAIIAoYC2kA0QDQC8kBGQEYC2kA0AvJARkBGHsRANEBGAxZANEBGQDRARkA0QEZANEBGQDRARkA0QEZANEBGAvJABAJcAlwDFgN2A3ZAFkA0QEZANEBGQDRARgJcAlwDFkA0QEZANEBGAtoexEA0QEZANEBGQDRARkA0QEYDdgLyHsQCDkA0AhQCGgIgAiYCLAIyAjgCPgJEAkoCUAMWAlYCXAMWAlwDFgJcAxYCXAMWAlwDFgLaHsQC2h7EAtoexALaHsQC2h7EA3ZAFgN2QBYDdkAWA3ZAFkA0QEZANEBGQDRARkA0QEYC8kAEAvJABALyQAQC8kAEHsRABAJiAtQCaAJuAsICdAJ6AoBARkBGQEZARkBGQEYChgKMApICtgKYAp5ARkBGAqQCqgKwArYCvALIAsICyALOAtQC2gLgAuYC7EAEHsQC8gL4A3ZANEA0A3YC/gMEA3YDCkAWAxADFkAWQBYDHAMiAygDLgM0AzQDOgM6A0ADQANAA0ADQANGA0YDRgNGA0YDRgNGA0YDRgNMA0wDTANMQDQexANSA1gDXgNkA2oDcAN2A3YDfAABAdQBZQABAL8BDQABAM0BwQABAFgBwQABASkBDAABAO4B9QABAPMB9QABAK4B9QABAP8B9QABALcB9QABAMoBwQABAMYBwQABAH0BwQABAMwBwQABAW4BZQABAcoBZQABAl4BZQABAlwBZQABAlsBZQABAmUBZQABAmIBZQABAbsBZQABAdEBZQABAm0BZQABAjoBZQABAjsBZQABAdIBZQABAc0BZQABAmwBZQABAmsBZQABAmgBZQABAmcBZQABAl8BZQABAcsBZQABAc8BZQABAXcBZQABAdwBZQABAa0BZQABAMYAQgABARoBZQABAwYBZQABAekBZQABARkBZQABAoIBDQABAUcBDQABATcBDQABA1EBDQABAe0BDQABAgQBDQABAqQBDQABASkBHwABATIBHwABAOIBHwABAUIBHwABAOYBHwABANkBDQABAMwBDQABAM0AQgABAFgAQgABAH0AQgABAI0BwQABAQwBZQABAAABZQAEAAAAAQAIAAFH3gAMAAFJfgJuAAIAZQAkAD0AAABEAF0AGgCCAJgANACaALgASwC6AUkAagFVAVUA+gFXAgAA+wIXAhcBpQIgAiABpgI9Aj0BpwJAAkABqAJCAkUBqQJHAkoBrQJMAmkBsQJuAnEBzwJ1A1UB0wNgBIUCtASiBKYD2gTFBMcD3wTJBMwD4gTOBRED5gUVBRUEKgUYBVYEKwVcBVwEagVjBWQEawVnBWkEbQVrBXAEcAV0BXQEdgWHBZUEdwWXBusEhgbxBvoF2wb+BwcF5QcLBxcF7wcbByQF/AdAB0QGBgdIB0gGCwdcB3EGDAeJB6sGIgfEB9MGRQfWB9sGVQfkB+QGWwfpB+wGXAfuB/AGYAfyB/YGYwf5B/kGaAgFCAUGaQgKCAsGaggNCA4GbAgQCBIGbggVCBYGcQgbCDwGcwhGCEcGlQhMCE8GlwhRCFIGmwhVCFUGnQhYCFkGnghcCFwGoAheCF8GoQhkCGcGowhpCGkGpwh0CHsGqAh9CIUGsAiLCQ4GuQkQCRMHPQkWCRkHQQkcCRwHRQkqCS8HRgkxCTEHTAk+CUsHTQlOCU8HWwlWCVYHXQlcCV8HXgljCWMHYgl0CXgHYwl6CX4HaAmMCY0HbQmXCZgHbwmcCZwHcQmsCa0HcgmvCa8HdAmxCbEHdQmzCbMHdgm3CbcHdwm6CboHeAm8CbwHeQnDCcUHegnWCdYHfQneCeYHfgnoCekHhwnrCewHiQrICsgHiwrWCtYHjArYCt0HjQrfCt8HkwriCuMHlArqCusHlgrvCu8HmAuAC4AHmQyIDIgHmgyKDIoHmwyQDJAHnAedOyAehCB8GtYgmjt8ENobKiCgJH4kriCmI+ggrDuOJXo7jiV6III7Dj0iJYYfPiCaI7IcdCFmIEZKUCE2IWw7OkpoJLoldCV0IUIhciE8IXg7siEkJPAhSCF+OvwheCEqHyARTBciIMoWOBY4FjgPPBLAJKIPQiB8FkoWShZKHFAWVhZWFlYQvBUMD0gWYhZiFmIPThuED1QWjBaMFowb9hGyH3QhThY+Fj4WPg9aEsYPYA9mSlAWUBZQFlARWBdkF2QXZBFkHaYcCBZoFmgWaA9sExo7shaSFpIWkhv8E0QhMBM4Hn4Pch54FkQPeCFmGsQayhrEGsoPfg+EGsQayg+KITYVDBT0D5APlhruGvQcRA+cIJohbBZKFlAWGhYgD6IPqA+uD7QQ2hYgFrAWthsqJLoPug/AHtIPxh7MFlwgoCV0D8wU+g/SD9gXZCSuIUIXrA/eD+QgpiFyIKYhciCmIXIgpiFyFjIWkiCsIXgWMhaSF1IgrCF4FfAV9hZuFnQWYhZoHz4YwBucFnoleiFIG5wWehvGG8wbxhvMIIIhfhvGG8w7Djr8D+ofgDsOOvwcAhwID/AP9haYFp4P/BACFowWkj0iIXgRmhGgEbITRBBcHGgcbhAIEA4caBxuEBQQGhAgECYQLBAyFmIWaCCCIX4QOCBMHRwQPh0uEEQfFBBKOyAehCBeEFAgmhx0Gyo7jiCgJK4lhiPoIKwQVjuOEOwlehVOOw4jshD4IJogcCR4ELwQXBBiEGgQbhB0EHokxiFOIWAguCTqEIAekBCGJDwXrBUwI/QYxhCMO7IQkjuyIUgkxhJ4GNgfsCTqEgwfIBCYEJ4QpBCqELAcUBDIELYkciCCIKAQvCR+EMIWJhDIEM4Q1BDsOyAgXh6EIF4j7iCaHxQ7fBDaEOAQ5iPiI+gbKjuOEOwleiB8Ow4Q8hD4IJoSohD+EQQRChEQERYRHCWAHM4RIiFmESgXmhEuJFohbBE0O6AROhFAGJAkTiRUF6Y7siA6ISRKUBFGFyIYQhFMGLo7siQeJB4U1hFSIL4YciRCSlARWBF2EV4YbCF+JXQRZCV0EWoRcBF2EXwRghGIEY4RlBGaEaARmhGgEaYRrBGyE0QamiR4F2QcdBG4Eb47ICFmO447sj0iIXgWShHEFlARyh00EioSSBHQEdYR3BHiF5oR6BHuI9wX+hH0EfoSABIGIHASDDuOO7ISEhh+EhgSHjUuEiQdNBIqJHIXfBIwEjYcMhI8EkIk8BUSGKISSBJOHz4SVCSoIMQSWhJgIBxKXCAcEmYStBemIHwXpha8F6YcyBJsEnIXpiB8SlA7DhJ4I7IXIiOyFyIWLEpuHxQSfh/yEoQStBjYErQkuhKKEpASihKQIKASlhKcI+4YkBKiIXgSqCP0O44SrhK0E6ofMh8gIKASujteEsASxiAWGIoSzBLSH/Ig0BLYEt4S5BLqEvAS9h7eISoS/BMCEwgTDhuEExo7jjuyExQTGhMgEyYTLBb+EzITOBM+E0QTShNQN24TVhNcE2IVEhiiE2hKbhNuE3QgXiE2IFITejUcE4AkciFmE4YTjBOSE5gTnhhmGtYTpCCaJOoj0BOqOyAhZhOwE7YTvBPCE7wTwhPIE84T1BPaFjgWPhPgE+YT4BPmE+wT8hP4E/4eeBZEIJohbBQEFAoUEBQWFBwUIhQcFCIUKBQuFDQUOhZKFlAUQBRGIKAldDuOO7IUTBRSFFgUXhRYFF4UZBRqFHAUdhZiFmgUfBSCFHwUghSIFI4UlBSaIEwj9D0iIXgUoBSmFKwUshSsFLIUuBS+FMQUyhTQFNYjshciFNwU4hToFO4U9DsOOvwhMBa8IF4hMBT6FQAgahUGFWYVDCBwIF4hMCTAFRIgQCSoHHQVGB0KF0YkfiCgFR4VJBUqFTAVNiCsHpA7jjLQFTwVQhcoIBwVSCF+FU4VVBdwFVoVYDsOJHgf8iOyJOofjCDKHt4e3iEqISoVZhx0IMQVbEp6FXIVeBV+FYQVihWQFZY1+hWcFaI0khWoFa4WOBY+FlYXZBZiFmgWjBaSFbQVuhXAFcYcDhwUFcAVxhXMFdgV0hXYFd4V5BXqJPAWGhYgGzwbQjuOO7IV8BX2FfwWAhYIFg4WFBYaFiAWJhYsFjIWkhY4Fj4eeBZEFkoWUBruGvQWVhdkHswWXBZiFmgWbhZ0G5wWehaAFoYWjBaSFpgWnhakFqoWsBa2FrwWwhbIFs4cdCDKFtQW2iCaIWwW4Bb4FuAW+BbmFuwW8hb4Hw4W/iFCGHgXBBcKITw7ICB8FxAgpjsOIX4gyhcWGKIehD0iJYYgmhccJH4ldB+SJPAleiFII7IXIiFmJPAk8BcoH2gYfiEwF7gg0BesJOokwCEGF7hKaEpWH6QfpCF4Fy4XLiV0JDwaHBc0FzohchdAF0YXRhdGIXgheCRIO7IXTBdSGEIYchdYGHIYchhyF14XXiFmIWYhfhdkF2QhBhdkF2oXcCF4JAAheB+kHyAXdhd8IMoXgiEqISoXvhe+F4gXjheUF5okwBegF6YldBesF7IXuBe+F74XyhfEF8oX0BfWF9wX4hfoF+4X9B0KF/oX+hgAGAYjoBgMGBIYEhgYGB4YJBqgGlgafBgqGDAhGEpQIRgYNhg8HHQYQhhIO7IgXiFIN24YThhUGFodChhgGGY7skpQJXQ7jhhsGHIfdCEwIHwj6Bh4O7IgHCB8IBw7jiTwHz4fIBh+GIQYihiQISogviC+JAwYlhicGKIYqBiuGLQgOhi6ISoY2BjYGNgYwBjGIXgYzBj2INYg1iQMGNIY2BjeGOQhKhjqIMohGBjwGPYY9hj8GQIZCBkIGQ4ZFBkaGSAlJhkmGSwZMhk4GT4ZRBlEGUoZUBlWGVwZYhloGW4ZhhmGGiIZdBl6GYAZhhmMGeYZkhpGGZgZnhmkGpoacBmqGpoZsBm2GbwamhoiGmQZwhnIGc4Z1BnaGeAZ5iDoGewlDhnyGfgZ/h9WGgQaCiF4GhAaFhocJDwhJCQAIEYhNjs6SmghQiEkGiIaKBouGjQaOhpAIQAaRhqaI6AaTBpSGlIjoBpYGl4aZBpkGpoamhpqGnAadhp8GoIaiBqaGo4alBqaGqAaphqmGqwashq4Gr4gRh6EIEYehCBGGsQayhrQITYa1iE2GtYhNhrWITYa1iE2HFAa3BriGuggmiFsIJohbBruGvQa+hsAGwYbDBsSGxgbKiS6Gx4bJBsqJLobKiS6IKAldBswGzYbPBtCJK4hQiSuIUIgpiFyG0gbTiCmIXIgpiFyG1QbWiPoITwbYBtmIKwheCCsIXggrCF4G2wbcht4G34bhBuKG5AblhucG6IbrhuoG64btCV6IUgbuhvAJXohSBveG+QggiF+G8YbzBvSG9gb3hvkG+ob8DsOOvw7Djr8Ow46/Bv2G/wcAhwIPSIheBwOHBQcGhwgHCYcLBwyISocOBw+Hz4fIBxEHEocUBxWHFwcYhxoHG4cdCDKHHQgyiS6HHocgByGHIwckh2yHbIduB24HbgduB2+Hb47IDsgHJgcnhykHKocsBy2HLwcvBzCHMIcwhzCJHgkeBzIPbI2QhzOHegd6B3uHe4d7h3uHfQd9BzUHqIc2hzgNTQc5hzsHPIc+Bz4HP4c/hz+HP4dBB0EIJodCiBSHRAdFh0cHSIdIh72HvYdKB0oHSgdKB0uHTQdOh1AHUYdTB1SHVIdWB1YHVgdWB1eHV4fRB1kHWodcB4kHiQeKh4qHioeKh4wHjAfFB12HXw1NB2CHYgdjh2UHmwebB2aHZoelh6WHaAdoB2mHaYdrB2sHyYfJh2yHbIduB24HbgduB2+Hb4dxB3KNoQd0B3WHdweqB3iHegd6B3uHe4d7h3uHfQd9B36HgAeBh4MHhIeHh4YHh4eJB4kHioeKh4qHioeMB4wHjYePB5CHkIeSB5OHlQeWh5gHmYebCTGHmwech5yHngefh6EOyAeih6WHpAelh6cHpwgQCB8I+geoh6oHq4etB66HroewB7GHswe0h7YHt4e5B7qHvAe8B72HvYe/B8CHwgfDh8UIFIfGh8mHyAfJh8sHywfMh84Hz4fRB9KH1AfUB9WH1wfYiE8H2gfbiFyH24fdCAcH3ofgB+GJLokriFCH4wgyh+SH5gf/h+eH6QfqiQMH7Afth+2H7Yfth+8H7wfvB+8H8Ifwh/CH8IfyB/IH8gfyB/OH84fzh/OH9Qf1B/UH9Qf2h/aH+Af4B/mH+Yf7B/sH/IgrB/4H/4gBCAKIBAgFjaiIBxKXCAiICggLjaiIDQgOiBAIEYgTCBSIFgkciO+IF4gZCBqJK4kriSuIKY7jjuOJXogcCB2O447jiWGJVAgrCB8JK4grCCCIIg7fCCOIJQ7ICCaIKA9IiCmIKwgsiEGIQYguCC+IMQgyiDQINYhBiEGIQYg3CDiIOI7siDoIO4hBiEGIQAhBiD0IQYg+iEAIQYhBiEMIRIhGCFCIUIhQiFyIR4hJCTwJPAhKiEwITAhNiFyITwheCFmIXg7skpoIUIheCFIIX4hTiFUIVohYCFmIWwhciF4JXQheCHqIX4hhCGKIZAhliGcIaIhqCGuIbQhuiHAIcYhzCHSId4h2CHkId4h5CHqSyJLIiHwSyIjiCOOIfYjlCOUIfwjmiICIggjiCIOIhQiGiIgIiYiLCIyIy4iOCJoIj4iRCJKIlAiViJcInoiYiJoIm4ihiJ0InoieiKGIoAihiKGIoYijCKSIuAiyCKYIuAi4CKeIuAiyCKkIrYiqiKwIrYivCLCIsgiziLUNvwi2iLgIvIi5iLsIvI29iL4Iv429iL+NvYjBDb2NvYi/jb2NvYjBCMKIxAjIiMWIxwjIiMoIy4jNCM6I0AjRiNMI1IjWCNeI2QjaiNwI3YjfCOCI4gjjiOUI5ojoCOmI6wjsiO4I74jxCPKI9Aj1iPcI+4j4iPoO447jiPuO44j9CP6JAAkxiQGJFokDCQSJBgkHiQkJCokMCQ2JDwkQiRIJFokTiRUJFokYCRmJGwkciR4JH4khCSKJJAkliScJKIkqCSuJLRKUCS6OzokwCTGJMwk0iTYJN4k5CTkJOok8CT2JPwlAiUIJQ4lFCUaJSAlJiUsJTIlOCU+JUQlSiVQJVYlXCViJWglbjS8JXQleiWAJYYljCWSJZg2tAABAUYDlQABAfECygABAYQDlQABAYkDlQABAYsCygABAR8C5QABAR8DNwABAb8CGwABATEC5QABAR8CrgABAUYCzQABAXsDlwABAR0C6AABAWwDrQABATADXQABASACrgABASAC6AABAZQDnAABAS4C7QABAZQDlwABAS4C6AABALEDlQABAIgC5QABAIgCrgABALEDlwABAZgC6AABAJIDrQABAJMDrQABAIgD2wABARoDrQABAXIDXQABATsCrgABAXID5gABATsDNwABASMDlwABAO4C6AABANsC/QABAW4C1AABAUcDvgABAR8DvgABAcMDrQABAbgC/gABAUwCygABAToCygABAcgCygABAIsDRgABAS4CygABARgCygABASQDkAABAToDIgABARoDIgABAUoDIgABAIsDIgABATYDRgABAPQC+AABAS0C/QABAPIC+AABAVYCGwABAIsC4AABATYC4AABATEDIgABATYDIgABAZMDIgABATcDrQABALEDkAABAd0CygABAXwCygABAT0DrQABAT4DrAABAZQCygABAZEDrAABAVkCygABAXACygABAUoCygABAZoCygABAVQCygABAg0CygABAhQCygABAV8CygABAbYCygABAUACygABAUQCygABAS8C/QABAQACGwABAYcCGwABAVMCGwABAVEC/QABAPoCGwABAQ4CGwABAYwCGwABASAC4AABAN8C/gABAIgC4AABAawCGwABAbsCGwABATsC+AABARYC/gABAQgC/QABAUACGwABAREDXgABAOUCtQABAdcDrQABAZMC/gABAdcDkAABAZMC4AABASQDrQABAcsDrQABAeUC/gABAYgDrQABAU0C/gABAUIChAABApACygABAhcCGwABAV0CygABAloCygABAggCGwABAoECygABAiECGwABASwDWQABAP8CmwABAYgC9wABAT4CygABAUoDrQABAQ8C/gABAi8CGwABAZkCGwABAYgDogABAVMC/QABASwC+AABATUCygABAVICygABARUCGwABAaQCGwABAVwCygABAScCGwABAIcC+AABAbUCGwABAYYCygABAPkCGwABAXQCGwABAUYCGwABAfsCygABAYYCGwABAbgDrAABAYkC/QABAXkCygABAXMCygABAVcCGwABAWECygABAUYDrAABAUYDkAABAR8C4AABATADrAABASAC/QABAX4DkAABAR4C4AABAbgDkAABAYkC4AABAS8DkAABAP8C4AABAYgDXQABAU0CrgABAYgDkAABAU0C4AABAYkDhQABATEC4AABAUEDhQABAPoC4AABAT4DXQABAT4DkAABAQgC4AABAT4DrQABAQgC/gABAWEDkAABATkC4AABAN8CGwABAbQDkAABAZAC4AABAUsCygABATECygABARACGwABAcYC+AABAZ4CGwABAfQCygABAbkCGwABAgACygABAdACGwABAYICygABAVQCGwABATkCGwABAUYD3QABAR8DOAABAUYD0QABAR8DLAABAUYEDAABAR8DZwABAUYEGgABAR8DdQABAUYD8QABAR8DTAABAUYEEwABAR8DbgABAUYEGAABAR8DcwABATAD3QABASADOAABATADlQABASAC5QABATAD0QABASADLAABATAEDAABASADZwABATAEGgABASADdQABALED3QABAIgDOAABAYkD3QABATEDOAABAYkD0QABATEDLAABAYkEDAABATEDZwABAYkEGgABATEDdQABAY4DrQABAT0C/gABAY4D3QABAT0DOAABAY4DlQABAT0C5QABAXID3QABATsDOAABAZYDrQABAV4C/gABAZYD3QABAV4DOAABAZYDlQABAV4C5QABAZYCygABAV4CGwABASQD3QABAQgDOAABASQDlQABAQgC5QABAToC+AABAUICygABATUC+AABAXsDUgABAW4CygABAQ0CygABAbADGwABATwCygABARgC/gABAIwC+AABARoC/gABAgQCygABAbMCGwABAWACygABARMCygABASECygABALwC/gABASYCygABAMAC/QABAR0C/QABAO0ClAABAKIC+AABAXUC+AABAQIC+AABAIkCygABA/YDrQABA8sC/gABA1oC/gABAqAC6AABAZgC+AABA5AC6AABAv4C6AABAXID+QABATsDSgABAXIEGQABATsDagABAUYD+QABAUYD7wABAR8DSgABAcMDXQABAbgCrgABAawCygABAYkDXQABATECrgABASUDrQABAQUC/gABA/YCygABA8sCGwABA1oC+AABAZQDrQABAS4C/gABAeUCygABAU0CygABAYQDrQABAUYDrQABAR8C/gABAR8C7QABATADrQABASAC/gABALEDrQABAIgC7QABAYkDrQABATEC/gABAYkDnAABATEC7QABAPQC/gABAT8DnAABAPQC7QABAXIDrQABATsC/gABAXIDnAABATsC7QABARwCygABAOoCGwABAXcDrQABAIkD2wABAXYCygABAbEC+AABAV4CygABAS8C+AABAUYDlwABAR8C6AABAYkD+QABAYkDlwABATEC6AABAYkD7wABATEDSgABAQgCrgABAMsClAABAeUC+AABAR0C+AABAOUCygABASAC+AABAQgCGwABATcC/QABATsC/QABAMYC+AABALcC+AABAVgC+AABAdsCGwABAbECGwABAY4CGwABANUC+AABALUCGwABAIgC/gABAMACGwABAMAClAABAQgDCwABAPsCGwABARQCGwABAN0C+AABAPECGwABAYkC1QABASgCGwABASMC/QABAUMCGwABARgCGwABAOACGwABATcC/gABAN0C/QABAugC+AABAswC+AABAiIClAABAdQC/QABApMClAABAlYC/QABAakC+AABAYQC+AABAQMCygABAT4CGwABAFkC5wABAM0C6gABAJ8CYgABAIoCYgABALoCYgABAQYCYgABAKwCYgABALACYgABAJAC6gABASwC/QABAa8CygABAXgC+AABAYMCygABAO8CGwABAPkCygABARUC/gABAQIC/QABAUQCGwABAPwCGwABANUCGwABAXkCGwABAQ0CGwABAWsCGwABAbgCGwABASYCGwABAOMCGwABAI4CGwABAOICGwABAQQCGwABAOECGwABAXICGwABAT8CGwABAd4CGwABARkCGwABATsBDQABATICGwABATYCGwABAZACGwABATYCmAABAXACGwABAOcCGwABAP4CGwABANQCywABAUMCywABANUCywABAOwCywABAMUCywABAK8CywABAQYCywABAHMCywABAF8CywABAN8CywABAGACywABASoCywABAPwCywABAP8CywABAOMCywABANACywABAM8CywABALcCywABAPACywABATICywABAR4CYgABANkC5wABAK4C5wABALsCYgABALYCYgABAJQCYgABAF0CYgABAFoC5wABATwCYgABAIECYgABAM0BwAABANkCYgABAG0CqwABAKkCYgABAKUCYgABANUC6gABAK0CYgABAMYC6AABAPICYgABALcCYgABAJ8A4wABAKkA4wABANUBawABAK0A4wABAPIA4wABALcA4wABAT4AAAABANICYgABAKYCGwABAMoCYgABALkCYgABAK8CYgABAMYC6gABAKYCYgABAKcC6gABAMQCYgABAFoCYgABAGwCYgABAFgC5wABAJICYgABATUCYgABANYCYgABAMYCYgABAPQC5wABAJ4CYgABAFgC6gABAH0CqwABAMkCYgABAMcCYgABAM0CYgABAKsCYgABAJoCYgABALMCYgABAKoCYgABAMQC6gABAUgDlwABAXsDrQABAR0C/gABAWwDlwABAWwCygABASAC4QABATADmQABASAC6gABATADnAABASAC7QABASoDlwABAQEDoQABAZQDXQABAS4CrgABAXcDlwABAIkDxQABAXcDkAABAIkDvgABAXcCygABALEEGQABAIgDagABAVcDrQABAIoD2wABAJMDXQABAIgDiwABAcsDlwABAeUC6AABAYQDlwABATsC6AABAYkEIAABATEDcQABAYkEBQABATEDVgABAYkDkAABATEC4QABAYkDmQABATEC6gABAT8DrQABAU4C/gABAU4C6AABAT8DlwABAPQC6AABAT8DXQABAPQCrgABAR0DrQABAPMC/gABAR0EBQABAPMDVgABAR0DlwABAPMC6AABARoDlwABAKcDXAABAXIDkAABATsC4AABAXIDlQABATsC5QABAXIEIAABATsDcQABAXIEBQABATsDVgABATMDlQABAQUC5QABATMCygABAdcDlwABAZMC6AABATADlwABAQ4C6AABATADkAABAQ4C4AABASQDlwABAQgC6AABASMDrQABAO4C/gABASMCygABAKcDWAABAZMDNwABAQgDNwABAR8DGAABANsDoQABAb4CygABAcICygABAaYCygABAagCygABAaMDKgABAaYDKgABARoDDAABARoDBwABAiECygABAhECygABAcoCygABAl4CygABAlwCygABAlsCygABAmUDKgABAmIDKgABAIsDDAABAIsDBwABAIsDXAABASkCygABAboCygABAdsCygABAdQCygABAcsDKgABATEDBwABAbsCygABAdECygABAm0CygABAmsCygABAjoCygABAjsCygABATYDDAABATYDBwABATYDXAABAkgCygABAl8CygABAncDKgABAckCygABAmkCygABAj8CygABAkQCygABAjIDKgABAk8DKgABARoC/QABAIsC/QABATEC/QABATYC/QABAToDDAABAToDBwABAToDXAABAxICGwABAw0CGwABA4sCGwABA3MCGwABA3gCGwABA3oCGwABAUoDDAABAUoDBwABAUoDXAABA9MCGwABA80CGwABBG0CGwABBGwCGwABBGkCGwABBGgCGwABBGACGwABAZMDDAABAZMDBwABAZMDXAABA9wCGwABA+kCGwABBH4CGwABBFoCGwABBGICGwABBEcCGwABBE8CGwABAToC7QABAToCrgABAToC/QABAToC5QABAUYDnAABAUYDXQABAUgCygABAxkCGwABAUoCGwABAUoC/QABAUoC5QABAc8CygABA3cCGwABAIsC7QABAIsCrgABAIsDCgABAIsC5QABAIsDXQABALEDnAABALEDXQABASACygABASUCygABATYC7QABATYCrgABATYDCgABATEDDAABATYC5QABATYDXQABASQDnAABASQDXQABAbkCygABAZkCygABAZMCGwABAZMC/QABAZMC5QABAdwCygABAa0CygABAdcCygABAbICygABA5oCGwABALsA4wABAMYA4wABALAA4wABALYA4wABAMYCGwABAQwCygABATICygABAR8C+AABAKcC+AABAYcCygABAR8CygABAYECygABAQ8CGwABAZ0CGwABAQcCGwABARICygABAXUCGwABAToDawABAToDiQABAIsDawABAIsDiQABATYDawABATYDiQABAIsDuQABAIsDtwABATYDuQABATYDtwABAW8CygABAWoCygABAeQCygABAaACGwABAZwCygABAZ8CGwABAcMCygABAT0CygABAgkCygABAaICGwABAisCygABAXUCygABATwCGwABAX4CygABAU4C+AABAY4CygABAccCygABAWsCygABATcCygABAwYCygABAPoCygABAZ0CygABAkUCygABAXsCygABAR0CygABAekCygABASEAAAABARkAAAABATACygABALECygABAJMCygABAYQCygABAOgCGwABATAC+QABASwCGwABAP8CGwABAO4CGwABAR4CGwABAQwCGwABAQ4C+AABAKwC/QABAFgBXgABANYC/QABAFgA4wABAFgCYwABAFgCYgABAIgCGwABAnUCGwABAoICGwABAPUCGwABAUcCGwABAU4CGwABAQUCGwABATcC+AABAQsC+AABAeUCGwABAIoC+AABAPQCGwABAUgC/QABAYMAAAABASkC/QABAQoCGwABAR8CGwABASACGwABAIgC+AABATsCGwABAPMCGwABARMCPwABARIDFAABARIDEQABARIDIgABARIC9AABARIDFwABARIC0gABARICPwABARIDWwABARIDqgABARIDCQABAX4CPwABAXADFAABAQ0CPwABATkDFAABATkCPwABATkDIgABATkC/QABASkDIgABAPMDEQABAPMC9AABAPMDFwABAPMC0gABAO8CPwABAUYCPwABAUYDEQABAUYDIgABAUYCRwABAUYC/QABATICPwABATIDIgABAJoDFAABAJoDEQABAJoDIgABAJoC9AABAJoDDAABAJoDFwABAJoC0gABAJoCPwABAJoDCQABAH0DIgABARcCPwABAH0DFAABAH0CPwABAOECPwABAXoCPwABAUIDIgABAUIDCQABAUIDFQABAUIC9AABAUIDFwABAUIDJgABAUIC1gABAUQCQAABAUIDFAABAUIDDQABAYMCPwABAP0CPwABAUICPwABAQcDFAABAQcDJgABAQcCPwABAOYDFAABAOYDIgABATECPwABATADFAABATADEQABATAC9AABATADFwABATADIgABATAC0gABATACPwABATADWwABATADCQABAQYCPwABAY0CPwABAY0DFAABAY0DIgABAY0C9AABAY0DFwABAQUCPwABAPcCPwABAPcDFAABAPcDIgABAPcC9AABAPcDFwABAPMCPwABAPMDFAABAPMDIgABAPMDDAABAFgC3QABAvwBdAABAOYCygABASQCygABAcsAAAABAXECygABAsYCygABAWcCygABAXQCygABAQcCygABAXgCygABAWgCygABAcsCygABAWUCygABAT0CGwABAlcCGwABATUCGwABARsDAAABAOkCGwABAXgCGwABAMsCygABAcwCGwABAFYC+AABALEC+AABATMC+AABAPICGwABAIsCGwABAagCGwABAUkCGwABASsCGwABAYMCGwABAS8CGwABAOQCYgABAMMCYgABAOQCygABAUcCygABAYgCygABAJICygABAMwCGwABARAC+gABAU0CGwABAT8C/QABAOYAAAABAUYDbwABAS8CygABAVcCygABAZ4CygABAIkC+AABATACGwABAToCGwABAfkCGwABANkC+AABAMwC+AABAd4ABwABAekAAQABARoCGwABATcCGwABAFkBaAABAFoBaAABAFgBaAABATwA4wABAM0A4wABANkA4wABAJ4A4wABAG0BLAABAPMCywABATcCYgABAI0C5wABAIAC5wABAX8AAAABAYUCygABAUAAAQABAYUAAAABASQAAAABADQBaQABAj4BUwABAiMBWQABAu8CygABAIgC6AABAT8CygABAPcCygABATYCygABAOL//AABAMkCywABAYAAAAAEAAAAAQAIAAEqBAAMAAEqZAUyAAIA2wAkAD0AAABEAF0AGgCCAIcANACJAJEAOgCTAJgAQwCbAJ8ASQCiAKcATgCpAK0AVACzALgAWQC7AL8AXwDBANEAZADUAOcAdQDqAOoAiQDsAOwAigDuAO4AiwDwAPIAjAD1APUAjwD3APgAkAD6AQEAkgEEAQoAmgENARIAoQEVASYApwEoAT8AuQFIAUkA0QFVAVUA0wFXAVsA1AFeAV8A2QFiAWcA2wFpAWoA4QFsAWwA4wFuAW4A5AFwAXEA5QFzAXMA5wF2AXcA6AF+AX8A6gGEAYQA7AGLAYsA7QGTAZMA7gGYAZgA7wGbAZsA8AGfAaIA8QGpAakA9QGrAasA9gGuAa4A9wG1AbcA+AG5AbsA+wG+Ab4A/gHJAckA/wHOAc4BAAHXAdcBAQHZAdoBAgHcAdwBBAHeAd4BBQHpAekBBgHtAe4BBwHwAfABCQH1AfUBCgH5AgABCwIXAhcBEwJCAkUBFAJMAkwBGAJOAk4BGQKTApQBGgKXApcBHAKkAqQBHQKpAqkBHgK4ArwBHwK/AsABJALPAtABJgLYAtgBKALaAtoBKQLcAtwBKgLqAuoBKwL9AyUBLAMnAzYBVQNBA0QBZQNPA1QBaQNgA2EBbwNwA3ABcQOPA48BcgOqA6wBcwOuA70BdgPCA8kBhgPPA9ABjgPTA90BkAPfA98BmwPhA+wBnAPvA/ABqAP1A/UBqgP3BAQBqwQKBA4BuQQUBBQBvgQWBBcBvwQcBCABwQQoBCgBxgQuBC4BxwQyBDIByAQ1BDUByQQ8BDwBygRGBEYBywRUBFQBzARWBFYBzQRZBFsBzgRlBGUB0QRrBGsB0gR9BH0B0wR/BIEB1ASEBIUB1wSjBKUB2QTGBMYB3ATMBMwB3QTaBNsB3gThBOEB4ATmBOYB4QToBOsB4gT9BP4B5gUJBQwB6AUOBQ4B7AUYBRgB7QUaBSgB7gUqBTAB/QUzBTUCBAU5BTkCBwU7BTwCCAU+BT4CCgVCBUcCCwVJBUoCEQVNBVMCEwVWBVYCGgVcBVwCGwVjBWMCHAVpBWkCHQVsBXACHgV0BXQCIwWIBYgCJAWMBYwCJQWOBZACJgWiBaICKQWmBacCKgWrBdgCLAXaBjwCWgZGBk0CvQZUBlkCxQZiBmkCywZyBoUC0waOBpEC5waqBqsC6wa4Br8C7QbIBs8C9QbnBusC/Qb2BvoDAgcEBwcDBwcTBxcDCwcgByEDEAdAB0MDEgdIB0gDFgdiB2MDFwdlB2cDGQfZB9kDHAffB98DHQfkB+QDHgfqB+wDHwfuB/ADIgfyB/YDJQf5B/kDKggFCAUDKwgKCAsDLAgNCA4DLggQCBEDMAgVCBYDMggbCCADNAgxCDEDOgg5CDkDOwhGCEcDPAhNCE8DPghRCFIDQQhVCFUDQwhYCFkDRAhcCFwDRghkCGcDRwh0CHsDSwiACIUDUwiLCJcDWQiaCKEDZgijCKMDbgilCLUDbwi3CL4DgAjACMsDiAjNCNEDlAjTCNsDmQjeCN4DogjgCOADowjiCOwDpAjuCO4DrwjwCQ4DsAkQCRMDzwkcCRwD0wktCS4D1AlOCU4D1gl6CXoD1wmMCY0D2AmYCZgD2gmcCZwD2wmsCa0D3AmvCa8D3gm3CbcD3wm6CboD4Am8CbwD4QnWCdYD4gnfCeYD4wnrCesD6wrWCtYD7ArYCtsD7QrfCt8D8QriCuMD8grqCuoD9ArvCu8D9QyIDIgD9gyQDJAD9wP4EtoJ/A0sEqQLdgmuCbQLBBIUDJYMnBJKDIoSdBNcC1gTXA0sC2oLTAt8DTIJugnACxYJzAvWCagMqBK2C9wTMgu4DK4SJhImC74S7AusEoYTbgugC7gLxAvKEsgL4gumCdgJxgneCdIS2hLaEtoS2hLaEtoNLAt2C3YLdgt2EhQSFBIUEhQSdBNcE1wTXBNcE1wLfAt8C3wLfAsWC9YL1gvWC9YL1gvWDKgL3AvcC9wL3BKGE24TbhNuE24TbgviC+IL4gviCd4J3hLaC9YS2gvWEtoL1g0sDKgNLAyoDSwMqA0sDKgSpBK2C3YL3At2C9wLdgvcC3YL3At2C9wJtAu4CbQLuAm0C7gJtAu4CwQMrhIUEhQSFBIUEiYSFAyWDJwLvhJKEuwSShLsEkoS7BJKEuwSdBKGEnQShhJ0EoYH8hNcE24TXBNuE1wTbg0sC8QNLAvEDSwLxAtqC8oLagvKC2oLygtqC8oLTBLIC0wSyBLIC3wL4gt8C+ILfAviC3wL4gt8C+ILfAviCboJ2AsWCd4LFgnMCdIJzAnSCcwJ0gtqC8oH+ApQB/4IBAr+CwQS2gn8C3YJzAsEE1wSFAycDIoSdBNcC1gLTAsWCcASFAsWC9AJxggKE24MxhNuC3YLahIUEhQMlhLaCfwLdgyKCwQTXAtYDSwLTAnAC9YL3BNuC6AMqAneCcYL3AvKEiYSJgneCboJ2Am6CdgJugnYCxYJ3ggQDIoLrBLaC9YLdgvcDSwMqAsWDK4SFBIUEtoL1hLaC9YLdgvcE1wTbgneCd4J3hK2EtoL1hLaC9YS2gvWEtoL1hLaC9YS2gvWEtoL1hLaC9YS2gvWEtoL1hLaC9YS2gvWC3YL3At2C9wLdgvcC3YL3At2C9wLdgvcC3YL3At2C9wSFBIUEiYTXBNuE1wTbhNcE24TXBNuE1wTbhNcE24TXBNuC3wL4gt8C+ILFgneCxYJ3gsWCd4LTBLICBYLfBLaC9YSFBNcE24LfAviC3wL4gt8C+ILfAviC3wL4hLaC9YS2gvWCbQLuAycC74TXBNuE1wTbgm0C7gSdBKGEtoL1hLaC9YLdgvcC3YL3BIUEhQTXBNuE1wTbg0sC8QNLAvEC3wL4gt8C+ILBAyuCcwS2gvWC3YL3BNcE24TXBNuE1wTbhNcE24LFgneEtoNLAyoEkoLTAt8C3YL3A0sC8QLFgneCCgIHAu4CCISJggoDRQILgviDRQNFA0UE1wINAg6DHIIQAmWCEYITAhSCFgJSAyoCF4MqBImDSwNLBNcC7gJugnYCGQIaghwCHYIfAiCCdIIiAiOCI4IlAiaCKAIpgisCLIIuAi+CMQIygjQCNYI3AjiCOgI7gj0CPoJSAk2CQAJBgkMCYQJEgkYCR4JJAkqCZAJMAk2CTwJQglICU4LgglUCVoJYAlmC0AJbBKGCXILoAmoErYTMgu4C74LoAl4CX4JhAmKDHIJkAmWCZwJogn8CagJ/AmoCfwJqA0sDKgSpBK2EqQSthKkErYSpBK2EqQStgt2C9wLdgvcC3YL3At2C9wLdgvcCa4TMgm0C7gLBAyuCwQMrgsEDK4LBAyuCwQMrhIUEiYSFAycC74MnAu+DJwLvhJKEuwSShLsEkoS7BJKEuwMigusDIoLrBJ0EoYSdBKGEnQShhJ0EoYTXBNuE1wTbhNcE24TXBNuC1gLoAtYC6ANLAvEDSwLxA0sC8QNLAvEC2oLygtqC8oLagvKC2oLygtqC8oLTBLIC0wSyAtMEsgLTBLIC3wL4gt8C+ILfAviC3wL4gt8C+INMgumDTILpgm6CdgJugnYCcAJxgnACcYLFgneCcwJ0gnMCdIJzAnSDK4SyAnYCd4L1hLaEtoJ5AnqCfwJ8An2CfwKVgpWCgIKCAoOChQKGgogCuYKJgrgCiwKMgo4Cj4KRAycCkoKUApWClwKXBNuE24TbhNuE24TbgpiCmgKbgp0CnoKegqACoYKjAqSE24TbgqYEtoKngqkCqoKsAq2CrwKwgrICs4KzgrUCtoK4ArmEtoS2grsEtoS2gryDSwK+Ar+CwQSFBIUCwoLEAsWCxYSpAscCyILKAsuC0ALNAs6C0ALrAvWEsgMrgycC74LRgtMC1IMnAycDJwSShNcE1wLWAteC2QTXBNcDTINDhJ0DSwMnBJ0C2oLcA0UDRQS2gt2EhQLfBJKEnQLgguIC44LlAu+C74LvhLsC5oLoAu4C7gLphK2EuwLrBKGEoYLsgu4C74ShgvEC8oL0AvWC9wS7BKGEiYL4gvoC+4L9Av0C/QL9Av0C/QL9Av0C/QL9Av0C/oMYAxgDGAMYAxgDGAMAAwADAYMBgwGDAYMBgwGDAYMBgwGDAYMDAwSDBIMEgwSDBIMGAwYIFwgXCBcIFwgXCBcIFwgXCBcIFwMHgweDFQMVAwkDCQMJAwkDCQMKgw2DDYMNgw2DDYMNgw2DDYMNgw2DDYMNgw2DDYMMAw2DDwMPAw8DDwMQgxCDEIMQgxCDEIMSAxIDEgMSAxODE4MTgxODE4MTgxODE4MTgxODE4MVAxaDFoMWgxaDFoMYAxmDGYMZgxmDGYMbAxsDGwMbAxyDHgMfgx+DRQMhAyKE1wMkAyWDRQS2gycDKIMqAyuEzIMtAy6DMAMxgzMDNIM2AzeDOQM6gzwDPYM/A0CDQgNDg0UDRoNIA0mEiYNLA0yDTgNPgABApICGwABAiICygABAzYCygABAdYCygABAgoC/QABAXYCYgABAfYCygABABQCGwABAFb/IwABADIAAAABAB7/hwABAAT/IwABAWEC5wABAQcCYgABAf8CYgABAUoCYgABAIwC5wABASECYgABAtsC+AABAjf/9wABAkQAPAABAkEADgABANkCFAABAkP/aAABAdQCGwABAV8CywABAZ4CywABAc8CywABAV0CywABAUYCywABAcsCywABAdkCywABANkCywABALACywABAY4CywABAPECywABAkcCywABAesCywABAfUCywABAfICywABAYECywABAY8CywABAWECywABAdMCywABAlcCywABAVQC5wABAW0C5wABAWcCYgABAWkC5wABAkgCYgABAXoCYgABAYICYgABAOUCqwABAXcBJwABACABHwABAUkCYgABAW8C6gABAVQCYgABAWECYgABAQcA4wABAXUA4wABAUkA4wABAW8BawABAWEA4wABADoAAAABATACYgABAP4C6gABAW4CYgABADgAmgABAXUCYgABAA0BHwABAR0CYgABAVMC6gABAgsC+AABAfwCygABAsMCygABA5kCygABAk4CygABAgsCGwABAioCygABAbYCGwABAxMCGwABAfsCGwABApQCygABApgCygABAn4CygABAnkCygABAnwCygABAwoCygABAwUCygABAvsCygABAvoCygABAysCygABAzECygABA74CygABA70CygABA8cCygABA8MCygABAcwCygABAcYCygABAlYCygABAncCygABAnECygABAmcCygABAy8CygABA0UCygABA+ECygABA98CygABA68CygABAsICygABA1gCygABA28CygABA4cCygABAiACygABApMCygABApsCygABAoQCygABAogCygABAoUCygABAoMCygABAzQCygABAy4CygABA80CygABA8kCygABA8ECygABA8gCygABA8ACygABAh4CygABAmgCygABAy0CygABAzACygABAtgCygABAbwCygABAcECygABAjMCygABAtYCygABAqoCygABA1ACygABAyECygABAWcA4wABAXoA4wABAVQA4wABAHIAAAABAh8CygABBHoCygABAlACygABAq0CygABA1YCygABAhICygABA0sCygABAhkCygABAs4CygABAKQBXgABAKQCYwABA2ICGwABA5cCGwABAlwCGwABAlECGwABAfoCGwABA4MCGwABAegCGwABAjICGwABAisC+AABAZUCGwABAbwCGwABAjUC/QABAgwCGwABAigCGwABAj4CGwABAqUClAABA0EClAABAg8CPwABAgUCPwABAj0CPwABAbECPwABAZsCPwABAkICPwABAlACPwABAOYCPwABAPwCPwABAuACPwABAeMCPwABAm8CPwABAfkCPwABAbcCPwABAbkCPwABAkwCPwABAfgCPwABAwUCPwABAfYCPwABAdkCPwABAdECPwABAKQC3QABAvwA1wABABQCygABABMCygABA4ICygABACgCGwABAQ4CygABAmQCygABAtMCygABAdMCGwABAh8C+AABAwECGwABASkC+AABARwC+AABAh8CGwABAWEBaAABAWkBaAABAIwBaAABAkgA4wABAXYA4wABAYIA4wABASEA4wABAOUBLAABAMEC5wABAKYCygABABAAAQABAKYAAAABABQAAAABADQC3QABA9kCygABA2YCygABAmUCygABAlMCygABAYMCywABAzACGwAFAAAAAQAIAAEG0gKEAAEIEgAMABIAJgA4AEoA2AD8AFwAbgB8AJYAqAC6AMYA2ADqAPwBDgFIAYoAAgAGAAwAAQDeAAAAAQK7AAAAAgAGAAwAAQEaAAAAAQIt/xkAAgAGAAwAAQFKAAAAAQNoAAAAAgAGAAwAAQCgAAAAAQIEAAAAAwAWABwACAABA1MAAAADAAgADgAUAAEAkAAAAAEB9QAAAAEDUQAAAAIABgAMAAEAngAAAAEB7QAAAAIABgAMAAEAnQAAAAEB7AAAAAIABgAkAAEDrgAAAAIABgAMAAEBLwAAAAEDhQAAAAIABgAMAAEBigAAAAEDswAAAAIABgAMAAEA/wAAAAEDAQAAAAIABgAMAAEBMAAAAAECvgAAAAcAEAAWABwAIgAoAC4ANAABAqwAjgABAMAAjgABAjEBkgABAbYAjgABATwBkgABAjH/iQABATz/iQAIABIAGAAeACQAKgAwADYAPAAB/r3/RQABAT7/RQAB/jAArwABAAP+1wABAc8ArwAB/r0CDwABAT4CDwABAAMCcQACAAYADAABANcCHgABAkwAAAAFAAAAAQAIAAEK/AAMAAELIgAgAAEACAVmB/EILQhUCTAJPQlvCXIACAASAEIAJABUADYAQgBUAGYAAgAGAAwAAQDAAQ0AAQK5AQ0AAgAGAAwAAQCIAQ0AAQGYAQ0AAgAGABIAAQOtAWUAAgAGAAwAAQGJAWUAAQOyAWUAAgAGAAwAAQExAQ0AAQK/AQ0ABwAQABYAHAAiACgALgA0AAECqwEsAAEAwAEsAAECMQIxAAEBtQEsAAEBPAIxAAECMQAnAAEBPAAnAAUAAAABAAgAAQrUAAwAAQx0ADQAAQASBWYH3wfjB/EIVAiGCIcIiAiJCIoJMAkzCT0JZQlvCXIMYwyRABIAJgA4AEoAuADcAFwAYgBiAHwAiACaAKYAuADKANwA7gEoAWoAAgAGAAwAAQCnApQAAQIIAvgAAgAGAAwAAQEaAsoAAQItAeMAAgAGAAwAAQFGAsoAAQNjAsoAAgAOABQAAwAIAA4AFAABAQEC/QABAmYC/QABA1EC/QACABIABgABAe0C/QACAAYADAABAR8C/QABAewC/QACAAYAJAABA60CygACAAYADAABASoCygABA6ACygACAAYADAABAYkCygABA7ICygACAAYADAABAPYCGwABAxECGwACAAYADAABATECGwABAr8CGwAHABAAFgAcACIAKAAuADQAAQKrAcsAAQDAAcsAAQIxAs8AAQG1AcsAAQE8As8AAQIxAMYAAQE8AMYACAASABgAHgAkACoAMAA2ADwAAf69ABgAAQE+ABgAAf4wAYIAAQAD/6oAAQHPAYIAAf69AuIAAQE+AuIAAQADA0QAAgAGAAwAAQDWAAMAAQJBAhsABQAAAAEACAABE1YADAABE7YAUAABACAA8wD0AmkDoQOiA6MDpAOlA6YDpwOoA6kDzAPNA84FZgfjB/EILQhUCIYIhwiICIkIigi/CTAJPQlvCXIMYwyRACAAQgBUAGAAxgDSAOQAbAB4AIoAlgCiALQAxgDSAOQA9gEIAYoBGgGcASwBMgFAAVQBYAFyAX4BigGcAa4B6AIqAAIABgAMAAEBTgLKAAECcALKAAIABgA8AAEA/ALoAAIBQgAGAAEESQIbAAIAEgAGAAEDJgLKAAIABgAMAAEBcgLKAAEDFALoAAIAlgAGAAECDALoAAIAEgAGAAEEFgLKAAIABgAMAAEC9ALKAAEEBALoAAIABgAMAAECPwIbAAEDcQLoAAIAEgAGAAEE/QLKAAIABgAMAAECyQLKAAEEkwIbAAIABgAMAAECMgL4AAEEIwIbAAIABgAMAAEBYQKUAAEDngL4AAIABgAMAAECHALKAAEEOQLKAAIABgAMAAEA2AL4AAEB5wL4AAIAOgAcAAMANAAWAAgAAQPFAugAAwAmAAgADgABAusC/QABA6EC+AACABIABgABAmEC6AACAAYADAABAYcC/QABAjwC+AACDR4ABgABAhoCPwACAAYAEgABBSECygACAAYADAABAv0CygABBSYCygACAAYADAABAkYCGwABA9QCGwAHABAAFgAcACIAKAAuADQAAQNRAcsAAQFlAcsAAQLWAs8AAQJaAcsAAQHhAs8AAQLWAMYAAQHhAMYACAASABgAHgAkACoAMAA2ADwAAf8RABgAAQGSABgAAf6EAYIAAQBX/6oAAQIjAYIAAf8RAuIAAQGSAuIAAQBXA0QAAgAGAAwAAQAgAAMAAQNIAhsABgAQAAEACgAAAAEADACUAAEBTAL+AAIAFgIoAigAAAuWC5kAAQucC7IABQu4C7sAHAvCC8QAIAvIC8kAIwvOC9EAJQvUC9UAKQvXC9cAKwvaC9oALAvdC90ALQvhC+EALgvrC+sALwvwC/AAMAv3C/wAMQv/C/8ANwwQDBEAOAwzDDkAOgw8DDwAQQxJDEkAQgxODE4AQwx/DH8ARAACAB4CKAIoAAALlguZAAELnAuyAAULuAu7ABwLwgvEACALyAvJACMLzgvRACUL1AvVACkL1wvXACsL2gvaACwL3QvdAC0L4QvhAC4L6wvrAC8L8AvwADAL9wv8ADEL/wwEADcMBgwNAD0MEgwmAEUMKAwpAFoMLAwtAFwMLwwxAF4MPAw8AGEMTgxOAGIMVQxcAGMMYAxgAGsMZgxtAGwMbwxzAHQMdQx3AHkMeQyAAHwMggyHAIQARQAAAawAAAEWAAABHAAAAawAAAGsAAABQAAAAawAAAGsAAABrAAAAawAAAEiAAABKAAAAS4AAAGsAAABNAAAAUAAAAFAAAABrAAAAawAAAFAAAABrAAAAawAAAGsAAABrAAAAawAAAGsAAABrAAAAUAAAAE6AAABrAAAAUAAAAFAAAABrAAAAawAAAGsAAABrAAAAUAAAAGsAAABRgAAAUYAAAFYAAABrAAAAXAAAAFMAAABrAAAAVIAAAFYAAABrAAAAWoAAAFeAAABrAAAAawAAAGsAAABZAAAAWoAAAFwAAABdgAAAXwAAAGsAAABrAAAAYIAAAGIAAABjgAAAY4AAAGUAAABmgAAAaAAAAGmAAABrAAB//UAAAABAA0AAAAB/6EAAAABAF8AAAAB/tIAAAABAAMAAAABAAIAAAABAAEAAAAB//4AAAAB/woAAAABABUAAAABAAYAAAAB//0AAAAB//cAAAAB//sAAAAB//8AAAAB//8ACAABAAAANQABAAD/4gABAAD/5gABAAD/2QABAAD/1AAB/v0AAAABAGUAAAABACAAAAABAAAAAACKARYBHAEiAWQBZAEoAS4BLgE0AToBQAFGAUwBUgFYAb4BXgGyAWQBrAFqAXABdgF8AYIBiAGOAZQBmgGgAaYBrAHEAbIB0AG4Ab4BxAHKAcoB6AHQAdAB1gHcAeIB6AHuAfQB+gIAAgYCBgIMAhICGAJaAh4CJALGAioCMAJOAjYCPAJCAsYCxgLAAsYCxgLGAkgCxgLGAsYCxgLGAsYCxgLGAk4CigLGAsYCVALGAsYCWgLGAsYClgLGAsYCxgLGAmACZgJsAsYCxgKoAnICxgLGAsYCxgJ4AsYCxgLGAsYCxgLGAsYCfgKEAooCkAKWAsYCnAKiAqICxgLGAsYCqALGAsYCrgK0AsYCugLAAsYCxgLMAAEAAv8jAAH/9/80AAEAD/80AAEAA/8bAAEAAv8wAAEAAv8cAAEAAP8qAAH/of8RAAEAX/8RAAH+0/9GAAEAAv9LAAEABf8dAAEAAP8eAAEAAv8mAAEAA/85AAEAAv84AAEAAv8+AAEAAv89AAEAAv9BAAEAA/9kAAEAAv9lAAEAA/8hAAEABP8bAAEAAP8mAAEAA/8cAAEAA/9PAAEAAv8xAAEAAv8lAAEAA/8QAAEAAv8hAAEAAP8QAAEAAv8QAAEAA/8XAAEAAv9vAAEAF/8iAAEACP8QAAEAAv8bAAH//f8sAAEAAP8KAAEAAv73AAEAAv8OAAH/+f8QAAH//f8VAAEAAv8SAAEAEQJsAAEAKAJsAAEAAgJsAAH/qAIoAAEACgIMAAH/nAIoAAEACQJsAAEACgIgAAH/vAIMAAEACAIgAAEACAJsAAEAPgJsAAH+//8cAAEAIv8eAAH/wQIMAAEAUAJsAAEAVgJsAAEAGwIMAAEAGwJsAAEAAwJsAAEAEAJsAAEABQIMAAEACwJsAAEADAJsAAH/3f7qAAH/5wJsAAEAGAJsAAEABAJsAAEACgJsAAEADQJsAAYAEAABAAoAAQABAAwAHAABADIAcAABAAYLswu0C7ULtgu3DD0AAQAJDAYMDAwcDG0McQx2DHoMfgyDAAYAAAAaAAAAIAAAACYAAAAsAAAAMgAAADgAAQAEARMAAQABASEAAQAAARsAAQABAR8AAQAAAV4AAf//ANsACQAgACAAIAAUABoAIAAgACAAIAABAFYC2AABAAsC2AABAAoC2AAGABAAAQAKAAIAAQAMANAAAQGsBh4AAgAgAVMBVAAABMEEwQACBuwG7AADBu4G8AAEBvsG/QAHBwgHCgAKBxgHGgANByUHJgAQB1YHVgASB4UHiAATCt4K3gAXC4ELlAAYC7wLwQAsC8ULxwAyC8sLzQA1C9IL0gA4C9YL1gA5C9gL2QA6C9sL3AA8C94L4AA+C+IL6gBBC+wL7wBKC/EL9gBOC/0L/gBUDAAMDwBWDBIMMQBmDDoMOwCGDD4MSACIDEsMTQCTDE8MYgCWDGYMfgCqDIAMhwDDAAIAJATBBMEAAAbuBu4AAQb7Bv0AAgcIBwoABQcaBxoACAclByYACQreCt4ACwuBC5QADAu8C8EAIAvFC8cAJgvLC80AKQvSC9IALAvWC9YALQvYC9kALgvbC9wAMAveC+AAMgviC+IANQvmC+oANgvsC+8AOwvxC/YAPwv9C/4ARQwADAQARwwGDA8ATAwSDCkAVgwsDC0AbgwvDDEAcAw6DDsAcww+DEgAdQxLDE0AgAxPDFIAgwxVDFwAhwxgDGAAjwxmDG0AkAxvDHcAmAx5DIAAoQyCDIcAqQDLAAADRgAAA14AAAMuAAADNAAAAzoAAANkAAADXgAAA0AAAANGAAADRgAAA0wAAANSAAADWAAAA14AAANkAAADagAAA3AAAAN2AAADfAAABGwAAARsAAAEbAAABGwAAAOCAAAEbAAABGwAAAOIAAADjgAAA5QAAARmAAAEYAAABGYAAAPoAAADmgAABGAAAAOgAAAEbAAABGwAAAOmAAAEWgAABGwAAAOsAAAD7gAAA7IAAARsAAAEbAAABFoAAAO4AAADvgAABGwAAARaAAADxAAABGwAAAPWAAAEWgAABFoAAARaAAAEbAAABGAAAARsAAAEbAAAA8oAAARsAAAD3AAAA9YAAAPQAAAEbAAABGwAAARsAAAEbAAABGwAAAPWAAAEbAAAA9wAAAPoAAAD4gAAA+gAAAQ8AAAEWgAAA+gAAARgAAAEbAAABGwAAARgAAAEWgAABFoAAARsAAAEbAAABGwAAARsAAAEbAAABGwAAARsAAAEbAAABGwAAARsAAAEbAAABGwAAARsAAAEbAAAA+4AAAPuAAAEbAAABGwAAARsAAAEbAAABGwAAARsAAAEbAAABGwAAARsAAAEbAAABGwAAARsAAAEbAAABGwAAARsAAAEbAAABGwAAARsAAAEbAAABGwAAARsAAAEbAAABGwAAARsAAAEbAAABGwAAARsAAAEbAAABGwAAARsAAAEbAAABGwAAARgAAAD9AAABAwAAAP6AAAEHgAABAAAAAQGAAAEDAAABAwAAAQSAAAEGAAABB4AAAQkAAAEbAAABCoAAAQ8AAAEMAAABDYAAAQ8AAAEQgAABEgAAAROAAAEbAAABGwAAARsAAAEbAAABGwAAARsAAAEbAAABGwAAARaAAAEWgAABFQAAARsAAAEWgAABGAAAARsAAAEbAAABGwAAARsAAAEbAAABGwAAARsAAAEbAAABGwAAARsAAAEbAAABGwAAARsAAAEbAAABGYAAARsAAAEbAAABGwAAARsAAAEbAAABGwAAARsAAAEbAAABGwAAARsAAAEbAAABGwAAARsAAAEbAAABGwAAARsAAAEbAAABGwAAf7bAhsAAQCAAhsAAQCBAhsAAQEdAhsAAQEjAhsAAQEWAhsAAQEcAhsAAQEuAhsAAQEhAhsAAQEkAhsAAQEtAhsAAQELAhsAAQCJAhsAAf//AWUAAQCvATEAAf6ZAhsAAf70AhsAAQA6AhsAAf7KAhsAAQABAnkAAf7XAhsAAf/9AZAAAf/+AZAAAf/AAhsAAQBBAhsAAf//Ag8AAf6uAmsAAf7fAhsAAf/+AhsAAf/9AhsAAf7rAhsAAQADAhsAAQAAAZAAAQAEAZAAAQCLAj8AAQEQAj8AAQEfAj8AAQEqAj8AAQEpAj8AAQEdAj8AAQEnAj8AAQEgAj8AAf/9AekAAf7qAhsAAf7xAhsAAf7mAhsAAf7nAhsAAf//ArwAAQAAAf8AAf//AD8AAf//AhsAAQABAhsAAQACAhsAAQAAAhsArwFgAWYBbAFyAYQBeAF+AYQBigGQAZYBnAGiAagBrgG0AboBwAHGAcwB0gHYAd4B5AHqAeoB8AH2AfwDagICAggCDgIUAhoCIAImAiwCMgI4Aj4CaAJ0ArwCdAJEAkoCUAJWAlwCgAJiAmgCbgJ0AnQCegKAAoYCjAKSApgCngKkAqoCsAK2ArwCwgLIAsgDuALOAtQDygLaBAwC+AO+BAwEDAOUA5QDlALgAuYDvgQMAuwEDAQGAv4C8gQMBAwEDAQMBAwC+AOsBAwEBgMEAv4EDAMEBAwDCgQMA7gDEAQMBAwEDAMWAxwDIgMoAy4DNAM6A0ADRgNGA0wDUgNYA14DZANqA3ADdgN8A4IDiAQMA44DlAQMBAwEBgQMBAwDmgQMBAwEDAQMBAwEDAOgA6YDrAOsA7IDuAO+A8QDygPQA9YD3APiA+gD7gQMBAwD9AP6BAwEAAQMBAYEBgQMAAH+3QM4AAEAgwMMAAEBJAMHAAEBPAMHAAEBGwMHAAEBNQMHAAEBKwNcAAEBDgL9AAEBOAL9AAEAiQMMAAECdgFQAAEAAALbAAEAAALoAAH+mQL9AAH+9AL9AAEAOgL+AAEAAgL9AAEAAwL+AAEAAgLrAAEABQM3AAH+ygLkAAEAAQKwAAEAAQNKAAEAAgL7AAH+1wL+AAEAAgNPAAEAAgLtAAEAAQLKAAEAAALKAAEAAgMHAAEAAgNiAAEAAgPBAAH/wgL+AAEAQwL+AAEAAgL6AAEAAgMEAAEAAgOhAAEAAgNcAAEAAgMPAAEAAwMKAAEAAgKkAAEAAwLnAAEAAgNaAAH//wLhAAEAAAMWAAH+4QL6AAEAAgMpAAEAAAL+AAEAAgLiAAH//wLqAAEABQLqAAH+7QLkAAEABQLhAAH+6AMMAAEAAQLfAAEABQL+AAEAAwM7AAEAAgNKAAEAAgNMAAEAAwOGAAEAAgNDAAEAFQOcAAEADgOeAAEALgOeAAEAAAJwAAEAAwLKAAEAGQNEAAEAEQNEAAEAFQNEAAEABgNEAAEACANEAAH//wNEAAH/yQOcAAEAPgNEAAEAAwM8AAEABgM7AAEBLAL0AAEAjQL9AAEA7gMXAAEBTAMUAAEBaQMXAAEBLQMUAAEBLAMFAAEBIAM9AAEBLAMAAAEBIgLLAAEAAgLlAAH//wLKAAH+6ANGAAH+7ALNAAH+8wLlAAH+6AMOAAH+6QMOAAEADANEAAEACgOTAAEAUANEAAEADgNEAAEAVgNEAAEAHANEAAH/9wOcAAEACwNEAAEACgOeAAEABALtAAEABwNEAAH/ugOcAAEACgOWAAH/ygOcAAEACgOcAAEAIAOeAAEADwNEAAEADv/CAAEAGANEAAH//wN0AAEACQNEAAEACgNEAAYAEAABAAoAAwABAAwAGAABAGwAlgABAAQLlQuaC5sL0wABACgMAQwCDAQMBgwHDAkMCgwLDAwMDQwcDB4MHwwhDCcMKAwpDFgMawxtDG8McAxxDHIMdQx2DHcMeQx6DHwMfQx+DH8MgAyCDIMMhAyFDIYMhwAEAAAAEgAAABgAAAAeAAAAJAAB/5ICygABACoCigAB/+4CbQABALYCGwAoAFIAWABeALgAagDWAGQAdgC4ANYAuABqAIIA4gCyAHYAjgBwAHYAfACCAIIAiACOAJQAmgCgAKYArACyANYAuAC+AMQAygDQANYA3ADiAOgAAQBqA5wAAQB4A54AAQBqA54AAQC2A0QAAQCKA0QAAQB3A0QAAQB1A0QAAQDTA0QAAQBuA0QAAQB8A5wAAQCCA0QAAQB8A0QAAQBxA5wAAQA+A5YAAQCGA5wAAQAuA5wAAQDJA0QAAQCHA0QAAQBX/8IAAQBhA0QAAQBlA0QAAQBTA3QAAQB/A0QAAQB4A0QAAQB7A0QAAQBkA0QAAAABAAAACgHSAyoABERGTFQAGmN5cmwARmdyZWsAgGxhdG4ArAAEAAAAAP//ABEAAAABAAIABAAHAAgACQAQABEAEgATABQAFQAWABcAGAAZAAoAAVNSQiAAMgAA//8AEQAAAAEAAgAFAAcACAAJABAAEQASABMAFAAVABYAFwAYABkAAP//AAEADwAEAAAAAP//ABEAAAABAAIABgAHAAgACQAQABEAEgATABQAFQAWABcAGAAZACIABUNBVCAASk1BSCAAdE1PTCAAnk5BViAAyFJPTSAA8gAA//8AEQAAAAEAAgADAAcACAAJABAAEQASABMAFAAVABYAFwAYABkAAP//ABIAAAABAAIAAwAHAAgACQAKABAAEQASABMAFAAVABYAFwAYABkAAP//ABIAAAABAAIAAwAHAAgACQALABAAEQASABMAFAAVABYAFwAYABkAAP//ABIAAAABAAIAAwAHAAgACQAMABAAEQASABMAFAAVABYAFwAYABkAAP//ABIAAAABAAIAAwAHAAgACQANABAAEQASABMAFAAVABYAFwAYABkAAP//ABIAAAABAAIAAwAHAAgACQAOABAAEQASABMAFAAVABYAFwAYABkAGmFhbHQAnmMyc2MApmNhc2UArGNjbXAAsmNjbXAAwGNjbXAAymNjbXAA1mRub20A4mZyYWMA6GxudW0A8mxvY2wA+GxvY2wA/mxvY2wBBGxvY2wBCmxvY2wBEGxvY2wBFm51bXIBHG9udW0BIm9yZG4BKHBudW0BLnJ0bG0BNHNtY3ABOnN1YnMBQHN1cHMBRnRudW0BTHplcm8BUgAAAAIAAAABAAAAAQAhAAAAAQAjAAAABQACAAMABgADAAYAAAADAAIAAwAGAAAABAACAAMABgAIAAAABAACAAMABgAHAAAAAQAVAAAAAwAWABcAGAAAAAEAHQAAAAEADQAAAAEADAAAAAEACgAAAAEACQAAAAEACwAAAAEAEQAAAAEAFAAAAAEAIAAAAAEAGwAAAAEAHgAAAAEAJAAAAAEAIgAAAAEAEgAAAAEAEwAAAAEAHwAAAAEAJQAmAE4AYgCAAJoBbgFuAcAIVAn4ChIKRApECmYKiArWCvYLFgs2C0oLtAwkDAIMEAwkDDIMcAxwDIgM0AzyDQoNUA2QDdYQUBLOEy4TQgABAAAAAQAIAAEABgS1AAEAAQTJAAMAAAABAAgAAQAQAAEACAADB6kHqgerAAEAAQELAAQAAAABAAgAARLIAAEACAABAAQKAwACDDIABgAAAAIACgAcAAMAAAABAPgAAQBmAAEAAAAEAAMAAAABAOYAAgAUAFQAAQAAAAUAAgAKAigCKAAAC5YLmQABC5sLuwAFC8ILxAAmC8gLygApC84L0QAsC9ML1QAwC9cL2gAzC9wL3QA3DE4MTgA5AAIAEATBBMEAAAuBC5QAAQu8C8EAFQvFC8cAGwvLC80AHgvSC9IAIQvWC9YAIgvbC9sAIwxLDE0AJAxrDGsAJwxwDHIAKAx2DHcAKwx8DHwALQx+DH4ALgyADIAALwyDDIYAMAABAAAAAQAIAAIAJgAQCCoILAgrCCIIIwg8CDMFZwg0CDUINgg3CDgIOQg6CDsAAQAQAEwATQDxAe4B8AMoBBkENQRqBH8E2wVOBYIFkAWUBdcABAAAAAEACAABBl4AFQAwADoARABOAGoAfACGAJAAmgC2AMgB2gLsA/4FEAYiBiwGNgZABkoGVAABAAQAxgACC6cAAQAEANoAAgunAAEABADwAAILpwADAAgAEAAWA8gAAwunAUwCRwACC5sDxgACC6cAAgAGAAwCSQACC5sBMwACC6cAAQAEAMcAAgunAAEABADbAAILpwABAAQA8QACC6cAAwAIABAAFgPJAAMLpwFMAkgAAgubA8cAAgunAAIABgAMAkoAAgubATQAAgunABwAOgBCAEoAUgBaAGIAagByAHoAggCKAJIAmgCiAKoAsgC6AMIAygDSANoA4gDqAPIA+gEAAQYBDArzAAMEpwSoCvUAAwSnBKkK9AADBKcEqgryAAMEpwSrCv0AAwSoBKcK/wADBKgEqAsBAAMEqASpCwAAAwSoBKoK/gADBKgEqwsJAAMEqQSnCwsAAwSpBKgLDQADBKkEqQsMAAMEqQSqCwoAAwSpBKsLAwADBKoEpwsFAAMEqgSoCwcAAwSqBKkLBgADBKoEqgsEAAMEqgSrCvcAAwSrBKcK+QADBKsEqAr7AAMEqwSpCvoAAwSrBKoK+AADBKsEqwr8AAIEqAsIAAIEqQsCAAIEqgr2AAIEqwAcADoAQgBKAFIAWgBiAGoAcgB6AIIAigCSAJoAogCqALIAugDCAMoA0gDaAOIA6gDyAPoBAAEGAQwLKwADBKcEpwstAAMEpwSoCy8AAwSnBKkLLgADBKcEqgssAAMEpwSrCzYAAwSoBKcLOQADBKgEqQs4AAMEqASqCzcAAwSoBKsLQQADBKkEpwtDAAMEqQSoC0UAAwSpBKkLRAADBKkEqgtCAAMEqQSrCzsAAwSqBKcLPQADBKoEqAs/AAMEqgSpCz4AAwSqBKoLPAADBKoEqwsxAAMEqwSnCzMAAwSrBKgLNQADBKsEqQs0AAMEqwSqCzIAAwSrBKsLKgACBKcLQAACBKkLOgACBKoLMAACBKsAHAA6AEIASgBSAFoAYgBqAHIAegCCAIoAkgCaAKIAqgCyALoAwgDKANIA2gDiAOoA8gD6AQABBgEMC2MAAwSnBKcLZQADBKcEqAtnAAMEpwSpC2YAAwSnBKoLZAADBKcEqwtvAAMEqASnC3EAAwSoBKgLcwADBKgEqQtyAAMEqASqC3AAAwSoBKsLegADBKkEpwt8AAMEqQSoC30AAwSpBKoLewADBKkEqwt1AAMEqgSnC3cAAwSqBKgLeQADBKoEqQt4AAMEqgSqC3YAAwSqBKsLaQADBKsEpwtrAAMEqwSoC20AAwSrBKkLbAADBKsEqgtqAAMEqwSrC2IAAgSnC24AAgSoC3QAAgSqC2gAAgSrABwAOgBCAEoAUgBaAGIAagByAHoAggCKAJIAmgCiAKoAsgC6AMIAygDSANoA4gDqAPIA+gEAAQYBDAtHAAMEpwSnC0kAAwSnBKgLSwADBKcEqQtKAAMEpwSqC0gAAwSnBKsLUwADBKgEpwtVAAMEqASoC1cAAwSoBKkLVgADBKgEqgtUAAMEqASrC10AAwSpBKcLXwADBKkEqAthAAMEqQSpC2AAAwSpBKoLXgADBKkEqwtYAAMEqgSnC1oAAwSqBKgLWwADBKoEqQtZAAMEqgSrC00AAwSrBKcLTwADBKsEqAtRAAMEqwSpC1AAAwSrBKoLTgADBKsEqwtGAAIEpwtSAAIEqAtcAAIEqQtMAAIEqwAcADoAQgBKAFIAWgBiAGoAcgB6AIIAigCSAJoAogCqALIAugDCAMoA0gDaAOIA6gDyAPoBAAEGAQwLDwADBKcEpwsRAAMEpwSoCxMAAwSnBKkLEgADBKcEqgsQAAMEpwSrCxkAAwSoBKcLGwADBKgEqAsdAAMEqASpCxwAAwSoBKoLGgADBKgEqwslAAMEqQSnCycAAwSpBKgLKQADBKkEqQsoAAMEqQSqCyYAAwSpBKsLHwADBKoEpwshAAMEqgSoCyMAAwSqBKkLIgADBKoEqgsgAAMEqgSrCxQAAwSrBKcLFQADBKsEqAsXAAMEqwSpCxYAAwSrBKoLDgACBKcLGAACBKgLJAACBKkLHgACBKoAAQAECCcAAgrxAAEABAgpAAIK8QABAAQIlAACDEkAAQAECK4AAgxJAAEABAjBAAIMSQABAAQI+wACDEkAAQAVACQAKAAsADIAOABEAEgATABSAFgEpwSoBKkEqgSrCCYIKAiNCKUIuAjzAAQAAAABAAgAAQGSAAMADABuAQAACAASABwAJgAwADoARABOAFgHjgAEC4gLkwuEB40ABAuIC5MLgweQAAQLiAuUC4QHjwAEC4gLlAuDB4oABAuLC5MLhAeJAAQLiwuTC4MHjAAEC4sLlAuEB4sABAuLC5QLgwAMABoAJAAuADgAQgBMAFYAYABqAHQAfgCIB5YABAuIC5MLhAeVAAQLiAuTC4MHmAAEC4gLlAuEB5cABAuIC5QLgwekAAQLgQuIC4QHowAEC4ELiAuDB6IABAuBC4sLhAehAAQLgQuLC4MHkgAEC4sLkwuEB5EABAuLC5MLgweUAAQLiwuUC4QHkwAEC4sLlAuDAAwAGgAkAC4AOABCAEwAVgBgAGoAdAB+AIgHngAEC4gLkwuEB50ABAuIC5MLgwegAAQLiAuUC4QHnwAEC4gLlAuDB6gABAuBC4gLhAenAAQLgQuIC4MHpgAEC4ELiwuEB6UABAuBC4sLgweaAAQLiwuTC4QHmQAEC4sLkwuDB5wABAuLC5QLhAebAAQLiwuUC4MAAQADAX0BhQGRAAEAAAABAAgAAgAKAAIIIggjAAEAAgHuAfAAAQAAAAEACAACABYACAgbCIAIHAiBCB0IhAgeCIUAAQAIAMYAxwDaANsA8ADxATMBNAABAAAAAQAIAAIADgAEAUgBSQEjASQAAQAEAR8BIANgA2EAAQAAAAEACAACAA4ABAgfCIIIIAiDAAEABAD8AP0BBgEHAAYAAAADAAwAIAA0AAMAAAACAFIAPAABAFIAAQAAAA4AAwAAAAIAXgAoAAEAXgABAAAADwADAAAAAgBqABQAAQBqAAEAAAAQAAEAAQB5AAQAAAABAAgAAQAIAAEADgABAAEATwABAAQBAQACAHkABAAAAAEACAABAAgAAQAOAAEAAQAvAAEABAEAAAIAeQAEAAAAAQAIAAEACAABAA4AAQABCMcAAQAECMsAAgB5AAEAAAABAAgAAQAGB6cAAQABAcoAAQAAAAEACAACADIAFgqOCo8K1AotCi4KLwowCjEKMgozCjQKNQo2Cs4J3wngCeEJ4gnjCeQJ5QnmAAEAFgALAAwADgATABQAFQAWABcAGAAZABoAGwAcACAASwBOAE8AUABRAFMAVgBXAAEAAAABAAgAAgAkAA8KmAqZCtUHPQB7AHQAdQIqAisHPgIsAi0HPwrPAhcAAQAPAAsADAAOABMAFAAVABYAFwAYABkAGgAbABwAIABRAAEAAAABAAgAAQC0CfsAAQAAAAEACAABAAYCBAABAAEAEgABAAAAAQAIAAEAkgoFAAYAAAACAAoAIgADAAEAEgABAEIAAAABAAAAGQABAAECFgADAAEAEgABACoAAAABAAAAGgACAAEKDgoXAAAAAQAAAAEACAABAAb/9gACAAEKGAohAAAABgAAAAIACgAkAAMAAQAsAAEAEgAAAAEAAAAcAAEAAgAkAEQAAwABABIAAQAcAAAAAQAAABwAAgABABMAHAAAAAEAAgAyAFIAAQAAAAEACAACAA4ABABsAHwAbAB8AAEABAAkADIARABSAAEAAAABAAgAAQAG//YAAgABCfkKAgAAAAEAAAABAAgAAgAuABQJ7wnwCfEJ8gnzCfQJ9Qn2CfcJ+An5CfoJ+wn8Cf0J/gn/CgAKAQoCAAIAAgATABwAAAoECg0ACgABAAAAAQAIAAIALgAUABMAFAAVABYAFwAYABkAGgAbABwKBAoFCgYKBwoICgkKCgoLCgwKDQACAAEJ7woCAAAAAQAAAAEACAACAC4AFAoECgUKBgoHCggKCQoKCgsKDAoNCfkJ+gn7CfwJ/Qn+Cf8KAAoBCgIAAgACABMAHAAACe8J+AAKAAEAAAABAAgAAgE6AJoKqQt/Cq4KrwqwCI0ImgibCKEIpQivCLAItQi4CMMIxQjHCM0IzgjUCOAI4gjjCOcI7gjzCP4I/wkECQUJCgqnCqgKpQqmCqsMSgqxCJIIjgiQCJcIkQiVCJgIngisCKYIqQiqCL4IuQi7CLwIogjTCNkI1QjXCN4I2AjcCPgI9Aj2CPcJBgjhCJMIjwiUCJwInwidCKMIpAitCKcIqwiuCKgIsgixCLMItwi2CMIIwAi6CMEIvQi/CMQIxgjICMoIyQjLCMwIzwjRCNAI0gjbCNYI2gjfCOQI5gjlCOgI6wjqCOkI8gjwCO8I/Qj6CPUI/Aj5CPsJAQkHCQgJCwkNCQwIlgiZCN0I7AkDCQAJAgkJCqwKrQqqCPEI7Qw+DD8MQAxBDEIMQwxEDEUMRgxHDEgMSQABAJoABAAJAAsADAAiACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwAPQA+AEAAXgBgAGMAcQCBAIIAgwCEAIUAhgCHAIgAiQCKAIsAjACNAI4AjwCQAJEAkgCTAJQAlQCWAJcAmACaAJsAnACdAJ4AnwCgAMIAxADGAMgAygDOANAA0gDUANYA2ADaANwA3gDgAOQA5gDoAOoA7ADuAPAA8gDzAPUA9wD6APwA/gEAAQIBBAEGAQgBCwENAQ8BEQETARUBFwEZARsBHQEfASEBIwElAScBKQErAS0BLwExATMBNQE3ATkBOgE8AT4BQgFEAUYBSAH5AfsB/QH/AhMCFAIVA2AH2AuBC4ILgwuEC4ULhguHC4gLiQuKC4sLpwABAAAAAQAIAAIBPACbCqkLfwquCq8KsAqnCqgIjQiaCJsIoQilCK8IsAi1CLgIwwjFCMcIzQjOCNQI4AjiCOMI5wjuCPMI/gj/CQQJBQkKCqUKpgqrDEoKsQjtCJIIjgiQCJcIkQiVCJgIngisCKYIqQiqCL4IuQi7CLwIogjTCNkI1QjXCN4I2AjcCPgI9Aj2CPcJBgjhCQgIkwiPCJQInAifCKAInQijCKQIrQinCKsIrgioCLIIsQi0CLMItwi2CMIIwAi6CMEIvwjECMYIyAjKCMkIywjMCM8I0QjQCNII2wjWCNoI3wjkCOYI5QjoCOsI6gjpCPII8AjvCP0I+gj1CPwI+Qj7CQEJBwkLCQ0JDAiWCJkI3QjsCQMJAAkCCQkKrAqtCqoI8Qw+DD8MQAxBDEIMQwxEDEUMRgxHDEgMSQABAJsABAAJAAsADAAiAD4AQABEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBgAGMAcQCBAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALoAuwC8AL0AvgC/AMAAwQDDAMUAxwDJAMsAzQDPANEA0wDVANcA2QDbAN0A3wDhAOMA5QDnAOkA6wDtAO8A8QD0APYA+AD7AP0A/wEBAQMBBQEHAQkBDAEOARABEgEUARYBGAEaARwBHgEgASIBJAEmASgBKgEsAS4BMAEyATQBNgE4ATsBPQE/AUMBRQFHAUkB+gH8Af4CAAITAhQCFQNhC4ELgguDC4QLhQuGC4cLiAuJC4oLiwun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CksKdgqiCk4KSgqCCk0KQgp8BzYKtAq/CrcKugq5CrgKuwq8Cr0Kvgc3BzgHOQc6BzsHPAc9CQ4CKgIrBz4CLAItBz8K1QrSCs8KmAqZAhcK1ArRCs4KjgqPB0UHRgdHAhgCGQdIB0kCGgdKB0sKwwNVAhsKwArECsUHVQfVCsYKwQrCCscMlArcCt0JjgrfCuACHAreCZcK6wriCasJhwmACY8JpwmoCYgJgQmJAh0K5QmQAh4HVwrwCZEJkgmLCYIJkwroCuoK7AruAh8K7wmUCuYCIArICYMLgAmYCY0Jhgl/AiEJqQmZCZoJjAmbCaoKyQrLCtAKzQrjCtsK4QmmCaUJlgmKCtcK2ArZCtYK2gmVCaEJogmjCaQK6QrKCucHWAdZCu0KKgorCiwHWgdbCiQKJQomCicKKAopAiICIwIkAiUKIgfXB9kMigdrB2wHbQduB28HcAdxCCUIMggwCCEIMQyIDIsMjApsCmsKVwpwClQKbQpkCmMKRQpYCnEKZQpWCm8KRwpeCkwKZwpRCkMKRgqMCkQHcgpSCl0Kmgp5ClUKbgp3CngKWQpyCpIKkwqQCpEKlgqXCpQKlQqDClwKdApJCmkJ7gpzCo0KfQpiCmEKfwpACkEKfgp7Cp4KnQqGCocKiAqJCp8KigqkDJUMlgkaCUwJGwlNCRwJTgkdCU8JHglQCR8JUQkgCVIJIQlTCSIJVAkjCVUJJAlWCSUJVwkmCVgJJwlZCSgJWgkpCVsJKglcCSsJXQksCV4JLQlfCS4JYAkvCWEJMAliCXIMVAxjDGQMZQqLCrMJcwkxCWMJMglkCTMJZQk0CWYJNQlnCTYJaAk3CWkJOAlqCTkJawk6CWwJOwltCTwJbgk9CW8JPglwCXQJdQxfDGAH3Ag9B90IPgfeCD8H3whAB+AIQQfhCEIH4ghDCEQIRQfjCEYH5AhHB+UISAfmCEkH5whKB+gISwfpCEwH6ghNB+sITgfsCE8H7QhQB+4IUQfvCFIH8AhTB/EIVAfyCFUH8whWB/QIVwf1CFgH9ghZB/cIWgf4CFsH+QhcB/oIXQmECYUH+wheB/wIXwf9CGAH/ghhB/8IYggACGMJ5whkCGUIZghnCGgIaQhqCGsIAQhsCAIIbQgDCAQIbggFCG8IBghwCAcIcQgICHIHfgd/B4AHgQeCCAkIcwkPCAoIdAgL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ACYBTVUAAAcLowI9AAAAAP//AF//RgHxAsoCJgAoAAAABwujAlsAAP//ADT/RgILAiUCJgBIAAAABwujAloAAP//AF8AAAHxA90CJgAoAAABBwJLAlgApQAIsQEBsKWwMysAAP//ADT/9gILAzgCJgBIAAAABwJLAlkAAP//AF8AAAHxA5QCJgAoAAABBwFRAEoArwAIsQEBsK+wMysAAP//ADT/9gILAuUCJgBIAAAABgFROwAAAP//AF8AAAJCA9ECJgAoAAABBwNWAlEApQAIsQECsKWwMysAAP//ADT/9gI/AywCJgBIAAAABwNWAk4AAP//ABMAAAHxA9ECJgAoAAABBwNXAlIApQAIsQECsKWwMysAAP//ABH/9gILAywCJgBIAAAABwNXAlAAAP//AF8AAAIhBAwCJgAoAAABBwNYAlAApQAIsQECsKWwMysAAP//ADT/9gIbA2cCJgBIAAAABwNYAkoAAP//AF8AAAHxBBoCJgAoAAABBwNZAk8ApQAIsQECsKWwMysAAP//ADT/9gILA3UCJgBIAAAABwNZAkoAAP//AF//RgHxA60CJgAoAAAAJwujAlsAAAEHAUoAVACvAAixAgGwr7AzKwAA//8ANP9GAgsC/gImAEgAAAAmAUpEAAAHC6MCWgAAAAD//wAmAAABOwPdAiYALAAAAQcCSwHfAKUACLEBAbClsDMrAAD//wA7AAAA/AM4AiYIKgAAAAcCSwG2AAD//wAm/0YBOwLKAiYALAAAAAcLowHfAAD//wBM/0YAxQLoAiYATAAAAAcLowG4AAD//wA8/0YC1QLVAiYAMgAAAAcLowK4AAD//wA0/0YCLgIlAiYAUgAAAAcLowJeAAD//wA8//YC1QPdAiYAMgAAAQcCSwK3AKUACLECAbClsDMrAAD//wA0//YCLgM4AiYAUgAAAAcCSwJeAAD//wA8//YC1QPRAiYAMgAAAQcDVgKvAKUACLECArClsDMrAAD//wA0//YCRwMsAiYAUgAAAAcDVgJWAAD//wA8//YC1QPRAiYAMgAAAQcDVwKvAKUACLECArClsDMrAAD//wAY//YCLgMsAiYAUgAAAAcDVwJXAAD//wA8//YC1QQMAiYAMgAAAQcDWAKuAKUACLECArClsDMrAAD//wA0//YCLgNnAiYAUgAAAAcDWAJWAAD//wA8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AQcAagBQAK8ACLEBArCvsDMrAAD////0AAACJgO9AiYASwAAAQcAav9jAN0ACLEBArDdsDMrAAD//wAt/xACjALKAiYAKwAAAAYAeigAAAD//wAf/xACJgL4AiYASwAAAAYAehoAAAD//wBf/z4CjALKAiYAKwAAAAcLrQF3AAD//wBT/z4CJgL4AiYASwAAAAcLrQE7AAD////0/0IBbgLKAiYALAAAAAcLrwCxAAD////L/0IBRQLoAiYATAAAAQcBUf+j/OQACbECAbj85LAzKwD//wAeAAABUAQZAiYALAAAAQcHgwCxAK8ACLEBA7CvsDMrAAD////1AAABJwNqAiYIKgAAAAcHgwCIAAD//wBfAAACeAOtAiYALgAAAQcAdgDqAK8ACLEBAbCvsDMrAAD//wBFAAACKQPbAiYATgAAAQcAdgAdAN0ACLEBAbDdsDMrAAD//wBf/0YCeALKAiYALgAAAAcLowJ9AAD//wBT/0YCKQL4AiYATgAAAAcLowJGAAD//wBf/2QCeALKAiYALgAAAAcLsAFPAAD//wBT/18CKQL4AiYATgAAAQcBTABw/QEACbEBAbj9AbAzKwD//wBf/0YB/ALKAiYALwAAAAcLowJcAAD//wBK/0YAwwL4AiYATwAAAAcLowG2AAD////5/0YB/ANdAiYALwAAACcLowJcAAABBwFM/9EArwAIsQIBsK+wMysAAP///+7/RgEhA4sCJgBPAAAAJwujAbYAAAEHAUz/xgDdAAixAgGw3bAzKwAA//8AX/9rAfwCygImAC8AAAEHAUwAbP0NAAmxAQG4/Q2wMysA////7f9pASAC+AImAE8AAAEHAUz/xf0LAAmxAQG4/QuwMysA//8AX/84AfwCygImAC8AAAAHC6wBLgAA////1P84AT8C+AImAE8AAAEHAUr/rPzaAAmxAQG4/NqwMysA//8AXwAAAzcDlwImADAAAAEHAU4BaQCvAAixAQGwr7AzKwAA//8AUwAAA2YC6AImAFAAAAAHAU4BhAAA//8AX/9GAzcCygImADAAAAAHC6MC8wAA//8AU/9GA2YCJQImAFAAAAAHC6MDDAAA//8AXwAAAqkDlwImADEAAAEHAU4BIgCvAAixAQGwr7AzKwAA//8AUwAAAiYC6AImAFEAAAAHAU4A2QAA//8AX/9GAqkCygIm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/82wMysAAAD////nAAADewMqACcAKwDvAAABBwb9/3H/zgAJsQECuP/OsDMrAAAA////5wAAA3cDKgAnACsA6wAAAQcHCv9x/84ACbEBArj/zrAzKwAAAP//AFH/9gFZAwwCJgGFAAAABgbsCwAAAP//AE//9gFZAwwCJgGFAAAABgcmAgAAAP//AAP/9gFZAwcCJgGFAAAABwb7/24AAP//AAP/9gFZAwcCJgGFAAAABwcI/3UAAP//ABT/9gFZAwcCJgGFAAAABwb8/2gAAP//ABL/9gFZAwcCJgGFAAAABwcJ/28AAP///97/9gFZA1wCJgGFAAAABwb9/2gAAP///9P/9gFZA1wCJgGFAAAABwcK/10AAP//AAAAAAG5AtQAJgAsfgABBgbsucgACbEBAbj/yLAzKwAAAP//AAAAAAGzAtQAJgAseAABBgcms8gACbEBAbj/yLAzKwAAAP//AAAAAAJRAtQAJwAsARYAAAEHBvv/a//NAAmxAQK4/82wMysAAAD//wAAAAACQwLUACcALAEIAAABBwcI/3L/zQAJsQECuP/NsDMrAAAA//8ACQAAAmQC1AAnACwBKQAAAQcG/P9d/80ACbEBArj/zbAzKwAAAP//AAAAAAJeAtQAJwAsASMAAAEHBwn/Xf/NAAmxAQK4/82wMysAAAD////nAAACVQMqACcALAEaAAABBwb9/3H/zgAJsQECuP/OsDMrAAAA////5wAAAlQDKgAnACwBGQAAAQcHCv9x/84ACbEBArj/zrAzKwAAAP//ADT/9gIuAwwCJgBSAAAABwbsALEAAP//ADT/9gIuAwwCJgBSAAAABwcmAKgAAP//ADT/9gIuAwcCJgBSAAAABgb7FAAAAP//ADT/9gIuAwcCJgBSAAAABgcIGwAAAP//ADT/9gIuAwcCJgBSAAAABgb8DgAAAP//ADT/9gIuAwcCJgBSAAAABgcJFQAAAP//AAD/9gMHAtUAJgAyMgABBgbsucgACbECAbj/yLAzKwAAAP//AAD/9gMdAtUAJgAySAABBgcms8gACbECAbj/yLAzKwAAAP//AAD/9gO5AtUAJwAyAOQAAAEHBvv/a//NAAmxAgK4/82wMysAAAD//wAA//YDtwLVACcAMgDiAAABBwcI/3L/zQAJsQICuP/NsDMrAAAA//8AA//2A4YC1QAn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ARD/8wJhADQCdgBTAmEANAJhADQCYQA0AmEANAJhADQCPAAwAmEANAJ2AE4CdgBOAnYATgJ2AE4CDwABAmwAUwIPAAECjgAAAj4ALQKOAAACPgAtAo4AAAI+AC0CeQA8AeoANAJ5ADwB6gA0AnkAPAHqADQCeQA8AeoANALdAF8CbAA0At0AHAJyADQCLQBfAjwANAItAF8CPAA0Ai0AXwI8ADQCLQBfAjwANAItAF8CPAA0AtcAPAJsADQC1wA8AmwANALXADwCbAA0AtcAPAJsADQC7ABfAnb/1QLsAAACdgAHAWL/9AEQ/8oBYgAYARD/7gFiAA8BEP/mAWIAJgEQACABYgAmAoQAJgIgAEwBIv+zARD/xgJ4AF8CLwBTAi8AUwIYAE4BEABDAhgAXwEQAEMCGABfARAAUwIYAF8BKABTAhgACQEQ//YDCABfAnYAUwMIAF8CdgBTAwgAXwJ2AFMCyAABAwgAXwJ2AFMDEQA8AmEANAMRADwCYQA0AxEAPAJhADQDrQA8A7sAMwJ5AF8BqQBTAnkAXwGpAEECeQBfAakAPwImADIB5AAxAiYAMgHkADECJgAyAeQAMQImADIB5AAxAjMADQF/ABICMwANAX8AEgIzAA0BfwASAuIAWQJ2AE4C4gBZAnYATgLiAFkCdgBOAuIAWQJ2AE4C4gBZAnYATgLiAFkCdgBOA60ACAMnAAsCRwAAAg8AAQJHAAACPgAiAdsAIwI+ACIB2wAjAj4AIgHbACMBVwBTAjwAXgKPAAACPgAtA4b//wNwAC0DEQA8AmEANAImADIB5AAxAbsAKAG7ACgBgwAoAZ0AKADIACgBMwAoAP8AKAHKACgBzgAoAkEA+AJBAH4ClAAGAREARAKLAAADSgAAAeoAAANEAAAC7AAAA0H/+wFs/+gCjgAAApAAXwIXAF8CXAAWAi0AXwI+ACIC7ABfAxEAPAFiACYCeABfAmwAAAOWAF8DCABfAjAAJAMRADwC3wBfAmQAXwJBACUCMwANAkcAAAM1ADECYgADAzkANQMPACMBYgAcAkcAAAJwADQB+AAqAnYAUwFsAFECbgBMAnAANAKAAFMCFQAEAmAAMwH4ACoB6AA0AnYAUwJaADQBbABRAi8AUwI0//0CegBTAjEAAQHjADMCYQA0AqsADAJhAEkB6AA0AnQANAHwAA0CbgBM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ARAABwFsAFEBTAAfAYsABAFu//YBDwBTAq8AUwO1AE8DtQBPA7UAUwJ2/+MCdgBTApIAUwJhADQDYgA0AxwANQLvADMBqQARAakAEQGpABEBqQBTAakAUwFpAFABaQATAj0AVQI9AFUB5AAxARD/4wEQ/+MBEP/tARD/mAF/ABkBfwASAnYABwJqAB0CdgBPAg4AAAMnAAsCDwAAAfYAAAHbACMCKAAjAgoAEgIK//IBugAJAboAGgG6AAkB4gA0AxEAPAJQAFMCYQArAkUANAKEAFMBEP+iAi8ABgHAAFMCbAA0AboACQG6ABkDzgA0A+4ANAQaADQDCAASAiAAEgNvABIDfAAQAqcAUwJxAFMCBQAAAlMAUwJ8/+wCfP/sAZkANgGZADYAsf/aARQANgEUAAsBFAALAXQANwIMAAcBVwABALsADAGAAAwAuwAMALsADACtAB4ArQAeASkACAEpABMBHQAYAR0AGAEdABEBHQAKAKYAKAExACgBMQAoAKYAKAGDACgBMQAoATEAKAE5AEQBOQBEAMEAKADBACgBDgAeAQ4AHgEOAB4BGgAeARwAKAFWAAAAsQA2ATsAIAFhAAkBHwARAaIATgGiAE4BogBOAaIATgGiAE4BogBOAaIATgG7ACgB7wAoAYAADAGeACgBngAoAUsAKAFLACgBMQAoAc4AKAHOACgBygAoAREARAD2ACgA9gAoAPYAKAD2ACgCDgAoAg4AKAIWACgAAP6FAOYAFADmABQCQQDyAeoAIAHqADQB6gAgARIAHwJXADAC2f/oAk0AAALvADMCif/6AwUAPAJhADQCbAA8AegANAIcAF8B3QBUAfH/+wIrAC8CUf/zAgT/tQKJ//oCYQA0AeoANAEQ/8YDEgA8AfgANAHzAB8CZABfAmwAUwJ5ADwDlgBfAvIAUwJhAAMCeQAgAnkAPAJ5ACADEQA8AmwANAOtAAgDJwALAhkACgLVAAgDcAAxAlAACgIJADsCWABWAlgAIwHRAFYB/QAiARwAUgFkADICCQBWAcEAFQLkAFYCeABWAn8AOwIJACMCbQASAm0AHwJtAAgDuwAxAjAAOQJ2ADcCdgA3AfwAVgIXABUCFwAVAdEAFQJlAE8CbQAmAx8AFAJtACgB5wAAAt8ACgHbACMB6gAhAc4ALQH8ABABwgBWAfsACgJaAFYB/ABWApwANQJMAA4BqQAAAkv//wGrAD4BqwANAd0APgFqAD4BagAnAdgAJwHmAD4A5gAZALz/zgGbAD4BXQA+AlUAPgH4AD4B+AA+Af8AJwHGACUBjQA+AZsAPgFtAAgB4AA6AmQABQF1AB0BdQA0AZMAIgI8ACABkwA2AZMAIgF0ACIBdAAgAUgAGwFGABYBkwAiALkANQFsADYCaQA2AZkANgGMACIBPgAVAZkAJAGZACQBkwA2APkADAGZADMBlAAZAmkAMwFWAAABSgAKAaAANgFaAAMBjAAhAeQAIgFu//YAsQAxARQANgGZADMBVgAAAaAANgFaAAMBjAAvAeQAIgFu//YDrgBPAmz/1wJsADQBZf/wA7X/7AJ5/+wCbP/VAan/1QFp/9QB5P/7AX//5AHbABkCbABTAaMANgJEACAD9AASAUwAHwFsAAQCbAAHAmYABwJqAAcCbABTAmwANAFlABADHQA0Ai8AUwEQACwDtQBTAnYAUwJsAFMBqQAsAeQAMQHB/+MCDgAAAh8ADgHbACMCPgAtAmwANAJsADQCPAA0Af8AKgH9ACICpAAxARAATAHqACABEP/jAnYATgH9ACIBkwA2AT4AIgFdAB8BjAAiAUsAFgDoAAoAsf/aAZMAIgGZADQAsQAFAO0ANQDYABQA2AAUALH/wwCwADYAsQAdASMANgJpADYCaQAzAZn/7QGZADYBrAA2AYwAIgHoACEBOwAgALH/7QD5AAwBmQAFAZEAEwGOADMBmQAzAVYAAAE1ABcBNQAXAWYAFwFUAAwBhwAiApAAXwJsAFMCkABfAmwAUwKQAF8CbABTAnkAPAHqADQC3QBfAmwANALdAF8CbAA0At0AXwJsADQC3QBfAmwANALdAF8CbAA0Ai0AXwI8ADQCLQBfAjwANAItAF8CPAA0Ai0AXwI8ADQCLQBfAjwANAIQAF8BZQAQAtcAPAJsADQC7ABfAnYAUALsAF8CdgBTAuwAXwJ2//QC7AAtAnYAHwLsAF8CdgBTAWL/9AEQ/8sBYgAeARD/9QJ4AF8CLwBFAngAXwIvAFMCeABfAi8AUwIYAF8BEABKAhj/+QEQ/+4CGABfARD/7QIYAF8BEP/UA5YAXwO1AFMDlgBfA7UAUwMIAF8CdgBTAwgAXwJ2AFMDCABfAnYAUwMIAF8CdgBTAxEAPAJhADQDEQA8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AhkASQIKAC4CCgAuAgoALgIKAC4CCgAuAgoALgJRAEkCUQAMAlEASQJRAAwBxQBJAcUASQHFAEkBxQA+AcUAPwHFAEkBxQBJAcUAPAHFAEkBxQBJAa8ASQJWAC8CVgAvAlYALwJWAC8CVgAvAmQASQJgAAcCZABJATQAIgE0ACIBNP/5ATT/5wE0AAQBNAAiATT/4wIuACIBNAABATQAIgE0/90A+v+8APr/vAIMAEkCDABJAcMASQHDAEkBwwBJAcMASQHDAEkBwv/uAvQASQKDAEkCgwBJAoMASQKDAEkCgwBJAoMASQKDADACgwAwAoMAMAKDADACgwAwAoMAMAKDADACgwAwAoMAMAKDADACgwAwAwYAMAH3AEkB+QBJAoMAMAINAEkCDQBJAg0ASQINAEkBywAoAcsAKAHLACgBywAoAcsAKAHLACgCYABDAc0ADQHNAA0BzQANAc0ADQHNAA0CYABEAmAARAJgAEQCYABEAmAARAJgAEQCYABEAmAARAJgAEQCYABEAmAARAIMAAADGQAOAxkADgMZAA4DGQAOAxkADgIKAAEB7QAAAe0AAAHtAAAB7QAAAe0AAAHlABsB5QAbAeUAGwHlABsAsQAxAUcAQQMuADICEAAfAmQAMQOWAF8BYgAmBHIACwLi/+oFlwAGAsoABgLhAAMCQgAfAkIAHwIkACsBmAAoAuQAWQMPADwEFAA8Ao//4gOuAAIDXgBfBBwAPAPsAF8CogAAAvUAEAPsAF8CrwAMAvEAFQOVAAYDrAADBFsAXwMRADwDDwA8BTIAPALJAAYCJAAyBL4AKgQ/AEUDfgAGAvYADgIsAA4C3ABfAiwADgNmAA4CvwBfBBgAXwU6ADwDEgA8Ann/1wS4ABICaQARAmkABQI3ADMCXQASAdIANAJpADQBlf+4A5cAUwKC/9ICggAGAmcALwHdACEB3QAhAeQAKwFsAFECeQBPAdkAHAOQADoCrgACA3sACQM7AFMDUAA0A2kAUwIzAAACaAAIA2gAUgIwAAICiQARAvoAEgMFAAUDsQBTAmEANAKLADMD9QA0Al0AEgHkACwEEgAiA8UARAL/ABEC8gAWAfsAFgKCAFMB+wAWAwwAFgJ1AFMDlwBTA/AANAJhADQCYAAzA2oALAJCAKYBxwAIAYYANgHHAF8CjgAbAxAAYAJ1AF8BIv+zAZcAUwIfABUCmgBTAn0AUgKgAD0C3gABAi8AIANRABgCSgALAjQAEwIYABsDRgACBCL//ALn//wDQQALAwkAYQNo//wCEAAfAo4AAAJ4ADIDCQBhAwoAYQKPAGEDDQA9AsoAYQJ2ACYC2gAkAigAYQJeADMCeABfAlsAHAM4//wEg//8AucACQIR/+4C7AAvAt8ALwLsAEoCQwAJAfMACQFXACABV/9vAh8ABQMJADECdgAfAnMAHgHOABgB4AAYAkT/qwHsADQCdgBTA04ANAFcABACWwAqAmEAKwJbADsCbwADA4gALQGfADoCPQADAxYAEQFeAAgCaQAzAbL//wGLAAABlwAdA6wAUwJ1AFMCdQBTAcsALAHLACwCTwAxA7sAMwPGAD0DxgA9A7wAMwO8ADMCeQBPAjYAVgFNAFMCZQBTAe4AAAKpAAABwwAWAoYADwFlABMCdQBPAnUABAOsAE8DrABTAqwAEwIz//ECYf/xAjn/6QKEAA4CIP+FAoT/hQIg/3oCdQBPAmwANAGZADYBbAA2ALEANgJpADYBmQA2AZMANgE7ACAA+QAMAYQAIQHmAAACbQAhAZkANgEa//8BAQADAb0ADAJBANsCTgA2Ac8AFQIsACUCPAArAj8AFAI8ADsCRQA2AgYACQJPADcCRQAxAlIANAGlABECKQArAh8AHQI/ABcCNAA5AkEANAIXABcCPAAtAkEAKwI8AC0CLAAhAiwAPgIsAC4CLAAkAiwACAIsADECLAApAiwAIQIsACUCLAAgAWcAEwFnACcBZwAZAWcAFQFnAAkBZwAhAWcAFQFnABwBZwAYAWcAEgFnABMBZwAnAWcAGQFnABUBZwAJAWcAIQFnABUBZwAcAWcAGAFnABIBvwAnA3QAEwM9ACcDcgAZA2UAFQNoAAkDJQAnA1AAIQNQACcDNgAnBC4AJwFnABMBZwAnAWcAGQFnABUBZwAJAWcAIQFnABUBZwAcAWcAGAFnABIEXgAMAoQANgKEAFgBRgBMAUYAGAGPABQBhQASAmEAFgJcABYBvAA8AcAAkQMtACYCrwBKAjsANAH0ADAC7gCEBBIADwLCAEQDRAA1A0oANgI4AB0D6AAAApoANgNFADUBEQBEAUIAJQE1AGQBxgAdAlwAFgH0AHoB9AA9AfQAPQH0AIEB9AAwAicApgIlACYB9AC2A0QANgLuAKYD6AAAA3MACQLAAAkBEQAmAREARAH0ACMB9AAjAfQAPANJADID6AAAAo8AWAHFACAA+wAwAfQAeAH0AHgB9ACHAfQAPQH0AD0B9ACBAfQAMAInALICPABmA0oANgPoAEMCFwA2AjsAMAI8ADACPAAwAksAJgH4AEABEQBEAREASAHjAC4BEQBFAiUAJgIiAEQA8AA2A0QANgJhABYBcgBAAAD/oQEJAEABUwBEAsIANgD+ADUCIwBDAu4AegERAEQA5wAmAOcAHQFMAFABTAAZAUwAUAFMABkCFwAoAhcAGgPoANMD6ADUAOcAJgDnAB0BQgAJAUIAJQFCACULGAAoB4AAKAE+ACUB9P/9ASD//QNZACkCp//9AcQAPQFEABgBRQAbAQoAOQEKABcA2gAxAa0AMQDaADIBEgAfARIAHQEFAB8BBQAXAX0ACgF9ABYB7QAVAkIAcQG3AAACWAAAAlgAAAJYAAACWAAAAlgAAAJYAAAAAAAAAAAAAAAAAAAAAAAAAlgAAAKDABYDPQA5AksACgNCAFUC1wAVAiwAEgMWAA0CcQA3Av4AGgJeACUC4QABAhUAIQGCAAUB0wACAVgAIwFYACMBfwAHAVgAIwFYACMGKwApAVgAIwFYACMCGAAcAmwAGgLTAEgCGAAcAkcAAAOoACkC5QAdAsQAHQNoACkD6AAyAkUAIAV1AF8DegAyARAATAHGAA8DbAAEAikAGwKPACwCegBfArUAYgJVAF8CggAfAyAAMwQH//IDHgARAmsAAANEACwA+P+DAh4ATgIeAE4CHgBOAh4ATgF/ABQCHgAOAh4AFwIeAAsCHgAaAh4AGgF/ACICHgAmAh4AIgIeACgCHgAmAh4AJgF/ABICHgASAh4AFwIeABICHgATAh4AEgF/ABYCHgAaAh4AIwIeABoCHgAWAh4AJwF/ABQCHgAXAh4ADgIeABoCHgALAh4AGgIeAE4CHgBOAh4ATgIeAE4BfwASAh4AFwIeABICHgATAh4AEgIeABIBfwAiAh4AIgIeACYCHgAmAh4AKAIeACYBfwAWAh4AIwIeABoCHgAWAh4AGgIeACcBfwAlAh4AJwIeAC4CHgAlAh4AJQIeACUBfwAaAh4AGgIeABoCHgAaAh4AGgIeABoCHgBOAh4ATgIeAE4CHgBOAX8AHwIeABcCHgAf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AACwhAAAsewAALLUAACz4AAAtKAAALWQAAC2NAAAtkQAALb8AAC4VAAAukwAALwEAAC9WAAAvbgAAL4EAAC+GAAAvoQAAL8AAAC/oAAAv/AAAMC8AADAvAAAwLwAAMC8AADAvAAAwLwAAMC8AADAvAAAwLwAAMC8AADAvAAAwLwAAMC8AADAvAAAxXQAAMZEAADGXAAAxmwAAMd0AADIZAAAyTAAAMlUAADJbAAAyYQAAMmcAADKIAAAysAAAMtcAADL5AAAzKAAAM0MAADNMAAAzVQAAM1sAADNhAAAzigAAM7EAADPUAAAz+AAAND4AADSCAAA0ogAANMAAADTmAAA1CgAANTUAADVfAAA1kAAANb8AADYwAAA2oAAANqQAADaoAAA20AAANvYAADchAAA3UgAAN1sAADdhAAA3nQAAN6MAADfWAAA4AwAAOGIAADi+AAA4xwAAOM8AADjyAAA5FgAAOSsAADm0AAA6CAAAOjsAADpsAAA6kAAAOrQAADraAAA7GgAAOzIAADtJAAA7ggAAO6wAADvRAAA79AAAO/oAADwAAAA8HAAAPDYAADxTAAA8cQAAPI8AADyvAAA8yQAAPOIAADz9AAA9FwAAPS8AAD1GAAA9gAAAPawAAD4RAAA+ZAAAPmoAAD5wAAA+hgAAPpwAAD6gAAA+twAAPtIAAD7xAAA/DQAAPygAAD9DAAA/XQAAP38AAD+fAAA/wwAAP+cAAEACAABABgAAQGAAAECgAABBAgAAQUQAAEFIAABBUQAAQVcAAEGOAABBtQAAQfQAAEIuAABCXAAAQn8AAEKYAABCsgAAQtEAAELxAABDFAAAQzYAAEM6AABDQwAAQ0kAAENSAABDWAAAQ1wAAENgAABDaQAAQ28AAEOZAABDnQAAQ6YAAEOsAABDtQAAQ7sAAEPEAABDygAAQ+8AAEQVAABEHgAARCQAAEQtAABEMwAARDwAAERCAABERgAAREoAAERTAABEWQAARGIAAERoAABEcQAARHcAAESAAABEhgAARI8AAESVAABEngAARKQAAES5AABEzQAARNYAAETcAABE4gAARQsAAEU0AABFWwAARXgAAEWTAABFsQAARbUAAEXqAABGHgAARmEAAEaTAABGvwAARuoAAEcrAABHTwAAR3sAAEeoAABHzwAAR/MAAEgRAABILgAASGAAAEhkAABIvgAASPwAAEkCAABJCAAASREAAEkXAABJIAAASSYAAEkvAABJNQAAST4AAElEAABJTQAASVMAAEleAABJZgAASW8AAEl1AABJfgAASYQAAEmNAABJkwAASZwAAEmiAABJrQAASbUAAEm7AABJwQAAScoAAEnQAABJ2QAASd8AAEnoAABJ7gAASfcAAEn9AABKBgAASgwAAEoVAABKGwAASiYAAEouAABKNwAASj0AAEpDAABKSQAASk8AAEpVAABKXgAASmQAAEptAABKcwAASnwAAEqCAABKiwAASpEAAEqaAABKoAAASqsAAEqzAABKvAAASsIAAErLAABK0QAAStoAAErgAABK6QAASu8AAEr1AABK+wAASwEAAEsHAABLEAAASxYAAEsfAABLJQAASy4AAEs0AABLPQAAS0MAAEtMAABLUgAAS1gAAEteAABLZAAAS20AAEt2AABLfAAAS4UAAEuLAABLkQAAS7UAAEvdAABMFQAATEQAAExoAABMjQAATMYAAE0AAABNIgAATTwAAE1CAABNSAAATY0AAE3NAABN0QAAThAAAE4wAABOVQAATnkAAE6qAABO5AAATugAAE8XAABPOAAAT3gAAE+AAABPlwAAT5sAAE/NAABP7gAAUCUAAFBOAABQkAAAUKkAAFDHAABQ+wAAUSsAAFFAAABRjwAAUccAAFHtAABR8QAAUfUAAFIrAABSVQAAUocAAFLMAABS8AAAUx0AAFNIAABTTAAAU4IAAFOuAABT0gAAVAsAAFQnAABUTgAAVHsAAFSoAABU5gAAVQMAAFUiAABVJgAAVU4AAFV1AABVpwAAVd0AAFYDAABWKAAAVlIAAFaCAABWjwAAVpUAAFaxAABWtQAAVsAAAFbIAABW0AAAVtYAAFbcAABW4gAAVugAAFbuAABW9AAAVv0AAFcDAABXDAAAVxIAAFcbAABXIQAAVyoAAFcwAABXOQAAVz8AAFdIAABXTgAAV1cAAFddAABXZgAAV2wAAFd1AABXewAAV4EAAFeHAABXkAAAV5YAAFfIAABYJgAAWC8AAFg1AABYPgAAWEcAAFhNAABYUwAAWF4AAFhmAABYbwAAWHUAAFh7AABYgQAAWIcAAFiQAABYlgAAWMIAAFjtAABY9gAAWPwAAFkFAABZCwAAWRQAAFkaAABZIwAAWSkAAFkyAABZOAAAWUEAAFlHAABZUAAAWVYAAFlfAABZZQAAWW4AAFl0AABZfQAAWYMAAFmMAABZkgAAWZsAAFmhAABZqgAAWbAAAFnYAABZ/wAAWggAAFoRAABaOQAAWpgAAFrGAABa9AAAWvoAAFr+AABbBwAAWw0AAFsTAABbGQAAWyIAAFsoAABbMQAAWzcAAFtAAABbRgAAW0wAAFtSAABbWwAAW2EAAFuKAABb1gAAXAYAAFxBAABcfQAAXKgAAFzdAABdDwAAXSYAAF1GAABdhAAAXawAAF3KAABd5wAAXhcAAF47AABePwAAXmcAAF6oAABeygAAXvcAAF88AABfhQAAX6wAAF/dAABf/AAAYCkAAGAxAABgaQAAYHEAAGDFAABg6AAAYSEAAGFaAABhrgAAYbQAAGHcAABh4AAAYgwAAGItAABifQAAYoEAAGKqAABi1AAAYxAAAGMYAABjSgAAY4wAAGOuAABjsgAAY8gAAGPwAABkFQAAZCwAAGRZAABkYQAAZIoAAGTRAABlCgAAZToAAGVTAABlVwAAZcQAAGXzAABl9wAAZf8AAGYoAABmUgAAZnwAAGayAABmywAAZuQAAGcEAABnDQAAZ0QAAGdxAABnqgAAZ80AAGgHAABoDwAAaDIAAGhkAABoiQAAaLsAAGjDAABoywAAaNMAAGjmAABpDAAAaTcAAGk7AABpeAAAaZ0AAGmjAABpwQAAaeQAAGnqAABp7gAAahoAAGpdAABqYQAAapEAAGqZAABqqAAAau0AAGscAABrSwAAa6kAAGwmAABsngAAbPcAAG1GAABtoAAAbgUAAG5HAABuYgAAbo0AAG6mAABu4AAAbygAAG8xAABvOgAAb0MAAG9MAABvVQAAb14AAG9nAABvcAAAb3kAAG99AABvgQAAb4UAAG+JAABvoAAAb7cAAG/WAABv3AAAb+QAAG/sAABv/wAAcAcAAHALAABwDwAAcBMAAHAbAABwIwAAcCgAAHAtAABwQQAAcEwAAHBUAABwXAAAcGQAAHBsAABwdAAAcIIAAHCHAABwkAAAcJkAAHCiAABwqwAAcLQAAHDHAABw3AAAcPEAAHEGAABxFwAAcSgAAHE7AABxQwAAcUsAAHFPAABxYQAAcXMAAHF9AABxhwAAcY8AAHGYAABxoAAAcagAAHGvAABxwAAAcdMAAHHlAABx9QAAchAAAHIpAAByQAAAckQAAHJVAAByawAAcm8AAHJzAAByfAAAcoUAAHKJAAByxAAAcs4AAHLXAABy2wAAczcAAHNkAABzhwAAc7AAAHPcAAB0CQAAdCkAAHRcAAB0jQAAdLoAAHTZAAB1NAAAdW0AAHVxAAB1dQAAdXkAAHV9AAB1gQAAdYUAAHWJAAB1jQAAdbUAAHXbAAB2CgAAdg4AAHYUAAB2GgAAdh4AAHYiAAB2JgAAdioAAHZFAAB2ZAAAdrIAAHbdAAB3AAAAdxcAAHc5AAB3TgAAd34AAHeXAAB3sAAAd8cAAHffAAB3+wAAeBMAAHgxAAB4VAAAeF4AAHhoAAB4cgAAeHoAAHimAAB4vAAAeNEAAHjvAAB5EAAAeTIAAHlBAAB5WQAAeWMAAHltAAB5dwAAeXwAAHmnAAB5qwAAec8AAHn6AAB6JAAAejQAAHpKAAB6WgAAel4AAHp8AAB6pQAAeq4AAHq3AAB6wAAAevgAAHsBAAB7CgAAexMAAHscAAB7JQAAey4AAHs3AAB7QAAAe0kAAHtSAAB7WwAAe3sAAHuEAAB7jQAAe5YAAHufAAB7qAAAe7EAAHu6AAB7wwAAe8wAAHvVAAB73gAAe+cAAHvwAAB7+QAAfAIAAHwLAAB8FAAAfB0AAHwmAAB8LwAAfDgAAHxBAAB8SgAAfFMAAHxcAAB8ZQAAfG4AAHx3AAB8gAAAfIkAAHySAAB8mwAAfKQAAHytAAB8tgAAfL8AAHzIAAB80QAAfNkAAHzhAAB86QAAfPEAAHz5AAB9AQAAfQkAAH0RAAB9GQAAfVoAAH2zAAB+EAAAflgAAH6sAAB+9AAAf0YAAH+NAAB/vgAAgAEAAIA/AACAiAAAgJAAAICZAACAxAAAgS8AAIFNAACBbQAAgbkAAIHgAACCFgAAgmMAAILFAACDBQAAg2UAAIOQAACDrQAAg/IAAIQrAACEegAAhLkAAIT1AACFOAAAhV8AAIWFAACFqQAAhhYAAIZ2AACGxwAAhv0AAIc7AACHeAAAh7IAAIfdAACIDAAAiEYAAIiSAACIxgAAiM8AAIjYAACI4QAAiOoAAIjzAACI/AAAiQUAAIkOAACJFwAAiSAAAIkpAACJMgAAiTsAAIlEAACJTQAAiVYAAIlfAACJaAAAiXEAAIl6AACJgwAAiYwAAImVAACJngAAiacAAImwAACJuQAAicIAAInLAACJ1AAAid0AAInmAACJ7wAAifgAAIoBAACKCgAAihMAAIocAACKIgAAiigAAIouAACKNwAAikAAAIpLAACKUwAAilwAAIpiAACKaAAAim4AAIp3AACKgAAAiq0AAIsBAACLBwAAiw0AAIsWAACLHAAAiyUAAIsrAACLMQAAizcAAIs9AACLRgAAi1EAAItZAACLYgAAi2sAAIt0AACLegAAi4MAAIuMAACLkgAAi5gAAIuhAACLqgAAi7AAAIu2AACLvAAAi8IAAIvIAACL0QAAi9oAAIvgAACL6QAAi/IAAIv4AACL/gAAjAQAAIwNAACMEwAAjBkAAIwkAACMLwAAjDgAAIxBAACMRwAAjFAAAIxZAACMXwAAjGUAAIxrAACMdAAAjHoAAIyAAACMhgAAjI8AAIyYAACMngAAjKQAAIytAACMswAAjLwAAIzCAACMywAAjNEAAIzaAACM4AAAjOkAAIzvAACM+AAAjP4AAI0HAACNDQAAjRMAAI0ZAACNJAAAjSwAAI01AACNPgAAjUcAAI1NAACNUwAAjVkAAI1iAACNaAAAjXEAAI13AACNggAAjYoAAI2TAACNmwAAjaEAAI2nAACNsAAAjbYAAI28AACNxQAAjc4AAI3UAACN3QAAjeMAAI3pAACN8gAAjfsAAI4BAACOCgAAjhAAAI4ZAACOHwAAjiUAAI4rAACONAAAjjoAAI5AAACORgAAjk8AAI5VAACOXgAAjmQAAI5tAACOcwAAjnwAAI6CAACOiAAAjo4AAI6UAACOmgAAjqAAAI6oAACOrgAAjrQAAI66AACOwwAAjskAAI7PAACO1QAAjtsAAI7hAACO5wAAju0AAI7zAACO/AAAjwUAAI8OAACPFwAAjyAAAI8pAACPMgAAjzsAAI9BAACPRwAAj00AAI9TAACPWQAAj18AAI9oAACPcQAAj3sAAI+FAACPjwAAj5kAAI+fAACPpQAAj6sAAI+xAACPtwAAj70AAI/DAACPyQAAj9IAAI/bAACP5QAAj+8AAI/5AACQAwAAkA0AAJAXAACQHQAAkCMAAJApAACQLwAAkDUAAJA7AACQQQAAkEcAAJBQAACQWQAAkGMAAJBtAACQdwAAkIEAAJCLAACQlQAAkJsAAJChAACQpwAAkK0AAJCzAACQuQAAkMIAAJDLAACQ1QAAkN8AAJDpAACQ8wAAkPkAAJD/AACRBQAAkQsAAJERAACRFwAAkR0AAJEjAACRLAAAkTYAAJFAAACRSQAAkU8AAJFVAACRWwAAkWEAAJFnAACRbQAAkXMAAJF5AACRggAAkYsAAJGVAACRnwAAkakAAJGzAACRvQAAkcYAAJHMAACR0gAAkdgAAJHeAACR5AAAkeoAAJHwAACR9gAAkfwAAJICAACSCAAAkg4AAJIUAACSGgAAkiIAAJIqAACSMQAAkjgAAJI/AACSRgAAkk0AAJJUAACSXwAAkmoAAJJ1AACSgAAAkosAAJKWAACSoQAAkqwAAJK0AACSvAAAksQAAJLMAACS1AAAktwAAJLkAACS7AAAkvcAAJMCAACTDgAAkxoAAJMmAACTMgAAkz4AAJNKAACTUgAAk1oAAJNhAACTaAAAk28AAJN2AACTfQAAk4QAAJOPAACTmgAAk6YAAJOyAACTvgAAk8oAAJPWAACT4gAAk+gAAJPuAACT9QAAk/sAAJQCAACUCAAAlA8AAJQYAACUIQAAlCoAAJQzAACUOQAAlFMAAJR1AACUeQAAlH0AAJSzAACUuwAAlMEAAJTJAACUzwAAlNcAAJTgAACU6QAAlPIAAJT7AACVAQAAlUcAAJWNAACVvAAAlcIAAJXIAACVzgAAldQAAJXaAACV4AAAlekAAJXyAACV+wAAlgQAAJZIAACWjAAAlrsAAJbBAACWxwAAls0AAJbTAACW2QAAlt8AAJblAACW6wAAlvQAAJb9AACXBwAAlxEAAJcaAACXTQAAl4UAAJeaAACXoQAAl6cAAJevAACXtQAAl70AAJfGAACXzwAAl9gAAJfhAACX5wAAl/0AAJgWAACYJAAAmDsAAJhUAACYbQAAmHsAAJiBAACYnAAAmK0AAJi+AACY0AAAmQMAAJk2AACZNgAAmVEAAJlVAACZmQAAmdEAAJoFAACaFgAAmiYAAJo6AACabwAAmo0AAJq+AACa7wAAmvcAAJr/AACbBwAAmw8AAJsXAACbQQAAm38AAJvLAACcFwAAnE0AAJylAACc6AAAnQcAAJ0oAACdggAAnbkAAJ31AACeKQAAnlYAAJ6XAACezQAAnvIAAJ75AACfOAAAn58AAJ+0AACgCAAAoIMAAKCHAACgpgAAoMIAAKDtAAChHAAAoUsAAKGcAAChygAAoc4AAKHwAACiDgAAoi4AAKJIAACiYgAAopcAAKKbAACi3AAAoxkAAKNXAACjaQAAo3oAAKOhAACjrgAAo8gAAKPgAACj9wAApBAAAKQdAACkKgAApEIAAKRaAACkYgAApG4AAKR6AACkggAApJwAAKSxAACkvAAApMoAAKT0AAClHgAApTIAAKVGAAClXQAApXQAAKV6AAClgAAApYYAAKWMAAClkgAApZgAAKWeAAClpAAApaoAAKWwAACltgAApbwAAKXCAAClyAAApc4AAKXUAACl2gAApeAAAKXmAACl7AAApfIAAKX4AACl/gAApgQAAKYKAACmEAAAphYAAKYcAACmIgAApigAAKYuAACmNAAApmgAAKZsAACmpAAApu4AAKdGAACnoAAAp/YAAKggAACoUQAAqH8AAKizAACo3gAAqQMAAKkoAACpWAAAqXsAAKmqAACpwwAAqd0AAKonAACqcgAAqrEAAKrvAACrRQAAq5sAAKvzAACsSwAArIkAAKy/AACs4wAArSEAAK1MAACtoAAArbsAAK3XAACuOwAArokAAK7HAACvHgAArzUAAK9LAACvbQAAr48AAK+yAACv2wAAr/EAALAZAACwWwAAsGMAALCKAACwsQAAsNwAALD0AACxFwAAsSAAALFMAACxdQAAscUAALHLAACyFQAAskoAALJwAACymwAAss4AALLWAACy9wAAsxYAALM8AACzUQAAs2gAALOXAACznQAAs6MAALPIAACz9QAAtEkAALR2AAC0rQAAtMgAALTvAAC1GQAAtUwAALV1AAC1mQAAtbYAALXkAAC2EQAAtjoAALZmAAC2lwAAtsMAALbLAAC20wAAtwUAALcvAAC3UAAAt2IAALd/AAC3qQAAt9gAALf2AAC4HwAAuEkAALh6AAC4mwAAuJ8AALjiAAC5FwAAuR8AALknAAC5VgAAuZcAALnAAAC5xAAAucoAALnQAAC51gAAudwAALniAAC56AAAuf4AALoCAAC6BgAAugoAALpgAAC6ZAAAuqQAALqoAAC63wAAuuoAALrwAAC7CQAAuyIAALtHAAC7bwAAu5wAALukAAC73wAAvAAAALwjAAC8LAAAvDAAALw4AAC8VgAAvGsAALx0AAC8fQAAvIMAALysAAC8zQAAvPcAAL0yAAC9WwAAvYIAAL3PAAC94QAAvgkAAL5jAAC+xAAAvzUAAL+IAAC/5AAAwDkAAMA9AADAYAAAwIEAAMCpAADAuwAAwM0AAMD5AADBQQAAwUcAAMGGAADB5gAAwjAAAMJ0AADCvwAAwtkAAMMBAADDIQAAw1gAAMOJAADDvAAAw9AAAMP+AADEKgAAxFEAAMSzAADEywAAxRQAAMVPAADFmgAAxcYAAMYPAADGPAAAxmIAAMaUAADGnAAAxqcAAMbXAADHAQAAxyEAAMdPAADHdwAAx58AAMf0AADIFQAAyEUAAMh0AADIogAAyKYAAMiqAADIsgAAyNgAAMj9AADJAwAAyQkAAMkPAADJFQAAyRsAAMkhAADJJwAAyS8AAMk3AADJPQAAyUMAAMmTAADKHQAAyjoAAMpAAADKSAAAylAAAMpWAADKXAAAymQAAMpqAADKcgAAyn8AAMqHAADKpgAAyqwAAMrWAADK+QAAyv8AAMsHAADLDQAAyxUAAMsbAADLMgAAy1IAAMtaAADLXgAAy3MAAMt5AADLgQAAy4kAAMuRAADLlwAAy6AAAMumAADLrgAAy7QAAMvGAADL6wAAy/MAAMv7AADMAQAAzAcAAMwdAADMPgAAzEYAAMxbAADMYQAAzGkAAMxxAADMdwAAzH8AAMyFAADMiwAAzJMAAMyZAADMoQAAzLgAAMzAAADM1wAAzN0AAMztAADM8wAAzPwAAM0CAADNCwAAzSMAAM1BAADNWwAAzWEAAM1pAADNbwAAzZQAAM2cAADNugAAzcAAAM3IAADN0AAAzdYAAM3cAADN5QAAze4AAM4hAADOKQAAzjEAAM6PAADOqgAAzsYAAM7pAADPCAAAzw4AAM8WAADPHAAAz0cAAM9NAADPVQAAz1sAAM9jAADPaQAAz6UAAM+2AADPzgAAz9YAAM/cAADP4gAAz/gAAM/+AADQBgAA0A4AANAUAADQGgAA0CMAANArAADQUgAA0FsAANBjAADQeQAA0J8AANClAADQrgAA0LQAANC6AADQzwAA0OMAANDpAADQ8QAA0PcAAND9AADRFAAA0RoAANEiAADRKwAA0TQAANFFAADRTwAA0VUAANFbAADRYwAA0XcAANGnAADRxwAA0foAANIuAADScAAA0qwAANLyAADS+AAA0xIAANM0AADTWgAA05c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AAQ4QAAEOQQABDn8AAQ6uAAEPSgABD3QAAQ+bAAEP0wABD9cAARAaAAEQggABEKsAARDLAAERHAABETkAARFNAAERYQABEXYAARGLAAERnQABEa8AARHCAAER1AABEeYAARH4AAESCgABEh0AARIxAAESTgABEmIAARJ1AAESiAABEp0AARKwAAESxgABEtwAARLxAAETBAABExkAARMsAAETQQABE1YAARNsAAETewABE4sAAROdAAETsAABE8YAARPZAAET7gABFAQAARQaAAEUMAABFEAAARRRAAEUYwABFH4AARSQAAEUogABFLIAARTDAAEU1gABFOcAART8AAEVDwABFR8AARUuAAEVQAABFVEAARVjAAEVdgABFYcAARWZAAEVrQABFcIAARXXAAEV7AABFf0AARYPAAEWIgABFjQAARZGAAEWWAABFnQAARaRAAEWrwABFswAARbeAAEW8gABFwUAARcaAAEXLwABF0QAARdWAAEXagABF30AAReRAAEXpAABF7kAARfKAAEX3QABF/IAARgHAAEYHQABGDMAARhEAAEYVQABGGgAARh6AAEYjAABGJ4AARiwAAEYwwABGNcAARj1AAEZCgABGR8AARkzAAEZRwABGVwAARlxAAEZgwABGZYAARmqAAEZvQABGdEAARnmAAEZ9wABGgoAARofAAEaNAABGkkAARpfAAEacAABGoEAARqUAAEapgABGrgAARrLAAEa3QABGu8AARsDAAEbIAABGzQAARtIAAEbWgABG24AARuAAAEblAABG6kAARu9AAEb0QABG+UAARv6AAEcDwABHBkAARxnAAEcbwABHHQAARx4AAEcfQABHIIAARyHAAEcjAABHJEAARyWAAEcmwABHKAAARylAAEctAABHMQAARzaAAEc/AABHSIAAR08AAEdQAABHUQAAR1IAAEdTAABHVQAAR1cAAEdbwABHYIAAR2TAAEdpAABHboAAR3XAAEd8wABHgoAAR4SAAEeLQABHkcAAR5cAAEeZAABHmwAAR5wAAEedAABHnwAAR6XAAEetwABHr8AAR7HAAEezwABHtcAAR7fAAEe5wABHvYAAR77AAEfAwABHwsAAR8bAAEfJAABHzQAAR9LAAEfZgABH3sAAR+bAAEfqgABH8YAAR/OAAEf0wABH9cAAR/yAAEf9wABH/8AASAYAAEgRAABIH0AASC1AAEgywABINwAASJPAAEibAABInMAASKZAAEipwABIsQAASLhAAEjHgABIyUAASMpAAEjQQABI3MAASOTAAEjrAABI7QAASPDAAEjywABI+wAASQGAAEkGgABJCYAASQ5AAEkVgABJJQAASSfAAEkrAABJLMAASS6AAElAwABJU0AASVpAAEldQABJYgAASW6AAElzQABJegAASX7AAEmFgABJkAAASZcAAEmYgABJpoAASbTAAEm8AABJxcAAScwAAEnbgABJ4EAASecAAEnqQABJ70AASfbAAEoDgABKBYAASgfAAEoKAABKDEAASg6AAEoQwABKEwAAShaAAEoYwABKGwAASh6AAEogwABKIwAASiVAAEongABKKYAASirAAEoxQABKQEAASkKAAEpEwABKRwAASklAAEpLgABKTcAASlAAAEpSQABKVIAASlbAAEpZAABKW0AASl2AAEpfwABKYgAASmRAAEpmgABKaMAASmsAAEptQABKb4AASnxAAEp+gABKgMAASoMAAEqFQABKh4AASonAAEqMAABKjkAASpCAAEqSwABKksAASpUAAEqXAABKmQAASpsAAEqdAABKnwAASqEAAEquAABKt4AASrmAAErBAABKx4AASsxAAErRQABK1kAASt5AAErkQABK6oAASvBAAEr3QABK/sAASwIAAEsIgABLCYAASwrAAEsMwABLDgAASw9AAEsYwABLIAAASyWAAEsqwABLMcAASzoAAEs8QABLPoAAS0DAAEtDAABLRUAAS0eAAEtJwABLTAAAS1IAAEtZwABLY0AAS2WAAEtsQABLcwAAS31AAEuBQABLlMAAS5cAAEuZQABLm4AAS53AAEugAABLokAAS6SAAEumwABLqQAAS6tAAEutgABLr8AAS7IAAEu0QABLtcAAS7gAAEu6QABLvIAAS77AAEvBAABLw0AAS8WAAEvHwABLygAAS8xAAEvOgABL0MAAS9MAAEvVQABL14AAS9nAAEvcAABL3kAAS+CAAEviwABL6YAAS+uAAEv+QABMCoAATBQAAEwYwABMIQAATDmAAEw8AABMS0AATFUAAExngABMbYAATHDAAEx2wABMfsAATIDAAEyCwABMiMAATJCAAEySgABMlIAATJsAAEyhwABMqIAATK9AAEy1gABMvAAATMLAAEzJgABM0AAATNZAAEzYQABM2kAATN8AAEzhAABM5QAAEAAAyuAMoAGAEYABUAAgCYAKoAiwAAAYkNbQAIAAgAAAARANIAAwABBAkAAABeAAAAAwABBAkAAQAaAF4AAwABBAkAAgAOAHgAAwABBAkAAwA0AIYAAwABBAkABAAgALoAAwABBAkABQCQANoAAwABBAkABgAeAWoAAwABBAkABwBEAYgAAwABBAkACAAqAcwAAwABBAkACQAoAfYAAwABBAkACgBCAh4AAwABBAkACwA+AmAAAwABBAkADAA8Ap4AAwABBAkADQKWAtoAAwABBAkADgA0BXAAAwABBAkAEAASBaQAAwABBAkAEQAMBbYAQwBvAHAAeQByAGkAZwBoAHQAIAAyADAAMQA1ACAARwBvAG8AZwBsAGUAIABJAG4AYwAuACAAQQBsAGwAIABSAGkAZwBoAHQAcwAgAFIAZQBzAGUAcgB2AGUAZAAuAE4AbwB0AG8AIABTAGEAbgBzACAATQBlAGQAUgBlAGcAdQBsAGEAcgAyAC4AMAAwADAAOwBHAE8ATwBHADsATgBvAHQAbwBTAGEAbgBzAC0ATQBlAGQAaQB1AG0ATgBvAHQAbwAgAFMAYQBuAHMAIABNAGUAZABpAHUAbQBWAGUAcgBzAGkAbwBuACAAMgAuADAAMAAwADsARwBPAE8ARwA7AG4AbwB0AG8ALQBzAG8AdQByAGMAZQA6ADIAMAAxADcAMAA5ADEANQA6ADkAMABlAGYAOQA5ADMAMwA4ADcAYwAwADsAIAB0AHQAZgBhAHUAdABvAGgAaQBuAHQAIAAoAHYAMQAuADcAKQBOAG8AdABvAFMAYQBuAHMALQBNAGUAZABpAHUAbQBOAG8AdABvACAAaQBzACAAYQAgAHQAcgBhAGQAZQBtAGEAcgBrACAAbwBmACAARwBvAG8AZwBsAGUAIABJAG4AYwAuAE0AbwBuAG8AdAB5AHAAZQAgAEkAbQBhAGcAaQBuAGcAIABJAG4AYwAuAE0AbwBuAG8AdAB5AHAAZQAgAEQAZQBzAGkAZwBuACAAVABlAGEAbQBEAGUAcwBpAGcAbgBlAGQAIABiAHkAIABNAG8AbgBvAHQAeQBwAGUAIABkAGUAcwBpAGcAbgAgAHQAZQBhAG0ALgBoAHQAdABwADoALwAvAHcAdwB3AC4AZwBvAG8AZwBsAGUALgBjAG8AbQAvAGcAZQB0AC8AbgBvAHQAbwAvAGgAdAB0AHAAOgAvAC8AdwB3AHcALgBtAG8AbgBvAHQAeQBwAGUALgBjAG8AbQAvAHMAdAB1AGQAaQBvAFQAaABpAHMAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlACAAaQBzACAAbABpAGMAZQBuAHMAZQBkACAAdQBuAGQAZQByACAAdABoAGUAIABTAEkATAAgAE8AcABlAG4AIABGAG8AbgB0ACAATABpAGMAZQBuAHMAZQAsACAAVgBlAHIAcwBpAG8AbgAgADEALgAxAC4AIABUAGgAaQBzACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAGkAcwAgAGQAaQBzAHQAcgBpAGIAdQB0AGUAZAAgAG8AbgAgAGEAbgAgACIAQQBTACAASQBTACIAIABCAEEAUwBJAFMALAAgAFcASQBUAEgATwBVAFQAIABXAEEAUgBSAEEATgBUAEkARQBTACAATwBSACAAQwBPAE4ARABJAFQASQBPAE4AUwAgAE8ARgAgAEEATgBZACAASwBJAE4ARAAsACAAZQBpAHQAaABlAHIAIABlAHgAcAByAGUAcwBzACAAbwByACAAaQBtAHAAbABpAGUAZAAuACAAUwBlAGUAIAB0AGgAZQAgAFMASQBMACAATwBwAGUAbgAgAEYAbwBuAHQAIABMAGkAYwBlAG4AcwBlACAAZgBvAHIAIAB0AGgAZQAgAHMAcABlAGMAaQBmAGkAYwAgAGwAYQBuAGcAdQBhAGcAZQAsACAAcABlAHIAbQBpAHMAcwBpAG8AbgBzACAAYQBuAGQAIABsAGkAbQBpAHQAYQB0AGkAbwBuAHMAIABnAG8AdgBlAHIAbgBpAG4AZwAgAHkAbwB1AHIAIAB1AHMAZQAgAG8AZgAgAHQAaABpAHMAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlAC4AaAB0AHQAcAA6AC8ALwBzAGMAcgBpAHAAdABzAC4AcwBpAGwALgBvAHIAZwAvAE8ARgBMAE4AbwB0AG8AIABTAGEAbgBzAE0AZQBkAGkAdQBtAAIAAAAAAAD/nAAyAAAAAAAAAAAAAAAAAAAAAAAAAAAMrgAAAQIBAwADAAQABQAGAAcACAAJAAoACwAMAA0ADgAPABAAEQASABMAFAAVABYAFwAYABkAGgAbABwAHQAeAB8AIAAhACIAIwAkACUAJgAnACgAKQAqACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADoAOwA8AD0APgA/AEAAQQBCAEMARABFAEYARwBIAEkASgBLAEwATQBOAE8AUABRAFIAUwBUAFUAVgBXAFgAWQBaAFsAXABdAF4AXwBgAGEBBACjAIQAhQC9AJYA6ACGAI4AiwCdAKkApAEFAIoBBgCDAJMBBwEIAI0BCQCIAMMA3gEKAJ4AqgD1APQA9gCiAK0AyQDHAK4AYgBjAJAAZADLAGUAyADKAM8AzADNAM4A6QBmANMA0ADRAK8AZwDwAJEA1gDUANUAaADrAO0AiQBqAGkAawBtAGwAbgCgAG8AcQBwAHIAcwB1AHQAdgB3AOoAeAB6AHkAewB9AHwAuAChAH8AfgCAAIEA7ADuALoBCwEMAQ0BDgEPARAA/QD+AREBEgETARQA/wEAARUBFgEXAQEBGAEZARoBGwEcAR0BHgEfASABIQEiASMA+AD5ASQBJQEmAScBKAEpASoBKwEsAS0BLgEvATABMQEyATMA+gE0ATUBNgE3ATgBOQE6ATsBPAE9AT4BPwFAAUEBQgDiAOMBQwFEAUUBRgFHAUgBSQFKAUsBTAFNAU4BTwFQAVEAsACxAVIBUwFUAVUBVgFXAVgBWQFaAVsA+wD8AOQA5QFcAV0BXgFfAWABYQFiAWMBZAFlAWYBZwFoAWkBagFrAWwBbQFuAW8BcAFxALsBcgFzAXQBdQDmAOcBdgCmAXcBeAF5AXoBewF8AX0BfgDYAOEA2gDbANwA3QDgANkA3wF/AYABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwCbAbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcoBywHMAc0BzgHPAdAB0QHSAdMB1AHVAdYB1wHYAdkB2gHbAdwB3QHeAd8B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAfQB9QH2AfcB+AH5AfoB+wH8Af0B/gH/AgACAQICAgMCBAIFAgYCBwIIAgkCCgILAgwCDQIOAg8CEAIRAhICEwIUAhUCFgIXAhgCGQIaAhsCHAIdAh4CHwIgAiECIgIjAiQCJQImAicCKAIpAioCKwCyALMCLAItALYAtwDEAi4AtAC1AMUAggDCAIcAqwDGAi8CMAC+AL8CMQC8AjIA9wIzAjQCNQI2AjcCOACMAjkCOgI7AjwCPQI+Aj8CQAJBAkICQwJEAkUCRgJHAkgCSQJKAksCTAJNAk4CTwJQAlECUgJTAlQCVQJWAlcCWAJZAloCWwJcAl0CXgJfAmACYQJiAmMCZAJlAmYCZwJoAmkCagJrAmwCbQJuAm8CcAJxAnICcwJ0AnUCdgJ3AngCeQJ6AnsCfAJ9An4CfwKAAoECggKDAoQChQKGAocCiAKJAooCiwKMAo0CjgKPApACkQKSApMClAKVApYClwKYApkCmgKbApwCnQKeAp8CoAKhAqICowKkAqUCpgKnAqgCqQKqAqsCrAKtAq4CrwKwArECsgKzArQCtQK2ArcCuAK5AroCuwK8Ar0CvgK/AsACwQLCAsMCxALFAsYCxwLIAskCygLLAswCzQLOAs8C0ALRAtIC0wLUAtUC1gLXAtgC2QLaAtsC3ALdAt4C3wLgAuEC4gLjAuQC5QLmAucC6ALpAuoC6wLsAu0C7gLvAvAC8QLyAvMC9AL1AvYC9wL4AvkC+gL7AvwC/QL+Av8DAAMBAwIDAwMEAwUDBgMHAwgDCQMKAwsDDAMNAw4DDwMQAxEDEgMTAxQDFQMWAxcDGAMZAxoDGwMcAx0DHgMfAyADIQMiAyMDJAMlAyYDJwMoAykDKgMrAywDLQMuAy8DMAMxAzIDMwM0AzUDNgM3AzgDOQM6AzsDPAM9Az4DPwNAA0EDQgNDA0QDRQNGA0cDSANJA0oDSwNMA00DTgNPA1ADUQNSA1MDVANVA1YDVwNYA1kDWgNbA1wDXQNeA18DYANhA2IDYwNkA2UDZgNnA2gDaQNqA2sDbANtA24DbwNwA3EDcgNzA3QDdQN2A3cDeAN5A3oDewN8A30DfgN/A4ADgQOCA4MDhAOFA4YDhwOIA4kDigOLA4wDjQOOA48DkAORA5IDkwOUA5UDlgOXA5gDmQOaA5sDnAOdA54DnwOgA6EDogOjA6QDpQOmA6cDqAOpA6oDqwOsA60DrgOvA7ADsQOyA7MDtAO1A7YDtwO4A7kDugO7A7wDvQO+A78DwAPBA8IDwwPEA8UDxgPHA8gDyQPKA8sDzAPNA84DzwPQA9ED0gPTA9QD1QPWA9cD2APZA9oD2wPcA90D3gPfA+AD4QPiA+MD5APlA+YD5wPoA+kD6gPrA+wD7QPuA+8D8APxA/ID8wP0A/UD9gP3A/gD+QP6A/sD/AP9A/4D/wQABAEEAgQDBAQEBQQGBAcECAQJBAoECwQMBA0EDgQPBBAEEQQSBBMEFAQVBBYEFwQYBBkEGgQbBBwEHQQeBB8EIAQhBCIEIwQkBCUEJgQnBCgEKQQqBCsELAQtBC4ELwQwBDEEMgQzBDQENQQ2BDcEOAQ5BDoEOwQ8BD0EPgQ/BEAEQQRCBEMERARFBEYERwRIBEkESgRLBEwETQROBE8EUARRBFIEUwRUBFUEVgRXBFgEWQRaBFsEXARdBF4EXwRgBGEEYgRjBGQEZQRmBGcEaARpBGoEawRsBG0EbgRvBHAEcQRyBHMEdAR1BHYEdwR4BHkEegR7BHwEfQR+BH8EgASBBIIEgwSEBIUEhgSHBIgEiQSKBIsEjASNBI4EjwSQBJEEkgSTBJQElQSWBJcEmASZBJoEmwScBJ0EngSfBKAEoQSiBKMEpASlBKYEpwSoBKkEqgSrBKwErQSuBK8EsASxBLIEswS0BLUEtgS3BLgEuQS6BLsEvAS9BL4EvwTABMEEwgTDBMQExQTGBMcEyATJBMoEywTMBM0EzgTPBNAE0QTSBNME1ATVBNYE1wTYBNkE2gTbBNwE3QTeBN8E4AThBOIE4wTkBOUE5gTnBOgE6QTqBOsE7ATtBO4E7wTwBPEE8gTzBPQE9QT2BPcE+AT5BPoE+wT8BP0E/gT/BQAFAQUCBQMFBAUFBQYFBwUIBQkFCgULBQwFDQUOBQ8FEAURBRIFEwUUBRUFFgUXBRgFGQUaBRsFHAUdBR4FHwUgBSEFIgUjBSQFJQUmBScFKAUpBSoFKwUsBS0FLgUvBTAFMQUyBTMFNAU1BTYFNwU4BTkFOgU7BTwFPQU+BT8FQAVBBUIFQwVEBUUFRgVHBUgFSQVKBUsFTAVNBU4FTwVQBVEFUgVTBVQFVQVWBVcFWAVZBVoFWwVcBV0FXgVfBWAFYQViBWMFZAVlBWYFZwVoBWkFagVrBWwFbQVuBW8FcAVxBXIFcwV0BXUFdgV3BXgFeQV6BXsFfAV9BX4FfwWABYEFggWDBYQFhQWGBYcFiAWJBYoFiwWMBY0FjgWPBZAFkQWSBZMFlAWVBZYFlwWYBZkFmgWbBZwFnQWeBZ8FoAWhBaIFowWkBaUFpgWnBagFqQWqBasFrAWtBa4FrwWwBbEFsgWzBbQFtQW2BbcFuAW5BboFuwW8Bb0FvgW/BcAFwQXCBcMFxAXFBcYFxwXIBckFygXLBcwFzQXOBc8F0AXRBdIF0wXUBdUF1gXXBdgF2QXaBdsF3AXdBd4F3wXgBeEF4gXjBeQF5QXmBecF6AXpBeoF6wXsBe0F7gXvBfAF8QXyBfMF9AX1BfYF9wX4BfkF+gX7BfwF/QX+Bf8GAAYBBgIGAwYEBgUGBgYHBggGCQYKBgsGDAYNBg4GDwYQBhEGEgYTBhQGFQYWBhcGGAYZBhoGGwYcBh0GHgYfBiAGIQYiBiMGJAYlBiYGJwYoBikGKgYrBiwGLQYuBi8GMAYxBjIGMwY0BjUGNgY3BjgGOQY6BjsGPAY9Bj4GPwZABkEGQgZDBkQGRQZGBkcGSAZJBkoGSwZMBk0GTgZPBlAGUQZSBlMGVAZVBlYGVwZYBlkGWgZbBlwGXQZeBl8GYAZhBmIGYwZkBmUGZgZnBmgGaQZqBmsGbAZtBm4GbwZwBnEGcgZzBnQGdQZ2BncGeAZ5BnoGewZ8Bn0GfgZ/BoAGgQaCBoMGhAaFBoYGhwaIBokGigaLBowGjQaOBo8GkAaRBpIGkwaUBpUGlgaXBpgGmQaaBpsGnAadBp4GnwagBqEGogajBqQGpQamBqcGqAapBqoGqwasBq0GrgavBrAGsQayBrMGtAa1BrYGtwa4BrkGuga7BrwGvQa+Br8GwAbBBsIGwwbEBsUGxgbHBsgGyQbKBssGzAbNBs4GzwbQBtEG0gbTBtQG1QbWBtcG2AbZBtoG2wbcBt0G3gbfBuAG4QbiBuMG5AblBuYG5wboBukG6gbrBuwG7QbuBu8G8AbxBvIG8wb0BvUG9gb3BvgG+Qb6BvsG/Ab9Bv4G/wcABwEHAgcDBwQHBQcGBwcHCAcJBwoHCwcMBw0HDgcPBxAHEQcSBxMHFAcVBxYHFwcYBxkHGgcbBxwHHQceBx8HIAchByIHIwckByUHJgcnBygHKQcqBysHLActBy4HLwcwBzEHMgczBzQHNQc2BzcHOAc5BzoHOwc8Bz0HPgc/B0AHQQdCB0MHRAdFB0YHRwdIB0kHSgdLB0wHTQdOB08HUAdRB1IHUwdUB1UHVgdXB1gHWQdaB1sHXAddB14HXwdgB2EHYgdjB2QHZQdmB2cHaAdpB2oHawdsB20HbgdvB3AHcQdyB3MHdAd1B3YHdwd4B3kHegd7B3wHfQd+B38HgAeBB4IHgweEB4UHhgeHB4gHiQeKB4sHjAeNB44HjweQB5EHkgeTB5QHlQeWB5cHmAeZB5oHmwecB50HngefB6AHoQeiB6MHpAelB6YHpweoB6kHqgerB6wHrQeuB68HsAexB7IHswe0B7UHtge3B7gHuQe6B7sHvAe9B74HvwfAB8EHwgfDB8QHxQfGB8cHyAfJB8oHywfMB80HzgfPB9AH0QfSB9MH1AfVB9YH1wfYB9kH2gfbB9wH3QfeB98H4AfhB+IH4wfkB+UH5gfnB+gH6QfqB+sH7AftB+4H7wfwB/EH8gfzB/QH9Qf2B/cH+Af5B/oH+wf8B/0H/gf/CAAIAQgCCAMIBAgFCAYIBwgICAkICggLCAwIDQgOCA8IEAgRCBIIEwgUCBUIFggXCBgIGQgaCBsIHAgdCB4IHwggCCEIIggjCCQIJQgmCCcIKAgpCCoIKwgsCC0ILggvCDAIMQgyCDMINAg1CDYINwg4CDkIOgg7CDwIPQg+CD8IQAhBCEIA1whDCEQIRQhGCEcISAhJCEoISwhMCE0ITghPCFAIUQhSCFMIVAhVCFYIVwhYCFkIWghbCFwIXQheCF8IYAhhCGIIYwhkCGUIZghnCGgIaQhqCGsIbAhtCG4IbwhwCHEIcghzCHQIdQh2CHcIeAh5CHoIewh8CH0Ifgh/CIAIgQiCCIMIhAiFCIYIhwiICIkIigiLCIwIjQiOCI8IkAiRCJIIkwiUCJUIlgiXCJgImQiaCJsInAidCJ4InwigCKEIogijCKQIpQimCKcIqAipCKoIqwisCK0IrgivCLAIsQiyCLMItAi1CLYItwi4CLkIugi7CLwIvQi+CL8IwAjBCMIIwwjECMUIxgjHCMgIyQjKCMsIzAjNCM4IzwjQCNEI0gjTCNQI1QjWCNcI2AjZCNoI2wjcCN0I3gjfCOAI4QjiCOMI5AjlCOYI5wjoCOkI6gjrCOwI7QjuCO8I8AjxCPII8wj0CPUI9gj3CPgI+Qj6CPsI/Aj9CP4I/wkACQEJAgkDCQQJBQkGCQcJCAkJCQoJCwkMCQ0JDgkPCRAJEQkSCRMJFAkVCRYJFwkYCRkJGgkbCRwJHQkeCR8JIAkhCSIJIwkkCSUJJgknCSgJKQkqCSsJLAktCS4JLwkwCTEJMgkzCTQJNQk2CTcJOAk5CToJOwk8CT0JPgk/CUAJQQlCCUMJRAlFCUYJRwlICUkJSglLCUwJTQlOCU8JUAlRCVIJUwlUCVUJVglXCVgJWQlaCVsJXAldCV4JXwlgCWEJYgljCWQJZQlmCWcJaAlpCWoJawlsCW0JbglvCXAJcQlyCXMJdAl1CXYJdwl4CXkJegl7CXwJfQl+CX8JgAmBCYIJgwmECYUJhgmHCYgJiQmKCYsJjAmNCY4JjwmQCZEJkgmTCZQJlQmWCZcJmAmZCZoJmwmcCZ0JngmfCaAJoQmiCaMJpAmlCaYJpwmoCakJqgmrCawJrQmuCa8JsAmxCbIJswm0CbUJtgm3CbgJuQm6CbsJvAm9Cb4JvwnACcEJwgnDCcQJxQnGCccJyAnJCcoJywnMCc0JzgnPCdAJ0QnSCdMJ1AnVCdYJ1wnYCdkJ2gnbCdwJ3QneCd8J4AnhCeIJ4wnkCeUJ5gnnCegJ6QnqCesJ7AntCe4J7wnwCfEJ8gnzCfQJ9Qn2CfcJ+An5CfoJ+wn8Cf0J/gn/CgAKAQoCCgMKBAoFCgYKBwoICgkKCgoLCgwKDQoOCg8KEAoRChIKEwoUChUKFgoXChgKGQoaChsKHAodCh4KHwogCiEKIgojCiQKJQomCicKKAopCioKKwosCi0KLgovCjAKMQoyCjMKNAo1CjYKNwo4CjkKOgo7CjwKPQo+Cj8KQApBCkIKQwpECkUKRgpHCkgKSQpKCksKTApNCk4KTwpQClEKUgpTClQKVQpWClcKWApZCloKWwpcCl0KXgpfCmAKYQpiCmMKZAplCmYKZwpoCmkKagprCmwKbQpuCm8KcApxCnIKcwp0CnUKdgp3CngKeQp6CnsKfAp9Cn4KfwqACoEKggqDCoQKhQqGCocKiAqJCooKiwqMCo0KjgqPCpAKkQqSCpMKlAqVCpYKlwqYCpkKmgqbCpwKnQqeCp8KoAqhCqIKowqkCqUKpgqnCqgKqQqqCqsKrAqtCq4KrwqwCrEKsgqzCrQKtQq2CrcKuAq5CroKuwq8Cr0Kvgq/CsAKwQrCCsMKxArFCsYKxwrICskKygrLCswKzQrOCs8K0ArRCtIK0wrUCtUK1grXCtgK2QraCtsK3ArdCt4K3wrgCuEK4grjCuQK5QrmCucK6ArpCuoK6wrsCu0K7grvCvAK8QryCvMK9Ar1CvYK9wr4CvkK+gr7CvwK/Qr+Cv8LAAsBCwILAwsECwULBgsHCwgLCQsKCwsLDAsNCw4LDwsQCxELEgsTCxQLFQsWCxcLGAsZCxoLGwscCx0LHgsfCyALIQsiCyMLJAslCyYLJwsoCykLKgsrCywLLQsuCy8LMAsxCzILMws0CzULNgs3CzgLOQs6CzsLPAs9Cz4LPwtAC0ELQgtDC0QLRQtGC0cLSAtJC0oLSwtMC00LTgtPC1ALUQtSC1MLVAtVC1YLVwtYC1kLWgtbC1wLXQteC18LYAthC2ILYwtkC2ULZgtnC2gLaQtqC2sLbAttC24LbwtwC3ELcgtzC3QLdQt2C3cLeAt5C3oLewt8C30Lfgt/C4ALgQuCC4MLhAuFC4YLhwuIC4kLiguLC4wLjQuOC48LkAuRC5ILkwuUC5ULlguXC5gLmQuaC5sLnAudC54LnwugC6ELogujC6QLpQumC6cLqAupC6oLqwusC60LrguvC7ALsQuyC7MLtAu1C7YLtwu4C7kLugu7C7wLvQu+C78LwAvBC8ILwwvEC8ULxgvHC8gLyQvKC8sLzAvNC84LzwvQC9EL0gvTC9QL1QvWC9cL2AvZC9oL2wvcC90L3gvfC+AL4QviC+ML5AvlC+YL5wvoC+kL6gvrC+wL7QvuC+8L8AvxC/IL8wv0C/UL9gv3C/gL+Qv6C/sL/Av9C/4L/wwADAEMAgwDDAQMBQwGDAcMCAwJDAoMCwwMDA0MDgwPDBAMEQwSDBMMFAwVDBYMFwwYDBkMGgwbDBwMHQweDB8MIAwhDCIMIwwkDCUMJgwnDCgMKQwqDCsMLAwtDC4MLwwwDDEMMgwzDDQMNQw2DDcMOAw5DDoMOww8DD0MPgw/DEAMQQxCDEMMRAxFDEYMRwxIDEkMSgxLDEwMTQxODE8MUAxRDFIMUwxUDFUMVgxXDFgMWQxaDFsMXAxdDF4MXwxgDGEMYgxjDGQMZQxmDGcMaAxpDGoMawxsDG0MbgxvDHAMcQxyDHMMdAx1DHYMdwx4DHkMegx7DHwMfQx+DH8MgAyBDIIMgwyEDIUMhgyHDIgMiQyKDIsMjAyNDI4MjwyQDJEMkgyTDJQMlQyWDJcMmAyZDJoMmwycDJ0MngyfDKAMoQyiDKMMpAylDKYMpwyoDKkMqgyrDKwMrQyuDK8MsAyxDLIMswy0DLUMtgy3DLgMuQy6DLsMvAy9DL4MvwzADMEMwgzDDMQMxQROVUxMAkNSB3VuaTAwQTAHdW5pMDBBRAlvdmVyc2NvcmUHdW5pMDBCMgd1bmkwMEIzB3VuaTAwQjUHdW5pMDBCOQdBbWFjcm9uB2FtYWNyb24GQWJyZXZlBmFicmV2ZQdBb2dvbmVrB2FvZ29uZWsLQ2NpcmN1bWZsZXgLY2NpcmN1bWZsZXgEQ2RvdARjZG90BkRjYXJvbgZkY2Fyb24GRGNyb2F0B0VtYWNyb24HZW1hY3JvbgZFYnJldmUGZWJyZXZlCkVkb3RhY2NlbnQKZWRvdGFjY2VudAdFb2dvbmVrB2VvZ29uZWsGRWNhcm9uBmVjYXJvbgtHY2lyY3VtZmxleAtnY2lyY3VtZmxleARHZG90BGdkb3QHdW5pMDEyMgd1bmkwMTIzC0hjaXJjdW1mbGV4C2hjaXJjdW1mbGV4BEhiYXIEaGJhcgZJdGlsZGUGaXRpbGRlB0ltYWNyb24HaW1hY3JvbgZJYnJldmUGaWJyZXZlB0lvZ29uZWsHaW9nb25lawJJSgJpagtKY2lyY3VtZmxleAtqY2lyY3VtZmxleAd1bmkwMTM2B3VuaTAxMzcMa2dyZWVubGFuZGljBkxhY3V0ZQZsYWN1dGUHdW5pMDEzQgd1bmkwMTNDBkxjYXJvbgZsY2Fyb24ETGRvdARsZG90Bk5hY3V0ZQZuYWN1dGUHdW5pMDE0NQd1bmkwMTQ2Bk5jYXJvbgZuY2Fyb24LbmFwb3N0cm9waGUDRW5nA2VuZwdPbWFjcm9uB29tYWNyb24GT2JyZXZlBm9icmV2ZQ1PaHVuZ2FydW1sYXV0DW9odW5nYXJ1bWxhdXQGUmFjdXRlBnJhY3V0ZQd1bmkwMTU2B3VuaTAxNTcGUmNhcm9uBnJjYXJvbgZTYWN1dGUGc2FjdXRlC1NjaXJjdW1mbGV4C3NjaXJjdW1mbGV4B3VuaTAyMUEHdW5pMDIxQgZUY2Fyb24GdGNhcm9uBFRiYXIEdGJhcgZVdGlsZGUGdXRpbGRlB1VtYWNyb24HdW1hY3JvbgZVYnJldmUGdWJyZXZlBVVyaW5nBXVyaW5nDVVodW5nYXJ1bWxhdXQNdWh1bmdhcnVtbGF1dAdVb2dvbmVrB3VvZ29uZWsLV2NpcmN1bWZsZXgLd2NpcmN1bWZsZXgLWWNpcmN1bWZsZXgLeWNpcmN1bWZsZXgGWmFjdXRlBnphY3V0ZQpaZG90YWNjZW50Cnpkb3RhY2NlbnQFbG9uZ3MKQXJpbmdhY3V0ZQphcmluZ2FjdXRlB0FFYWN1dGUHYWVhY3V0ZQtPc2xhc2hhY3V0ZQtvc2xhc2hhY3V0ZQd1bmkwMjE4B3VuaTAyMTkFdG9ub3MNZGllcmVzaXN0b25vcwpBbHBoYXRvbm9zCWFub3RlbGVpYQxFcHNpbG9udG9ub3MIRXRhdG9ub3MJSW90YXRvbm9zDE9taWNyb250b25vcwxVcHNpbG9udG9ub3MKT21lZ2F0b25vcxFpb3RhZGllcmVzaXN0b25vcwVBbHBoYQRCZXRhBUdhbW1hB3VuaTAzOTQHRXBzaWxvbgRaZXRhA0V0YQVUaGV0YQRJb3RhBUthcHBhBkxhbWJkYQJNdQJOdQJYaQdPbWljcm9uAlBpA1JobwVTaWdtYQNUYXUHVXBzaWxvbgNQaGkDQ2hpA1BzaQd1bmkwM0E5DElvdGFkaWVyZXNpcw9VcHNpbG9uZGllcmVzaXMKYWxwaGF0b25vcwxlcHNpbG9udG9ub3MIZXRhdG9ub3MJaW90YXRvbm9zFHVwc2lsb25kaWVyZXNpc3Rvbm9zBWFscGhhBGJldGEFZ2FtbWEFZGVsdGEHZXBzaWxvbgR6ZXRhA2V0YQV0aGV0YQRpb3RhBWthcHBhBmxhbWJkYQd1bmkwM0JDAm51AnhpB29taWNyb24DcmhvBnNpZ21hMQVzaWdtYQN0YXUHdXBzaWxvbgNwaGkDY2hpA3BzaQVvbWVnYQxpb3RhZGllcmVzaXMPdXBzaWxvbmRpZXJlc2lzDG9taWNyb250b25vcwx1cHNpbG9udG9ub3MKb21lZ2F0b25vcwlhZmlpMTAwMjMJYWZpaTEwMDUxCWFmaWkxMDA1MglhZmlpMTAwNTMJYWZpaTEwMDU0CWFmaWkxMDA1NQlhZmlpMTAwNTYJYWZpaTEwMDU3CWFmaWkxMDA1OAlhZmlpMTAwNTkJYWZpaTEwMDYwCWFmaWkxMDA2MQlhZmlpMTAwNjIJYWZpaTEwMTQ1CWFmaWkxMDAxNwlhZmlpMTAwMTgJYWZpaTEwMDE5CWFmaWkxMDAyMAlhZmlpMTAwMjEJYWZpaTEwMDIyCWFmaWkxMDAyNAlhZmlpMTAwMjUJYWZpaTEwMDI2CWFmaWkxMDAyNwlhZmlpMTAwMjgJYWZpaTEwMDI5CWFmaWkxMDAzMAlhZmlpMTAwMzEJYWZpaTEwMDMyCWFmaWkxMDAzMwlhZmlpMTAwMzQJYWZpaTEwMDM1CWFmaWkxMDAzNglhZmlpMTAwMzcJYWZpaTEwMDM4CWFmaWkxMDAzOQlhZmlpMTAwNDAJYWZpaTEwMDQxCWFmaWkxMDA0MglhZmlpMTAwNDMJYWZpaTEwMDQ0CWFmaWkxMDA0NQlhZmlpMTAwNDYJYWZpaTEwMDQ3CWFmaWkxMDA0OAlhZmlpMTAwNDkJYWZpaTEwMDY1CWFmaWkxMDA2NglhZmlpMTAwNjcJYWZpaTEwMDY4CWFmaWkxMDA2OQlhZmlpMTAwNzAJYWZpaTEwMDcyCWFmaWkxMDA3MwlhZmlpMTAwNzQJYWZpaTEwMDc1CWFmaWkxMDA3NglhZmlpMTAwNzcJYWZpaTEwMDc4CWFmaWkxMDA3OQlhZmlpMTAwODAJYWZpaTEwMDgxCWFmaWkxMDA4MglhZmlpMTAwODMJYWZpaTEwMDg0CWFmaWkxMDA4NQlhZmlpMTAwODYJYWZpaTEwMDg3CWFmaWkxMDA4OAlhZmlpMTAwODkJYWZpaTEwMDkwCWFmaWkxMDA5MQlhZmlpMTAwOTIJYWZpaTEwMDkzCWFmaWkxMDA5NAlhZmlpMTAwOTUJYWZpaTEwMDk2CWFmaWkxMDA5NwlhZmlpMTAwNzEJYWZpaTEwMDk5CWFmaWkxMDEwMAlhZmlpMTAxMDEJYWZpaTEwMTAyCWFmaWkxMDEwMwlhZmlpMTAxMDQJYWZpaTEwMTA1CWFmaWkxMDEwNglhZmlpMTAxMDcJYWZpaTEwMTA4CWFmaWkxMDEwOQlhZmlpMTAxMTAJYWZpaTEwMTkzCWFmaWkxMDA1MAlhZmlpMTAwOTgGV2dyYXZlBndncmF2ZQZXYWN1dGUGd2FjdXRlCVdkaWVyZXNpcwl3ZGllcmVzaXMGWWdyYXZlBnlncmF2ZQlhZmlpMDAyMDgNdW5kZXJzY29yZWRibA1xdW90ZXJldmVyc2VkBm1pbnV0ZQZzZWNvbmQJZXhjbGFtZGJsCW5zdXBlcmlvcglhZmlpMDg5NDEGcGVzZXRhBEV1cm8JYWZpaTYxMjQ4CWFmaWk2MTI4OQlhZmlpNjEzNTIHdW5pMjEyNgllc3RpbWF0ZWQJb25lZWlnaHRoDHRocmVlZWlnaHRocwtmaXZlZWlnaHRocwxzZXZlbmVpZ2h0aHMNY3lyaWxsaWNicmV2ZRBjYXJvbmNvbW1hYWNjZW50C2NvbW1hYWNjZW50EWNvbW1hYWNjZW50cm90YXRlB3VuaTIwNzQHdW5pMjA3NQd1bmkyMDc3B3VuaTIwNzgHdW5pMjAwMAd1bmkyMDAxB3VuaTIwMDIHdW5pMjAwMwd1bmkyMDA0B3VuaTIwMDUHdW5pMjAwNgd1bmkyMDA3B3VuaTIwMDgHdW5pMjAwOQd1bmkyMDBBB3VuaTIwMEIHdW5pRkVGRgd1bmlGRkZDB3VuaUZGRkQHdW5pMDFGMAd1bmkwMkJDB3VuaTAzRDEHdW5pMDNEMgd1bmkwM0Q2B3VuaTFFM0UHdW5pMUUzRgd1bmkxRTAwB3VuaTFFMDEHdW5pMDJGMwVPaG9ybgVvaG9ybgVVaG9ybgV1aG9ybgRob29rB3VuaTA0MDAHdW5pMDQwRAd1bmkwNDUwB3VuaTA0NUQHdW5pMDQ2MAd1bmkwNDYxB3VuaTA0NjIHdW5pMDQ2Mwd1bmkwNDY0B3VuaTA0NjUHdW5pMDQ2Ngd1bmkwNDY3B3VuaTA0NjgHdW5pMDQ2OQd1bmkwNDZBB3VuaTA0NkIHdW5pMDQ2Qwd1bmkwNDZEB3VuaTA0NkUHdW5pMDQ2Rgd1bmkwNDcwB3VuaTA0NzEHdW5pMDQ3Mgd1bmkwNDczB3VuaTA0NzQHdW5pMDQ3NQd1bmkwNDc2B3VuaTA0NzcHdW5pMDQ3OAd1bmkwNDc5B3VuaTA0N0EHdW5pMDQ3Qgd1bmkwNDdDB3VuaTA0N0QHdW5pMDQ3RQd1bmkwNDdGB3VuaTA0ODAHdW5pMDQ4MQd1bmkwNDgyB3VuaTA0ODgHdW5pMDQ4OQd1bmkwNDhBB3VuaTA0OEIHdW5pMDQ4Qwd1bmkwNDhEB3VuaTA0OEUHdW5pMDQ4Rgd1bmkwNDkyB3VuaTA0OTMHdW5pMDQ5NAd1bmkwNDk1B3VuaTA0OTYHdW5pMDQ5Nwd1bmkwNDk4B3VuaTA0OTkHdW5pMDQ5QQd1bmkwNDlCB3VuaTA0OUMHdW5pMDQ5RAd1bmkwNDlFB3VuaTA0OUYHdW5pMDRBMAd1bmkwNEExB3VuaTA0QTIHdW5pMDRBMwd1bmkwNEE0B3VuaTA0QTUHdW5pMDRBNgd1bmkwNEE3B3VuaTA0QTgHdW5pMDRBOQd1bmkwNEFBB3VuaTA0QUIHdW5pMDRBQwd1bmkwNEFEB3VuaTA0QUUHdW5pMDRBRgd1bmkwNEIwB3VuaTA0QjEHdW5pMDRCMgd1bmkwNEIzB3VuaTA0QjQHdW5pMDRCNQd1bmkwNEI2B3VuaTA0QjcHdW5pMDRCOAd1bmkwNEI5B3VuaTA0QkEHdW5pMDRCQgd1bmkwNEJDB3VuaTA0QkQHdW5pMDRCRQd1bmkwNEJGB3VuaTA0QzAHdW5pMDRDMQd1bmkwNEMyB3VuaTA0QzMHdW5pMDRDNAd1bmkwNEM1B3VuaTA0QzYHdW5pMDRDNwd1bmkwNEM4B3VuaTA0QzkHdW5pMDRDQQd1bmkwNENCB3VuaTA0Q0MHdW5pMDRDRAd1bmkwNENFB3VuaTA0Q0YHdW5pMDREMAd1bmkwNEQxB3VuaTA0RDIHdW5pMDREMwd1bmkwNEQ0B3VuaTA0RDUHdW5pMDRENgd1bmkwNEQ3B3VuaTA0RDgHdW5pMDREOQd1bmkwNERBB3VuaTA0REIHdW5pMDREQwd1bmkwNEREB3VuaTA0REUHdW5pMDRERgd1bmkwNEUwB3VuaTA0RTEHdW5pMDRFMgd1bmkwNEUzB3VuaTA0RTQHdW5pMDRFNQd1bmkwNEU2B3VuaTA0RTcHdW5pMDRFOAd1bmkwNEU5B3VuaTA0RUEHdW5pMDRFQgd1bmkwNEVDB3VuaTA0RUQHdW5pMDRFRQd1bmkwNEVGB3VuaTA0RjAHdW5pMDRGMQd1bmkwNEYyB3VuaTA0RjMHdW5pMDRGNAd1bmkwNEY1B3VuaTA0RjYHdW5pMDRGNwd1bmkwNEY4B3VuaTA0RjkHdW5pMDRGQQd1bmkwNEZCB3VuaTA0RkMHdW5pMDRGRAd1bmkwNEZFB3VuaTA0RkYHdW5pMDUwMAd1bmkwNTAxB3VuaTA1MDIHdW5pMDUwMwd1bmkwNTA0B3VuaTA1MDUHdW5pMDUwNgd1bmkwNTA3B3VuaTA1MDgHdW5pMDUwOQd1bmkwNTBBB3VuaTA1MEIHdW5pMDUwQwd1bmkwNTBEB3VuaTA1MEUHdW5pMDUwRgd1bmkwNTEwB3VuaTA1MTEHdW5pMDUxMgd1bmkwNTEzB3VuaTFFQTAHdW5pMUVBMQd1bmkxRUEyB3VuaTFFQTMHdW5pMUVBNAd1bmkxRUE1B3VuaTFFQTYHdW5pMUVBNwd1bmkxRUE4B3VuaTFFQTkHdW5pMUVBQQd1bmkxRUFCB3VuaTFFQUMHdW5pMUVBRAd1bmkxRUFFB3VuaTFFQUYHdW5pMUVCMAd1bmkxRUIxB3VuaTFFQjIHdW5pMUVCMwd1bmkxRUI0B3VuaTFFQjUHdW5pMUVCNgd1bmkxRUI3B3VuaTFFQjgHdW5pMUVCOQd1bmkxRUJBB3VuaTFFQkIHdW5pMUVCQwd1bmkxRUJEB3VuaTFFQkUHdW5pMUVCRgd1bmkxRUMwB3VuaTFFQzEHdW5pMUVDMgd1bmkxRUMzB3VuaTFFQzQHdW5pMUVDNQd1bmkxRUM2B3VuaTFFQzcHdW5pMUVDOAd1bmkxRUM5B3VuaTFFQ0EHdW5pMUVDQgd1bmkxRUNDB3VuaTFFQ0QHdW5pMUVDRQd1bmkxRUNGB3VuaTFFRDAHdW5pMUVEMQd1bmkxRUQyB3VuaTFFRDMHdW5pMUVENAd1bmkxRUQ1B3VuaTFFRDYHdW5pMUVENwd1bmkxRUQ4B3VuaTFFRDkHdW5pMUVEQQd1bmkxRURCB3VuaTFFREMHdW5pMUVERAd1bmkxRURFB3VuaTFFREYHdW5pMUVFMAd1bmkxRUUxB3VuaTFFRTIHdW5pMUVFMwd1bmkxRUU0B3VuaTFFRTUHdW5pMUVFNgd1bmkxRUU3B3VuaTFFRTgHdW5pMUVFOQd1bmkxRUVBB3VuaTFFRUIHdW5pMUVFQwd1bmkxRUVEB3VuaTFFRUUHdW5pMUVFRgd1bmkxRUYwB3VuaTFFRjEHdW5pMUVGNAd1bmkxRUY1B3VuaTFFRjYHdW5pMUVGNwd1bmkxRUY4B3VuaTFFRjkHdW5pMjBBQhNjaXJjdW1mbGV4YWN1dGVjb21iE2NpcmN1bWZsZXhncmF2ZWNvbWISY2lyY3VtZmxleGhvb2tjb21iE2NpcmN1bWZsZXh0aWxkZWNvbWIOYnJldmVhY3V0ZWNvbWIOYnJldmVncmF2ZWNvbWINYnJldmVob29rY29tYg5icmV2ZXRpbGRlY29tYhBjeXJpbGxpY2hvb2tsZWZ0EWN5cmlsbGljYmlnaG9va1VDB3VuaTAxNjIHdW5pMDE2Mwd1bmkwMTgwB3VuaTAxODEHdW5pMDE4Mgd1bmkwMTgzB3VuaTAxODQHdW5pMDE4NQd1bmkwMTg2B3VuaTAxODcHdW5pMDE4OAd1bmkwMTg5B3VuaTAxOEEHdW5pMDE4Qgd1bmkwMThDB3VuaTAxOEQHdW5pMDE4RQd1bmkwMThGB3VuaTAxOTAHdW5pMDE5MQd1bmkwMTkzB3VuaTAxOTQHdW5pMDE5NQd1bmkwMTk2B3VuaTAxOTcHdW5pMDE5OAd1bmkwMTk5B3VuaTAxOUEHdW5pMDE5Qgd1bmkwMTlDB3VuaTAxOUQHdW5pMDE5RQd1bmkwMTlGB3VuaTAxQTIHdW5pMDFBMwd1bmkwMUE0B3VuaTAxQTUHdW5pMDFBNgd1bmkwMUE3B3VuaTAxQTgHdW5pMDFBOQd1bmkwMUFBB3VuaTAxQUIHdW5pMDFBQwd1bmkwMUFEB3VuaTAxQUUHdW5pMDFCMQd1bmkwMUIyB3VuaTAxQjMHdW5pMDFCNAd1bmkwMUI1B3VuaTAxQjYHdW5pMDFCNwd1bmkwMUI4B3VuaTAxQjkHdW5pMDFCQQd1bmkwMUJCB3VuaTAxQkMHdW5pMDFCRAd1bmkwMUJFB3VuaTAxQkYHdW5pMDFDMAd1bmkwMUMxB3VuaTAxQzIHdW5pMDFDMwd1bmkwMUM0B3VuaTAxQzUHdW5pMDFDNgd1bmkwMUM3B3VuaTAxQzgHdW5pMDFDOQd1bmkwMUNBB3VuaTAxQ0IHdW5pMDFDQwd1bmkwMUNEB3VuaTAxQ0UHdW5pMDFDRgd1bmkwMUQwB3VuaTAxRDEHdW5pMDFEMgd1bmkwMUQzB3VuaTAxRDQHdW5pMDFENQd1bmkwMUQ2B3VuaTAxRDcHdW5pMDFEOAd1bmkwMUQ5B3VuaTAxREEHdW5pMDFEQgd1bmkwMURDB3VuaTAxREUHdW5pMDFERgd1bmkwMUUwB3VuaTAxRTEHdW5pMDFFMgd1bmkwMUUzB3VuaTAxRTQHdW5pMDFFNQd1bmkwMUU2B3VuaTAxRTcHdW5pMDFFOAd1bmkwMUU5B3VuaTAxRUEHdW5pMDFFQgd1bmkwMUVDB3VuaTAxRUQHdW5pMDFFRQd1bmkwMUVGB3VuaTAxRjEHdW5pMDFGMgd1bmkwMUYzB3VuaTAxRjQHdW5pMDFGNQd1bmkwMUY2B3VuaTAxRjcHdW5pMDFGOAd1bmkwMUY5B3VuaTAyMDAHdW5pMDIwMQd1bmkwMjAyB3VuaTAyMDMHdW5pMDIwNAd1bmkwMjA1B3VuaTAyMDYHdW5pMDIwNwd1bmkwMjA4B3VuaTAyMDkHdW5pMDIwQQd1bmkwMjBCB3VuaTAyMEMHdW5pMDIwRAd1bmkwMjBFB3VuaTAyMEYHdW5pMDIxMAd1bmkwMjExB3VuaTAyMTIHdW5pMDIxMwd1bmkwMjE0B3VuaTAyMTUHdW5pMDIxNgd1bmkwMjE3B3VuaTAyMUMHdW5pMDIxRAd1bmkwMjFFB3VuaTAyMUYHdW5pMDIyMAd1bmkwMjIxB3VuaTAyMjIHdW5pMDIyMwd1bmkwMjI0B3VuaTAyMjUHdW5pMDIyNgd1bmkwMjI3B3VuaTAyMjgHdW5pMDIyOQd1bmkwMjJBB3VuaTAyMkIHdW5pMDIyQwd1bmkwMjJEB3VuaTAyMkUHdW5pMDIyRgd1bmkwMjMwB3VuaTAyMzEHdW5pMDIzMgd1bmkwMjMzB3VuaTAyMzQHdW5pMDIzNQd1bmkwMjM2B3VuaTAyMzgHdW5pMDIzOQd1bmkwMjNBB3VuaTAyM0IHdW5pMDIzQwd1bmkwMjNEB3VuaTAyM0UHdW5pMDIzRgd1bmkwMjQwB3VuaTAyNDEHdW5pMDI0Mgd1bmkwMjQzB3VuaTAyNDQHdW5pMDI0NQd1bmkwMjQ2B3VuaTAyNDcHdW5pMDI0OAd1bmkwMjQ5B3VuaTAyNEEHdW5pMDI0Qgd1bmkwMjRDB3VuaTAyNEQHdW5pMDI0RQd1bmkwMjRGB3VuaTAyNTAHdW5pMDI1MQd1bmkwMjUyB3VuaTAyNTMHdW5pMDI1NAd1bmkwMjU1B3VuaTAyNTYHdW5pMDI1Nwd1bmkwMjU4B3VuaTAyNTkHdW5pMDI1Qgd1bmkwMjVFB3VuaTAyNUYHdW5pMDI2MAd1bmkwMjYxB3VuaTAyNjIHdW5pMDI2Mwd1bmkwMjY0B3VuaTAyNjUHdW5pMDI2Ngd1bmkwMjY3B3VuaTAyNjgJaW90YUxhdGluB3VuaTAyNkEHdW5pMDI2Qgd1bmkwMjZDB3VuaTAyNkQHdW5pMDI2RQd1bmkwMjZGB3VuaTAyNzAHdW5pMDI3MQd1bmkwMjcyB3VuaTAyNzMHdW5pMDI3NAd1bmkwMjc1B3VuaTAyNzYLb21lZ2FjbG9zZWQHdW5pMDI3OAd1bmkwMjc5B3VuaTAyN0EHdW5pMDI3Qgd1bmkwMjdDB3VuaTAyN0QHdW5pMDI3RQd1bmkwMjdGB3VuaTAyODAHdW5pMDI4MQd1bmkwMjgyB3VuaTAyODMHdW5pMDI4NAd1bmkwMjg1B3VuaTAyODYHdW5pMDI4Nwd1bmkwMjg4B3VuaTAyODkHdW5pMDI4QQd1bmkwMjhCB3VuaTAyOEMHdW5pMDI4RAd1bmkwMjhFB3VuaTAyOEYHdW5pMDI5MAd1bmkwMjkxB3VuaTAyOTIHdW5pMDI5Mwd1bmkwMjk0B3VuaTAyOTUNZ2xvdHRhbHR1cm5lZAd1bmkwMjk3B3VuaTAyOTgHdW5pMDI5OQd1bmkwMjlBB3VuaTAyOUIHdW5pMDI5Qwd1bmkwMjlEB3VuaTAyOUUHdW5pMDI5Rgd1bmkwMkEwB3VuaTAyQTEHdW5pMDJBMgVkemxpZwd1bmkwMkE0CWR6bGlnY3VybAV0c2xpZwd1bmkwMkE3CXRjbGlnY3VybAd1bmkwMkE5B3VuaTAyQUEHdW5pMDJBQgd1bmkwMkFDB3VuaTAyQUQHdW5pMDJBRQd1bmkwMkFGB3VuaTAyQjAHdW5pMDJCMQd1bmkwMkIyB3VuaTAyQjMHdW5pMDJCNAd1bmkwMkI1B3VuaTAyQjYHdW5pMDJCNwd1bmkwMkI4B3VuaTAyQjkHdW5pMDJCQQd1bmkwMkJCB3VuaTAyQkQHdW5pMDJCRQd1bmkwMkJGB3VuaTAyQzAHdW5pMDJDMQd1bmkwMkMyB3VuaTAyQzMHdW5pMDJDNAd1bmkwMkM1B3VuaTAyQzgHdW5pMDJDQQd1bmkwMkNCB3VuaTAyQ0MHdW5pMDJDRAd1bmkwMkNFB3VuaTAyQ0YHdW5pMDJEMAd1bmkwMkQxB3VuaTAyRDIHdW5pMDJEMwd1bmkwMkQ0B3VuaTAyRDUHdW5pMDJENgd1bmkwMkQ3B3VuaTAyREYHdW5pMDJFMAd1bmkwMkUxB3VuaTAyRTIHdW5pMDJFMwd1bmkwMkU0B3VuaTAyRTUHdW5pMDJFNgd1bmkwMkU3B3VuaTAyRTgHdW5pMDJFOQd1bmkwMkVBB3VuaTAyRUIHdW5pMDJFQwd1bmkwMkVEB3VuaTAyRUUHdW5pMDJFRgd1bmkwMkYwB3VuaTAyRjEHdW5pMDJGMgd1bmkwMkY0B3VuaTAyRjUHdW5pMDJGNgd1bmkwMkY3B3VuaTAyRjgHdW5pMDJGOQd1bmkwMkZBB3VuaTAyRkIHdW5pMDJGQwd1bmkwMkZEB3VuaTAyRkUHdW5pMDJGRg1ob29rYWJvdmVjb21iB3VuaTAzNzQHdW5pMDM3NQd1bmkwMzdBB3VuaTAzN0IHdW5pMDM3Qwd1bmkwMzdEB3VuaTAzN0UHdW5pMDNEMAd1bmkwM0QzB3VuaTAzRDQEcGhpMQd1bmkwM0Q3B3VuaTAzRDgHdW5pMDNEOQd1bmkwM0RBB3VuaTAzREIHdW5pMDNEQwd1bmkwM0REB3VuaTAzREUHdW5pMDNERgd1bmkwM0UwB3VuaTAzRTEHdW5pMDNGMAd1bmkwM0YxB3VuaTAzRjIHdW5pMDNGMwd1bmkwM0Y0B3VuaTAzRjUHdW5pMDNGNgd1bmkwM0Y3B3VuaTAzRjgHdW5pMDNGOQd1bmkwM0ZBB3VuaTAzRkIHdW5pMDNGQwd1bmkwM0ZEB3VuaTAzRkUHdW5pMDNGRgd1bmkwNTFBB3VuaTA1MUIHdW5pMDUxQwd1bmkwNTFEB3VuaTFEMDAHdW5pMUQwMQd1bmkxRDAyB3VuaTFEMDMHdW5pMUQwNAd1bmkxRDA1B3VuaTFEMDYHdW5pMUQwNwd1bmkxRDA4B3VuaTFEMDkHdW5pMUQwQQd1bmkxRDBCB3VuaTFEMEMHdW5pMUQwRAd1bmkxRDBFB3VuaTFEMEYHdW5pMUQxMAd1bmkxRDExB3VuaTFEMTIHdW5pMUQxMwd1bmkxRDE0B3VuaTFEMTUHdW5pMUQxNgd1bmkxRDE3B3VuaTFEMTgHdW5pMUQxOQd1bmkxRDFBB3VuaTFEMUIHdW5pMUQxQwd1bmkxRDFEB3VuaTFEMUUHdW5pMUQxRgd1bmkxRDIwB3VuaTFEMjEHdW5pMUQyMgd1bmkxRDIzB3VuaTFEMjQHdW5pMUQyNQd1bmkxRDI2B3VuaTFEMjcHdW5pMUQyOAd1bmkxRDI5B3VuaTFEMkEHdW5pMUQyQgd1bmkxRDJDB3VuaTFEMkQHdW5pMUQyRQd1bmkxRDJGB3VuaTFEMzAHdW5pMUQzMQd1bmkxRDMyB3VuaTFEMzMHdW5pMUQzNAd1bmkxRDM1B3VuaTFEMzYHdW5pMUQzNwd1bmkxRDM4B3VuaTFEMzkHdW5pMUQzQQd1bmkxRDNCB3VuaTFEM0MHdW5pMUQzRAd1bmkxRDNFB3VuaTFEM0YHdW5pMUQ0MAd1bmkxRDQxB3VuaTFENDIHdW5pMUQ0Mwd1bmkxRDQ0B3VuaTFENDUHdW5pMUQ0Ngd1bmkxRDQ3B3VuaTFENDgHdW5pMUQ0OQd1bmkxRDRBB3VuaTFENEIHdW5pMUQ0Qwd1bmkxRDREB3VuaTFENEUHdW5pMUQ0Rgd1bmkxRDUwB3VuaTFENTEHdW5pMUQ1Mgd1bmkxRDUzB3VuaTFENTQHdW5pMUQ1NQd1bmkxRDU2B3VuaTFENTcHdW5pMUQ1OAd1bmkxRDU5B3VuaTFENUEHdW5pMUQ1Qgd1bmkxRDVDB3VuaTFENUQHdW5pMUQ1RQd1bmkxRDVGB3VuaTFENjAHdW5pMUQ2MQd1bmkxRDYyB3VuaTFENjMHdW5pMUQ2NAd1bmkxRDY1B3VuaTFENjYHdW5pMUQ2Nwd1bmkxRDY4B3VuaTFENjkHdW5pMUQ2QQd1bmkxRDZCB3VuaTFENkMHdW5pMUQ2RAd1bmkxRDZFB3VuaTFENkYHdW5pMUQ3MAd1bmkxRDcxB3VuaTFENzIHdW5pMUQ3Mwd1bmkxRDc0B3VuaTFENzUHdW5pMUQ3Ngd1bmkxRDc3B3VuaTFENzgHdW5pMUQ3OQd1bmkxRDdBB3VuaTFEN0IHdW5pMUQ3Qwd1bmkxRDdEB3VuaTFEN0UHdW5pMUQ3Rgd1bmkxRDgwB3VuaTFEODEHdW5pMUQ4Mgd1bmkxRDgzB3VuaTFEODQHdW5pMUQ4NQd1bmkxRDg2B3VuaTFEODcHdW5pMUQ4OAd1bmkxRDg5B3VuaTFEOEEHdW5pMUQ4Qgd1bmkxRDhDB3VuaTFEOEQHdW5pMUQ4RQd1bmkxRDhGB3VuaTFEOTAHdW5pMUQ5MQd1bmkxRDkyB3VuaTFEOTMHdW5pMUQ5NAd1bmkxRDk1B3VuaTFEOTYHdW5pMUQ5Nwd1bmkxRDk4B3VuaTFEOTkHdW5pMUQ5QQd1bmkxRDlCB3VuaTFEOUMHdW5pMUQ5RAd1bmkxRDlFB3VuaTFEOUYHdW5pMURBMAd1bmkxREExB3VuaTFEQTIHdW5pMURBMwd1bmkxREE0B3VuaTFEQTUHdW5pMURBNgd1bmkxREE3B3VuaTFEQTgHdW5pMURBOQd1bmkxREFBB3VuaTFEQUIHdW5pMURBQwd1bmkxREFEB3VuaTFEQUUHdW5pMURBRgd1bmkxREIwB3VuaTFEQjEHdW5pMURCMgd1bmkxREIzB3VuaTFEQjQHdW5pMURCNQd1bmkxREI2B3VuaTFEQjcHdW5pMURCOAd1bmkxREI5B3VuaTFEQkEHdW5pMURCQgd1bmkxREJDB3VuaTFEQkQHdW5pMURCRQd1bmkxREJGB3VuaTFFMDIHdW5pMUUwMwd1bmkxRTA0B3VuaTFFMDUHdW5pMUUwNgd1bmkxRTA3B3VuaTFFMDgHdW5pMUUwOQd1bmkxRTBBB3VuaTFFMEIHdW5pMUUwQwd1bmkxRTBEB3VuaTFFMEUHdW5pMUUwRgd1bmkxRTEwB3VuaTFFMTEHdW5pMUUxMgd1bmkxRTEzB3VuaTFFMTQHdW5pMUUxNQd1bmkxRTE2B3VuaTFFMTcHdW5pMUUxOAd1bmkxRTE5B3VuaTFFMUEHdW5pMUUxQgd1bmkxRTFDB3VuaTFFMUQHdW5pMUUxRQd1bmkxRTFGB3VuaTFFMjAHdW5pMUUyMQd1bmkxRTIyB3VuaTFFMjMHdW5pMUUyNAd1bmkxRTI1B3VuaTFFMjYHdW5pMUUyNwd1bmkxRTI4B3VuaTFFMjkHdW5pMUUyQQd1bmkxRTJCB3VuaTFFMkMHdW5pMUUyRAd1bmkxRTJFB3VuaTFFMkYHdW5pMUUzMAd1bmkxRTMxB3VuaTFFMzIHdW5pMUUzMwd1bmkxRTM0B3VuaTFFMzUHdW5pMUUzNgd1bmkxRTM3B3VuaTFFMzgHdW5pMUUzOQd1bmkxRTNBB3VuaTFFM0IHdW5pMUUzQwd1bmkxRTNEB3VuaTFFNDAHdW5pMUU0MQd1bmkxRTQyB3VuaTFFNDMHdW5pMUU0NAd1bmkxRTQ1B3VuaTFFNDYHdW5pMUU0Nwd1bmkxRTQ4B3VuaTFFNDkHdW5pMUU0QQd1bmkxRTRCB3VuaTFFNEMHdW5pMUU0RAd1bmkxRTRFB3VuaTFFNEYHdW5pMUU1MAd1bmkxRTUxB3VuaTFFNTIHdW5pMUU1Mwd1bmkxRTU0B3VuaTFFNTUHdW5pMUU1Ngd1bmkxRTU3B3VuaTFFNTgHdW5pMUU1OQd1bmkxRTVBB3VuaTFFNUIHdW5pMUU1Qwd1bmkxRTVEB3VuaTFFNUUHdW5pMUU1Rgd1bmkxRTYwB3VuaTFFNjEHdW5pMUU2Mgd1bmkxRTYzB3VuaTFFNjQHdW5pMUU2NQd1bmkxRTY2B3VuaTFFNjcHdW5pMUU2OAd1bmkxRTY5B3VuaTFFNkEHdW5pMUU2Qgd1bmkxRTZDB3VuaTFFNkQHdW5pMUU2RQd1bmkxRTZGB3VuaTFFNzAHdW5pMUU3MQd1bmkxRTcyB3VuaTFFNzMHdW5pMUU3NAd1bmkxRTc1B3VuaTFFNzYHdW5pMUU3Nwd1bmkxRTc4B3VuaTFFNzkHdW5pMUU3QQd1bmkxRTdCB3VuaTFFN0MHdW5pMUU3RAd1bmkxRTdFB3VuaTFFN0YHdW5pMUU4Ngd1bmkxRTg3B3VuaTFFODgHdW5pMUU4OQd1bmkxRThBB3VuaTFFOEIHdW5pMUU4Qwd1bmkxRThEB3VuaTFFOEUHdW5pMUU4Rgd1bmkxRTkwB3VuaTFFOTEHdW5pMUU5Mgd1bmkxRTkzB3VuaTFFOTQHdW5pMUU5NQd1bmkxRTk2B3VuaTFFOTcHdW5pMUU5OAd1bmkxRTk5B3VuaTFFOUEHdW5pMUU5Qgd1bmkxRjAwB3VuaTFGMDEHdW5pMUYwMgd1bmkxRjAzB3VuaTFGMDQHdW5pMUYwNQd1bmkxRjA2B3VuaTFGMDcHdW5pMUYwOAd1bmkxRjA5B3VuaTFGMEEHdW5pMUYwQgd1bmkxRjBDB3VuaTFGMEQHdW5pMUYwRQd1bmkxRjBGB3VuaTFGMTAHdW5pMUYxMQd1bmkxRjEyB3VuaTFGMTMHdW5pMUYxNAd1bmkxRjE1B3VuaTFGMTgHdW5pMUYxOQd1bmkxRjFBB3VuaTFGMUIHdW5pMUYxQwd1bmkxRjFEB3VuaTFGMjAHdW5pMUYyMQd1bmkxRjIyB3VuaTFGMjMHdW5pMUYyNAd1bmkxRjI1B3VuaTFGMjYHdW5pMUYyNwd1bmkxRjI4B3VuaTFGMjkHdW5pMUYyQQd1bmkxRjJCB3VuaTFGMkMHdW5pMUYyRAd1bmkxRjJFB3VuaTFGMkYHdW5pMUYzMAd1bmkxRjMxB3VuaTFGMzIHdW5pMUYzMwd1bmkxRjM0B3VuaTFGMzUHdW5pMUYzNgd1bmkxRjM3B3VuaTFGMzgHdW5pMUYzOQd1bmkxRjNBB3VuaTFGM0IHdW5pMUYzQwd1bmkxRjNEB3VuaTFGM0UHdW5pMUYzRgd1bmkxRjQwB3VuaTFGNDEHdW5pMUY0Mgd1bmkxRjQzB3VuaTFGNDQHdW5pMUY0NQd1bmkxRjQ4B3VuaTFGNDkHdW5pMUY0QQd1bmkxRjRCB3VuaTFGNEMHdW5pMUY0RAd1bmkxRjUwB3VuaTFGNTEHdW5pMUY1Mgd1bmkxRjUzB3VuaTFGNTQHdW5pMUY1NQd1bmkxRjU2B3VuaTFGNTcHdW5pMUY1OQd1bmkxRjVCB3VuaTFGNUQHdW5pMUY1Rgd1bmkxRjYwB3VuaTFGNjEHdW5pMUY2Mgd1bmkxRjYzB3VuaTFGNjQHdW5pMUY2NQd1bmkxRjY2B3VuaTFGNjcHdW5pMUY2OAd1bmkxRjY5B3VuaTFGNkEHdW5pMUY2Qgd1bmkxRjZDB3VuaTFGNkQHdW5pMUY2RQd1bmkxRjZGB3VuaTFGNzAHdW5pMUY3MQd1bmkxRjcyB3VuaTFGNzMHdW5pMUY3NAd1bmkxRjc1B3VuaTFGNzYHdW5pMUY3Nwd1bmkxRjc4B3VuaTFGNzkHdW5pMUY3QQd1bmkxRjdCB3VuaTFGN0MHdW5pMUY3RAd1bmkxRjgwB3VuaTFGODEHdW5pMUY4Mgd1bmkxRjgzB3VuaTFGODQHdW5pMUY4NQd1bmkxRjg2B3VuaTFGODcHdW5pMUY4OAd1bmkxRjg5B3VuaTFGOEEHdW5pMUY4Qgd1bmkxRjhDB3VuaTFGOEQHdW5pMUY4RQd1bmkxRjhGB3VuaTFGOTAHdW5pMUY5MQd1bmkxRjkyB3VuaTFGOTMHdW5pMUY5NAd1bmkxRjk1B3VuaTFGOTYHdW5pMUY5Nwd1bmkxRjk4B3VuaTFGOTkHdW5pMUY5QQd1bmkxRjlCB3VuaTFGOUMHdW5pMUY5RAd1bmkxRjlFB3VuaTFGOUYHdW5pMUZBMAd1bmkxRkExB3VuaTFGQTIHdW5pMUZBMwd1bmkxRkE0B3VuaTFGQTUHdW5pMUZBNgd1bmkxRkE3B3VuaTFGQTgHdW5pMUZBOQd1bmkxRkFBB3VuaTFGQUIHdW5pMUZBQwd1bmkxRkFEB3VuaTFGQUUHdW5pMUZBRgd1bmkxRkIwB3VuaTFGQjEHdW5pMUZCMgd1bmkxRkIzB3VuaTFGQjQHdW5pMUZCNgd1bmkxRkI3B3VuaTFGQjgHdW5pMUZCOQd1bmkxRkJBB3VuaTFGQkIHdW5pMUZCQwd1bmkxRkJEB3VuaTFGQkUHdW5pMUZCRgd1bmkxRkMwB3VuaTFGQzEHdW5pMUZDMgd1bmkxRkMzB3VuaTFGQzQHdW5pMUZDNgd1bmkxRkM3B3VuaTFGQzgHdW5pMUZDOQd1bmkxRkNBB3VuaTFGQ0IHdW5pMUZDQwd1bmkxRkNEB3VuaTFGQ0UHdW5pMUZDRgd1bmkxRkQwB3VuaTFGRDEHdW5pMUZEMgd1bmkxRkQzB3VuaTFGRDYHdW5pMUZENwd1bmkxRkQ4B3VuaTFGRDkHdW5pMUZEQQd1bmkxRkRCB3VuaTFGREQHdW5pMUZERQd1bmkxRkRGB3VuaTFGRTAHdW5pMUZFMQd1bmkxRkUyB3VuaTFGRTMHdW5pMUZFNAd1bmkxRkU1B3VuaTFGRTYHdW5pMUZFNwd1bmkxRkU4B3VuaTFGRTkHdW5pMUZFQQd1bmkxRkVCB3VuaTFGRUMHdW5pMUZFRAd1bmkxRkVFB3VuaTFGRUYHdW5pMUZGMgd1bmkxRkYzB3VuaTFGRjQHdW5pMUZGNgd1bmkxRkY3B3VuaTFGRjgHdW5pMUZGOQd1bmkxRkZBB3VuaTFGRkIHdW5pMUZGQwd1bmkxRkZEB3VuaTFGRkUHdW5pMjAwQwd1bmkyMDBEB3VuaTIwMEUHdW5pMjAwRgd1bmkyMDEyB3VuaTIwMTYHdW5pMjAxRgd1bmkyMDJBB3VuaTIwMkIHdW5pMjAyQwd1bmkyMDJEB3VuaTIwMkUHdW5pMjAyRgd1bmkyMDM0B3VuaTIwM0UHdW5pMjA1RQd1bmkyMDZBB3VuaTIwNkIHdW5pMjA2Qwd1bmkyMDZEB3VuaTIwNkUHdW5pMjA2Rgd1bmkyMDcwB3VuaTIwNzYHdW5pMjA3OQd1bmkyMDkwB3VuaTIwOTEHdW5pMjA5Mgd1bmkyMDkzB3VuaTIwOTQHdW5pMjBBMAd1bmkyMEExB3VuaTIwQTIHdW5pMjBBNQd1bmkyMEE2B3VuaTIwQTgHdW5pMjBBOQd1bmkyMEFEB3VuaTIwQUUHdW5pMjBBRgd1bmkyMEIwB3VuaTIwQjEHdW5pMjBCMgd1bmkyMEIzB3VuaTIwQjQHdW5pMjBCNQd1bmkyMEI5B3VuaTIwRjAHdW5pMjExNwd1bmkyMTREB3VuaTIxNEUHdW5pMjE1Mwd1bmkyMTU0B3VuaTIxODQHdW5pMkM2MAd1bmkyQzYxB3VuaTJDNjIHdW5pMkM2Mwd1bmkyQzY0B3VuaTJDNjUHdW5pMkM2Ngd1bmkyQzY3B3VuaTJDNjgHdW5pMkM2OQd1bmkyQzZBB3VuaTJDNkIHdW5pMkM2Qwd1bmkyQzZEB3VuaTJDNzEHdW5pMkM3Mgd1bmkyQzczB3VuaTJDNzQHdW5pMkM3NQd1bmkyQzc2B3VuaTJDNzcHdW5pMkUxNwd1bmlBNzE3B3VuaUE3MTgHdW5pQTcxOQd1bmlBNzFBB3VuaUE3MUIHdW5pQTcxQwd1bmlBNzFEB3VuaUE3MUUHdW5pQTcxRgd1bmlBNzIwB3VuaUE3MjEHdW5pQTc4OAd1bmlBNzg5B3VuaUE3OEEHdW5pQTc4Qgd1bmlBNzhDDWRpZXJlc2lzYWN1dGUNZGllcmVzaXNncmF2ZQd1bmlGRTIwB3VuaUZFMjEHdW5pRkUyMgd1bmlGRTIzE3VuaTAzQjEwMzA0MDMxMzAzMDATdW5pMDNCMTAzMDQwMzEzMDMwMRN1bmkwM0IxMDMwNDAzMTQwMzAwE3VuaTAzQjEwMzA0MDMxNDAzMDETdW5pMDNCMTAzMDYwMzEzMDMwMBN1bmkwM0IxMDMwNjAzMTMwMzAxE3VuaTAzQjEwMzA2MDMxNDAzMDATdW5pMDNCMTAzMDYwMzE0MDMwMRN1bmkwM0I5MDMwNDAzMTMwMzAwE3VuaTAzQjkwMzA0MDMxMzAzMDETdW5pMDNCOTAzMDQwMzE0MDMwMBN1bmkwM0I5MDMwNDAzMTQwMzAxE3VuaTAzQjkwMzA2MDMxMzAzMDATdW5pMDNCOTAzMDYwMzEzMDMwMRN1bmkwM0I5MDMwNjAzMTQwMzAwE3VuaTAzQjkwMzA2MDMxNDAzMDETdW5pMDNDNTAzMDQwMzEzMDMwMBN1bmkwM0M1MDMwNDAzMTMwMzAxE3VuaTAzQzUwMzA0MDMxNDAzMDATdW5pMDNDNTAzMDQwMzE0MDMwMRN1bmkwM0M1MDMwNjAzMTMwMzAwE3VuaTAzQzUwMzA2MDMxMzAzMDETdW5pMDNDNTAzMDYwMzE0MDMwMBN1bmkwM0M1MDMwNjAzMTQwMzAxE3VuaTAzQjkwMzA4MDMwNDAzMDATdW5pMDNCOTAzMDgwMzA0MDMwMRN1bmkwM0I5MDMwODAzMDYwMzAwE3VuaTAzQjkwMzA4MDMwNjAzMDETdW5pMDNDNTAzMDgwMzA0MDMwMBN1bmkwM0M1MDMwODAzMDQwMzAxE3VuaTAzQzUwMzA4MDMwNjAzMDATdW5pMDNDNTAzMDgwMzA2MDMwMQhFbmcuYWx0MQhFbmcuYWx0MghFbmcuYWx0Mwt1bmkxRkNEMDJDOQt1bmkxRkNFMDJDOQt1bmkxRkREMDJDOQt1bmkxRkRFMDJDOQhkb3RhY3V0ZQhjYXJvbmRvdA5tYWNyb25kaWVyZXNpcw10aWxkZWRpZXJlc2lzCnRpbGRlYWN1dGULbWFjcm9uZ3JhdmULbWFjcm9uYWN1dGUNZGllcmVzaXNjYXJvbg5kaWVyZXNpc21hY3Jvbgt0aWxkZW1hY3Jvbglkb3RtYWNyb24NZG90bWFjcm9uLmNhcA91bmkwMzAxMDMwNjAzMDgPdW5pMDMwMDAzMDYwMzA4D3VuaTAzMDEwMzA0MDMwOA91bmkwMzAwMDMwNDAzMDgLdW5pMUZERTAzMDYLdW5pMUZERDAzMDYLdW5pMUZDRTAzMDYLdW5pMUZDRDAzMDYHdW5pMDUxNAd1bmkwNTE1B3VuaTA1MTYHdW5pMDUxNwd1bmkwNTE4B3VuaTA1MTkHdW5pMDUxRQd1bmkwNTFGB3VuaTA1MjAHdW5pMDUyMQd1bmkwNTIyB3VuaTA1MjMHdW5pMDUyNAd1bmkwNTI1B3VuaTA1MjYHdW5pMDUyNw9jeXJpbGxpY19vdG1hcmsHdW5pMjBCQQd1bmkxRUZBB3VuaTJDNkUHdW5pMUU5RQdUdXJuZWRhB3VuaTFFRkMHdW5pMUVGRQd1bmlBNzIyB3VuaUE3MjQHdW5pQTcyNgd1bmlBNzI4B3VuaUE3MkEHdW5pQTcyQwd1bmlBNzJFB3VuaUE3MzIHdW5pQTczNAd1bmlBNzM2B3VuaUE3MzgHdW5pQTczQQd1bmlBNzNDB3VuaUE3M0UHdW5pQTc0MAd1bmlBNzQyB3VuaUE3NDQHdW5pQTc0Ngd1bmlBNzQ4B3VuaUE3NEEHdW5pQTc0Qwd1bmlBNzRFB3VuaUE3NTAHdW5pQTc1Mgd1bmlBNzU0B3VuaUE3NTYHdW5pQTc1OAd1bmlBNzVBB3VuaUE3NUMHdW5pQTc1RQd1bmlBNzYwB3VuaUE3NjQHdW5pQTc2Ngd1bmlBNzY4B3VuaUE3NkEHdW5pQTc2Qwd1bmlBNzZFB3VuaUE3NzkHdW5pQTc3Qgd1bmlBNzdEB3VuaUE3N0UHdW5pQTc4MAd1bmlBNzgyB3VuaUE3ODQHdW5pQTc4Ngd1bmlBNzhEB3VuaUE3OTAHdW5pQTc5Mgd1bmlBN0EwB3VuaUE3QTIHdW5pQTdBNAd1bmlBN0E2B3VuaUE3QTgHdW5pQTdBQQd1bmlBN0FCB3VuaUE3QUMHdW5pQTdBRAd1bmlBN0IwB3VuaUE3QjEHdW5pQTdCMgd1bmlBN0IzB3VuaUE3QjQHdW5pQTdCNg9Bb2dvbmVrLmxvY2xOQVYPRW9nb25lay5sb2NsTkFWD0lvZ29uZWsubG9jbE5BVg9Vb2dvbmVrLmxvY2xOQVYUTGNvbW1hYWNjZW50LmxvY2xNQUgUTmNvbW1hYWNjZW50LmxvY2xNQUgHVHVybmVkZRBhZmlpMTAxMDNkb3RsZXNzEGFmaWkxMDEwNWRvdGxlc3MKZGVsdGFsYXRpbgd1bmkyQzc4B3VuaTAyNUMHdW5pMDI1RAd1bmkwMUREB3VuaTAyNUEOaW9nb25la2RvdGxlc3MHdW5pMDIzNwd1bmkxRUZCB3VuaTFFOUMHdW5pMUU5RAd1bmkyQzdBCnN1YnNjcmlwdGoHdW5pMkM3OQ51bmkwMjQ5ZG90bGVzcw51bmkwMjlEZG90bGVzcw51bmkwMkIyZG90bGVzcw51bmkwM0YzZG90bGVzcw51bmkxRDYyZG90bGVzcw51bmkxRDk2ZG90bGVzcw51bmkxREE0ZG90bGVzcw51bmkxREE4ZG90bGVzcw51bmkxRTJEZG90bGVzcw51bmkxRUNCZG90bGVzcwd1bmlBNzIzB3VuaUE3MjUHdW5pQTcyNwd1bmlBNzI5B3VuaUE3MkIHdW5pQTcyRAd1bmlBNzJGB3VuaUE3MzAHdW5pQTczMQd1bmlBNzMzB3VuaUE3MzUHdW5pQTczNwd1bmlBNzM5B3VuaUE3M0IHdW5pQTczRAd1bmlBNzNGB3VuaUE3NDEHdW5pQTc0Mwd1bmlBNzQ1B3VuaUE3NDcHdW5pQTc0OQd1bmlBNzRCB3VuaUE3NEQHdW5pQTc0Rgd1bmlBNzUxB3VuaUE3NTMHdW5pQTc1NQd1bmlBNzU3B3VuaUE3NTkHdW5pQTc1Qgd1bmlBNzVEB3VuaUE3NUYHdW5pQTc2MQd1bmlBNzY1B3VuaUE3NjcHdW5pQTc2OQd1bmlBNzZCB3VuaUE3NkQHdW5pQTc2Rgd1bmlBNzcxB3VuaUE3NzIHdW5pQTc3Mwd1bmlBNzc0B3VuaUE3NzUHdW5pQTc3Ngd1bmlBNzc3B3VuaUE3NzgHdW5pQTc3QQd1bmlBNzdDB3VuaUE3N0YHdW5pQTc4MQd1bmlBNzgzB3VuaUE3ODUHdW5pQTc4Nwd1bmlBNzhFB3VuaUE3OTEHdW5pQTc5Mwd1bmlBN0ExB3VuaUE3QTMHdW5pQTdBNQd1bmlBN0E3B3VuaUE3QTkHdW5pQTdCNQd1bmlBN0I3B3VuaUE3RkEHdW5pMUVGRAd1bmkxRUZGD2FvZ29uZWsubG9jbE5BVg9lb2dvbmVrLmxvY2xOQVYUbGNvbW1hYWNjZW50LmxvY2xNQUgUbmNvbW1hYWNjZW50LmxvY2xNQUgPaW9nb25lay5sb2NsTkFWD3VvZ29uZWsubG9jbE5BVgNmX2YFZl9mX2kFZl9mX2wDZl9pA2ZfbAdsb25nc190A3NfdARhLnNjCWFhY3V0ZS5zYwlhYnJldmUuc2MOYWNpcmN1bWZsZXguc2MMYWRpZXJlc2lzLnNjCWFncmF2ZS5zYwphbWFjcm9uLnNjCmFvZ29uZWsuc2MIYXJpbmcuc2MNYXJpbmdhY3V0ZS5zYwlhdGlsZGUuc2MFYWUuc2MKYWVhY3V0ZS5zYwRiLnNjBGMuc2MJY2FjdXRlLnNjCWNjYXJvbi5zYwtjY2VkaWxsYS5zYw5jY2lyY3VtZmxleC5zYwdjZG90LnNjBGQuc2MGZXRoLnNjCWRjYXJvbi5zYwlkY3JvYXQuc2MEZS5zYwllYWN1dGUuc2MJZWJyZXZlLnNjCWVjYXJvbi5zYw5lY2lyY3VtZmxleC5zYwxlZGllcmVzaXMuc2MNZWRvdGFjY2VudC5zYwllZ3JhdmUuc2MKZW1hY3Jvbi5zYwplb2dvbmVrLnNjBGYuc2MEZy5zYwlnYnJldmUuc2MOZ2NpcmN1bWZsZXguc2MPZ2NvbW1hYWNjZW50LnNjB2dkb3Quc2MEaC5zYwdoYmFyLnNjDmhjaXJjdW1mbGV4LnNjBGkuc2MJaWFjdXRlLnNjCWlicmV2ZS5zYw5pY2lyY3VtZmxleC5zYwxpZGllcmVzaXMuc2MNaWRvdGFjY2VudC5zYwlpZ3JhdmUuc2MFaWouc2MKaW1hY3Jvbi5zYwppb2dvbmVrLnNjCWl0aWxkZS5zYwRqLnNjDmpjaXJjdW1mbGV4LnNjBGsuc2MPa2NvbW1hYWNjZW50LnNjBGwuc2MJbGFjdXRlLnNjCWxjYXJvbi5zYw9sY29tbWFhY2NlbnQuc2MHbGRvdC5zYwlsc2xhc2guc2MEbS5zYwRuLnNjCW5hY3V0ZS5zYwluY2Fyb24uc2MPbmNvbW1hYWNjZW50LnNjBmVuZy5zYwludGlsZGUuc2MEby5zYwlvYWN1dGUuc2MJb2JyZXZlLnNjDm9jaXJjdW1mbGV4LnNjDG9kaWVyZXNpcy5zYwlvZ3JhdmUuc2MQb2h1bmdhcnVtbGF1dC5zYwpvbWFjcm9uLnNjCW9zbGFzaC5zYw5vc2xhc2hhY3V0ZS5zYwlvdGlsZGUuc2MFb2Uuc2MEcC5zYwh0aG9ybi5zYwRxLnNjBHIuc2MJcmFjdXRlLnNjCXJjYXJvbi5zYw9yY29tbWFhY2NlbnQuc2MEcy5zYwlzYWN1dGUuc2MJc2Nhcm9uLnNjC3NjZWRpbGxhLnNjDnNjaXJjdW1mbGV4LnNjD3Njb21tYWFjY2VudC5zYw1nZXJtYW5kYmxzLnNjBHQuc2MHdGJhci5zYwl0Y2Fyb24uc2MLdGNlZGlsbGEuc2MPdGNvbW1hYWNjZW50LnNjBHUuc2MJdWFjdXRlLnNjCXVicmV2ZS5zYw51Y2lyY3VtZmxleC5zYwx1ZGllcmVzaXMuc2MJdWdyYXZlLnNjEHVodW5nYXJ1bWxhdXQuc2MKdW1hY3Jvbi5zYwp1b2dvbmVrLnNjCHVyaW5nLnNjCXV0aWxkZS5zYwR2LnNjBHcuc2MJd2FjdXRlLnNjDndjaXJjdW1mbGV4LnNjDHdkaWVyZXNpcy5zYwl3Z3JhdmUuc2MEeC5zYwR5LnNjCXlhY3V0ZS5zYw55Y2lyY3VtZmxleC5zYwx5ZGllcmVzaXMuc2MJeWdyYXZlLnNjBHouc2MJemFjdXRlLnNjCXpjYXJvbi5zYw16ZG90YWNjZW50LnNjB3VuaTIwNzEHdW5pQTc4Rgd1bmlBN0Y3B3VuaUE3RkIHdW5pQTdGQwd1bmlBN0ZEB3VuaUE3RkUHdW5pQTdGRgd1bmkwNTI4B3VuaTA1MkEHdW5pMDUyQwd1bmkwNTJFB3VuaUE2NDAHdW5pQTY0Mgd1bmlBNjQ0B3VuaUE2NDYHdW5pQTY0OAd1bmlBNjRBB3VuaUE2NEMHdW5pQTY0RQd1bmlBNjUwB3VuaUE2NTIHdW5pQTY1NAd1bmlBNjU2B3VuaUE2NTgHdW5pQTY1QQd1bmlBNjVDB3VuaUE2NUUHdW5pQTY2MAd1bmlBNjYyB3VuaUE2NjQHdW5pQTY2Ngd1bmlBNjY4B3VuaUE2NkEHdW5pQTY2Qwd1bmlBNjgwB3VuaUE2ODIHdW5pQTY4NAd1bmlBNjg2B3VuaUE2ODgHdW5pQTY4QQd1bmlBNjhDB3VuaUE2OEUHdW5pQTY5MAd1bmlBNjkyB3VuaUE2OTQHdW5pQTY5Ngd1bmlBNjk4B3VuaUE2OUEHdW5pMDUyOQd1bmkwNTJCB3VuaTA1MkQHdW5pMDUyRgd1bmkxQzgwB3VuaTFDODEHdW5pMUM4Mgd1bmkxQzgzB3VuaTFDODQHdW5pMUM4NQd1bmkxQzg2B3VuaTFDODcHdW5pMUM4OAd1bmlBNjQxB3VuaUE2NDMHdW5pQTY0NQd1bmlBNjQ3B3VuaUE2NDkHdW5pQTY0Qgd1bmlBNjREB3VuaUE2NEYHdW5pQTY1MQd1bmlBNjUzB3VuaUE2NTUHdW5pQTY1Nwd1bmlBNjU5B3VuaUE2NUIHdW5pQTY1RAd1bmlBNjVGB3VuaUE2NjEHdW5pQTY2Mwd1bmlBNjY1B3VuaUE2NjcHdW5pQTY2OQd1bmlBNjZCB3VuaUE2NkQHdW5pQTY4MQd1bmlBNjgzB3VuaUE2ODUHdW5pQTY4Nwd1bmlBNjg5B3VuaUE2OEIHdW5pQTY4RAd1bmlBNjhGB3VuaUE2OTEHdW5pQTY5Mwd1bmlBNjk1B3VuaUE2OTcHdW5pQTY5OQd1bmlBNjlCEWFmaWkxMDA2Ni5sb2NsU1JCB3VuaUE2NkUHdW5pQTY3Rgd1bmlBNjlDB3VuaUE2OUQHdW5pMDM3MAd1bmkwMzcyB3VuaTAzNzYHdW5pMDNDRgd1bmkwMzdGB3VuaTAzNzEHdW5pMDM3Mwd1bmkwMzc3C3VuaTAzRDAuYWx0CENmcmFrdHVyCEhmcmFrdHVyCElmcmFrdHVyCFJmcmFrdHVyCFpmcmFrdHVyB3VuaUE3NjIHdW5pQTc2Mwd1bmkyMTJDB3VuaTIxMEIHdW5pMjExMAd1bmkyMTEyDlBpRG91YmxlU3RydWNrB3VuaTIxMUIHVHVybmVkRgd1bmkyMTJCDUNEb3VibGVTdHJ1Y2sNSERvdWJsZVN0cnVjaw1ORG91YmxlU3RydWNrDVBEb3VibGVTdHJ1Y2sNUURvdWJsZVN0cnVjaw1SRG91YmxlU3RydWNrDVpEb3VibGVTdHJ1Y2sTSXRhbGljRERvdWJsZVN0cnVjaxFHYW1tYURvdWJsZVN0cnVjawd1bmkyMTA3B3VuaTIxMkEHdW5pMjEzMAd1bmkyMTMxB3VuaTIxMzMHdW5pQTc5Ngd1bmlBNzk4B3VuaUE3OUEHdW5pQTc5Qwd1bmlBNzlFE0l0YWxpY2REb3VibGVTdHJ1Y2sTSXRhbGljZURvdWJsZVN0cnVjaxNJdGFsaWNpRG91YmxlU3RydWNrE0l0YWxpY2pEb3VibGVTdHJ1Y2sRZ2FtbWFEb3VibGVTdHJ1Y2sOcGlEb3VibGVTdHJ1Y2sHdW5pMjEwRQd1bmkyMTBGB3NjcmlwdGUHc2NyaXB0bwdzY3JpcHRnB3VuaUE3OTQHdW5pQTc5NQd1bmlBNzk3B3VuaUE3OTkHdW5pQTc5Qgd1bmlBNzlEB3VuaUE3OUYHdW5pQUIzMAd1bmlBQjMxB3VuaUFCMzIHdW5pQUIzMwd1bmlBQjM0B3VuaUFCMzUHdW5pQUIzNgd1bmlBQjM3B3VuaUFCMzgHdW5pQUIzOQd1bmlBQjNBB3VuaUFCM0IHdW5pQUIzQwd1bmlBQjNEB3VuaUFCM0UHdW5pQUIzRgd1bmlBQjQwB3VuaUFCNDEHdW5pQUI0Mgd1bmlBQjQzB3VuaUFCNDQHdW5pQUI0NQd1bmlBQjQ2B3VuaUFCNDcHdW5pQUI0OAd1bmlBQjQ5B3VuaUFCNEEHdW5pQUI0Qgd1bmlBQjRDB3VuaUFCNEQHdW5pQUI0RQd1bmlBQjRGB3VuaUFCNTAHdW5pQUI1MQd1bmlBQjUyB3VuaUFCNTMHdW5pQUI1NAd1bmlBQjU1B3VuaUFCNTYHdW5pQUI1Nwd1bmlBQjU4B3VuaUFCNTkHdW5pQUI1QQd1bmlBQjY0B3VuaTIwOTUHdW5pMjA5Ngd1bmkyMDk3B3VuaTIwOTgHdW5pMjA5OQd1bmkyMDlBB3VuaTIwOUIHdW5pMjA5Qwd1bmlBNzcwB3VuaUE3RjgHdW5pQTdGOQd1bmlBQjVDB3VuaUFCNUQHdW5pQUI1RQd1bmlBQjVGB3VuaTJFMkYHemVyby5sZgZvbmUubGYGdHdvLmxmCHRocmVlLmxmB2ZvdXIubGYHZml2ZS5sZgZzaXgubGYIc2V2ZW4ubGYIZWlnaHQubGYHbmluZS5sZgh6ZXJvLm9zZgdvbmUub3NmB3R3by5vc2YJdGhyZWUub3NmCGZvdXIub3NmCGZpdmUub3NmB3NpeC5vc2YJc2V2ZW4ub3NmCWVpZ2h0Lm9zZghuaW5lLm9zZgp6ZXJvLnNsYXNoCXplcm8udG9zZghvbmUudG9zZgh0d28udG9zZgp0aHJlZS50b3NmCWZvdXIudG9zZglmaXZlLnRvc2YIc2l4LnRvc2YKc2V2ZW4udG9zZgplaWdodC50b3NmCW5pbmUudG9zZgl6ZXJvLmRub20Ib25lLmRub20IdHdvLmRub20KdGhyZWUuZG5vbQlmb3VyLmRub20JZml2ZS5kbm9tCHNpeC5kbm9tCnNldmVuLmRub20KZWlnaHQuZG5vbQluaW5lLmRub20JemVyby5udW1yCG9uZS5udW1yCHR3by5udW1yCnRocmVlLm51bXIJZm91ci5udW1yCWZpdmUubnVtcghzaXgubnVtcgpzZXZlbi5udW1yCmVpZ2h0Lm51bXIJbmluZS5udW1yB3VuaTIxNUYHdW5pMjE4OQd1bmkyMTU1B3VuaTIxNTYHdW5pMjE1Nwd1bmkyMTU4B3VuaTIxNTkHdW5pMjE1QQd1bmkyMTUwB3VuaTIxNTEHdW5pMjE1Mgd1bmkyMDgwB3VuaTIwODEHdW5pMjA4Mgd1bmkyMDgzB3VuaTIwODQHdW5pMjA4NQd1bmkyMDg2B3VuaTIwODcHdW5pMjA4OAd1bmkyMDg5B3VuaTIwNDIHdW5pMjA0Qwd1bmkyMDREB3VuaTIwNDUHdW5pMjA0NgVjYXJldAd1bmkyMDQxB3VuaTIwNDAHdW5pMjA1MAd1bmkyRTM2B3VuaTJFMzcHdW5pMjA1Qwd1bmkyRTEzB3VuaTJFMTYHdW5pMkUwOA9kb3dud2FyZHNhbmNvcmEHdW5pMkUwRQd1bmkyMDQ5B3VuaTJFMkQHdW5pMjA1OQd1bmkyMDU1B3VuaTJFMTAHdW5pMjA1Qgd1bmkyMDU4B3VuaTIwMjcHdW5pMjA0Mwd1bmkyRTEyB3VuaTJFMTgHdW5pMjA1NAd1bmkyRTA0B3VuaTJFMUMHdW5pMkUwQwd1bmkyRTAyB3VuaTJFMDkHdW5pMkUyMAd1bmkyMDRFDm9uZWRvdGVubGVhZGVyHG9uZWRvdG92ZXJ0d29kb3RzcHVuY3R1YXRpb24HdW5pMkUxOQd1bmkyRTBGB3VuaTIwNDcHdW5pMjA0OAd1bmkyRTM0B3VuaTJFMzMHdW5pMkUwNwd1bmkyRTA2B3VuaTJFMEIHdW5pMjAzQgd1bmkyRTExEXJldmVyc2VkcGFyYWdyYXBoFHJldmVyc2VkcXVlc3Rpb25tYXJrB3VuaTIwNEYHdW5pMkUwMQd1bmkyRTAwB3VuaTJFMDUHdW5pMkUxRAd1bmkyRTBEB3VuaTJFMDMHdW5pMkUwQQd1bmkyRTIxB3VuaTJFMzAZc3F1YXJlZGZvdXJkb3RwdW5jdHVhdGlvbgd1bmkyMDUzB3VuaTIwNTYHdW5pMkUxRQd1bmkyRTFGB3VuaTJFMUIHdW5pMjA0QQd1bmkyRTM5B3VuaTIwNUQHdW5pMkUzMgd1bmkyRTM4B3VuaTJFMzUHdW5pMjA1MQ50d29kb3RlbmxlYWRlcgd1bmkyMDVBHHR3b2RvdHNvdmVyb25lZG90cHVuY3R1YXRpb24HdW5pMjAzRgd1bmkyMDIzB3VuaTJFM0MHdW5pMkUzRAd1bmkyRTNFB3VuaTJFM0YHdW5pMkU0MQd1bmlBNjczDXVwd2FyZHNhbmNvcmEHdW5pMkUzMQd1bmkyMDhEB3VuaTIwOEUTYnJhY2toYWxmYm90dG9tbGVmdBRicmFja2hhbGZib3R0b21yaWdodBBicmFja2hhbGZ0b3BsZWZ0EWJyYWNraGFsZnRvcHJpZ2h0FWxlZnRkb3VibGVwYXJlbnRoZXNpcxZyaWdodGRvdWJsZXBhcmVudGhlc2lzB3VuaTJFMjYHdW5pMkUyNwd1bmkyMDdEB3VuaTIwN0UHdW5pMkUxQQd1bmkyMDEwB3VuaTIwMTEHdW5pMkUzQgd1bmkyRTNBB3VuaTJFNDAHdW5pMjAzNgd1bmkyMDM1B3VuaTIwNTcHdW5pMjAzNwd1bmkyRTQyDGJyYWNlbGVmdC5zYw1icmFjZXJpZ2h0LnNjDmJyYWNrZXRsZWZ0LnNjD2JyYWNrZXRyaWdodC5zYwlleGNsYW0uc2MMZXhjbGFtZGJsLnNjDWV4Y2xhbWRvd24uc2MQZ3VpbHNpbmdsbGVmdC5zYxFndWlsc2luZ2xyaWdodC5zYwxwYXJlbmxlZnQuc2MNcGFyZW5yaWdodC5zYwtxdWVzdGlvbi5zYw9xdWVzdGlvbmRvd24uc2MHdW5pQTkyRQd1bmlBNjdFB3VuaTIwNUYHdW5pMjAyOAd1bmkyMDI5B3VuaTIwNjEHdW5pMjA2NAd1bmkyMDYzB3VuaTIwNjIHdW5pMjA2Ngd1bmkyMDY3B3VuaTIwNjgHdW5pMjA2OQd1bmkyMDYwB3VuaTIwQjYHdW5pMjBCQwd1bmkyMEJEB3VuaTIwQUEHdW5pMjBCNwd1bmkyMEI4B3VuaTIwQkIHdW5pMjBCRQd1bmkyMTI3B3VuaTIxMzUHdW5pMjE0Qgd1bmkyMTM2B3VuaTIwNTIHdW5pMjEzOAd1bmkyMDhDB3VuaTIwN0MHdW5pMjEzNwd1bmkyMDhCB3VuaTIwN0IHdW5pMjAzMQd1bmkyMDhBB3VuaTIwN0EScmV2ZXJzZWRTYW5zU2VyaWZMFXN1bW1hdGlvbkRvdWJsZVN0cnVjaxB0dXJuZWRTYW5zU2VyaWZHEHR1cm5lZFNhbnNTZXJpZkwQdHVybmVkU2Fuc1NlcmlmWQhSb3RhdGVkUQd1bmkyMTAwB3VuaTIxMDEHdW5pMjEwNgd1bmkyMTAzB3VuaTIxMDQHdW5pMjEzQgd1bmkyMTA5B3VuaTIxMzkHdW5pMjAzRAd1bmkyMTE0B3VuaTIxMjUHdW5pMjE0QwxwcmVzY3JpcHRpb24HdW5pMjE0QQd1bmkyMTFGB3VuaTIxMDgHdW5pMjEyMBhzeW1ib2xmb3JzYW1hcml0YW5zb3VyY2UHdW5pMjEyMQd1bmkyMTIzC3dlaWVyc3RyYXNzB3VuaTAyREUXdW5pMDJFNV91bmkwMkU1X3VuaTAyRTkXdW5pMDJFNV91bmkwMkU1X3VuaTAyRTYXdW5pMDJFNV91bmkwMkU1X3VuaTAyRTgXdW5pMDJFNV91bmkwMkU1X3VuaTAyRTcPdW5pMDJFNV91bmkwMkU5F3VuaTAyRTVfdW5pMDJFOV91bmkwMkU1F3VuaTAyRTVfdW5pMDJFOV91bmkwMkU5F3VuaTAyRTVfdW5pMDJFOV91bmkwMkU2F3VuaTAyRTVfdW5pMDJFOV91bmkwMkU4F3VuaTAyRTVfdW5pMDJFOV91bmkwMkU3D3VuaTAyRTVfdW5pMDJFNhd1bmkwMkU1X3VuaTAyRTZfdW5pMDJFNRd1bmkwMkU1X3VuaTAyRTZfdW5pMDJFORd1bmkwMkU1X3VuaTAyRTZfdW5pMDJFNhd1bmkwMkU1X3VuaTAyRTZfdW5pMDJFOBd1bmkwMkU1X3VuaTAyRTZfdW5pMDJFNw91bmkwMkU1X3VuaTAyRTgXdW5pMDJFNV91bmkwMkU4X3VuaTAyRTUXdW5pMDJFNV91bmkwMkU4X3VuaTAyRTkXdW5pMDJFNV91bmkwMkU4X3VuaTAyRTYXdW5pMDJFNV91bmkwMkU4X3VuaTAyRTgXdW5pMDJFNV91bmkwMkU4X3VuaTAyRTcPdW5pMDJFNV91bmkwMkU3F3VuaTAyRTVfdW5pMDJFN191bmkwMkU1F3VuaTAyRTVfdW5pMDJFN191bmkwMkU5F3VuaTAyRTVfdW5pMDJFN191bmkwMkU2F3VuaTAyRTVfdW5pMDJFN191bmkwMkU4F3VuaTAyRTVfdW5pMDJFN191bmkwMkU3D3VuaTAyRTlfdW5pMDJFNRd1bmkwMkU5X3VuaTAyRTVfdW5pMDJFNRd1bmkwMkU5X3VuaTAyRTVfdW5pMDJFORd1bmkwMkU5X3VuaTAyRTVfdW5pMDJFNhd1bmkwMkU5X3VuaTAyRTVfdW5pMDJFOBd1bmkwMkU5X3VuaTAyRTVfdW5pMDJFNxd1bmkwMkU5X3VuaTAyRTlfdW5pMDJFNRd1bmkwMkU5X3VuaTAyRTlfdW5pMDJFNhd1bmkwMkU5X3VuaTAyRTlfdW5pMDJFOBd1bmkwMkU5X3VuaTAyRTlfdW5pMDJFNw91bmkwMkU5X3VuaTAyRTYXdW5pMDJFOV91bmkwMkU2X3VuaTAyRTUXdW5pMDJFOV91bmkwMkU2X3VuaTAyRTkXdW5pMDJFOV91bmkwMkU2X3VuaTAyRTYXdW5pMDJFOV91bmkwMkU2X3VuaTAyRTgXdW5pMDJFOV91bmkwMkU2X3VuaTAyRTcPdW5pMDJFOV91bmkwMkU4F3VuaTAyRTlfdW5pMDJFOF91bmkwMkU1F3VuaTAyRTlfdW5pMDJFOF91bmkwMkU5F3VuaTAyRTlfdW5pMDJFOF91bmkwMkU2F3VuaTAyRTlfdW5pMDJFOF91bmkwMkU4F3VuaTAyRTlfdW5pMDJFOF91bmkwMkU3D3VuaTAyRTlfdW5pMDJFNxd1bmkwMkU5X3VuaTAyRTdfdW5pMDJFNRd1bmkwMkU5X3VuaTAyRTdfdW5pMDJFORd1bmkwMkU5X3VuaTAyRTdfdW5pMDJFNhd1bmkwMkU5X3VuaTAyRTdfdW5pMDJFOBd1bmkwMkU5X3VuaTAyRTdfdW5pMDJFNw91bmkwMkU2X3VuaTAyRTUXdW5pMDJFNl91bmkwMkU1X3VuaTAyRTUXdW5pMDJFNl91bmkwMkU1X3VuaTAyRTkXdW5pMDJFNl91bmkwMkU1X3VuaTAyRTYXdW5pMDJFNl91bmkwMkU1X3VuaTAyRTgXdW5pMDJFNl91bmkwMkU1X3VuaTAyRTcPdW5pMDJFNl91bmkwMkU5F3VuaTAyRTZfdW5pMDJFOV91bmkwMkU1F3VuaTAyRTZfdW5pMDJFOV91bmkwMkU5F3VuaTAyRTZfdW5pMDJFOV91bmkwMkU2F3VuaTAyRTZfdW5pMDJFOV91bmkwMkU4F3VuaTAyRTZfdW5pMDJFOV91bmkwMkU3F3VuaTAyRTZfdW5pMDJFNl91bmkwMkU1F3VuaTAyRTZfdW5pMDJFNl91bmkwMkU5F3VuaTAyRTZfdW5pMDJFNl91bmkwMkU4F3VuaTAyRTZfdW5pMDJFNl91bmkwMkU3D3VuaTAyRTZfdW5pMDJFOBd1bmkwMkU2X3VuaTAyRThfdW5pMDJFNRd1bmkwMkU2X3VuaTAyRThfdW5pMDJFORd1bmkwMkU2X3VuaTAyRThfdW5pMDJFNhd1bmkwMkU2X3VuaTAyRThfdW5pMDJFOBd1bmkwMkU2X3VuaTAyRThfdW5pMDJFNw91bmkwMkU2X3VuaTAyRTcXdW5pMDJFNl91bmkwMkU3X3VuaTAyRTUXdW5pMDJFNl91bmkwMkU3X3VuaTAyRTkXdW5pMDJFNl91bmkwMkU3X3VuaTAyRTYXdW5pMDJFNl91bmkwMkU3X3VuaTAyRTgXdW5pMDJFNl91bmkwMkU3X3VuaTAyRTcPdW5pMDJFOF91bmkwMkU1F3VuaTAyRThfdW5pMDJFNV91bmkwMkU1F3VuaTAyRThfdW5pMDJFNV91bmkwMkU5F3VuaTAyRThfdW5pMDJFNV91bmkwMkU2F3VuaTAyRThfdW5pMDJFNV91bmkwMkU4F3VuaTAyRThfdW5pMDJFNV91bmkwMkU3D3VuaTAyRThfdW5pMDJFORd1bmkwMkU4X3VuaTAyRTlfdW5pMDJFNRd1bmkwMkU4X3VuaTAyRTlfdW5pMDJFORd1bmkwMkU4X3VuaTAyRTlfdW5pMDJFNhd1bmkwMkU4X3VuaTAyRTlfdW5pMDJFOBd1bmkwMkU4X3VuaTAyRTlfdW5pMDJFNw91bmkwMkU4X3VuaTAyRTYXdW5pMDJFOF91bmkwMkU2X3VuaTAyRTUXdW5pMDJFOF91bmkwMkU2X3VuaTAyRTkXdW5pMDJFOF91bmkwMkU2X3VuaTAyRTYXdW5pMDJFOF91bmkwMkU2X3VuaTAyRTgXdW5pMDJFOF91bmkwMkU2X3VuaTAyRTcXdW5pMDJFOF91bmkwMkU4X3VuaTAyRTUXdW5pMDJFOF91bmkwMkU4X3VuaTAyRTkXdW5pMDJFOF91bmkwMkU4X3VuaTAyRTYXdW5pMDJFOF91bmkwMkU4X3VuaTAyRTcPdW5pMDJFOF91bmkwMkU3F3VuaTAyRThfdW5pMDJFN191bmkwMkU1F3VuaTAyRThfdW5pMDJFN191bmkwMkU5F3VuaTAyRThfdW5pMDJFN191bmkwMkU2F3VuaTAyRThfdW5pMDJFN191bmkwMkU4F3VuaTAyRThfdW5pMDJFN191bmkwMkU3D3VuaTAyRTdfdW5pMDJFNRd1bmkwMkU3X3VuaTAyRTVfdW5pMDJFNRd1bmkwMkU3X3VuaTAyRTVfdW5pMDJFORd1bmkwMkU3X3VuaTAyRTVfdW5pMDJFNhd1bmkwMkU3X3VuaTAyRTVfdW5pMDJFOBd1bmkwMkU3X3VuaTAyRTVfdW5pMDJFNw91bmkwMkU3X3VuaTAyRTkXdW5pMDJFN191bmkwMkU5X3VuaTAyRTUXdW5pMDJFN191bmkwMkU5X3VuaTAyRTkXdW5pMDJFN191bmkwMkU5X3VuaTAyRTYXdW5pMDJFN191bmkwMkU5X3VuaTAyRTgXdW5pMDJFN191bmkwMkU5X3VuaTAyRTcPdW5pMDJFN191bmkwMkU2F3VuaTAyRTdfdW5pMDJFNl91bmkwMkU1F3VuaTAyRTdfdW5pMDJFNl91bmkwMkU5F3VuaTAyRTdfdW5pMDJFNl91bmkwMkU2F3VuaTAyRTdfdW5pMDJFNl91bmkwMkU4F3VuaTAyRTdfdW5pMDJFNl91bmkwMkU3D3VuaTAyRTdfdW5pMDJFOBd1bmkwMkU3X3VuaTAyRThfdW5pMDJFNRd1bmkwMkU3X3VuaTAyRThfdW5pMDJFORd1bmkwMkU3X3VuaTAyRThfdW5pMDJFNhd1bmkwMkU3X3VuaTAyRThfdW5pMDJFOBd1bmkwMkU3X3VuaTAyRThfdW5pMDJFNxd1bmkwMkU3X3VuaTAyRTdfdW5pMDJFNRd1bmkwMkU3X3VuaTAyRTdfdW5pMDJFORd1bmkwMkU3X3VuaTAyRTdfdW5pMDJFNhd1bmkwMkU3X3VuaTAyRTdfdW5pMDJFOAd1bmlBQjVCDGFtcGVyc2FuZC5zYwd1bmkyMTI5B3VuaTAzMDgHdW5pMDMwNwlncmF2ZWNvbWIJYWN1dGVjb21iB3VuaTAzMEIHdW5pMDMwMgd1bmkwMzBDB3VuaTAzMDYHdW5pMDMwQQl0aWxkZWNvbWIHdW5pMDMwNAtvdmVybGluZWNtYgd1bmkwMzBEB3VuaTAzMEUHdW5pMDMwRgd1bmkwMzEwB3VuaTAzMTEHdW5pMDMxMgd1bmkwMzEzB3VuaTAzMTQHdW5pMDMxNQd1bmkwMzE2B3VuaTAzMTcHdW5pMDMxOAd1bmkwMzE5B3VuaTAzMUEHdW5pMDMxQgd1bmkwMzFDB3VuaTAzMUQHdW5pMDMxRQd1bmkwMzFGB3VuaTAzMjAYaG9va3BhbGF0YWxpemVkYmVsb3djb21iFmhvb2tyZXRyb2ZsZXhiZWxvd2NvbWIMZG90YmVsb3djb21iB3VuaTAzMjQHdW5pMDMyNQd1bmkwMzI3B3VuaTAzMjgHdW5pMDMyOQd1bmkwMzJBB3VuaTAzMkIHdW5pMDMyQwd1bmkwMzJEB3VuaTAzMkUHdW5pMDMyRgd1bmkwMzMwB3VuaTAzMzEHdW5pMDMzMgd1bmkwMzMzB3VuaTAzMzQWc3Ryb2tlc2hvcnRvdmVybGF5Y29tYhVzdHJva2Vsb25nb3ZlcmxheWNvbWIVc2xhc2hzaG9ydG92ZXJsYXljb21iFHNsYXNobG9uZ292ZXJsYXljb21iB3VuaTAzMzkHdW5pMDMzQQd1bmkwMzNCB3VuaTAzM0MHdW5pMDMzRAd1bmkwMzNFB3VuaTAzM0YHdW5pMDM0MAd1bmkwMzQxB3VuaTAzNDYHdW5pMDM0Nwd1bmkwMzQ4B3VuaTAzNDkHdW5pMDM0QQd1bmkwMzRCB3VuaTAzNEMHdW5pMDM0RAd1bmkwMzRFB3VuaTAzNEYHdW5pMDM1MAd1bmkwMzUxB3VuaTAzNTIHdW5pMDM1Mwd1bmkwMzU0B3VuaTAzNTUHdW5pMDM1Ngd1bmkwMzU3B3VuaTAzNTgHdW5pMDM1OQd1bmkwMzVBB3VuaTAzNUIHdW5pMDM1Qwd1bmkwMzVEB3VuaTAzNUUHdW5pMDM1Rgd1bmkwMzYwB3VuaTAzNjEHdW5pMDM2Mg9hY3V0ZWdyYXZlYWN1dGULYWN1dGVtYWNyb24HdW5pMURGRQd1bmkxREZGC2JyZXZlbWFjcm9uGWNvbWJpbmluZ2NvbmpvaW5pbmdtYWNyb24XY29tYmluaW5nbWFjcm9ubGVmdGhhbGYYY29tYmluaW5nbWFjcm9ucmlnaHRoYWxmC2RvdHRlZGFjdXRlC2RvdHRlZGdyYXZlFWRvdWJsZWNpcmN1bWZsZXhhYm92ZQ9ncmF2ZWFjdXRlZ3JhdmULZ3JhdmVtYWNyb24HdW5pMUREMAd1bmkxREM0C21hY3JvbmJyZXZlB3VuaTFEQzYLb2dvbmVrYWJvdmUKc25ha2ViZWxvdw5zdXNwZW5zaW9ubWFyawd1bmkxQUIwB3VuaTFBQjEHdW5pMUFCMgd1bmkxQUIzB3VuaTFBQjQHdW5pMUFCNQd1bmkxQUI2B3VuaTFBQjcHdW5pMUFCOAd1bmkxQUI5B3VuaTFBQkEHdW5pMUFCQgd1bmkxQUJDB3VuaTFBQkQHdW5pMURFNwd1bmkxREU4B3VuaTFERTkHdW5pMURFQQd1bmkxREVCB3VuaTFERUMHdW5pMURFRAd1bmkxREVFB3VuaTFERUYHdW5pMURGMAd1bmkxREYxB3VuaTFERjIHdW5pMURGMwd1bmkxREY0B3VuaTFERjUHdW5pMURGQgd1bmkxREZDB3VuaTFERkQHdW5pMkRFMAd1bmkyREUxB3VuaTJERTIHdW5pMkRFMwd1bmkyREU0B3VuaTJERTUHdW5pMkRFNgd1bmkyREU3B3VuaTJERTgHdW5pMkRFOQd1bmkyREVBB3VuaTJERUIHdW5pMkRFQwd1bmkyREVEB3VuaTJERUUHdW5pMkRFRgd1bmkyREYwB3VuaTJERjEHdW5pMkRGMgd1bmkyREYzB3VuaTJERjQHdW5pMkRGNQd1bmkyREY2B3VuaTJERjcHdW5pMkRGOAd1bmkyREY5B3VuaTJERkEHdW5pMkRGQgd1bmkyREZDB3VuaTJERkQHdW5pMkRGRQd1bmkyREZGB3VuaUZFMDAHdW5pRkUyNwd1bmlGRTI4B3VuaUZFMjkHdW5pRkUyQQd1bmlGRTJCB3VuaUZFMkMHdW5pRkUyRAd1cmFib3ZlB3VzYWJvdmULemlnemFnYmVsb3cHdW5pMUFCRQ9kaWVyZXNpc2NvbWIuc2MQZG90YWNjZW50Y29tYi5zYwxncmF2ZWNvbWIuc2MMYWN1dGVjb21iLnNjE2h1bmdhcnVtbGF1dGNvbWIuc2MRY2lyY3VtZmxleGNvbWIuc2MMY2Fyb25jb21iLnNjDGJyZXZlY29tYi5zYwtyaW5nY29tYi5zYwx0aWxkZWNvbWIuc2MNbWFjcm9uY29tYi5zYw1vZ29uZWtjb21iLnNjDG92ZXJzY29yZS5zYwd1bmkwMzQyB3VuaTAzNDMHdW5pMDM0NAd1bmkwMzQ1B3VuaTA0ODMHdW5pMDQ4NAd1bmkwNDg1B3VuaTA0ODYHdW5pMDQ4Nwd1bmlBNjZGB3VuaUE2NzQHdW5pQTY3NQd1bmlBNjc2B3VuaUE2NzcHdW5pQTY3OAd1bmlBNjc5B3VuaUE2N0EHdW5pQTY3Qgd1bmlBNjdDB3VuaUE2N0QHdW5pQTY5RQd1bmlBNjlGB3VuaUZFMkUHdW5pRkUyRgd1bmlBNjcwB3VuaUE2NzEHdW5pQTY3Mgd1bmkxRERCB3VuaTFEREUHdW5pMURERgd1bmkxREUxB3VuaTFERTIHdW5pMDM2Mwd1bmkxREQ0B3VuaTFERDUHdW5pMURENgd1bmkxREQ3B3VuaTAzNjgHdW5pMDM2OQd1bmkwMzY0B3VuaTFERDkTZmxhdHRlbmVkb3BlbmFhYm92ZQd1bmkxRERBB3VuaTAzNkEHdW5pMDM2NQd1bmkxREQ4B3VuaTFEREMHdW5pMURERAd1bmkxREU1B3VuaTAzNkIHdW5pMURFMAd1bmkwMzY2B3VuaTFEQ0EHdW5pMDM2Qwd1bmkxREUzB3VuaTFERTQHdW5pMDM2RAd1bmkwMzY3B3VuaTAzNkUHdW5pMDM2Rgd1bmkxREU2B3VuaTJDN0QMY29tbWFhY2NlbnQyB3VuaTJDNzAHdW5pMkM3RQd1bmkyQzdGB3VuaUFCNjUHdW5pQTdBRQd1bmlBQjYwB3VuaUFCNjEHdW5pQUI2Mgd1bmlBQjYzGXN1bW1hdGlvbkRvdWJsZVN0cnVjay5taXIHdW5pMjBCRgd1bmkyRTQzB3VuaTJFNDQHdW5pQTcwMAd1bmlBNzAxB3VuaUE3MDIHdW5pQTcwMwd1bmlBNzA0B3VuaUE3MDUHdW5pQTcwNgd1bmlBNzA3B3VuaUE3MDgHdW5pQTcwOQd1bmlBNzBBB3VuaUE3MEIHdW5pQTcwQwd1bmlBNzBEB3VuaUE3MEUHdW5pQTcwRgd1bmlBNzEwB3VuaUE3MTEHdW5pQTcxMgd1bmlBNzEzB3VuaUE3MTQHdW5pQTcxNQd1bmlBNzE2AAAAAAEAAf//AA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABtAG0AVwBXAsoAAAIbAAD/EAQt/tsC1P/2AiX/9v8QBC3+2wBtAG0AVwBXAsr/9gL4Ahv/9v8QBC3+2wLV//YC/QIl//b/EAQt/tsAbQBtAFcAVwI/AAAELf7bAkj/+AQt/tsAbQBt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QCstsIksswkEAgNFWCEbIyFZQiuwCGWwAyRQeLEFARVFWDBZLQAAAABLuADIUlixAQGOWbABuQgACABjcLEAB0JAC7WhjQBvXwBDLwkAKrEAB0JAFKgIlAiACHYDZgZWBkoENggkBwkIKrEAB0JAFLIGngaKBnsBbgReBFACQAYtBQkIKrEAEEJBCypAJUAgQB3AGcAVwBLADcAJQAAJAAkqsQAZQkELAEAAQABAAEAAQABAAEAAQABAAAkACSqxAwBEsSQBiFFYsECIWLEDZESxKAGIUVi4CACIWLEDAERZG7EnAYhRWLoIgAABBECIY1RYsQMARFlZWVlZQBSqCJYIggh4A2gGWAZMBDgIJgcJDCq4Af+FsASNsQIARLMFZAYAREQAAAAKdHRmYXV0b2hpbnQgdmVyc2lvbiA9IDEuNwoKYWRqdXN0LXN1YmdseXBocyA9IDAKZGVmYXVsdC1zY3JpcHQgPSBsYXRuCmR3LWNsZWFydHlwZS1zdHJvbmctc3RlbS13aWR0aCA9IDAKZmFsbGJhY2stc2NhbGluZyA9IDAKZmFsbGJhY2stc2NyaXB0ID0gbm9uZQpmYWxsYmFjay1zdGVtLXdpZHRoID0gMApnZGktY2xlYXJ0eXBlLXN0cm9uZy1zdGVtLXdpZHRoID0gMQpncmF5LXN0cm9uZy1zdGVtLXdpZHRoID0gMApoaW50aW5nLWxpbWl0ID0gMjAwCmhpbnRpbmctcmFuZ2UtbWF4ID0gNTAKaGludGluZy1yYW5nZS1taW4gPSA4CmhpbnQtY29tcG9zaXRlcyA9IDAKaWdub3JlLXJlc3RyaWN0aW9ucyA9IDAKaW5jcmVhc2UteC1oZWlnaHQgPSAxNApyZWZlcmVuY2UgPSAKcmVmZXJlbmNlLWluZGV4ID0gMApzeW1ib2wgPSAwClRURkEtaW5mbyA9IDEKd2luZG93cy1jb21wYXRpYmlsaXR5ID0gMQp4LWhlaWdodC1zbmFwcGluZy1leGNlcHRpb25zID0gCmNvbnRyb2wtaW5zdHJ1Y3Rpb25zID0gCgoKAA=="

/***/ }),

/***/ "./node_modules/base64-loader/index.js!./node_modules/scratch-render-fonts/src/Scratch.ttf":
/*!****************************************************************************************!*\
  !*** ./node_modules/base64-loader!./node_modules/scratch-render-fonts/src/Scratch.ttf ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "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BgYCAgQDAwYBAwMEBAIEAgMFBAUFBQUFBQUFAgIDBAMEBQYFBAYGBgUGAwUHBQgGBQUFBgQGBgYIBwcFAgMCBAQDBQQEBQYDAwYDCQUEBQQEBAQGBQcGBQQAAAAMCgYABgYCAwUDBAYBAwMEBQMEAgMFBAUGBQUFBgUFAgIDBAQEBQcGBQYGBgYGAwUHBgkHBgYGBwUGBwcJCAcFAgMDBAUEBQQEBgcDBAYDCgYEBQQFBQQGBQgGBgQAAAANCwcABwcCAwUDBAcBAwMFBQMEAgQGBAUGBgYGBgYFAgIDBAQEBQcGBQcHBwYHAwYIBgkIBgYGBwUHBwcKCAgGAwMDBAUEBQQEBgcEBAcDCwYFBQQFBQQHBggHBgUAAAAOCwcABwcCAwUEBAcCBAQFBQMFAwQGBQYHBgYGBgYGAgIEBQQEBggHBQgHBwcHAwYJBwoIBwYHCAUHCAgKCQgGAwQDBQYEBgUFBwgEBAcDCwcFBgUGBQUHBgkHBwUAAAAPDAgACAgCAwYEBAgCBAQFBgMFAwQGBQYHBwcGBwcGAgIEBQUFBgkHBggICAcIBAYJBwsJBwcHCAYICAgLCgkHAwQDBQYEBgUFBwgEBQgEDAcFBgUGBgUIBwoIBwUAAAAQDQgACAgCBAYEBQgCBAQGBgMFAwQHBQcIBwcHBwcHAgMEBgUFBwkIBgkICAgIBAcKCAwJCAcICQYICQkMCgoHAwQEBQYFBwUFBwkEBQgEDQgGBwYGBgUIBwoICAYAAAARDgkACQkDBAYFBQkCBAQGBgQGAwUHBgcICAcHCAgHAwMEBgUFBwoIBgkJCQgJBAcKCAwKCAgICQYJCgkNCwoIBAQEBgcFBwYGCAkFBQkEDggGBwYHBwYJCAsJCAYAAAASDwkACQkDBAcFBQkCBQUGBwQGAwUIBgcJCAgICAgHAwMFBgUGBwoJBwoKCQkKBAgLCQ0LCQgJCgcJCgoNDAsIBAUEBgcFCAYGCAoFBQkEDwkHCAYHBwYJCAwJCAYAAAATEAoACgoDBAcFBgoCBQUHBwQGAwUIBggJCQgICQgIAwMFBwYGCAsJBwoKCgkKBQgMCQ4LCQkJCgcKCwoODAsIBAUEBggGCAYGCQoFBgoFEAkHCAcIBwYKCQwKCQcAAAAUEAoACgoDBAgFBgoCBQUHCAQHBAYJBggKCQkICQkIAwMFBwYGCAsKCAsLCgkLBQkMCg4MCgkKCwgKCwsPDQwJBAUEBwgGCAcHCQsGBgoFEAoHCAcICAcKCQ0KCQcAAAAVEQsACwsDBQgGBgsCBQUHCAQHBAYJBwkKCgkJCgkJAwMFBwYHCQwKCAsLCwoLBQkNCg8MCgoKCwgLDAwQDgwJBAUFBwgGCQcHCgsGBgsFEQoICQcICAcLCQ4LCgcAAAAWEgsACwsDBQgGBwsCBgYICAUHBAYKBwkLCgoJCgoJAwMGCAcHCQ0LCAwMDAoMBQkNCxANCwoLDAgLDAwQDg0KBQYFBwkHCQcHCgwGBwsFEgsICQgJCAcLCg4LCggAAAAXEwwADAwDBQkGBwwCBgYICQUIBAYKBwkLCgoKCwoJAwQGCAcHCQ0LCQwMDAsMBgoOCxENCwsLDQkMDQ0RDw4KBQYFCAkHCggICwwGBwwFEwsICggJCQgMCg8MCwgAAAAYFAwADAwEBQkGBwwDBgYICQUIBAcKCAoMCwoKCwsKBAQGCAcICg4MCQ0NDQsNBgoPDBEODAsMDQkMDg0SEA4LBQYFCAoHCggICw0HBwwGFAwJCggKCQgMCxAMCwgAAAAAAQAAAZAABQACArwCigAAAI8CvAKKAAABxQAyAQMAAAAABAAAAAAAAAAAAAADAAAAAAAAAAAAAAAATUFDUgBAACAAegKz/zsAAAKzAMUAAAABAAAAAAAAAAEAAIAAAAAB9AGKAABgAAKzAnVCbGFjayBib3lzIG8gICAg/////zf///5CTEFSMDAAAAAAAAAAAQAAAAEAABIO2bBfDzz1AAAD6AAAAAC0STWnAAAAALRJNaf/mf87A2oDIAAAAAMAAgABAAAAAAABAAADIP84AAADMP+Z/7gDagABAAAAAAAAAAAAAAAAAAAAWwABAAAAWwChAAMAAAAAAAIACABAAAoAAABeALsAAQABAAAAEADGAAEAAAAAAAAAMgAAAAEAAAAAAAEACwAyAAEAAAAAAAIABwA9AAEAAAAAAAMACwBEAAEAAAAAAAQACwBPAAEAAAAAAAUAIABaAAEAAAAAAAYACwB6AAEAAAAAAAcAGgCFAAMAAQQJAAAAZACfAAMAAQQJAAEAFgEDAAMAAQQJAAIADgEZAAMAAQQJAAMAFgEnAAMAAQQJAAQAFgE9AAMAAQQJAAUAQAFTAAMAAQQJAAYAFgGTAAMAAQQJAAcANAGpQnkgSmFrb2IgRmlzY2hlciBha2EgUGl6emFEdWRlICpEaXN0cmlidXRlIGZyZWVseSpTY3JhdGNoRm9udFJlZ3VsYXJTY3JhdGNoRm9udFNjcmF0Y2hGb250aHR0cDovL2hqZW0uZ2V0Mm5ldC5kay9qZmlzY2hlci9TY3JhdGNoRm9udCoqKiBObyBUcmFkZU1hcmsgRm91bmQgKioqAEIAeQAgAEoAYQBrAG8AYgAgAEYAaQBzAGMAaABlAHIAIABhAGsAYQAgAFAAaQB6AHoAYQBEAHUAZABlACAAKgBEAGkAcwB0AHIAaQBiAHUAdABlACAAZgByAGUAZQBsAHkAKgBTAGMAcgBhAHQAYwBoAEYAbwBuAHQAUgBlAGcAdQBsAGEAcgBTAGMAcgBhAHQAYwBoAEYAbwBuAHQAUwBjAHIAYQB0AGMAaABGAG8AbgB0AGgAdAB0AHAAOgAvAC8AaABqAGUAbQAuAGcAZQB0ADIAbgBlAHQALgBkAGsALwBqAGYAaQBzAGMAaABlAHIALwBTAGMAcgBhAHQAYwBoAEYAbwBuAHQAKgAqACoAIABOAG8AIABUAHIAYQBkAGUATQBhAHIAawAgAEYAbwB1AG4AZAAgACoAKgAqAAAAAABUAGgAaQBzACAARgBvAG4AdAAgAFIAZQBuAGEAbQBlAGQAAAAAAAAA/AAAAxg="

/***/ }),

/***/ "./node_modules/base64-loader/index.js!./node_modules/scratch-render-fonts/src/SourceSerifPro-Regular.otf":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/base64-loader!./node_modules/scratch-render-fonts/src/SourceSerifPro-Regular.otf ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "T1RUTwAOAIAAAwBgQkFTRYselLEAA0f4AAAAOkNGRiCkrsYlAAA1cAABsWFEU0lH3DVp8QADSDQAABx4R0RFRmHWY74AAf0wAAACtEdQT1PojzgVAAIeMAABKchHU1VCbjuk3AAB/+QAAB5MT1MvMl+WmtkAAAFQAAAAYGNtYXB2jTkgAAAMDAAAKURoZWFkEAhqGQAAAOwAAAA2aGhlYQvaDEUAAAEkAAAAJGhtdHiQIqJwAAHm1AAAFlptYXhwBZdQAAAAAUgAAAAGbmFtZdba4s8AAAGwAAAKWXBvc3T/uAAyAAA1UAAAACAAAQAAAAIAAERZq0ZfDzz1AAMD6AAAAADUkpNPAAAAANSSk0//EP6xCLsD6gAAAAMAAgAAAAAAAAABAAAEDP6xAAAI4/8Q/xoIuwABAAAAAAAAAAAAAAAAAAAFlgAAUAAFlwAAAAMCKgGQAAUAAAKKAlgAAABLAooCWAAAAV4AMgEdAAACBAYDBQQFAgIEIAAChwIAAAMAAAAAAAAAAEFEQk8AQAAg//8C2v7yAAAEDAFPIAABnwAAAAAB2wKeAAAAIAADAAAAGgE+AAEAAAAAAAAAcAAAAAEAAAAAAAEAEABwAAEAAAAAAAIABwCAAAEAAAAAAAMAJwCHAAEAAAAAAAQAEABwAAEAAAAAAAUAOQCuAAEAAAAAAAYAFgDnAAEAAAAAAAcAYAD9AAEAAAAAAAgAGgFdAAEAAAAAAAkAEQF3AAEAAAAAAAsAGQGIAAEAAAAAAA0BTgGhAAEAAAAAAA4AGgLvAAMAAQQJAAAA4AMJAAMAAQQJAAEAIAPpAAMAAQQJAAIADgQJAAMAAQQJAAMATgQXAAMAAQQJAAQAIAPpAAMAAQQJAAUAcgRlAAMAAQQJAAYALATXAAMAAQQJAAcAwAUDAAMAAQQJAAgANAXDAAMAAQQJAAkAIgX3AAMAAQQJAAsAMgYZAAMAAQQJAA0CnAZLAAMAAQQJAA4ANAjnQ29weXJpZ2h0IDIwMTQsIDIwMTUsIDIwMTYgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQgKGh0dHA6Ly93d3cuYWRvYmUuY29tLyksIHdpdGggUmVzZXJ2ZWQgRm9udCBOYW1lICdTb3VyY2UnLlNvdXJjZSBTZXJpZiBQcm9SZWd1bGFyMi4wMDA7QURCTztTb3VyY2VTZXJpZlByby1SZWd1bGFyO0FET0JFVmVyc2lvbiAyLjAwMDtQUyAxLjA7aG90Y29udiAxNi42LjUxO21ha2VvdGYubGliMi41LjY1MjIwU291cmNlU2VyaWZQcm8tUmVndWxhclNvdXJjZSBpcyBhIHRyYWRlbWFyayBvZiBBZG9iZSBTeXN0ZW1zIEluY29ycG9yYXRlZCBpbiB0aGUgVW5pdGVkIFN0YXRlcyBhbmQvb3Igb3RoZXIgY291bnRyaWVzLkFkb2JlIFN5c3RlbXMgSW5jb3Jwb3JhdGVkRnJhbmsgR3JpZadoYW1tZXJodHRwOi8vd3d3LmFkb2JlLmNvbS90eXBlVGhpcyBGb250IFNvZnR3YXJlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBTSUwgT3BlbiBGb250IExpY2Vuc2UsIFZlcnNpb24gMS4xLg0KDQpUaGlzIEZvbnQgU29mdHdhcmUgaXMgZGlzdHJpYnV0ZWQgb24gYW4gJ0FTIElTJyBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgU0lMIE9wZW4gRm9udCBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UsIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyBnb3Zlcm5pbmcgeW91ciB1c2Ugb2YgdGhpcyBGb250IFNvZnR3YXJlLmh0dHA6Ly9zY3JpcHRzLnNpbC5vcmcvT0ZMAEMAbwBwAHkAcgBpAGcAaAB0ACAAMgAwADEANAAsACAAMgAwADEANQAsACAAMgAwADEANgAgAEEAZABvAGIAZQAgAFMAeQBzAHQAZQBtAHMAIABJAG4AYwBvAHIAcABvAHIAYQB0AGUAZAAgACgAaAB0AHQAcAA6AC8ALwB3AHcAdwAuAGEAZABvAGIAZQAuAGMAbwBtAC8AKQAsACAAdwBpAHQAaAAgAFIAZQBzAGUAcgB2AGUAZAAgAEYAbwBuAHQAIABOAGEAbQBlACAAJwBTAG8AdQByAGMAZQAnAC4AUwBvAHUAcgBjAGUAIABTAGUAcgBpAGYAIABQAHIAbwBSAGUAZwB1AGwAYQByADIALgAwADAAMAA7AEEARABCAE8AOwBTAG8AdQByAGMAZQBTAGUAcgBpAGYAUAByAG8ALQBSAGUAZwB1AGwAYQByADsAQQBEAE8AQgBFAFYAZQByAHMAaQBvAG4AIAAyAC4AMAAwADAAOwBQAFMAIAAxAC4AMAA7AGgAbwB0AGMAbwBuAHYAIAAxADYALgA2AC4ANQAxADsAbQBhAGsAZQBvAHQAZgAuAGwAaQBiADIALgA1AC4ANgA1ADIAMgAwAFMAbwB1AHIAYwBlAFMAZQByAGkAZgBQAHIAbwAtAFIAZQBnAHUAbABhAHIAUwBvAHUAcgBjAGUAIABpAHMAIABhACAAdAByAGEAZABlAG0AYQByAGsAIABvAGYAIABBAGQAbwBiAGUAIABTAHkAcwB0AGUAbQBzACAASQBuAGMAbwByAHAAbwByAGEAdABlAGQAIABpAG4AIAB0AGgAZQAgAFUAbgBpAHQAZQBkACAAUwB0AGEAdABlAHMAIABhAG4AZAAvAG8AcgAgAG8AdABoAGUAcgAgAGMAbwB1AG4AdAByAGkAZQBzAC4AQQBkAG8AYgBlACAAUwB5AHMAdABlAG0AcwAgAEkAbgBjAG8AcgBwAG8AcgBhAHQAZQBkAEYAcgBhAG4AawAgAEcAcgBpAGUA3wBoAGEAbQBtAGUAcgBoAHQAdABwADoALwAvAHcAdwB3AC4AYQBkAG8AYgBlAC4AYwBvAG0ALwB0AHkAcABlAFQAaABpAHMAIABGAG8AbgB0ACAAUwBvAGYAdAB3AGEAcgBlACAAaQBzACAAbABpAGMAZQBuAHMAZQBkACAAdQBuAGQAZQByACAAdABoAGUAIABTAEkATAAgAE8AcABlAG4AIABGAG8AbgB0ACAATABpAGMAZQBuAHMAZQAsACAAVgBlAHIAcwBpAG8AbgAgADEALgAxAC4ADQAKAA0ACgBUAGgAaQBzACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAGkAcwAgAGQAaQBzAHQAcgBpAGIAdQB0AGUAZAAgAG8AbgAgAGEAbgAgACcAQQBTACAASQBTACcAIABCAEEAUwBJAFMALAAgAFcASQBUAEgATwBVAFQAIABXAEEAUgBSAEEATgBUAEkARQBTACAATwBSACAAQwBPAE4ARABJAFQASQBPAE4AUwAgAE8A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AQ4AXAEMAF0BDQBZAQkAawEbAGcBFwBoARgAaQEZAHABIABuAR4AfAEsAHYBJgB4AScAdwEtAH0BLwB+ATABMQB/ATIAgQE0AIABMwCCATUAhgE5AIkBPACNAUAAigE9AUIAlwFLAJMBRwCYAUwAqAFcAKkBXQCrAV4AqgFfAK8BYwCzAWcAsQFlALABZAC4AW0AtwFsANIBiADAAXYAxAF6AMEBdwDCAXgAwwF5ANQBigDZAY8A2ADfAZUA4QGXAOABlgFqAKEBVQDMAYIAQgDyAHkBKQCZAU0AxQF7AMkBfwDGAXwAxwF9AMgBfgBqARoAiwE+ALIBZgC5AW4CiQKRApYCmAL/Av4DDAMPAw0DEwMJAw4CiwKSApcDFAMWAxgDGgMcAx4DIAMiAzEDJAMmAygDMAMvA5wDngNlA5gDZgNnA2gDawNtA5ADXgNfA2ADYQNiA2MDZANpA2wDhwOIA4kDigORA24DbwNwA3EDcgNzA3QDdQN2A3cDeAN5A3oDewN8A30DfgOGA38DgAOBA4IDgwOEA4UDiwOOA4wDjQOPA9EEHAPSBB0D0wQeA9QEHwPVBCAD1gQhA9cEIgPYBCMD2QQkA9oEJQPbBCYD3AQnA90EKAPeBCkD3wQqA+AEKwPhA+IELAQtA+MELgPkBC8D5QQwA+YEMQPnBDID6AQzA+kENAPqBDUD6wQ2AoECgwKEAooCjAKPApMClABUAQQAVQEFAGwBHABxASEAbwEfAIMBNgCEATcAhQE4AIcBOgCIATsAjgFBAI8BQwCQAUQArAFgAK0BYQCuAWIAtAFoALUBaQC6AXAAuwFxANYBjADTAYkA1QGLANoBkADiAZgASAD4AEkA+QBDAPMARQD1AEYA9gBHAPcARAD0AD0A7QA/AO8AQADwAEEA8QA+AO4AZAEUAGUBFQBmARYAXwEPAGEBEQBiARIAYwETAGABEAB7ASsAegEqAJ8BUwCgAVQAmgFOAJwBUACdAVEAngFSAJsBTwCiAVYApAFYAKUBWQCmAVoAowFXAMoBgADLAYEAzQGDAM8BhQDQAYYA0QGHAM4BhADcAZIA2wGRAN0BkwDeAZQB9QHzAfQB9gHmAecB6gHoAekB6wIUAhUB+ARBAd0CIAKIAioCKwKNArECrwKwBDgCGQLhAuMC5QLnAuIC5ALmAugC3QLHAsoC2gLrAvkBoQGeAZ8BogGjAAwAAAAAHKgAAAAAAAACYgAAACAAAAAgAAAAAQAAACEAAAAhAAAB3gAAACIAAAAiAAAB5QAAACMAAAAjAAACHwAAACQAAAAkAAACngAAACUAAAAlAAACuwAAACYAAAAmAAABpAAAACcAAAAnAAAB5AAAACgAAAApAAAB+gAAACoAAAAqAAACEwAAACsAAAArAAACxgAAACwAAAAsAAAB2gAAAC0AAAAtAAAB8AAAAC4AAAAuAAAB2QAAAC8AAAAvAAACDwAAADAAAAA5AAABpQAAADoAAAA7AAAB2wAAADwAAAA8AAACzAAAAD0AAAA9AAACywAAAD4AAAA+AAACzQAAAD8AAAA/AAAB4QAAAEAAAABAAAACHQAAAEEAAABaAAAAAgAAAFsAAABbAAAB/AAAAFwAAABcAAACEQAAAF0AAABdAAAB/QAAAF4AAABeAAAC0QAAAF8AAABfAAAB+QAAAGAAAABgAAADBQAAAGEAAAB6AAAAHAAAAHsAAAB7AAAB/gAAAHwAAAB8AAACEAAAAH0AAAB9AAAB/wAAAH4AAAB+AAAC0wAAAKAAAACgAAACtwAAAKEAAAChAAAB3wAAAKIAAACjAAACnwAAAKQAAACkAAACnQAAAKUAAAClAAACoQAAAKYAAACmAAACEgAAAKcAAACnAAACFgAAAKgAAACoAAADCgAAAKkAAACpAAACGAAAAKoAAACqAAACZAAAAKsAAACrAAAB7gAAAKwAAACsAAAC1QAAAK0AAACtAAAB8QAAAK4AAACuAAACGgAAAK8AAACvAAADCwAAALAAAACwAAACnAAAALEAAACxAAAC0AAAALIAAACzAAACIgAAALQAAAC0AAADBgAAALUAAAC1AAAC1wAAALYAAAC2AAACFwAAALcAAAC3AAAB9wAAALgAAAC4AAADEAAAALkAAAC5AAACIQAAALoAAAC6AAACZQAAALsAAAC7AAAB7wAAALwAAAC+AAACvQAAAL8AAAC/AAAB4gAAAMAAAADEAAAANgAAAMUAAADFAAAASgAAAMYAAADHAAAATAAAAMgAAADKAAAAVgAAAMsAAADLAAAAWgAAAMwAAADPAAAAcgAAANAAAADQAAAA4wAAANEAAADRAAAAjAAAANIAAADTAAAAkQAAANQAAADWAAAAlAAAANcAAADX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AAADaQAAA6sAAAOrAAADbAAAA6wAAAOvAAADhwAAA7AAAAOwAAADkQAAA7EAAAPBAAADbgAAA8IAAAPCAAADhgAAA8MAAAPJAAADfwAAA8oAAAPKAAADiwAAA8sAAAPLAAADjgAAA8wAAAPNAAADjAAAA84AAAPOAAADjwAAA9cAAAPXAAADkgAAA9kAAAPZAAADkwAAA9sAAAPbAAADlAAAA90AAAPdAAADlQAAA+EAAAPhAAADlgAABAAAAAQPAAADwQAABBAAAAQvAAADoQAABDAAAARfAAAD7AAABGIAAARiAAAD0QAABGMAAARjAAAEHAAABHIAAARyAAAD0gAABHMAAARzAAAEHQAABHQAAAR0AAAD0wAABHUAAAR1AAAEHgAABJAAAASQAAAD1AAABJEAAASRAAAEHwAABJIAAASSAAAD1QAABJMAAASTAAAEIAAABJYAAASWAAAD1gAABJcAAASXAAAEIQAABJgAAASYAAAD1wAABJkAAASZAAAEIgAABJoAAASaAAAD2AAABJsAAASbAAAEIwAABKAAAASgAAAD2QAABKEAAAShAAAEJAAABKIAAASiAAAD2gAABKMAAASjAAAEJQAABKoAAASqAAAD2wAABKsAAASrAAAEJgAABK4AAASuAAAD3AAABK8AAASvAAAEJwAABLAAAASwAAAD3QAABLEAAASxAAAEKAAABLIAAASyAAAD3gAABLMAAASzAAAEKQAABLYAAAS2AAAD3wAABLcAAAS3AAAEKgAABLoAAAS6AAAD4AAABLsAAAS7AAAEKwAABMAAAATBAAAD4QAABMIAAATCAAAELAAABM8AAATPAAAELQAABNAAAATQAAAD4wAABNEAAATRAAAELgAABNQAAATUAAAD5AAABNUAAATVAAAELwAABNYAAATWAAAD5QAABNcAAATXAAAEMAAABNgAAATYAAAD5gAABNkAAATZAAAEMQAABOIAAATiAAAD5wAABOMAAATjAAAEMgAABOYAAATmAAAD6AAABOcAAATnAAAEMwAABOgAAAToAAAD6QAABOkAAATpAAAENAAABO4AAATuAAAD6gAABO8AAATvAAAENQAABPIAAATyAAAD6wAABPMAAATzAAAENgAAHUMAAB1DAAACgAAAHUcAAB1HAAACgQAAHUgAAB1JAAACgwAAHU0AAB1NAAAChgAAHU8AAB1PAAACigAAHVAAAB1QAAACjAAAHVIAAB1SAAACjgAAHVYAAB1WAAACjwAAHVcAAB1YAAACkwAAHVsAAB1bAAAClQAAHZwAAB2cAAACggAAHaAAAB2gAAAChQAAHbsAAB27AAACmQAAHgwAAB4MAAAAVAAAHg0AAB4NAAABBAAAHg4AAB4OAAAAVQAAHg8AAB4PAAABBQAAHiAAAB4gAAAAbAAAHiEAAB4hAAABHAAAHiQAAB4kAAAAcQAAHiUAAB4lAAABIQAAHioAAB4qAAAAbwAAHisAAB4rAAABHwAAHjYAAB42AAAAgwAAHjcAAB43AAABNgAAHjgAAB44AAAAhAAAHjkAAB45AAABNwAAHjoAAB46AAAAhQAAHjsAAB47AAABOAAAHj4AAB4+AAAAhwAAHj8AAB4/AAABOgAAHkIAAB5CAAAAiAAAHkMAAB5DAAABOwAAHkQAAB5EAAAAjgAAHkUAAB5FAAABQQAAHkYAAB5GAAAAjwAAHkcAAB5HAAABQwAAHkgAAB5IAAAAkAAAHkkAAB5JAAABRAAAHloAAB5aAAAArAAAHlsAAB5bAAABYAAAHlwAAB5cAAAArQAAHl0AAB5dAAABYQAAHl4AAB5eAAAArgAAHl8AAB5fAAABYgAAHmAAAB5gAAAAtAAAHmEAAB5hAAABaAAAHmIAAB5iAAAAtQAAHmMAAB5jAAABaQAAHmwAAB5sAAAAugAAHm0AAB5tAAABcAAAHm4AAB5uAAAAuwAAHm8AAB5vAAABcQAAHoAAAB6AAAAA1gAAHoEAAB6BAAABjAAAHoIAAB6CAAAA0wAAHoMAAB6DAAABiQAAHoQAAB6EAAAA1QAAHoUAAB6FAAABiwAAHo4AAB6OAAAA2gAAHo8AAB6PAAABkAAAHpIAAB6SAAAA4gAAHpMAAB6TAAABmAAAHpcAAB6XAAABbwAAHp4AAB6eAAAAtgAAHqAAAB6gAAAASAAAHqEAAB6hAAAA+AAAHqIAAB6iAAAASQAAHqMAAB6jAAAA+QAAHqQAAB6kAAAAQwAAHqUAAB6lAAAA8wAAHqYAAB6mAAAARQAAHqcAAB6nAAAA9QAAHqgAAB6oAAAARgAAHqkAAB6pAAAA9gAAHqoAAB6qAAAARwAAHqsAAB6rAAAA9wAAHqwAAB6sAAAARAAAHq0AAB6tAAAA9AAAHq4AAB6uAAAAPQAAHq8AAB6vAAAA7QAAHrAAAB6wAAAAPwAAHrEAAB6xAAAA7wAAHrIAAB6yAAAAQAAAHrMAAB6zAAAA8AAAHrQAAB60AAAAQQAAHrUAAB61AAAA8QAAHrYAAB62AAAAPgAAHrcAAB63AAAA7gAAHrgAAB64AAAAZAAAHrkAAB65AAABFAAAHroAAB66AAAAZQAAHrsAAB67AAABFQAAHrwAAB68AAAAZgAAHr0AAB69AAABFgAAHr4AAB6+AAAAXwAAHr8AAB6/AAABDwAAHsAAAB7AAAAAYQAAHsEAAB7BAAABEQAAHsIAAB7CAAAAYgAAHsMAAB7DAAABEgAAHsQAAB7EAAAAYwAAHsUAAB7FAAABEwAAHsYAAB7GAAAAYAAAHscAAB7HAAABEAAAHsgAAB7IAAAAewAAHskAAB7JAAABKwAAHsoAAB7KAAAAegAAHssAAB7LAAABKgAAHswAAB7MAAAAnwAAHs0AAB7NAAABUwAAHs4AAB7OAAAAoAAAHs8AAB7PAAABVAAAHtAAAB7QAAAAmgAAHtEAAB7RAAABTgAAHtIAAB7SAAAAnAAAHtMAAB7TAAABUAAAHtQAAB7UAAAAnQAAHtUAAB7VAAABUQAAHtYAAB7WAAAAngAAHtcAAB7XAAABUgAAHtgAAB7YAAAAmwAAHtkAAB7ZAAABTwAAHtoAAB7aAAAAogAAHtsAAB7bAAABVgAAHtwAAB7cAAAApAAAHt0AAB7dAAABWAAAHt4AAB7eAAAApQAAHt8AAB7fAAABWQAAHuAAAB7gAAAApgAAHuEAAB7hAAABWgAAHuIAAB7iAAAAowAAHuMAAB7jAAABVwAAHuQAAB7kAAAAygAAHuUAAB7lAAABgAAAHuYAAB7mAAAAywAAHucAAB7nAAABgQAAHugAAB7oAAAAzQAAHukAAB7pAAABgwAAHuoAAB7qAAAAzwAAHusAAB7rAAABhQAAHuwAAB7sAAAA0AAAHu0AAB7tAAABhgAAHu4AAB7uAAAA0QAAHu8AAB7vAAABhwAAHvAAAB7wAAAAzgAAHvEAAB7xAAABhAAAHvIAAB7yAAAA3AAAHvMAAB7zAAABkgAAHvQAAB70AAAA2wAAHvUAAB71AAABkQAAHvYAAB72AAAA3QAAHvcAAB73AAABkwAAHvgAAB74AAAA3gAAHvkAAB75AAABlAAAIAcAACAHAAACuAAAIBAAACAQAAAB8gAAIBIAACASAAAB9QAAIBMAACAUAAAB8wAAIBUAACAVAAAB9gAAIBgAACAZAAAB5gAAIBoAACAaAAAB6gAAIBwAACAdAAAB6AAAIB4AACAeAAAB6wAAICAAACAhAAACFAAAICIAACAiAAAB+AAAICUAACAlAAAEQQAAICYAACAmAAAB3QAAIDAAACAwAAACvAAAIDIAACAzAAAC+gAAIDkAACA6AAAB7AAAIDwAACA8AAAEQgAAIEQAACBEAAACtAAAIEcAACBJAAAEQwAAIHAAACBwAAACIAAAIHEAACBxAAACiAAAIHQAACB5AAACJAAAIH0AACB+AAACKgAAIH8AACB/AAACjQAAIIAAACCJAAACNAAAII0AACCOAAACPgAAIKEAACChAAACowAAIKQAACCkAAACpAAAIKYAACCnAAACpQAAIKkAACCpAAACpwAAIKsAACCsAAACqAAAIK4AACCuAAACqgAAILEAACCyAAACqwAAILQAACC1AAACrQAAILgAACC4AAACsQAAILkAACC6AAACrwAAIL0AACC9AAACsgAAIL8AACC/AAACswAAIRMAACETAAAC3wAAIRYAACEWAAAEOAAAIRcAACEXAAACGQAAISAAACEgAAACHAAAISIAACEiAAACGwAAISYAACEmAAAC3AAAIS4AACEuAAAC4AAAIVMAACFUAAACwAAAIVsAACFeAAACwgAAIZAAACGQAAAC4QAAIZEAACGRAAAC4wAAIZIAACGSAAAC5QAAIZMAACGTAAAC5wAAIZYAACGWAAAC4gAAIZcAACGXAAAC5AAAIZgAACGYAAAC5gAAIZkAACGZAAAC6AAAIgIAACICAAAC2AAAIgYAACIGAAAC2wAAIg8AACIPAAAC3gAAIhEAACIRAAAC3QAAIhIAACISAAACxwAAIhUAACIVAAACtQAAIhkAACIZAAACygAAIhoAACIaAAAC2gAAIh4AACIeAAAC1gAAIisAACIrAAAC2QAAIkgAACJIAAAC1AAAImAAACJgAAAC0gAAImQAACJlAAACzgAAJaAAACWgAAAC6QAAJbIAACWzAAAC7QAAJbYAACW3AAAC7wAAJbwAACW9AAAC8QAAJcAAACXBAAAC8wAAJcYAACXG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qxeyF7kXwBfHF84X1RfcF+MX6hfxF/gX/xgGGA0YFBgbGCIYKRgwGDcYPhhFGEwYUxhaGGEYaBhvGHYYfRiEGIsYkhiZGKAYpxiuGLUYvBjDGMoY0RjYGN8Y5hjtGPQY+xkCGQkZEBkXGR4ZJRksGTMZOhlBGUgZTxlWGV0ZZBlrGXIZeRmAGYcZjhmVGZwZoxmqGbEZuBm/GcYZzRnUGdsZ5hntGfkaCBoUGhsaIhooGi4aNBo9GkQaSxpSGlYaWhpeGmIaZhpqGm4achp2GnoafhqCGoYaihqOGpIalhqaGp4aohqmGqoarhqyGrYauhrDGswa2hrjGu8a+RsCGwwbFhsgGyobNBs+G0gbUhtcG2YbcBt6G4QbjBuWG5sbphuvG7gbxhvTG9wb5RvvG/kcAhwLHBkcIhwuHDgcRRxPHFgcYhxsHHYcgByKHJQcnhyoHLEcvhzIHNEc3xzpHPMdAR0IHRIdIB0qHTMdPB1KHVYdYB1tHXcdgR2LHZUdnh2sHbYdvx3IHdId2R3jHe0d9x4AHgoeFB4dHiceMB45HkMeTR5XHmEeah5zHn0eix6UHqAeqh66HsQezh7YHuIe7B72HwAfCh8SHxwfJh8wHzofRB9NH1IfWx9kH24feB+CH4wflR+eH6gfsh/AH8of1B/dH+cf8R/7IAUgDyAYICEgLyA7IEUgTSBdIGcgcCB6IIQgjiCYIKIgrCC2IL4gyCDSINwg5iDwIPkhAiEQIRwhJSEuITohSCFSIVwhZSFvIXkhgiGLIZghoiGoIbAhuiHCIckh0SHZIeMh6iHwIfgh/yIHIhAiFSIaIh8iKSIuIjQiPCJCIkwiUiJYIl4iZiJ1IocilCKaIqAirCKzIrkivyLHIs4i1SLbIuMi6yLyIvsjCCMTIyIjMCM7I0cjVCNjI3MjfCOFI44jmiOnI7UjxCPQI90j5yPxI/skBSQPJBkkIyQtJDckQSRLJFUkXyRpJHMkfSSHJJEkmySlJK8kuSTDJM0k1yThJOsk9ST/JQklEyUdJSclMSU7JUUlTyVZJWMlbSV3JYEliyWVJZ8lqSWzJb0lxyXRJdsl5SXvJfkmAyYNJhcmISYrJjUmPyZJJlMmXSZnJnEmeyaFJo8mmSajJq0mtybBJssmzicuJ20nfUFtYWNyb25BYnJldmV1bmkxRUFFdW5pMUVCNnVuaTFFQjB1bmkxRUIydW5pMUVCNHVuaTAxQ0R1bmkxRUE0dW5pMUVBQ3VuaTFFQTZ1bmkxRUE4dW5pMUVBQXVuaTFFQTB1bmkxRUEyQW9nb25la0NhY3V0ZUNjYXJvbkNjaXJjdW1mbGV4Q2RvdGFjY2VudERjYXJvbkRjcm9hdHVuaTFFMEN1bmkxRTBFRWNhcm9uRW1hY3JvbkVkb3RhY2NlbnRFb2dvbmVrRWJyZXZldW5pMUVCRXVuaTFFQzZ1bmkxRUMwdW5pMUVDMnVuaTFFQzR1bmkxRUI4dW5pMUVCQXVuaTFFQkNHYnJldmVHZG90YWNjZW50dW5pMDEyMkdjYXJvbkdjaXJjdW1mbGV4dW5pMUUyMHVuaTAwNDcwMzAzSGJhcnVuaTFFMkFIY2lyY3VtZmxleHVuaTFFMjRJbWFjcm9uSWRvdGFjY2VudElvZ29uZWt1bmkwMUNGdW5pMUVDQXVuaTFFQzhJdGlsZGVKY2lyY3VtZmxleHVuaTAxMzZMYWN1dGVMY2Fyb251bmkwMTNCTGRvdHVuaTFFMzZ1bmkxRTM4dW5pMUUzQXVuaTFFM0V1bmkxRTQyTmFjdXRlTmNhcm9udW5pMDFGOHVuaTAxNDV1bmkxRTQ0dW5pMUU0NnVuaTFFNDh1bmkwMTRFT21hY3Jvbk9odW5nYXJ1bWxhdXR1bmkwMUQxdW5pMUVEMHVuaTFFRDh1bmkxRUQydW5pMUVENHVuaTFFRDZ1bmkxRUNDdW5pMUVDRU9ob3JudW5pMUVEQXVuaTFFRTJ1bmkxRURDdW5pMUVERXVuaTFFRTBSYWN1dGVSY2Fyb251bmkwMTU2dW5pMUU1QXVuaTFFNUN1bmkxRTVFU2FjdXRldW5pMDE1RXVuaTAyMThTY2lyY3VtZmxleHVuaTFFNjB1bmkxRTYydW5pMUU5RVRjYXJvbnVuaTAxNjJ1bmkwMjFBdW5pMUU2Q3VuaTFFNkVVbWFjcm9uVXJpbmdVaHVuZ2FydW1sYXV0VW9nb25la1VicmV2ZXVuaTAxRDN1bmkwMUQ3dW5pMDFEOXVuaTAxREJ1bmkwMUQ1dW5pMUVFNHVuaTFFRTZVaG9ybnVuaTFFRTh1bmkxRUYwdW5pMUVFQXVuaTFFRUN1bmkxRUVFVXRpbGRlV2FjdXRlV2NpcmN1bWZsZXhXZGllcmVzaXNXZ3JhdmVZY2lyY3VtZmxleHVuaTFFOEV1bmkxRUY0WWdyYXZldW5pMUVGNnVuaTFFRjhaYWN1dGVaZG90YWNjZW50dW5pMUU5MnVuaTAxOEZhbWFjcm9uYWJyZXZldW5pMUVBRnVuaTFFQjd1bmkxRUIxdW5pMUVCM3VuaTFFQjV1bmkwMUNFdW5pMUVBNXVuaTFFQUR1bmkxRUE3dW5pMUVBOXVuaTFFQUJ1bmkxRUExdW5pMUVBM2FvZ29uZWtjYWN1dGVjY2Fyb25jY2lyY3VtZmxleGNkb3RhY2NlbnRkY2Fyb25kY3JvYXR1bmkxRTBEdW5pMUUwRmVjYXJvbmVtYWNyb25lZG90YWNjZW50ZW9nb25la2VicmV2ZXVuaTFFQkZ1bmkxRUM3dW5pMUVDMXVuaTFFQzN1bmkxRUM1dW5pMUVCOXVuaTFFQkJ1bmkxRUJEZ2JyZXZlZ2RvdGFjY2VudHVuaTAxMjNnY2Fyb25nY2lyY3VtZmxleHVuaTFFMjF1bmkwMDY3MDMwM2hiYXJ1bmkxRTJCaGNpcmN1bWZsZXh1bmkxRTI1aW1hY3JvbmlvZ29uZWtpLnRya3VuaTAxRDB1bmkxRUNCdW5pMUVDOWl0aWxkZXVuaTAyMzdqY2lyY3VtZmxleHVuaTAxMzdrZ3JlZW5sYW5kaWNsYWN1dGVsY2Fyb251bmkwMTNDbGRvdHVuaTFFMzd1bmkxRTM5dW5pMUUzQnVuaTFFM0Z1bmkxRTQzbmFjdXRlbmNhcm9udW5pMDFGOXVuaTAxNDZ1bmkxRTQ1bmFwb3N0cm9waGV1bmkxRTQ3dW5pMUU0OXVuaTAxNEZvbWFjcm9ub2h1bmdhcnVtbGF1dHVuaTAxRDJ1bmkxRUQxdW5pMUVEOXVuaTFFRDN1bmkxRUQ1dW5pMUVEN3VuaTFFQ0R1bmkxRUNGb2hvcm51bmkxRURCdW5pMUVFM3VuaTFFRER1bmkxRURGdW5pMUVFMXJhY3V0ZXVuaTAxNTdyY2Fyb251bmkxRTVCdW5pMUU1RHVuaTFFNUZzYWN1dGV1bmkwMTVGdW5pMDIxOXNjaXJjdW1mbGV4dW5pMUU2MXVuaTFFNjNsb25nc3RjYXJvbnVuaTAxNjN1bmkwMjFCdW5pMUU5N3VuaTFFNkR1bmkxRTZGdW1hY3JvbnVyaW5ndWh1bmdhcnVtbGF1dHVvZ29uZWt1YnJldmV1bmkwMUQ0dW5pMDFEOHVuaTAxREF1bmkwMURDdW5pMDFENnVuaTFFRTV1bmkxRUU3dWhvcm51bmkxRUU5dW5pMUVGMXVuaTFFRUJ1bmkxRUVEdW5pMUVFRnV0aWxkZXdhY3V0ZXdjaXJjdW1mbGV4d2RpZXJlc2lzd2dyYXZleWNpcmN1bWZsZXh1bmkxRThGdW5pMUVGNXlncmF2ZXVuaTFFRjd1bmkxRUY5emFjdXRlemRvdGFjY2VudHVuaTFFOTN1bmkwMjU5dW5pMDI1MXVuaTAyNjFmX2lmX2xmX3RmX2ZmX2ZfaWZfZl9semVyby5zbGFzaHplcm8ubGZvbmUubGZ0d28ubGZ0aHJlZS5sZmZvdXIubGZmaXZlLmxmc2l4Lmxmc2V2ZW4ubGZlaWdodC5sZm5pbmUubGZ6ZXJvLmxmc2xhc2h6ZXJvLnRvc2ZvbmUudG9zZnR3by50b3NmdGhyZWUudG9zZmZvdXIudG9zZmZpdmUudG9zZnNpeC50b3Nmc2V2ZW4udG9zZmVpZ2h0LnRvc2ZuaW5lLnRvc2Z6ZXJvLm9zZm9uZS5vc2Z0d28ub3NmdGhyZWUub3NmZm91ci5vc2ZmaXZlLm9zZnNpeC5vc2ZzZXZlbi5vc2ZlaWdodC5vc2ZuaW5lLm9zZnplcm8uY2Fwb25lLmNhcHR3by5jYXB0aHJlZS5jYXBmb3VyLmNhcGZpdmUuY2Fwc2l4LmNhcHNldmVuLmNhcGVpZ2h0LmNhcG5pbmUuY2FwZXhjbGFtZG93bi5jYXBxdWVzdGlvbmRvd24uY2FwdW5pMDBBRHVuaTIwMTB1bmkyMDE1Z3VpbHNpbmdsbGVmdC5jYXBndWlsc2luZ2xyaWdodC5jYXBndWlsbGVtb3RsZWZ0LmNhcGd1aWxsZW1vdHJpZ2h0LmNhcGh5cGhlbi5jYXBzZnRoeXBoZW4uY2FwZW5kYXNoLmNhcGVtZGFzaC5jYXBob3Jpem9udGFsYmFyLmNhcHBhcmVubGVmdC5jYXBwYXJlbnJpZ2h0LmNhcGJyYWNrZXRsZWZ0LmNhcGJyYWNrZXRyaWdodC5jYXBicmFjZWxlZnQuY2FwYnJhY2VyaWdodC5jYXB1bmkyMTE3dW5pMjEyMGF0LmNhcHplcm8uc3Vwc29uZS5zdXBzdHdvLnN1cHN0aHJlZS5zdXBzZm91ci5zdXBzZml2ZS5zdXBzc2l4LnN1cHNzZXZlbi5zdXBzZWlnaHQuc3Vwc25pbmUuc3Vwc3BhcmVubGVmdC5zdXBzcGFyZW5yaWdodC5zdXBzYnJhY2tldGxlZnQuc3Vwc2JyYWNrZXRyaWdodC5zdXBzcGVyaW9kLnN1cHNjb21tYS5zdXBzY29sb24uc3Vwc2h5cGhlbi5zdXBzZW5kYXNoLnN1cHNlbWRhc2guc3Vwc3plcm8uc3Vic29uZS5zdWJzdHdvLnN1YnN0aHJlZS5zdWJzZm91ci5zdWJzZml2ZS5zdWJzc2l4LnN1YnNzZXZlbi5zdWJzZWlnaHQuc3Vic25pbmUuc3Vic3BhcmVubGVmdC5zdWJzcGFyZW5yaWdodC5zdWJzYnJhY2tldGxlZnQuc3Vic2JyYWNrZXRyaWdodC5zdWJzcGVyaW9kLnN1YnNjb21tYS5zdWJzemVyby5kbm9tb25lLmRub210d28uZG5vbXRocmVlLmRub21mb3VyLmRub21maXZlLmRub21zaXguZG5vbXNldmVuLmRub21laWdodC5kbm9tbmluZS5kbm9tcGFyZW5sZWZ0LmRub21wYXJlbnJpZ2h0LmRub21icmFja2V0bGVmdC5kbm9tYnJhY2tldHJpZ2h0LmRub21wZXJpb2QuZG5vbWNvbW1hLmRub216ZXJvLm51bXJvbmUubnVtcnR3by5udW1ydGhyZWUubnVtcmZvdXIubnVtcmZpdmUubnVtcnNpeC5udW1yc2V2ZW4ubnVtcmVpZ2h0Lm51bXJuaW5lLm51bXJwYXJlbmxlZnQubnVtcnBhcmVucmlnaHQubnVtcmJyYWNrZXRsZWZ0Lm51bXJicmFja2V0cmlnaHQubnVtcnBlcmlvZC5udW1yY29tbWEubnVtckEuc3Vwc0Iuc3Vwc0Muc3Vwc0Quc3Vwc0Uuc3Vwc0Yuc3Vwc0cuc3Vwc0guc3Vwc0kuc3Vwc0ouc3Vwc0suc3Vwc0wuc3Vwc00uc3Vwc04uc3Vwc08uc3Vwc1Auc3Vwc1Euc3Vwc1Iuc3Vwc1Muc3Vwc1Quc3Vwc1Uuc3Vwc1Yuc3Vwc1cuc3Vwc1guc3Vwc1kuc3Vwc1ouc3Vwc2Euc3Vwc2Iuc3Vwc2Muc3Vwc2Quc3Vwc2Uuc3Vwc2Yuc3Vwc2cuc3Vwc2guc3Vwc2kuc3Vwc2ouc3Vwc2suc3Vwc2wuc3Vwc20uc3Vwc24uc3Vwc28uc3Vwc3Auc3Vwc3Euc3Vwc3Iuc3Vwc3Muc3Vwc3Quc3Vwc3Uuc3Vwc3Yuc3Vwc3cuc3Vwc3guc3Vwc3kuc3Vwc3ouc3Vwc2VncmF2ZS5zdXBzZWFjdXRlLnN1cHN1bmkwMTkybGlyYXVuaTIwQTZwZXNldGF1bmkyMEE5ZG9uZ0V1cm91bmkyMEFFdW5pMjBCMXVuaTIwQjJ1bmkyMEI0dW5pMjBCNXVuaTIwQjl1bmkyMEJBdW5pMjBCOHVuaTIwQkR1bmkyMEJGdW5pMjIxNXNsYXNoLmZyYWN1bmkwMEEwdW5pMjAwN3NwYWNlLmZyYWN1bmkwMEEwLmZyYWN1bmkyMjE5bGVzc2VxdWFsZ3JlYXRlcmVxdWFsbm90ZXF1YWxhcHByb3hlcXVhbGluZmluaXR5dW5pMDBCNXBhcnRpYWxkaWZmaW50ZWdyYWxyYWRpY2FsdW5pMjIwNnVuaTIxMjZzdW1tYXRpb25wcm9kdWN0dW5pMjExM2VzdGltYXRlZHVuaTIxOTB1bmkyMTk2YXJyb3d1cHVuaTIxOTd1bmkyMTkydW5pMjE5OGFycm93ZG93bnVuaTIxOTl1bmkyNUEwdW5pMjVDNnVuaTI1Qzl1bmkyNzUydHJpYWd1cHVuaTI1QjN1bmkyNUI2dW5pMjVCN3RyaWFnZG51bmkyNUJEdW5pMjVDMHVuaTI1QzF1bmkyNjEwdW5pMjYxMXVuaTI3MTNtdXNpY2Fsbm90ZWxvemVuZ2V1bmkyMDMydW5pMjAzM3VuaTAyQkJ1bmkwMkJDdW5pMDJCRnVuaTAyQkV1bmkwMkM4dW5pMDJDOXVuaTAyQ0F1bmkwMkNCdW5pMDJDQ2Nhcm9uLmFsdGNvbW1hYmVsb3djbWIuYWx0dW5pMDMwMGdyYXZlY21iLmNhcHVuaTAzMDFhY3V0ZWNtYi5jYXB1bmkwMzAyY2lyY3VtZmxleGNtYi5jYXB1bmkwMzAzdGlsZGVjbWIuY2FwdW5pMDMwNG1hY3JvbmNtYi5jYXB1bmkwMzA2YnJldmVjbWIuY2FwdW5pMDMwN2RvdGFjY2VudGNtYi5jYXB1bmkwMzA4ZGllcmVzaXNjbWIuY2FwdW5pMDMwQXJpbmdjbWIuY2FwdW5pMDMwQmh1bmdhcnVtbGF1dGNtYi5jYXB1bmkwMzBDY2Fyb25jbWIuY2FwdW5pMDMyNnVuaTAzMjd1bmkwMzI4dW5pMDMyOXVuaTAzMkV1bmkwMzI0dW5pMDMyM3VuaTAzMDl1bmkwMzA5LmNhcHVuaTAzMUJ1bmkwMzMxdW5pMDMwODAzMDF1bmkwMzA4MDMwMS5jYXB1bmkwMzA4MDMwMHVuaTAzMDgwMzAwLmNhcHVuaTAzMDgwMzA0dW5pMDMwODAzMDQuY2FwdW5pMDMwODAzMEN1bmkwMzA4MDMwQy5jYXB1bmkwMzAyMDMwMXVuaTAzMDIwMzAxLmNhcHVuaTAzMDIwMzAwdW5pMDMwMjAzMDAuY2FwdW5pMDMwMjAzMDl1bmkwMzAyMDMwOS5jYXB1bmkwMzAyMDMwM3VuaTAzMDIwMzAzLmNhcHVuaTAzMDYwMzAxdW5pMDMwNjAzMDEuY2FwdW5pMDMwNjAzMDB1bmkwMzA2MDMwMC5jYXB1bmkwMzA2MDMwOXVuaTAzMDYwMzA5LmNhcHVuaTAzMDYwMzAzdW5pMDMwNjAzMDMuY2FwQWxwaGFCZXRhR2FtbWF1bmkwMzk0RXBzaWxvblpldGFFdGFUaGV0YUlvdGFLYXBwYUxhbWJkYU11TnVYaU9taWNyb25QaVJob1NpZ21hVGF1VXBzaWxvblBoaUNoaVBzaXVuaTAzQTlBbHBoYXRvbm9zRXBzaWxvbnRvbm9zRXRhdG9ub3NJb3RhdG9ub3NJb3RhZGllcmVzaXNPbWljcm9udG9ub3NVcHNpbG9udG9ub3NVcHNpbG9uZGllcmVzaXNPbWVnYXRvbm9zYWxwaGFiZXRhZ2FtbWFkZWx0YWVwc2lsb256ZXRhZXRhdGhldGFpb3Rha2FwcGFsYW1iZGF1bmkwM0JDbnV4aW9taWNyb25waXJob3NpZ21hdGF1dXBzaWxvbnBoaWNoaXBzaW9tZWdhdW5pMDNDMmFscGhhdG9ub3NlcHNpbG9udG9ub3NldGF0b25vc2lvdGF0b25vc2lvdGFkaWVyZXNpc29taWNyb250b25vc3Vwc2lsb250b25vc3Vwc2lsb25kaWVyZXNpc29tZWdhdG9ub3Npb3RhZGllcmVzaXN0b25vc3Vwc2lsb25kaWVyZXNpc3Rvbm9zdW5pMDNEN3VuaTAzRDl1bmkwM0RCdW5pMDNERHVuaTAzRTF1bmkwMzdFYW5vdGVsZWlhYW5vdGVsZWlhLmNhcHVuaTAzNzR1bmkwMzc1dG9ub3N0b25vcy5jYXBkaWVyZXNpc3Rvbm9zdW5pMDMwMS5ndW5pMDMwODAzMDEuZ3VuaTA0MTB1bmkwNDExdW5pMDQxMnVuaTA0MTN1bmkwNDE0dW5pMDQxNXVuaTA0MTZ1bmkwNDE3dW5pMDQxOHVuaTA0MTl1bmkwNDFBdW5pMDQxQnVuaTA0MUN1bmkwNDFEdW5pMDQxRXVuaTA0MUZ1bmkwNDIwdW5pMDQyMXVuaTA0MjJ1bmkwNDIzdW5pMDQyNHVuaTA0MjV1bmkwNDI2dW5pMDQyN3VuaTA0Mjh1bmkwNDI5dW5pMDQyQXVuaTA0MkJ1bmkwNDJDdW5pMDQyRHVuaTA0MkV1bmkwNDJGdW5pMDQwMHVuaTA0MDF1bmkwNDAydW5pMDQwM3VuaTA0MDR1bmkwNDA1dW5pMDQwNnVuaTA0MDd1bmkwNDA4dW5pMDQwOXVuaTA0MEF1bmkwNDBCdW5pMDQwQ3VuaTA0MER1bmkwNDBFdW5pMDQwRnVuaTA0NjJ1bmkwNDcydW5pMDQ3NHVuaTA0OTB1bmkwNDkydW5pMDQ5NnVuaTA0OTh1bmkwNDlBdW5pMDRBMHVuaTA0QTJ1bmkwNEFBdW5pMDRBRXVuaTA0QjB1bmkwNEIydW5pMDRCNnVuaTA0QkF1bmkwNEMwdW5pMDRDMXVuaTA0RDB1bmkwNEQ0dW5pMDRENnVuaTA0RDh1bmkwNEUydW5pMDRFNnVuaTA0RTh1bmkwNEVFdW5pMDRGMnVuaTA0MzB1bmkwNDMxdW5pMDQzMnVuaTA0MzN1bmkwNDM0dW5pMDQzNXVuaTA0MzZ1bmkwNDM3dW5pMDQzOHVuaTA0Mzl1bmkwNDNBdW5pMDQzQnVuaTA0M0N1bmkwNDNEdW5pMDQzRXVuaTA0M0Z1bmkwNDQwdW5pMDQ0MXVuaTA0NDJ1bmkwNDQzdW5pMDQ0NHVuaTA0NDV1bmkwNDQ2dW5pMDQ0N3VuaTA0NDh1bmkwNDQ5dW5pMDQ0QXVuaTA0NEJ1bmkwNDRDdW5pMDQ0RHVuaTA0NEV1bmkwNDRGdW5pMDQ1MHVuaTA0NTF1bmkwNDUydW5pMDQ1M3VuaTA0NTR1bmkwNDU1dW5pMDQ1NnVuaTA0NTd1bmkwNDU4dW5pMDQ1OXVuaTA0NUF1bmkwNDVCdW5pMDQ1Q3VuaTA0NUR1bmkwNDVFdW5pMDQ1RnVuaTA0NjN1bmkwNDczdW5pMDQ3NXVuaTA0OTF1bmkwNDkzdW5pMDQ5N3VuaTA0OTl1bmkwNDlCdW5pMDRBMXVuaTA0QTN1bmkwNEFCdW5pMDRBRnVuaTA0QjF1bmkwNEIzdW5pMDRCN3VuaTA0QkJ1bmkwNEMydW5pMDRDRnVuaTA0RDF1bmkwNEQ1dW5pMDREN3VuaTA0RDl1bmkwNEUzdW5pMDRFN3VuaTA0RTl1bmkwNEVGdW5pMDRGM3VuaTA0MzEuc3JidW5pMjExNmJyZXZlY21iLmN5cmJyZXZlY21iLmN5cmNhcHR1cmtpY2RzY2NtYnVuaTJFM0F1bmkyRTNCdTFGMTJGdTFGMTZBdTFGMTZCZXhjbGFtZGJsdW5pMjA0N3VuaTIwNDh1bmkyMDQ5QS5zY0Iuc2NDLnNjRC5zY0Uuc2NGLnNjRy5zY0guc2NJLnNjSi5zY0suc2NMLnNjTS5zY04uc2NPLnNjUC5zY1Euc2NSLnNjUy5zY1Quc2NVLnNjVi5zY1cuc2NYLnNjWS5zY1ouc2NBZ3JhdmUuc2NBYWN1dGUuc2NBY2lyY3VtZmxleC5zY0F0aWxkZS5zY0FkaWVyZXNpcy5zY0FtYWNyb24uc2NBYnJldmUuc2N1bmkxRUFFLnNjdW5pMUVCNi5zY3VuaTFFQjAuc2N1bmkxRUIyLnNjdW5pMUVCNC5zY3VuaTAxQ0Quc2N1bmkxRUE0LnNjdW5pMUVBQy5zY3VuaTFFQTYuc2N1bmkxRUE4LnNjdW5pMUVBQS5zY3VuaTFFQTAuc2N1bmkxRUEyLnNjQXJpbmcuc2NBb2dvbmVrLnNjQUUuc2NDY2VkaWxsYS5zY0NhY3V0ZS5zY0NjYXJvbi5zY0NjaXJjdW1mbGV4LnNjQ2RvdGFjY2VudC5zY0RjYXJvbi5zY0Rjcm9hdC5zY3VuaTFFMEMuc2N1bmkxRTBFLnNjRWdyYXZlLnNjRWFjdXRlLnNjRWNpcmN1bWZsZXguc2NFY2Fyb24uc2NFZGllcmVzaXMuc2NFbWFjcm9uLnNjRWRvdGFjY2VudC5zY0VvZ29uZWsuc2NFYnJldmUuc2N1bmkxRUJFLnNjdW5pMUVDNi5zY3VuaTFFQzAuc2N1bmkxRUMyLnNjdW5pMUVDNC5zY3VuaTFFQjguc2N1bmkxRUJBLnNjdW5pMUVCQy5zY0dicmV2ZS5zY0dkb3RhY2NlbnQuc2N1bmkwMTIyLnNjR2Nhcm9uLnNjR2NpcmN1bWZsZXguc2N1bmkxRTlFLnNjdW5pMUUyMC5zY3VuaTAwNDcwMzAzLnNjSGJhci5zY3VuaTFFMkEuc2NIY2lyY3VtZmxleC5zY3VuaTFFMjQuc2NJZ3JhdmUuc2NJYWN1dGUuc2NJY2lyY3VtZmxleC5zY0lkaWVyZXNpcy5zY0ltYWNyb24uc2NJZG90YWNjZW50LnNjSW9nb25lay5zY3VuaTAxQ0Yuc2N1bmkxRUNBLnNjdW5pMUVDOC5zY0l0aWxkZS5zY0pjaXJjdW1mbGV4LnNjdW5pMDEzNi5zY0xhY3V0ZS5zY0xjYXJvbi5zY3VuaTAxM0Iuc2NMZG90LnNjdW5pMUUzNi5zY3VuaTFFMzguc2N1bmkxRTNBLnNjTHNsYXNoLnNjdW5pMUUzRS5zY3VuaTFFNDIuc2NOYWN1dGUuc2N1bmkwMUY4LnNjTmNhcm9uLnNjTnRpbGRlLnNjdW5pMDE0NS5zY3VuaTFFNDQuc2N1bmkxRTQ2LnNjdW5pMUU0OC5zY09ncmF2ZS5zY09hY3V0ZS5zY3VuaTAxNEUuc2NPY2lyY3VtZmxleC5zY090aWxkZS5zY09kaWVyZXNpcy5zY09tYWNyb24uc2NPaHVuZ2FydW1sYXV0LnNjdW5pMDFEMS5zY3VuaTFFRDAuc2N1bmkxRUQ4LnNjdW5pMUVEMi5zY3VuaTFFRDQuc2N1bmkxRUQ2LnNjdW5pMUVDQy5zY3VuaTFFQ0Uuc2NPaG9ybi5zY3VuaTFFREEuc2N1bmkxRUUyLnNjdW5pMUVEQy5zY3VuaTFFREUuc2N1bmkxRUUwLnNjT3NsYXNoLnNjT0Uuc2NSYWN1dGUuc2NSY2Fyb24uc2N1bmkwMTU2LnNjdW5pMUU1QS5zY3VuaTFFNUMuc2N1bmkxRTVFLnNjU2FjdXRlLnNjU2Nhcm9uLnNjdW5pMDE1RS5zY3VuaTAyMTguc2NTY2lyY3VtZmxleC5zY3VuaTFFNjAuc2N1bmkxRTYyLnNjVGNhcm9uLnNjdW5pMDE2Mi5zY3VuaTAyMUEuc2N1bmkxRTk3LnNjdW5pMUU2Qy5zY3VuaTFFNkUuc2NVZ3JhdmUuc2NVYWN1dGUuc2NVY2lyY3VtZmxleC5zY1VkaWVyZXNpcy5zY1VtYWNyb24uc2NVcmluZy5zY1VodW5nYXJ1bWxhdXQuc2NVb2dvbmVrLnNjVWJyZXZlLnNjdW5pMDFEMy5zY3VuaTAxRDcuc2N1bmkwMUQ5LnNjdW5pMDFEQi5zY3VuaTAxRDUuc2N1bmkxRUU0LnNjdW5pMUVFNi5zY1Vob3JuLnNjdW5pMUVFOC5zY3VuaTFFRjAuc2N1bmkxRUVBLnNjdW5pMUVFQy5zY3VuaTFFRUUuc2NVdGlsZGUuc2NXYWN1dGUuc2NXY2lyY3VtZmxleC5zY1dkaWVyZXNpcy5zY1dncmF2ZS5zY1lhY3V0ZS5zY1lkaWVyZXNpcy5zY1ljaXJjdW1mbGV4LnNjdW5pMUU4RS5zY3VuaTFFRjQuc2NZZ3JhdmUuc2N1bmkxRUY2LnNjdW5pMUVGOC5zY1phY3V0ZS5zY1pjYXJvbi5zY1pkb3RhY2NlbnQuc2N1bmkxRTkyLnNjRXRoLnNjVGhvcm4uc2N1bmkwMThGLnNjQWxwaGEuc2NCZXRhLnNjR2FtbWEuc2NEZWx0YS5zY0Vwc2lsb24uc2NaZXRhLnNjRXRhLnNjVGhldGEuc2NJb3RhLnNjS2FwcGEuc2NMYW1iZGEuc2NNdS5zY051LnNjWGkuc2NPbWljcm9uLnNjUGkuc2NSaG8uc2NTaWdtYS5zY1RhdS5zY1Vwc2lsb24uc2NQaGkuc2NDaGkuc2NQc2kuc2NPbWVnYS5zY0lvdGFkaWVyZXNpcy5zY1Vwc2lsb25kaWVyZXNpcy5zY2dlcm1hbmRibHMuc2NmX2kuc2NmX2wuc2NhbXBlcnNhbmQuc2N6ZXJvLnNjb25lLnNjdHdvLnNjdGhyZWUuc2Nmb3VyLnNjZml2ZS5zY3NpeC5zY3NldmVuLnNjZWlnaHQuc2NuaW5lLnNjZXhjbGFtLnNjZXhjbGFtZG93bi5zY3F1ZXN0aW9uLnNjcXVlc3Rpb25kb3duLnNjcXVvdGVzaW5nbGUuc2NxdW90ZWRibC5zY3F1b3RlbGVmdC5zY3F1b3RlcmlnaHQuc2NxdW90ZWRibGxlZnQuc2NxdW90ZWRibHJpZ2h0LnNjaHlwaGVuLnNjZW5kYXNoLnNjZW1kYXNoLnNjcGFyZW5sZWZ0LnNjcGFyZW5yaWdodC5zY2JyYWNrZXRsZWZ0LnNjYnJhY2tldHJpZ2h0LnNjYnJhY2VsZWZ0LnNjYnJhY2VyaWdodC5zY3VuaTA0MTAuc2N1bmkwNDExLnNjdW5pMDQxMi5zY3VuaTA0MTMuc2N1bmkwNDE0LnNjdW5pMDQxNS5zY3VuaTA0MTYuc2N1bmkwNDE3LnNjdW5pMDQxOC5zY3VuaTA0MTkuc2N1bmkwNDFBLnNjdW5pMDQxQi5zY3VuaTA0MUMuc2N1bmkwNDFELnNjdW5pMDQxRS5zY3VuaTA0MUYuc2N1bmkwNDIwLnNjdW5pMDQyMS5zY3VuaTA0MjIuc2N1bmkwNDIzLnNjdW5pMDQyNC5zY3VuaTA0MjUuc2N1bmkwNDI2LnNjdW5pMDQyNy5zY3VuaTA0Mjguc2N1bmkwNDI5LnNjdW5pMDQyQS5zY3VuaTA0MkIuc2N1bmkwNDJDLnNjdW5pMDQyRC5zY3VuaTA0MkUuc2N1bmkwNDJGLnNjdW5pMDQwMC5zY3VuaTA0MDEuc2N1bmkwNDAyLnNjdW5pMDQwMy5zY3VuaTA0MDQuc2N1bmkwNDA1LnNjdW5pMDQwNi5zY3VuaTA0MDcuc2N1bmkwNDA4LnNjdW5pMDQwOS5zY3VuaTA0MEEuc2N1bmkwNDBCLnNjdW5pMDQwQy5zY3VuaTA0MEQuc2N1bmkwNDBFLnNjdW5pMDQwRi5zY3VuaTA0NjIuc2N1bmkwNDcyLnNjdW5pMDQ3NC5zY3VuaTA0OTAuc2N1bmkwNDkyLnNjdW5pMDQ5Ni5zY3VuaTA0OTguc2N1bmkwNDlBLnNjdW5pMDRBMC5zY3VuaTA0QTIuc2N1bmkwNEFBLnNjdW5pMDRBRS5zY3VuaTA0QjAuc2N1bmkwNEIyLnNjdW5pMDRCNi5zY3VuaTA0QkEuc2N1bmkwNEMwLnNjdW5pMDRDMS5zY3VuaTA0RDAuc2N1bmkwNEQ0LnNjdW5pMDRENi5zY3VuaTA0RDguc2N1bmkwNEUyLnNjdW5pMDRFNi5zY3VuaTA0RTguc2N1bmkwNEVFLnNjdW5pMDRGMi5z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pnqYC3MabFN1JYEeDgEAAQAAIhkAQhkArgAAqwEAsAAArQABhw4ArwABlgAAigAAsQABlwcAtQAAsgEBnwAAtAABoBYAuQAAtgIBtw8AjAABxwQAugABzAMAvgAAuwAB0AAAvAAAvwAAvQAB0Q8AjQEB4QYAwAAB6AoAxAAAwQIB8xYAxQECCgYAxwACEQEAmgAAnQACEwAAywAAyAEAzQAAygACFA4AzAACIwAAkAAAzgACJAcA0gAAzwECLAAA0QACLRYA1gAA0wICRAYAkQACSwoAkgACVgQA1wACWwQA2wAA2AACYAAA2QAA3AAA2gACYQ8AkwECcQYA3QACeAUAlQACfgUA4QAA3gIChBYA4gECmwYA5AACogEApwAAogACpAgABwAAEQkCrSkADwAADQAAGwEAeQAAAgAAYAAC1wAAIAAAewAC2AAAaAAAAwAAQQAACAAAaQAAdwAAdQEAawEAagAAeAAADgAC2QEAbwAAiQABOgAC2wAAcgAAdAAAQAAACQEAPAAAPgAAXAAAXgAC3A4AEAAAXQAAPQAAoAAACwAAcAEAZgAAcwAAqgAC6wAApQAAmQAC7AAAIQAC7QAABAAC7kMAiwAAjwADMjUAoQAAZwAABQAAYQEAZAADaAABLAADaQ8AYwADeQUABgAAegAAngAAmwAAowABRAEBQAMADAAApgAAqAAAnwADfwAAHgAAHQAAHwADgAEAnAAAPwADggAAXwADgwAAlwADhC4AfAIAiAAAfwAAgwAAgAEAhAAAhgAAggAAhQADswEAhwADtf8EtSwA7QAE4v8F4lQFlwMAAAEAAE0AAFAAAFgAAFoAAGQAAJgAAJsAAP4AARMAAUUAAVEAAVQAAaQAAcQAAdEAAdQAAecAAekAAmgAAoQAApAAArQAArcAAwYAAwkAA20AA3AAA3MAA4oAA/0ABAYABDMABD4ABHgABK8ABLIABLQABN0ABPwABRUABTAABUcABVQABYMABfcABhMABiIABkQABkcABoMABokABosABpYABpoABqcABrUABsIABwgABzcAB1MAB2oAB6oAB+AACCQACE4ACJQACKsACLgACO0ACPsACRkACVQACYMACaEACdkAChUACmwACuIACvEACwQACxMACykAC3EAC3MAC7MAC/EAC/oADAMADAwADFoADLIADL4ADRQADY4ADZsADaMADbEADboADh4ADkQADkwADqMADs4ADusADw8ADy4AD0wAD2cAD4MAD6kAEGAAELIAEOoAESsAET0AEWwAEX0AEZkAEasAEcYAEfIAEgYAEiEAEjoAElkAEmIAErgAEt0AEyQAE0oAE4MAE68AE/QAFB4AFHMAFIYAFKAAFKkAFOcAFPAAFTgAFXYAFbwAFgEAFkUAFlwAFnMAFo4AFqYAFswAFuwAFwUAFxsAFzcAF08AF3UAF40AF68AF+sAGAsAGCkAGFcAGIkAGMYAGPgAGTMAGXMAGgEAGssAGuwAGw8AGzEAG1sAG4wAG7gAG8kAG90AHGQAHHUAHIYAHJwAHLIAHUYAHXQAHckAHfMAHiIAHk8AHlgAHmEAHmoAHnIAHqkAHvAAHvcAH3gAH7AAH+4AH/YAIEoAIFIAIJ8AIOcAIUoAIU0AIVYAIa4AIbcAIjQAIpQAItoAIuIAIuoAI2QAI2wAI3UAI7YAI78AI/YAJDEAJDoAJG8AJLEAJLoAJOwAJR8AJVEAJVMAJcUAJjIAJk0AJmkAJp4AJsgAJvcAJx8AJ0MAJ2UAJ5kAJ7sAJ/EAKDcAKFkAKHUAKLkAKNUAKPcAKTIAKVYAKXsAKa0AKk8AKlcAKroAKscAKtkAKukAKvwAKzsAK9sAK/QALA4ALB0ALCwALEEALFgALHoALJcALLEALRAALSkALTgALV4ALW4ALYMALbIALc4ALeUALhEALlQALqMALusAL04AL4wAL9sAMEgAMH4AMLsAMMMAMPgAMRMAMS0AMUsAMV8AMXYAMcoAMcwAMeoAMhIAMiwAMkoAMmAAMoIAMqwAMtIAMy0AM0oAM3UAM5gAM70AM+EANBMANDsANIoANKgANNAANOoANQwANSYANVEANW8ANZIANcQANeYANggANhkANioANkIANlcANncANpMANq0ANr4ANtQANuYANwcANxkANzIAN2IAN3oAN40AN5AAN5cAN9YAN90AOBUAOFkAOOkAOXIAOZMAObkAOd4AOgYAOjsAOmMAOnYAOo0AOwgAOxsAOzIAO00AO2kAO7sAPGUAPKsAPQoAPTgAPW8APaEAPdAAPdcAPd8APgcAPkAAPncAPrMAPrsAPxYAP0MAP24AP8YAQAwAQGUAQKwAQN4AQTIAQTUAQT0AQZQAQZsAQe0AQlYAQpoAQqUAQrIAQx8AQykAQzkAQ4gAQ84ARBUARGsARHsARIoARNwAROQARRUARUcARYIARgEARnsARn0ARtMARz4AR5wAR+UASFgASLgASTUASaMASnoASrkASt8ASu4ASwAASxgASyAASzQAS0UAS1MAS2UAS9cATBgATDUATEQATE0ATGUATG0ATIEATJMATKEATKoATR0ATWMATZkATagATbsATdQATd4ATfIATgUAThMATiYATnAATp0ATqwATrYATs8ATtkATu0ATwEATw8ATxkAT1sAT4EAT9UAUE8AUIQAUOgAUU8AUXAAUe0AUkYAUlAAUmAAUnQAUpEAUrQAUs4AUvsAUyoAU04AU3EAU5YAU6YAU7cAU8EAU9AAU+IAU+4AU/sAVAUAVBUAVCUAVDsAVFAAVFMAVFYAVFkAVGkAVGwAVHwAVH8AVIsAVK0AVL8AVM8AVOAAVPYAVQ4AVSEAVTUAVUUAVVUAVWsAVYAAVYMAVYYAVZoAVZ0AVaAAVbEAVcMAVdkAVfEAVgQAVhgAVikAVjEAVkYAVlgAVuEAVzUAV8cAWIkAWM8AWVEAWdYAWooAWyQAW+kAW/MAW/0AXFEAXF0AXGwAXIIAXJIAXKIAXK0AXLgAXMQAXM8AXNoAXOUAXPAAXPwAXQgAXRYAXSEAXUYAXVsAXXAAXYQAXY8AXZ4AXbQAXcMAXdMAXd4AXekAXfUAXgAAXgoAXhQAXh4AXioAXjYAXkQAXk8AXloAXmgAXnwAXosAXrAAXrkAXsIAXs8AXtgAXuQAXu8AXvoAXwQAXw4AXxoAXyQAXzAAX0sAX2EAX3AAX4MAX44AX5kAX6UAX7AAX7sAX8YAX9EAX90AX+kAX/cAYAIAYAQAYAcAYGkAYOAAYUcAYYwAYhEAYnYAYvUAYzcAY1gAY6oAZAoAZEcAZMUAZSAAZVEAZaYAZf8AZn8AZusAZyoAZ4AAZ8MAaCoAaMQAaSgAaXwAaX4Aae0AakQAar8AasgAazUAa/kAbGcAbKAAbPkAbTkAbUwAbdoAbjkAbjwAbpwAbvcAb0QAb7cAcA8AcIAAcMMAcSsAcbcAchsAcm4AcpEAcrMAcuwAc5sAdEkAdMQAdRQAdaQAdj4AdwcAd3UAeCwAeKwAeTsAedsAenUAeu4Ae68AfEYAfNkAfVQAfdgAflAAfrcAf0EAf+8Af/IAf/UAf/gAf/sAf/0AgAAAgAMAgFcAgLYAgQUAgUYAgaAAgdYAghgAgmcAgrkAg2MAg7sAg90Ag+0AhCAAhDoAhEYAhFQAhHcAhJsAhMUAhO4AhRwAhT0AhXAAhXwAhZEAhakAhiEAhiMAhpQAhycAh08Ah1gAh20Ah7QAh/cAiG0AiPIAiSQAiV8AiZEAicsAifwAijQAimUAip4AirIAis8AiyUAi1MAi1oAi2wAi3cAi40Ai6IAi8cAi9MAi+oAi/4AjEYAjHUAjM0AjQAAjRAAjSkAjTMAjUIAjWYAjYcAjZ4AjaEAjbEAjcAAjc4Ajd0Aje0Ajf4Ajg0AjiUAjjgAjjsAjkwAjl4Ajm4AjoAAjpgAjq0AjrsAjtkAjuYAjvYAjwIAjxEAjyEAjzEAj0kAj2EAj3AAj3oAj4YAj5MAj6EAj68Aj8AAj8oAj9gAj+oAj/oAkAoAkBkAkCoAkDcAkEsAkGcAkHMAkH4AkI8AkJwAkKkAkL0AkNcAkOYAkRkAkSMAkVcAkWEAkYAAkZgAkbYAkdUAkeUAkfYAkgYAkhcAkigAkmEAkoEAkq0AkrkAku4AkvwAkzUAk0sAk1wAk4QAk6YAk8EAk8MAk8YAk8wAk88Ak9IAk+QAlGMAlG8AlL4AlRAAlRIAlVMAlf4AlhEAlmUAlmcAlq4AlrAAlrkAl38Al4EAmB4AmDMAmFIAmKAAmLcAmMoAmOYAmQMAmRsAmVkAmXYAmXkAmgkAmmQAmuAAmuMAmz8Am0IAm6cAm7gAnDoAnJYAnJgAnOwAnXkAnX0Ane8AnloAnroAnvQAnxIAn6cAoCIAoLQAoLcAoRkAoSAAoSgAoTAAoUUAoWgAoXAAoZMAocMAocsAoe0Aok4AovcAo0wAo7AApAcApF4ApHsApIcApJMApKQApM0ApN8ApPAApQUApRMApSYApUEApbgApboApb0ApksApk4ApoMAprAAprMApugApusApyoApywApz4Ap1EAp6EAp6MAp60Ap68Ap7IAqHIAqHQAqMUAqQQAqUAAqYMAqgIAqpgAqu0Aq1sAq/AArGYArG8ArMcArVMArVwArdYAreIAre4ArgoArg0ArpAArzwAr9MAr9wAr+UAsCEAsIEAsUMAsUUAsaYAseQAsjYAspUAstkAs2EAtAoAtIIAtPYAtP8AtVwAtfcAtlAAtrcAtsMAtw4AtzoAt5QAt/4AuHUAuKIAuMIAuMQAuPsAuQIAuRkAuZUAugQAugcAuosAupYAurkAuuUAuvYAuxYAu2MAu6AAvAUAvEEAvE4AvI0AvLUAvL4AvRYAvSEAvd0Avd8AvgkAvksAvnYAvqAAvxcAv3wAv8MAwDUAwKUAwSAAwS8AwVEAwecAwe8AwlEAwmAAwnoAwpUAwrYAwxsAw5AAw74AxBAAxCYAxHIAxKgAxUgAxUoAxaMAxd0Axj8AxqcAxvQAx1oAx9MAyCoAyJIAyMwAyRIAyYkAyekAyg8Ayj4Ayk8Ayn4AyowAyq0Ayq8Ays0AyukAyusAyzUAy0QAy8QAzIcAzJcAzKgAzMMAzNcAzOwAzYYAzkgAzuwAzvUAzxsAz2AAz5IAz8IAz8oAz8wAz9UAz/EAz/QA0CoA0D8A0EIA0EUA0EgA0EoA0FYA0FkA0FwA0HIA0HQA0O0A0PAA0QEA0QMA0QYA0UcA0UoA0UwA0U8A0VIA0V8A0W0A0XoA0boA0egA0gAA0hEA0ksA0oMA0sEA0u4A0zkA02MA03AA06IA07AA08sA1AsA1DoA1FMA1IsA1NEA1NMA1TYA1UQA1VYA1WQA1XgA1aUA1acA1c4A1fQA1f0A1gUA1g4A1kkA1poA1qUA1vIA10kA11UA110A12wA13UA18MA2BkA2CQA2G4A2MkA2OYA2QoA2SkA2UcA2WIA2fIA2g4A2jQA2scA2zYA2z8A26MA26wA27QA27wA2+YA3AQA3C0A3G0A3I4A3LYA3NwA3RMA3RwA3Y8A3aAA3dsA3fAA3iwA3mcA3rMA3uwA30oA31MA380A39YA398A4AAA4CcA4EEA4GQA4IQA4KIA4LwA4NYA4PQA4Q8A4TQA4VcA4XMA4YwA4asA4cYA4e0A4ggA4ikA4mQA4oUA4qUA4swA4vcA4y8A41oA45EA48oA5EgA5QsA5RMA5UMA5XYA5akA5eEA5hcA5i0A5kYA5sUA5t4A5vQA5xIA5y8A510A57MA598A6BsA6EsA6HoA6IMA6IsA6JQA6LsA6McA6PYA6P0A6YYA6ZMA6bcA6eQA6hkA6kAA6m4A6pAA6rkA6rwA6sQA6wIA6wsA61AA65gA68IA68oA69IA7EsA7FMA7FsA7F0A7GYA7L0A7RMA7RwA7XIA7dMA7dwA7hQA7k0A7oUA7ocA7vMA71wA72QA72YA72kA75AA75MA75YA75kA8AsA8A4A8BAA8FwA8F8A8GIA8NQA8OoA8UEA8UMA8ZQA8ZYA8ZkA8loA8lwA8vkA830A86cA86kA88UA9BEA9H0A9VMA9ZUA9dEA9iYA9p8A9s4A9y8A95IA97QA+C0A+IUA+M4A+RkA+ZEA+gsA+hwA+i4A+joA+koA+l4A+msA+oAA+pUA+qoA+uIA+xsA+1cA+5IA+/gA/F8A/GcA/OEA/OMA/OYA/W0A/XAA/acA/dgA/dsA/hcA/hoA/mgA/msA/m4A/oQA/tcA/tkA/uIA/uQA/ucA/6wA/64BAAMBAFwBAIMBAMMBAT4BAcYBAhgBAogBAxUBA5oBA6MBA/QBBHYBBH8BBPcBBQgBBQsBBTUBBTgBBbcBBloBBt4BBucBBvABByUBB5ABCFMBCFUBCKQBCOMBCTsBCYkBCcsBCnIBCxwBC4YBC/IBC/UBDF8BDPwBDXsBDdQBDdcBDiABDlABDlIBDqUBDx4BD0sBD24BD3ABD5YBD52vi734zb0B28f3/McD2xb4dPkx/HQG94T7shX7KPeABfe8Bqv8nxX7KfeD9yn3ggX7/PxxFfhxB/cq+4IF+wr7sRX3KPeA9yj7gAUO/AcOQh34KPdzhgpQHab3Ogr4HwpCCg71i/cxHffV9wETXPce99YVE5wqizP3FAoTXGL3qAfgChNsLQrqZhWwBxNc5NMdE2z4HQoOIQoOcoslCv8BD4AA9yMK9y/HXbmh/wBLgAAT1QBvCvewtAculgWJ3Yvg7hoT1gD3LwYT1QCZIwW594pdBhPWAH0sBfsvvgoT1YD3fwYT5YCh+xMFxAYT1YCE90UF/IYGE80ALQoOwgr39QoT3Pjw4xUTvPdMChPcMAoO9033OR0S9x7q99fpE3b3PAoTtvgeHd2L3/Ea99cGE3alChNu26AK5pUFE3a0+64tCg77ffejHfce6gMqCg6LHQ7Ki7ld9B33Hub3UPd6E2jjCrQHLJYFicmLyMEa7vcLBROo9zP7vTmBBRNoYveVBxOc9+0KE2y0+3oHE1z3zx0TaOKL4Y3gHuqWBbT7ri0KDoOLlwr3eeATXPd/HROc90wdE1z4MgoTPPeZChNccgoO9773ox33Fb/4foYdDoMdDvcHHfgfCvge9wID9zAgCrwKHw5oCvL7bMP3KLpeuPjrvfe9Cvcm6fcu9wITvviI+2wVtLuVoa0fgK8FgmtxiHcbE944V8DqiB/3H6D3EfcS91wavAr7L/ss+xb7bx4Tvvtf9wv7C/ccdB77ANIp9xMe++z4uxX3Ksb3Kfcf9x/E+yn7KvsrUvsp+x/7H1D3KfcrHg66gZsdEvce6vd/7hNufQoTrlwKE3YtChNutQoOL/c6CgHA3/eOKh0Oi4vjHfcv6fcv1xQcE7xvHRPc95kdE7z3fh0T3PetChO86x0OOR0O0Zl2+Qa9///OgAD3+h2OHRKa+R77e/d7E6T314QVtwYTivdn+QPilwUTorT7ewcTwl4H5IH7N/xzBROk+zz4dOuUBbj7pQcTlGIH1oIFDkYdDreLuV1NCl25YrQSlfd5+3n5CfuP93kTUpUWE1T3ebQGPZb3J/d89yD7fC+ABWL3rwcTobQHNZX7UPfM9zj3kuOWBRNRtPt5BxNJYgfgf/sZ+2gFE1T7FPdq45UFtPutYgf3Zx1MHQ6mCg7bHfdSChO4LB0TeCAdE7SFHRN49wMKDnB+xFXHZPeUChL23Drf94/lExtAqRYTK0D3KoEFE41Ak84FVba7e7ob9wnk8Pcu9y835iFUWHNWWx/3RvfnChNLQPglHfxLB/dNChMbQEB9BROKwPeskxVmYpuyYh/3pge4wbKYqhvWv0b7FPsVTk5EHw73tQoBteNIHQ5mfvdbChK45feP3zrcE4uA4goTK4D3mfuJFRMbgPcvlQUTTYD3hB0Ti0DBCg7MHRP0JR0T7EAKDvuOi/fuChPY9wn3ZhX3Xh1n95avBzH3Dgr4EQoT1Pse97EKp3UY90cKE7T33AoIE7g3gAUT2F/eBw7PHfdDHRPVEG4dE9So9x0dE7Ro9w0KE9UQrB0T2Gh5HRPSqMoHE9SofJUFE9io+DsKE9SomgoOsQoOxx372/uN7fkJd6l39xb3FBLg9xv7AdwTuPe5ChPU9yEdBRO0fJX7K7EdDlKLr/gksveU96UK3+33fBPc9wAdE+z3ph0T3H2TBQ77xouv+Uv3pQrfE7BTHRPQ96YdE7B9kwUO972L9x4d92vf92zfE9z30B0TvIPbBRPcVB0OjYv3Hh33b98T2PcLChO4g9wFE9gnCg73GB0BuOr3oeoDJh0OdvfwCoF3EvcJ3Tng94rlE+b3QR0T6vduHRPmVlh0WFwfE9aFywUT5nyV+yBpHQ5c+4Ou+AAKOtwT7Pcb934V9xzLyNWtrn5hux77oQdeZGp5Xxs7UMb3Fx/35/uZFfgGBxPcjvcbBRPqe5VHRgW/X12cWxv7CzAk+y37Jt0o9w7GuaPCsh8uB1aKVIpVHi98BWgHE+z3la4GO5kFisKKwcEaDvtJi/e1HfecHROw9AoT0H8KE7CA9woFE9CYHQ77PvclHQHB2/dI3AMtHQ77q36/+BPAVsIS5/d/ChPQ91IdE8j3fgoTsPd1HRPQlx0ORAoOKJp2+E6yEov4hPtS91IT4PerhRUT0Pc2+EHCmAWy+1JkB919+wT71fsO99bjmAWy+4ZkB8GB90r8RAUO99AKZAoOzR3KChKL+JT7VzoKDvcACg5CHfgc+VQrHan8XIYKQh33mflUJB33I/x1hgpCHffs+bA4HUT8XoYKx4tOCvgud9DFosb4Ax37efkcE3mQFhN6QwoTubQHhwoTfsQK9yb5SV4KE3k3HRN9nXR1m2cbE35Oa1g9fx8TefeW/GqGCseLTgr4Lnfl9wL4Ax1D9goTe5AWE31DChO7tAeHChN9xAoTe/dr+VMjCmn8dIYKx4tOCvgud/PKax33RPlhFffCyvvCBvd4/MGGCseLTgr4LnfOyGsd9075uz0K90/854YKx4tOCvgud9jHax332flGFee2zvdeCmtPG09nq/fzHUjnG3D3DRWld9nbBaGhj5maGp15mXp6fH5tfR7E/USGCsf3BR3WTgr4LnfOyPgDHaf3GhM9kBYTP0MKE120B4cKEz/ECvdO+bs9ChO99v66Igrb+GeGCseLTgr4LnfYx2sd99n5RhXntvUKXXpna08bT2SruHwfbYH4KQqm9w0VWu8FqX18mHobenl9eXyPfaF1H9k7Bdn8zIYKx4u0Yk4K+GfI9xbO+AMd9w28E5uQFvdFChOfxAr3xvmj9xkK91T88YYKx4tOCvgud9jH1PgjHRN8gJAWE30AQwoTvIC0B4cKE3sAxAr3NvnVnh0TfIBYHRN6gJf3dh0TewD3QB0TfID3Cgra/GeGCseLTgr4LnfWwWsd92b5z/fVCtr8m4YKQh33WPk3XB10/MOGCsf3BR3WTgr4Lnf4Ax2m9xoTupAWE75DChPatAeHChO+xAr37PmwOB0Tuvss/jEiCtz4Z4YKQh34Wvk3YAr3pfzOhgrHi7RiTgr5AM74Ax33mPcZHfdY+Tc5CpYKa/y9hgrHi04K+C5391z4Ix0TeZAWE3pDChO5tAeHChN2xAr3Vfkwwh0TeVgdE3WX93YdE3b3QB0TefeG/OyGCsf3BR3WTgr4Lnf4Ax2m9xoTupAWE75DChPatAeHChO+xAoTuvfX+4giCtz4Z4YKx4u0Yk4K+LvO+AMd9wz3GR33xfk4FTIK9wD8eIYKx4tOCvgud8+u9wWw+AMdjbfztxN9gJAWE36AQwoTvYC0B4cKE36AxAoTfYD32/k9Fa4d2PyBhgrH9/0KTgr4Lnf4Ax33a8sTvvfsCsL7OCl/BWL3JwdfbWhZVxqQCvf6Ch/nBhPetAeHChO+xAr4KPdzhgr3FR0TKFyQFvgGChOIXEWKSopMHjaBBRMoXWL4kwcTGF2S90YFUQYTLF33aB0TKF73fgYTKh6h+xMFxQYTKF6E90UF/LEGEyg897gKEykc9z/30gWSBg6m+3Cw9zy9W7v46733vQr3lMkT3PgbrhX7HSnz91j3V/cA8/caq62Ed68fn/sIBckGh/clBbJIRJRUG/tW+yT7J/teHxO8+1b3Dfsf90t8Hvd2Ch8T3LtipViTHpG2BdDQma3JH4/3JQVNBnf7CAV4ZGGDZRsOpvc6CvgfCkIKRPlaJB0Opvc6CrjB+B8KQgr7DPnV99UKDqb3Ogr4HwpCCo/5yTgdDqb3Ogq/9xT4Hwr3KPcaQgp3+VEVYh34Bh3/Aj+AAI4Kx8H36x331fcBE1b3HvfWFROWKosz9xQKE1Zi96gH4AoTZi0K6mYVsAcTVuTTHRNm+B0Kivi2FXN2BRNeQB2yHfX3BR3W9zEdrfca9y33ARMt9x731hUTTSqLM/cUChMtYveoB+AKEzUtCupmFbAHEy3k0x0TNfgdChOv8PyhJAr197cK9zEdgPea0fcBE633HvfWFRPNKosz9xQKE61i96gH4AoTtS0K6mYVsAcTreTTHRO1+B0KE6uA/IaIHSEK93r4FisdDiEK9xz4FiQdDiEK93D4hTgdDoosCsfBWh0TVMD3HvfKFROUwEkdE1TQYviaBxM00JL3RgVSBhNU0CgdE1Tg938GE1jgofsTBcQGE1TghPdFBfyGBhNTwC0K4viR99UKDoosCtb3AvfrHT32CidOHRNUkPce98oVE5SQSR0TVJRi+JoHEzSUkvdGBVIGE1SUKB0TVJj3fwYTWJih+xMFxAYTVJiE90UF/IYGE1KQLQoTVWDW+BUjCg6KLArkyqodv/gjwB2KLArO9xT36x2q9xqHTh0TVKD3HvfKFROUoEkdE1SoYviaBxM0qJL3RgVSBhNUqCgdE1Sw938GE1iwofsTBcQGE1SwhPdFBfyGBhNTwC0K91X4DRViHYr3/QrQCveg9yMK9yDLYE4dEzVA9x73yhUTVUBJHRO1kGL4LAdfbWhZVxqQCvf6Ch/YBpL3RgVSBnX7FAX7kwaJ3ovg7xoTNUD3KAaYLQW594BdBn0sBfsnvgoTNWD3fwYTOWCh+xMFxAYTNWCE90UF/IYGEzNALQoOiiwKyciqHbP4hz0KDiEKw/f5XB0Oigr3cPiFOB37L/5EJAohCvfN9/lgCg6KLAr3a8736x33Nbmp/wBLgAD4MAq8Xv8AS4AAE1TQ9x73yhUTlNBJHRNUyGL4mgcTNMiS90YFUgYTVMgoHRNU4Pd/BhNY4KH7EwXEBhNU4IT3RQX8hgYTU9AtCsL3+TkK9wgKiiwK903Bg8G1HRNS4C0Kv/fywh0TVWBYHRNU4Jf3dh0TUuD36gqKCvdY/MYkCoosCvcmzvfrHfcGvIlOHRNUoPce98oVE5SgSR0TVKhi+JoHEzSokvdGBVIGE1SoKB0TVLD3fwYTWLCh+xMFxAYTVLCE90UF/IYGE1PALQr3Off6FfcqHYosCsHFosa1HRNT4C0Kj/gLXgoTVWA3HRNV4J10dZtnGxNT4E5rWD1/Hw7CCrrI9/UKE9748OMVE773TAoT3jAK/AL5wj0KDsIKv/cU970K9zn3GsLpE9X48OMVE7X3TAoT3zAK+2z5SBViHcIK970K91TvyekT2vjw4xUTuvdMChPeMAr7MPs1KArCCrjB9/UKE9b48OMVE7b3TAoT3jAK++D5zPfVCg7CCvf1ChPc+PDjFRO890wKE9wwCvtd+cA4HQ7CCtXK9/UKE9748OMVE773TAoT3jAK/AX5XsAdwgqyxaLG9/UKE9v48OMVE7v3TAoT3zAK/CL5Rl4KE9s3HRPfrwr3TIu5XSUK/wD8gAC69wy5/wBugADiHfcd7Cvq99bqLekTeUD3fff8Fa6Lr64a99cGaItnaBp9+9cHLGeICveuBxO5QPgeHdmL2+Ua99cGE3lAMIs7iT8eL4AFYveutAcv1x2vi6+uGvcBufsBBoyui6+MreeWGLQHE3mA+65iBueAjGiLaIxoGfvXBhN1QIyui6+MruaVGBN6QPf9HeeAjGiLaIxoGfsAXQYTeUD3AAZni2hnGg73Tft3zfc1rgoS9x7qlN/3eukTuoBvCgcTu4D3rgYT24C0BxPagDCVBYndi9/xGvfXBhO6gKUKE7aA26AK5pUFE7qAtPuuLQoTu4Dz/EoVWAoO9033OR0S9x7q99fpE3b3PAoTtvgeHd2L3/Ea99cGE3alChNu26AK5pUFE3a0+64tCvel+IU4HQ73TfcFHdauChL3Huro9xrr6RM6gPc8ChNagPgeHd2L3/Ea99cGEzqApQoTNoDboArmlQUTu4C0+64tCveT/MYkCvt996Md9x7qAyoK9wb4FisdDvt996Md9x7qAyoK+BYEnXK1obWitaIZsaCXm50an3qZdnp6gW9vHmttbGxsaggO+333ox33HuoDKgrL+IU4HQ77fUsd1vcCEpv3B5LqkvcHE8gqChP0S/gVIwoO+31LHeTKAfce6gMqCiT4I8Ad+31LHc73FBL3C/ca+wfqE8gqChPwu/gNFWId+333/QpNChL3Astn9/8dE/AvgAVi9yUHX21oWVcakAr3+gofE2j0tAY1HQ77fUsdx8EB9x7qAyoKR/iR99UKDvt99wUd1k0KEvcL9xr7B+oTaCoKE/C7/MYkCvt9Sx33Js736x10vBPQKgoT6Kf3+hX3Kh37fUsdwcWixvfrHRPoKgoT+PsZ+AteChPoNx0T+K8Kix33PfdPOB0Oyou5XfQd9x7m4O+O93oTaOMKtAcslgWJyYvIwRru9wsFE6j3M/u9OYEFE2hi95UHE5r37QoTarT7egcTWvfPHRNs4ovhjeAe6pYFtPuuLQr3qPxwKAqDi5cK93ngE1z3fx0TnPdMHRNc+DIKEzz3mQoTXHIKu/gWJB0Og4uXCv8AxoAA9+cdVuATXPd/HROc90wdE1r4MgoTOveZChNabvseBft398od39Ia0Pg3CrT7r2IH54AFE1z3Th336fgQsgqDi5cKqu/t4BNe938dE573TB0TXvgyChM+95kKE15yCvd2/HAoCoOL96Qd9w/3I/8AqIAAJQr36x33OfciPeATTfd/HRON90wdE034MgoTLfeZChNNcgoTXvffW6kKDoP3BR3Wlwq19xrA4BMv938dE0/3TB0TL/gyChMf95kKEy9yChOv92D8xiQKg/cFHdb3pB3/AbKAACUK5Mr36x219xrA4BMvgPd/HRNPgPdMHRMvgPgyChMfgPeZChMvgHIKE6+A92D8xiIK+8X6VcAdg/e3CpcKaPeajeATrfd/HRPN90wdE634MgoTnfeZChOtcgoTqsf8q4gdg4uXCvd54BNc+CD4YBX7Ny4F2ffSHeeW95sKYgfn95EdYgctVgVSB+nABROcRYtFiUYeL4AFE1z4MgoTPPeZChNcbvseBft398od39Iangf3N+kFDve+96Md9xW/+H6GHfgB+UokHQ73vvcFHdZNCgH3Fb/3R/ca90WGHfgY+4gkCoMd96P5RiQdDvfOHb3B97EdE6SAshYTooD3hrQGE6SA94YdE1SA6goTpQC0+4UHE5UAYgcTlID3hwoTrICkCvdv+cX31QoOgx34AflUKx0O984dt8WixvexHROqQLIWE6lA94a0BhOqQPeGHRNaQOoKE6qAtPuFBxOagGIHE5pA94cKE65ApAr3Mfk/XgoTqkA3HROuQK8K9z0dy++U9zBYvhOogLIWE6SA94a0BhOogPeGHRNYgOoKE6kAtPuFBxOZAGIHE5iA94cKE6qApAr4KvsoKAr3zh279xT3Xwqe9xqf9zBYvhOkQLIWE6JA94a0BhOkQPeGHRNUQOoKE6SAtPuFBxOUgGIHE5RA94cKE61ApAr33Pk4FWId9xf3BR3W9xEKrfcakPcwWL4TVECyFhNSQPeGtAYTVED3hh0TLEDqChNUgLT7hQcTTIBiBxNMQPeHChPVQKQK9+v7iCQK9xf3twr3EQpj95pa9zBYvhPUQLIWE9JA94a0BhPUQPeGHROsQOoKE9SAtPuFBxPMgGIHE8xA94cKE9VApAr3XvttiB33Bx34Hwr4HvcCA/cwIAq8Ch/MyCsdDvcHHfgfCvge9wID9zAgCrwKH1zIJB0O9wcdxMj4Hwr4HvcCA/cwIAq8Ch/7JPdMPQoO9wcd+B8K+B73AgP3MCAKvAofnPdAOB0O9wcdssWixve9Cvge9wIT7PcwIAq8Ch8T/PtIvV4KE+w3HRP8rwr3Bx3H9wL3vQqn9gqm9wIT0vcwIAq8Ch8T/vsExyMKDvcHHdXK+B8K+B73AgP3MCAKvAof+yvVwB33Bx34Hwr4HvcCA/cwIAq8Ch8quFYK9wcduMH4Hwr4HvcCA/cwIAq8Ch/7B/dM99UKDvcHHfgfCvge9wID9zAgCrwKH/sNq1wdDvL3BR3H91gd+B8K9xb3GvcW9wID9zAgCrwKH5z3QDgd+yn+RCQK9wcd+B8K+B73AgP3MCAKvAof9xSrYAoO9wcd91zO970K9/28e/cCE9T3MCAKvAof+xarOQoT+PcICvcHHfc+wYPB970K+B73AhPs9zAgCrwKH/sZpBX3GMb3GFCbpPsX6ve2CiwFE9x89xaeHRPsWB0T3PdtCvL3BR3H91gd+B8K9xb3GvcW9wID9zAgCrwKH4r+CyQK9wcd9xfO+B8K93K89w/3AgP3MCAKvAofd6wV9yod9wcd970K+B73AkvLE/D3MCAK9wNn4FTGHxPowaOwvM42Cmh7dWl9HhPw99sKDvcHHfe9Cvge9wJLyxPw9zAgCvcDZ+BUxh8T6MGjsLzONgpoe3VpfR4T8PfbCkfIJB0O8vcFHcf3WB33vQr3Fvca9xb3AkvLE3T3MCAK9wNn4FTGHxNywaOwvM42Cmh7dWl9HhN099sKE/yK/gskCvcHHfe9Cvge9wJLyxPw9zAgCvcDZ+BUxh8T6MGjsLzONgpoe3VpfR4T8PfbCs3IKx0O9wcd9xfO970K93K89w/3AkvLE9z3MCAK9wNn4FTGHxPawaOwvM42Cmh7dWl9HhPc99sKd6wVE/z3Kh33Bx2yxaLG970K+B73AkvLE+z3MCAK9wNn4FTGHxPqwaOwvM42Cmh7dWl9HhPs99sKE/z7UL1eChPsNx0T/K8K8ny9aHb5I72Rd/e9Cvge9wITnPka+SQVYa0FE2xOQAW5VUiiRxv7L/ss+xb7byeoPLhRH0Y2tmkFE6zL2gVbwtFy0Rv3L/cr9xb3cPJs3FvFH/w9+4YV9yrG9yn3H8q5bFyrHvvN/BMFebuDxMQa91r7wBVKW6y+ax/3zfgUBZ5ZlFBQGvsrUvsp+x8eDvfifL1ovVn3Rvcg5h1ovfe9CvfQ6vc0uar/AEuAAP//yIAA/wBLgAATk8D3MPfjFfcvy/ck9z6qoomDpR6NM4syMxpaBzKLMok0HoNxdYlqG/s9S/cl9y8fEzXQ+Ub7MRUTVdB1+xQF+5MGid6L4O8a9ycGmC0FufeAXQZ9LAX7Jr4KE1Xg938GE1ngofsTBcQGE1XghPdFBfwCBhOTwJVWX5BsG/tL+yz7E/ty+3P3LPsT90sfE1XQq7aQlcAf+BYGEzXQkvdGBQ66gZsdEvce6vd/7hNufQoTrlwKE3YtChNutQq79w4kHQ66gZsdx8H36x33f+4Ta30KE6tcChNzLQoTb7UKbveJ99UKDrqBmx0S9x7q2u/D7hNtfQoTrVwKE3UtChNvtQr3Rf1uKAq69wUdzJsdEvce6sf3GrTuEzeAfQoTV4BcChM7gC0KE7eAtQr3Ef3OJAq69wUdzJsd5Mr36x3H9xq07hM3wH0KE1fAXAoTO8AtChO3wLUK9xH9ziIK+0r6VcAduvtEyvKbHRL3Hup495qD7hO2gH0KE9aAXAoTuoAtChO2gLUKE7UAdv2ziB0v9zoKAcDf944qHX/5WiQdDi/3Ogq4wQHA3/eOKh0/+dX31QoOL/twsPc891gdEsDf5rOmyangE/r3fK4VYG2TnGwfd/cKBU0GhfsgBW251HTVG4FEBRP+ewoT+pG4BfcMltzQ9wAa6ljF+xe+HmOaBUOnYrDJGtXGsteqpIV9pR6g+wUFyAaR9xcFq2BVn0gb+xQqRfsHJdBQ8mMfsnsF4GqxbksaPk5fLR4OL/c6CgHA39rv0iod3/ssKAov9zoKAcDf944qHcD5yTgdDi/3Ogq/9xQBwN/L9xq/Kh2v+VEVYh0v9wUdx/dYHQHA38X3GsUqHan7giQK4Xy5bCUK/wJLgAC99+sd9zTe9wDfE3y3FvdUBojwi/PzGvcDB/cvu8b3ErSthoSuHjtlX0g+GkSsWchbHq5wBbRroGlhGhO8T2BeSHt8jpR6Hnn3CgVZBoX7GQVvq758uxv3FMTp3Mpwukq/H2aoBWOrdKXIGs+suc+pHqUHp1lNm00b+0UzOftNHyAHE3w193QKDouL96IKx8ESo9f3L+n3L9cTpm8dE8b3mR0Trvd+HRPO960KE77rHUf4kffVCg6L+3Cw90vjHb73N1Dpgsnx1xPSAPeT9+gdNYk2HhPUACWABWIHE9EA9xb3Rh33G7QGE9KAJdcd46AK9y0GE+KA95kdE9qA934dE+oA960KE9oA6x0Oi4vjHfcv6S/v9yfXE6pvHRPK95kdE7r3fh0T2vetChO66x0TpvH8cCgKi/cFHdbjHfcc9xr7B+n3L9cTU28dE2P3mR0TW/d+HRNr960KE1vrHRPVu/zGJAqL97cK4x3U95r7SOn3L9cT028dE+P3mR0T2/d+HRPr960KE9vrHRPVOfyriB05Hfdp+ForHQ45HfcB+FokHQ45HfdK+Mk4HQ5UCs74YyMKDlMK5MrkChPGgEcdE5aAYgc1ChOmgPfrB+KWBRPHALT7hAcTjwBiBxOOgHAKE8aA9xMKmPhxwB1TCsCu9wWw9/4d0rfzt2/3LVi+E8fQRx0Tl9BiBzUKE6fQ9+sH4pYFE8egtPuEBxOPoGIHE4/QcAoTx9D3Ewr3O/hNFa4dDjkdzPhUVgr3D/tww/cp+BIK9yDKq/ctWL4T1oCy+QgV3oEFjTaLNTQa+wAH+0/tO/csnJuNjZseZWxwYFwaVLBqxrH31R2zpLO9rR/MtrjT9yEaE8yA9+oH4pcFE+UAtPuEYgcT5IDxfwX70gf7RVFK+wkpS8H3Px7aB+GL4Y3fHvGX95sKBw5TCsnI5AoTxoBHHROWgGIHNQoTpoD36wfilgUTxwC0+4QHE48AYgcTjoBwChPGgPcTCqL41T0KDlMKx8HkChPCgEcdE5KAYgc1ChOigPfrB+KWBRPDALT7hAcTiwBiBxOKgHAKE8KA9xMKxfjfFXN2BRPGgEAdVAqU+Jr3DR1TCtb3ApTB9/4dlPYK+wX3LVi+E8EQRx0TkRBiBzUKE6EQ9+sH4pYFE8EgtPuEBxOJIGIHE4kQcAoTwRD3EwoTxcDO+GMjCvt295YVc3YFE8MQQB1UCpT4mvcFClMK1vcCxcr3/h2U9gr7BfctWL4TwxBHHROTEGIHNQoToxD36wfilgUTwyC0+4QHE4sgYgcTixBwChPDEPcTChPHwM74YyMK+5r3PMAd9w/3BR3HZh33/h3k9xqX9y1YvhNiQEcdE0pAYgc1ChNSQPfrB+KWBRNigLT7hAcTRoBiBxNGQHAKE2JA9xMKE+NA9zD8eCQKUwr3Js73/h33VbyE9y1YvhOKQPdu960V2gcTwkDii+CN3x4TikDxl/ebCmIHE5JANQoTokD36wcTioDilgW0+4RiBxOKQPF+BfvRB/tFUUr7BSVLwfc/HhOPQPcp+EgV9yodUgoOUgr3BfhkJB0O9w/3BR3H+BIK5fcalvctWL7VyxNkgEcdE1TAYgc1CvfCB9qXxsTgGp2GnYKeHpZ+foyBGxNkwPAKE2UA+y0GE00AYgcTTIBwChNkgPcTChPmgPcx/HgkClIK92H4ZCsdDvcPfNL4yrr36Ar3Js73/h33TryL9y1YvtXLE5SA9273rRXaBxPEgOKL4I3fHhOUgPGX95sKYgcTpMA1CvfCB9qXxsTgGp2GnYKeHpZ+foyBGxOUwPAKE5UA+y1iBhOUgPF+BfvRB/tFUUr7BSVLwfc/HhOegPci+EgV9yod9w980vjKuvfoCsHFosbkCtXLE8qARx0TqsBiBzUK98IH2pfGxOAanYadgp4eln5+jIEbE8rA8AoTywD7LQYTmwBiBxOagHAKE8qA9xMKE86Ad/hZXgoTyoA3HRPOgK8KUwrBxaLG5AoTxUBHHROVQGIHNQoTpUD36wfilgUTxYC0+4QHE42AYgcTjUBwChPFQPcTChPHQHf4WV4KE8VANx0Tx0CvCkYdb/d+JB0ORh2x9+04HQ7zCtb3AhL36fYKufd3E8eA+SWEFbYGE4+A9z35A9+XBRPHgLT7dwcTj4BiB+Z++xT8YgUTx4D7KPhj8JcFtPukYgfwf/st/F4FE6eA+w/4XwUTj4DnlgUTx4C0+6QHE4+AYgcTl4DegfdI/QUFtgb3N/iaBTb3fSMKDkYd1fd+Kx0OTB33HvlzJB0OZQrW9wIS90X3B3bpqPd5+3L3BxPCAPcgHROTAPc1ChPDALT7eQcTkwDtChPCAPeVHROiAGIHgB0TzIDP+XwjCg5MHfdT+ew4HQ5lCs73FBL3o+k19xp493kTxPcgHROV9zUKE8W0+3kHE5XtChPE95UdE6RiB4AdE8r3R/l0FWIdqPcFHdZNCo4dEveP9xr7Bumo93kTYvcgHRNL9zUKE2O0+3kHE0vtChNi95UdE1JiB4AdE+T3K/tfJApMHfds+X0rHQ5lCvcmzhL3o+mOvHT3eROU9yAdE5X3NQq0+3ntChPE9ygdE5T3/R0TpIAdE5r3MflhFfcqHWUKwcWixvd9ChPK9yAdE5v3NQoTy7T7eQcTm+0KE8r3lR0TrmIHgB2K+XJeChPKNx0Tzp10dZtnGxOuTmtYPX8fDqYK+7f4yyQdDlaL92IKx8ESn/iTE1T4avdGFROU9wkKE6SD+0YFyAYTlPcJHRNck/dGBfwF+Ub31QoOVov3YgrO9xQS92/3GhNU+Gr3RhUTlPcJChOkg/tGBcgGE5T3CR0TXJP3RgX7ifjCFWIdVvcFHdb3YgoS93D3GhMs+Gr3RhUTTPcJChNUg/tGBcgGE0z3CR0TrJP3RgX7iPwRJAqyHZKLJQr/AGuAALr3s7r/AFeAACUK9+sdLOv3ku0T+m8KBxP297S0BiqWiq2LrYqtGc8G93nD7Or3BTbX+0MfLwami6eMph7slgW0BxP6+7RiBjMd6loVvge1i7a1GtwG9wzBWTE1VU77CR83BrCLsK4aDsB8vfewuveWxxK68Pf59CPzE/S696oV+073BCD3PPcw9xP3Hfdu93D7GfcQ+zYhPl9IWR6nbQW9ucuq1hsT+PPqPftIlh/8VwYT9Id4iGRtGvet+4cV+wBD7vWtjZ+PpB/39Ab7WYlJNPsCGw7bHfdSChO4LB0TeCAdE7SFHRN49wMKIvjePgrbHfdSChO4LB0TeCAdE7SFHRN49wMK+1n43i4K2x33lHf3UgoTvCwdE3wgHRO6hR0TfPcDCmX4wBWioQUTvPsY90QFaQb7GPtEonX3EvcGBQ7bHeLFosb3UgoTtiwdE3YgHRO1hR0TdvcDChO+++T46J0KE7ZXChO+6R3bHfcA9wYSuORb97cdMd853RO5ACwdE3kAIB0TuICFHRN5APcDChO2AE748isKDtsd9wDKErjkg/eaS9853RO6LB0TeiAdE7mFHRN69wMKE7T7tvjyiB3bHeLN6Hf3UgoTviwdE34gHRO9hR0TfvcDCvvK+XEVE75YCg7bHeHH91IKE7wsHRN8IB0TuoUdE3z3AwoTvPsz+NwV9yIKLPcFHcn3GArizeh39+UdE16ALB0TPoAgHRNeQIUdEz6A9wMK+8r5cRUT34BYCvcF/j0kCtsd4cf3UgoTvCwdE3wgHRO6hR0TfPcDCvvD+VwVE7z3Jh3bHeHI9yvOErjk9yi8hN853RO1ACwdE3UAIB0TtICFHRN1APcDChO+APtG+U4VMgr7CHk9Cg7bHeHH5cFfd8PB91IKE7eALB0Td4AgHRO3QIUdE3eA9wMKE7eA+zP43BXYHWyABU+UtkfnG/s39zSeHRO5gFgdE7eA920K2x3eyvR391IKE74sHRN+IB0TvYUdE373AwoTvvuu+YF4Ctsd91IKE7gsHRN4IB0TtIUdE3j3Awr7tfi2qAos9wUdyfcYCveUd/flHRPdACwdE70AIB0T3ICFHRO9APcDCmX4wBWioQUT3wD7GPdEBWkG+xj7RKJ19xL3BgWI/fMkCtsd91IKE7gsHRN4IB0TtIUdE3j3Awr78Plbpx3bHfdSCpu8E7gsHRN4IB0TtIUdE3j3Awr7tfi2OQoTuswK2x33Y8GDwfdSChO2LB0TdiAdE7WFHRN29wMK+7X4tvcjHRO2+CsdE673vwoTtvIKE66W93YdE7b36gos9wUdyfcYCvflHRPaLB0TuiAdE9mFHRO69wMKE977O/tVJArbHRK45PcxvHvfOd0TtCwdE3QgHROyhR0TdPcDChO4+z34x3Id2x3Js/cPsxK45J279wa7Zd853RO+gCwdE36AIB0TvkCFHRN+gPcDChO7APsz+OwVxR0s+3DD9yvNS8D4JLn3Ugo8yhPcuPcEFTjIYdQeE9rGrKXBwh+TXqhtwIgIE7lccGNfWRpUsGrBtvfVHa2qqqylHxO8oJyVlJued6MYfn5+gnsbdn+ftB/3Zwf3Elm7IiVBWT94HvffCpyMmRvNp3MqH3IHY4JhfmyACBPc+xtabF5SGvc9UBVdaaDAqZax4q0foJOvl66VCPsuB2NSeH9pGw6NHfg0CvdsCvsI+3Cw9z/L+Bq5AbXj90fJA/ep+E4VnJ2JhZ4fnUkFb5KZd60bpJuXpZAf1X5BwzEb+wz7Ay37Mvsn2y73EoMfgEEF92MK35DFt6XZGXKYBVpsWXBSGy1Jz/cS9xTJz+AfDve1CgG140gdYPcaLgr3tQreyvR3AbXjSB37Cve9eAr3tQr3lHcBteNIHfcH83od97UK8PcUAbXj2PcaSB2I9yckCoh+91sKoHcSuOX3j9863P8AWoAA9+cdE4nQ4goTKdD3mfuJFRMZ0PcvlQUTTND3hB0TirDBChOJ0Pdv+TyyCmZ+xFXGZXaqdvg2xMq59yd3p3cSuOX3j9863DreE43A92D4rhUTjaD3TfsUBrtiY5xWG/sLMCL7J/sg3Sv3DsS4or2xHxMtwJJFBRMdwPcvlQUTTcCvBzqYBfh9BxOOkNy5OgaP9ycFE42gfZP7MF4FaAfggQVK+00HRvv7FfcVy8vXHhONwKqtfmO5H/ubB2Jma3pgGxONoDtQxPcQHw5m9wUdyfdbChK45fX3GpbAChPF4Dr7myQKZvtEyu/3WwoSuOW095pXwAoTxcD7afuAiB3MHRP0JR0T7EAKtPcaPgrMHRP0JR0T7EAKX/caLgrlCveUd/ezHRP6JR0T9kAK9xTzeh3lCt7K9Hf3sx0T/SUdE/tACvsC9714CuUK9wD3BvdXCm33tx1S3hPogCUdE+SAQAoT8wD29y4rCg7lCvcAyvdXCor3mnfeE/klHRP1QAoT8vsZ9y6IHeUK8PcU91cK0Pcasd4T6yUdE/dACo/3JyQKLftww/cr9h33Vwr3CMrJ3hP795H3nwqzprCzqx+wp6CinrJznhhgZmVw9/EK99P3zgoi+xAiJfsq+zHjL/cbm5yMjpweZWxwXlwaE/ea+NIVyrpYUmmAeVv38wrCGw7lCuLN6Hf3sx0T/SUdE/tACvst960VWAoOzB0T9CUdE+xACvsU6agKLfcFHcn2HfeUd/dXCsv3GrbeE/2AJR0T+4BACvcU82MdiP3zJArMHRP0JR0T7EAK+1D3l6cdzB10vBP0JR0T7EAK+xTpOQoT8swK5Qr3Y8GDwfezHRP1JR0T80AK+xTp9yMd+CsdE+v3vwoT9fIKE+2W93YdE/P36got9wUdyfYd91cKzPcatd4TeyUdE/dACv0Z92gK5Qr3Vwr3Mryt3hP2JR0T7kAKefcDch3lCuLFosb3sx0T9SUdE/tACvs29ySdChP1VwoT/Z13d5tqGxP7VG5YPYAfDs8d9wnN6Hf3Qx0T1cRuHRPVqvcdHRO1mvcNChPVxKwdE9maeR0T06rKBxPVqnyVBRPZqvg7ChPVqpoK+yT3qBVYCg7PHfcX9xQSr91Q3EPTsfcaptyG1oGaE9SEbh0T1Er3HR0TtCr3DQoT1ISsHRPYKnkdE9JKygcT1Ep8lQUT2Er4OwoT1EqaChPVWo/3IiQKzx0Sr91Q3EPTw++23IbWgZoT1ShuHRPUtPcdHRO0dPcNChPVKKwdE9h0eR0T0rTKBxPUtHyVBRPYtPg7ChPUtJoKXvdS91kdzx33Bcr0d/dDHRPUxG4dE9Sq9x0dE7Sa9w0KE9TErB0T2Jp5HRPSqsoHE9SqfJUFE9iq+DsKE9SqpWtfmFgbIz5QIh8T1ar3SvcPFcmvWkRBZVZLTWi91NSxvsof+wb3uHgKzx33snf3Qx0T1YhuHRPVVPcdHRO1NPcNChPViKwdE9k0eR0T01TKBxPVVHyVBRPZVPg7ChPVVJoK9w7ueh3PHfceyhKv3VDcQ9Nx95pm3IbWgZoT1YRuHRPVSvcdHRO1KvcNChPVhKwdE9kqeR0T00rKBxPVSnyVBRPZSvg7ChPVSpoKE9US+xP3KYgdzx33CcWixvdDHRPVRG4dE9Uq9x0dE7Ua9w0KE9VErB0T2Rp5HRPTKsoHE9UqfJUFE9kq+DsKE9UqpWtfmFgbIz5QIh8T1ar3SvcPFcmvWkRBZVZLTWi91NSxvsof+zD3H50KE9UqVwoT1arpHYiLr/f509S59yf3pQrcOt443/dz4BPpgO8KE+yA+BcdE/KA+0wGj/cnBRPsgPgFHRPpgDkGDoj7d833NfdpHWT3Avcs4BPsgPdCHRP0gPemHRPsgN0KE+mA93yvBhPqgH8dE+yA9zcdE+mA+2/8yxVYCg6xCkP4LzgdDoj3BR3W92kdtPcau+AT7ID3Qh0T9ID3ph0T7IDdChPqgPd8rwZ/HRPsgPc3HRPtgEP9RyQK9yQKEvcD4BOwpR0T0I73HAUTsGcK9zb4sD4K9yQKEvcD4BOwpR0T0I73HAUTsGcK1PiwLgr3JAr3qHcS9wPgE7ilHRPYjvccBRO4Zwr3h/iSeh33JAr3FPglCvclChO692r4xCsKDvckCvcUyhKW95r7NuD3JQoTuHP4xIgd+8b3/QqvZ734QHepd/cW9xQS1MtY9xr7AN4TzQDvHRPOADv9bhWQCvf6Ch8TzIDdrwYTtIBFgR33GAeO9xwFE6yA3R0TzgD4BB33CQdfbWhZVxoOxx33JAryyvR3EvcD4BO8pR0T3I73HAUTvGcKivlTeAr4Cx34Tnepd/cW98EdE9zvHRPq9xcKBRPa3R1AfQVnBxPc9wr7XyQK+8aLrxL3A+B1vBPApR2O9xxnChOg6viZch33JAr2970d9wPg95wKE7xnClr4up0KE7RXChO86R33JAoS9wPgE7ClHRPQjvccBROwZwoO+9v7je75CHepdxL3A90TsPcpChPQjvccBROwfJX7LLEdDvvb+43u+Qh3qXf3qHcS9wPdE7j3KQoT2I73HAUTuHyV+yyxHfcu97V6HVKLr/gksveU96UK38HvU/d8E9r3AB0T6vemHRPcfZMF9zj97CgKXIuv+CSyjnepd/ecHe33fBPMsxb3fK8GRpkFirOKvbQazc73LfuMBfccrwZKl/s595n3A/g5CtV6+0D7RgX3DQcTrI73CAUTnHuV+y5pHVsHXopKilkeQX0FDvvGi6/5S/elCt8TsFMdE9D3ph0TsH2TBTO6JB0O+66Lr/lLd6d3oHcS9t//AFqAAPfnHROcUx0TzPemHROsfZMFE5z3KIyyCvvGi6/5S3endxLx7yzfE6hTHRPI96YdE6h9kwUTsKD97CgK+4WLr/dt9xT38velCt/T9xoT2FMdE+j3ph0T3H2TBfcp/HokCvgLHflLd6d3Etz3GvsA3xPUUx0T5PemHRPUfZMFE9hq/kIkCvgLHflLd6d37MoSkPea+073GvsA3xPZUx0T6femHRPZfZMFE9pq/kIiChPc+yP6j4gd+8b3twqv+Ut3p3cSnfea+0HfE9RTHRPk96YdE9R9kwUT2Ps3/ieIHfvGi6/4Snf3qfelCt8T2Pel+G4VOWAF9zIHE+j3ph0T2H2T+zBeBfe2HfuUBzlgBVMH3bYF+xMH+Dcd94yvBzuZBYrAisHAGvc5B922BQ73vYv3Hh33a9/3bN8T3PfQHRO8g9sFE9xUHbLjLgr3vfcFHdb3Hh33Vvca+wXf92zfE+v30B0T24PbBRPrVB0T7eX9RyQKjYv3Hh33b98T2PcLChO4g9wFE9gnCi/jLgr4Cgr3Bcr0d/ecHfdv3xPe9wsKE76D3AUT3icK+0b3j3gKjYv3Hh33b98T2PcLChO4g9wFE9gnCm7jPgr4Cgr3CcWixvecHfdv3xPW9wsKE7aD3AUT1icKE977ge2dChPWVwoT3ukdjYv3Hh3O77/fE9T3CwoTtIPcBRPUJwoT3IP88SgK+AoK9xf3FPecHbf3GrTfE9r3CwoTuoPcBRPaJwoT3kvwJAr3PPgsHal39613Erv3E/bg92/fE8v4svh8FU1HZlVaHxOrg9wFE8snChOf/AP3Pu4dDo33BR3W9x4dtPcat98T6vcLChPag9wFE+onChPuSP1HJAqN97cK9x4dc/eaeN8T6vcLChPag9wFE+onChPk+1v9LIgd9xgdAbjq96HqAyYduPi0Pgr3GB0BuOr3oeoDJh1l+LQuCvcYHeLN6HcBuOr3oeoDJh37K/lHFVgKDvcYHfeUdwG46veh6gMmHfcS+JZ6HfcYHeL3vR246veh6hPsJh0T/Ps3+L6dChPsVwoT/Okd9xgd9wD3BhK46m33tx1u6hPSJh0T7PT4yCsKDvcYHfcAyhK46o73mo/qE/QmHRPo+xf4yIgd9xgdAbjq96HqAyYdL/irfgr3GB3eyvR3Abjq96HqAyYd+wf5V3gK9xgdAbjq96HqAyYd+xX4jKgKVPcFHcn3bB33lHcBuOrP9xrO6gMmHfcS+JZjHYz98yQK9xgdAbjq96HqAyYd+1H5Macd9xgdErjq96HqTbwT8CYd+xX4jDkKE+jMCvcYHfdjwYPBErjq96HqE+wmHfsV+Iz3Ix34Kx0T3Pe/ChPs8goT3Jb3dh0T7PfqClT3BR3J92wdAbjqz/cazuoDJh2M+38kCvcYHQG46vc6vMHqAyYdf/idch1qCg5qClv4tC4KVPcFHcn3bB0SuOrR9xrM6njLE3T3eh0TcsGjsLzONgppfHVsfh66X0+jThv7CPsFNPs6HxN0pB0T/I77fyQKagrC+LQ+CvcYHRK46vc0vMfqeMsT+Pd6HRP0waOwvM42Cml8dWx+HrpfT6NOG/sI+wU0+zofE/ikHXn4nXId9xgd4ve9Hbjq96HqeMsT7Pd6HRPqwaOwvM42Cml8dWx+HrpfT6NOG/sI+wU0+zofE+ykHRP8+zz4vp0KE+xXChP86R1Ufrhrdqh2+Fu5fncSuOr3oeoTlvemfhX3CPcG3vc5HxOO2XLIZLUeusYFEzZrpV1SBahjXJpbG/sI+wU0+zpCoVKuYh9bUAUTVqxxBROWuMMFa7O+e74b+xr3jBX3G7rT4rOse2yhHvtr+58FgqiGr7Ua9xr7XxVfaZ2vdB/3bveiBZdrkWJbGvsaWkY1Hg73nH64XvYdErjq96HhNeP3ht4Tvfem+E4V4rtB+xv7GltINDVb0fca9xu70uEf+Lb75xUTfXSeBWRtXWz38Qr31PfOCiFGRmVOYx7KYkGvSBv7B/sGNfs6HxO9+zn3BTf3CM3RrMi1HlCuyGjbG+TMtNaxHxO7+1P35xXLuVhSa353XPfzCsMbDvtJi/e1HfecHROw9AoT0H8KE7CA9woFE9CYHfc/+LAuCvtJi/e1HRL3Be8q4BOo9AoTyH8KE6iA9woFE8iYHROw9z/7LSgK+0mL97Ud9wXK9Hf3nB0TvPQKE9x/ChO8gPcKBRPcmB3Q+VN4CvtJ9wUd1ve1HRLl9xr7AOAT1PQKE+R/ChPUgPcKBRPkmB0T2Pe6Cg77SfcFHdb3tR33HsoS5fca+wr3mvuQ4BPZ9AoT6X8KE9mA9woFE+mYHRPc97oKE9pY+bOIHftJ97cK97UdEqv3mvtG4BPU9AoT5H8KE9SA9woFE+SYHRPYgftoiB37PvclHQHB2/dI3AMtHX/44S4K+z73JR3eyvR3AcHb90jcAy0dM/mEeAr7Pvf8HfdsHRLB2/cNyYjcE/j3SzUV92MKBRP09wGVwsnRGspluiewHmyWBUekc5y3GrSrpsijooWAoR6bOwW/Bo/xBaVgYJpVG/sETUdCR7tj1HAfuXoFynWpdWAaXmdsP2xxkJZzHnjiBVQGj/sCBRP4unO2fsCKCA77PvclHQHB27DvttwDLR3SIygK+z73JR33lHcBwdv3SNwDLR33LvjDeh37PvclHfD3FBLB26b3Gp7cE9QtHRP8p/juJAr7PvcFHcn3bB0Swduo9xqc3BN0LR0T/Kn7UiQK+5iLr/j67gH23wP292YV+Dcd95avBzGaBYrAisDAGvdyB/cOkc2htB6Um5eZmZaodRh1paCDpBuvop6ljB+wgWWcWxtdWH1cXx9fWXBA+yEaDn9+uGuvZ/ca+M64Evbfz7qC08feddwTmoD292YVE1sA+Dcd9z0HidGK0dEa93IH8Yu2mLMew52uqs0b1KxiTFt5b11lH1tkd2NZGkSzbc1lHhOcgNVemHJoGllwbEh4do6UcR4TPIBz5QVaBhOcgI/7CwV6ubeAvRv3CMHE4stwrirHHxObAFKtdpu0GqqYqberHsGyq7nBGtpExCQxQVpCah55ZHtJJBoO+6t+v/gTwFbCtOj3FXcS5/d/CtL/ADyAAP//w4AA9+cdE9yA90X3BBX3ygcT2wD3HMD3fgoTvID3dR0T3ICXHfcP+QiyCvur9/wdv292+ETAVsIS5/d/Cv8ANoAAyRPV91IdE7P3fgoTrfd1HRO1X977gAdkinZyGkmrZ7+CHoA/94MdHxPVu2KlWJMekbi7jbGepKsZc6UFeXJ3gnUbaXahvh8O+6t+v/gTwFbCEuf3fwr//+yAAO8T0PdSHRPI934KE7D3dR0T0JcdE8Tg+3koCvurfr/4E8BWwveT9wYSf/cLfPd/Cv8AD4AA9wsT1PdSHRPS934KE7T3dR0T1JcdE9nb+QArCg77q/cFHcm/+BPAVsIS5/d/Cv//1oAA9xoT6PdSHRPk934KE9j3dR0T6JcdE+Kp+88kCvur+0TK77/4E8BWwhLW95r7ifd/ChPk91IdE+L3fgoT1Pd1HRPklx0T6CX7tIgdRAo0+Nw+CkQK+0H43C4KdB33r/dJHRMXgPi5FhNHgGIKE4uAJgoTh0D3BB0TJ0CVMgWK+L56HXQd9xv3BngdWve3Hf//xoAA97QdExcg+LkWE0cgYgoTiyAmChOHEPcEHRMnEJUyBROGwH748CsKDnQd9xvKeB1495r//+qAAPe0HRMXQPi5FhNHQGIKE4tAJgoThyD3BB0TJyCVMgUThoD7kPjwiB10HeSz9w+zeB2Qu/cGu/8ABoAA97QdExeQ+LkWE0eQYgoTi5AmChOHiPcEHRMniJUyBROHYPsP+OoVxR1ECvtw+NN+Cnb7cMP3K9JPsXR2pHakdvg0zIt3eB33Y8r//8+AAPe0HROFwPgU958KraSssaYfE4Wgso0FE6GgYgoTwqAmChPBkPcEHRORkJUyBROJwMyPBROFwFpvYVxWGg50HfcGzej3SR0TF8D4uRYTR8BiChOLwCYKE4eg9wQdEyeglTIF+6H5bxVYCg50HfcCyvT3SR0TF8D4uRYTR8BiChOLwCYKE4eg9wQdEyeglTIF+335f3gKdB309wJ4HWD3B+H3B/gRHfe0HRMXIPi5FhNHIGIKE4sgJgoThxD3BB0TJpCVMgX7qPkJ9zwd9xjQFaV43tQFn52Vmp4ao3mYeXd5fWt7HhOHQJ/7OvcuCnQd9wf3BpbBeB1a97cd///GgAD3tB0TFpD4uRYTRpBiChOKkCYKE4aI9wQdEyaIlTIFE4ZgfvjcKwqB95wVc3YFE4dQQB10HfT3AngdYPcH4fcH+BEd97QdExcg+LkWE0cgYgoTiyAmChOHEPcEHRMmkJUyBfuo+Qn3PB33NL0Vo6Bc6gWre3mZdxt5eX5zeJV8n3kfE4dA9xD7D/cuCnQd9wf3BrrKeB1a9ws195o19wv//8aAAPe0HRMXiPi5FhNHiGIKE4uIJgoTh4T3BB0TJ4SVMgUTh1B++NwrChOHIHH3NYgd94kKzfca/wAVgAD3tB0Ti0D4uRYTo0BiChPFQCYKE8Mg9wQdE5MglTIFE8PAJ/tXJAp2ftJNwXgd9yG8/wAfgAD3tB0TePi5FmIKZwfSfAUTuIj7uQVgXVt1XRtVcariH/cvB5D3oB37J9UK+40F+xiKvVvcGxO09wQdE3SVMgX7HPjFch1HCg5HCvs4+NwuCveJCsb3Gv8AHIAA/wBSgAD3+wrg//+xgADX3MsTi0D4uRYTo0j3Oh33rQeMuwXdlcnE4jYKX3FzVoAeE8Mg97MKE8UgJgoTwxD3BB0Tk5CVMgUg+1ckCkcKRfjcPgp2ftJNwXgd9xq8/wAmgAD/AFKAAPf7CuD//7GAANfcyxN5+LkW9zod960HjLsF3ZXJxOI2Cl9xc1aAHhO197MKJgoTs/cEHRNzlTIF+yP4xXIddB33BsWixnUK9/sK4P//sYAA19zLExbA+LkWE0bI9zod960HjLsF3ZXJxOI2Cl9xc1aAHhOGoPezChOKoCYKE4aQ9wQdEyeQlTIF+6745p0KE4agVwoTh6Cdd3ebahsTJ5BUblg9gB8OdB33BsWixvcQChMWwPi5FhNGwGIKE4rAJgoThqD3BB0TJ6CVMgX7rfjmnQoThsBXChOHwJ13d5tqGxMnoFRuWD2AHw730ApkCvs1+NouCvfQCvehd2QKl/i8eh330Ar3DfcGEov3eJX3C0n3cUr3C5D3SxPq+JmFFbAGE/X3JvhBwZgFsvtLZAfVfS37wvsF98PVmAWy+3FkB9V/+wT7xyT3x9mXBbL7eGQHxIH3NfxEBbAG9xf39wUT6qJHqy7X+1YIgfjuKwoO99AKZAo8+No+CsoKEov4lPtXOgr3L/nNLgrKCvcN9wYS9wz3C9n3V/tL9wsTzdAdE573Nfg9wZYFE86v+1cHE55nB+J/+w/76AUTzfsR9+njlQWw+4QHE61GChPNZLVwvR73vfnhKwoOygr3oXcSi/iU+1f37B0Tmvc1+D3BlgUTyq/7VwcTmmcH4n/7D/voBRPM+xH36eOVBbD7hAcTrEYKE8xktXC9HvfS+a96HcoK9wb3FBL3a/caa/fsHROa9zX4PcGWBRPKr/tXBxOaZwfif/sP++gFE8z7Effp45UFsPuEBxOsRgoTzGS1cL0e91L52iQKL/uW9xT7C/cC+NC1Y7NnrxL30fdX+0T3GhNi0B0TTPc1+D3BlgUTZK/7VwcTTGcH4n/7D/voBRNi+xH36eOVBbD7hAcTUkYKE2JktXC9HhOi98uCJArKChKL+JT7VzoK92/5zT4KygoS98G8ajoK9zn5tnIdygrv970di/iU+1f3VxPK0B0Tmfc1+D3BlgUTya/7VwcTmWcH4n/7D/voBRPK+xH36eOVBbD7hAcTqkYKE8pktXC9HhPOnvnXnQoTylcKE87pHfcACvts8C4K93Ad68r0dxKo+CYTnrb4bxUTroP7Kr+HBROe9ycdE16V9zcFVwYTnvdDCvu495x4CvdwHfcG9xQS9z33GhOUtvhvFROkg/sqv4cFE5T3Jx0TVJX3NwVXBhOc90MK+0j3BiQK+yj3BR3WtWH3N/c09yxgthL3RPcaE0y2+G8VE1SD+yq/hwUTTPcnHRMslfc3BVcGE8z3Qwr7Qf06JApRfrj4Ibn3lXewdxK46vec5hPc95p+Ffco4PcE90n3JlX3BTThHxPs9x7RebAFE9z7LD1fsVeqVKUZd2q6bbJvq2wZ+xZJnWb3ItS2W6hVoEUZrG1fnFcb+wT7ATX7L/s19TX3Ax+UuBU4W9D3FPcVuNLh3r1L+xj7E2BBMR8OWffwCvgxHRLj3Tng94rlE+v4N/d+FfsVTk5EZ2Sbr2Qe960Htb6xl6kb1r9G+xQfE/X7MPxKFTCaBYrBisHAGtwHWbW4e7kb9wnk8Pcu9y835iFWWXVaXR/3QPfnChPr99od3IEF/TkHVYpWilQeO30FaAcT7feVBg7cHVx+xFW/+BnEErjl95PfE7j3prcVPE/K9xH3IM3G980dzLqkxbMfE3hblqZruxuvppiyox93oQV+gICCeht1fZu2H/eGB473G/fhCh8TuPss3TT3CR4OX/uNuPgAChPs96a3FTxPyvcR9x/Nx/fNHcm5or+xH4r7BYNXdWYIXXFaeWUbc3SMkHQffb4FvX1/omobdHuAdH8fKJzVYecb3MikwrYftb+XzfcvGveDBxPcjvcbBRPs9+EK+y3dNfcJHw6Y+CoKlnf3iLAS9wngN933euATza8W95WvBjL3Dgr3dQeNWIxjRRpY+Ccd93yvB0eBHfcdBxOtjvcXBROde5UFE8tBfgX3WAoTq1dbeE+BIAgTrTeABRPNX973JB0Ok/gqCvead6l396oK3xPKgK8W95WvBjL3Dgr4EQoTzID3Ih0FE9KAfZMFE6mAZ3kFnnNilGMb+AcdCBOqgDeABRPKgF/e9yQdDrN+v2T37gr3Z/d/ChNtAPgu8BUTrQA9t2fRvrWeraQedKUFeXF3gnUbanWhvh/3yvgRChNqgPd+ClAGcPscBftt97EKp3UY90cKE1sA99wKCBNdADeABRNtAF/e9yQdZ/eWrwcx9w4K92X7gAdkinZyGg7B+CoK90HuXLr3qgrgN90T0oD3FQr3lq8HMfcOCvgRChPKQPse97EKCBPUQKd1BfdHCmBdeVGBIHuJGPtiBhPMgPfAHQgTsYCmdQX3bx33sB0TsoA3gAUT0oBf3vckHQ730Iuv+Bb3+h3//86AAMD3Q+5msPeqCuA33fd64BOqoPcVCveVrwcy9w4K93UHjViMY0UaWPgnHfd8rwdHgR33HQeO9xd7lUF+BROsYPdYCldbeE+BIHuJGPtiBhO0oPfAHaZ1GPdvHRPRoPewHRPKoDeABROqoF/e9yQdDvfLi6/4Fvf6Hf//zoAAwPdC7yju96oK3jjgN933cd8TolD3FQr3la8HMvcOCvgRChOykPciHX2TZ3kFnnNilGMbE7Qw+Acde4kY+2IGE6xQ98AdpnUY928dE8lQ97AdE8JQN4AFE6JQX973JB0O9wh+y/fms/dwrhKm4oLT90bNvvdfE/b45n4VpZ+Okqkfj7cqmGyrcahypRm50K7VoubXmRiz+19jB9p+eTxvSmZNGWS1Z7Fjt2ixc6Z2owjxwrm80BrWVsAoHhPuLUVVM1aeWL1SH4yJjYqMiQgT9idZWEgxGibhOvcR68uwu7celn6Xf5d9CGmsqn/AGxPu/Aj4XBVmuYOqrxrAs7O+vLFnUVFfX01gHoKVgpaClwjk+3QVrWWrZ69iCGllVXhTGxP2KlXT1L2ex9C1HxPurGWqZ7hUCA4j+BwdtOf3fugD9xn31hX3fsPFycfDUPt9+3tTUE9NU8X3fB73CvflFSAkMvuM+4vyM/b08+P3i/eMI+QiHw4ji68B923fA+D47RViB/cYlgX7/PeNCvsiowWKvYq+vRr3tvgCCiOL3fiouAH36eUDvPcBCiN++AwK9/XiRuQT6Pc++AFRCiP3VcoS97zeOPdQE6D4ePdVFcoHE8DgHSN+96cKfmwKI36498TIErPlMef3hOQT6PeVZx0ji5X4vt0BvvgxA/cZlfcvCiN+t/jbuBK396kKt08dI/eUx/e+uAGo5PeG5QPhd3UdI/gcHbPn937oA6+oFax2rsIFVbLAdcEb9PPj94vpfNJzvx+40WmfalcFxWRVo1QbICQy+4wqm0OlVx+993EV937DxcmysHI7oB77YvvbBYWxiLnDGvcK+7YVZGei1HUf92H32gWQZ45fVxr7e1NQTx4OJfgcHbLr93vrA/cb99YV937DxcfHwlD7fft9VFJPT1PD934e9wn35RX7ACIy+4z7jfQ19wD28uH3jfeMJOQgHw77RouvAfdN4APK+O8VYgf3DpUF+/33nx33t/gCCiuL3fiouAH38OUDw/cBCiZ+994d+AFRCiD3VcoS98HeOPdQE6D4ffdVFcoHE8DgHSp+96gdfmwKLH6498TIEr7lMef3hOQT6PegZx37EYuV+L7dAaf4MQP3ApX3Lwosfrf427gSvPepCrxPHTf3lPgVHXd1HSX4HB2y6/d76wOvqBWtdq3BBVazwXXBG/by4feN6nzTcr8fts9qn2tZBcRkVaJUG/sAIjL7jCmbQ6VWH8H3cxX3fsPFx7KvcjugHvtf+9gFhbCIuMIa9wj7thVlZ6HXdR/3X/fXBZBnjmBXGvt9VFJPHg4jfrj4YrkBrOj3jecD94/4sBX7BSI0+1P7VPQ49wX3BfLe91T3UyTi+wUf+xH7qhX3SMa/zcrIVvtH+0dOWExJUL33SB4OI4uv+H53qXcS92zgE7DV+HUVYgf3IpcF+4X3jQr7IaMFir2Kvr0a90AHE9CO9yMFE7B9lQUOI4vd+DC5Affh5QO59wEdI/sZ+AwK9/TiRuQT6Pc994lRCiPUyvgidxL3vN4491AT0Ph41BXKBxPg4B0j+xn3pwr7GWwKI36498TIErPlMef3hOQT6PeVZx0j+wyV+L7dAbn4MQP3FPsC9y8KI363+Nu4Erj3qQq4Tx0j9xzH9764Aa7k94blA+f7IHUdVX64+GK5Aa7q97XrA/eo+LAV+xH7CDX7VPtU9wg49xH3EPcH3vdU91T7B+H7EB/7JvuqFfdI0b/X1NFW+0f7R0VYQj9FvfdIHg77PIuv+H53qXcS91fgE7DK+HcVYgf3GJUF+4X3nx33QAcT0I73IwUTsH2VBQ4ri934MLkB9+rlA8L3AR0m+xn33h33iVEKINTK+CJ3EvfB3jj3UBPQ+H3UFcoHE+DgHSr7GfeoHfsZbAosfrj3xMgSvuUx5/eE5BPo96BnHfsR+wyV+L7dAaf4MQP3AvsC9y8KLH63+Nu4Erz3qQq8Tx039xz4FR37IHUdI364+PG4AbPn93/oA/cY9+gV94LExsnHw0/7gfuLU05PTVLH94we9wv36hUgIzH7kPua8zD29PPm95r3kCPlIh8OI4uvAfdt3wPg+QUVYgf3GJYF/BT3jQr7IqMFir2Kvr0a9874Agoji934v7gB9+nlA7wW+C/d++UGtba0tKWnCPcq9zK8zeMa8lPU+xUmMVoigB52lp1/oRunnJ68mB+d0AWPn5yMmBvUulQ3O1s5KiAfX1pZUlZRCA4jfrj3vL33l7gS9/XhRuUT6Pc++A4VWbsH8b1SMzNVTC18eIyQdh9+vwW9fX+haht0e4F0fx8nnNdh7Rv3HOTf9wDkWcwloB8T8N6ou8nTGu5AzfsJMD9hNXkeb5SegqEbrpegtpcfmb8FjpybjJcb2bhfOThVWTEfDiP3YsoS97zfN/dQE6D4ePdiFcoHE8Aj+C5QBvu9/DgFVvek+2Lf92IHN8oV+2gG92j3xAUOI36499rI9zzdAfgwHff6Hfdt5AP3dX4V9yDo5PcY9xwy1vsWam2Hg20fl/dIBfeu3fvbBnb7zqeDBZKqq4+nG+3HUiMoVkkpeXiNkXcffcEFwH1+mmwbdHiAdIIfLaDLXPEbDiN+uPfRyBKy5jDp94PkE+j3lH4V9wnj1/cm9xBB2PsBHxPYVlh1YGIfmvc05O73U7mFqxgT6PuMb/sb+0D7YRr7S94g9xoejbgVPFre90Qfj4uPjxqtsbqXtBvQul37AfsAX1VFHw4ji5X41d0BvfgxA/cZlRWVgQXdBveC+P4FvvwxOffvBw4jfrf48rgSt95N2/dg1lXgE+S39zAV+wThUvcM9wjk0/PmW8InvR4T2OfBpMm9GuZIzSIkN0slPq5N4FseE+QvXVpVQhoT2PD4CxXMvLTDy65VVEt3Y09cHia9dL7AGhPk9wD8iBVBV8PWz6qzy7Mf9wRXr2NOGkNcVUUeDiP3oMf3ybgBqOT3huYD4nkV95jH8/dE91oa9zY98/sX+xI0NvsU+xHjP/W/t5urrh50+yI6KvtBUgi0+F4V9MLBzNO9Rfs1fot+in4ecWxpfl8bQVG49B8O+8R+93IdfqkKDvvE+3T39gHZ9xsD92mo5wr7xH73I/dw93Id9/KpCvv/BG0KDvvE9/L3IxLZ9xv7GvciE6D3KvfyqQoTwMr71ecK97z4JAr3MvciFHD3Vx33wBazqquys2yrY2Nsa2NkqmuzHw77z373FvjLdxLb91wKE+D3JX73ER0T0K0KDvvP9/r3FhLb9xUx/wAygAATwPck+HwVZ29taGinba+vqKmurm6pZx8ToPdiHfvPkXb4y/cWEtv3FTH/ADKAABPg9yT5PhVnb21oaKdtr6+oqa6ubqlnHxPQ92Id+1B+9xb4y3cS4Pd8HRPk9yl+awoT1Pc0HRPM9zMKE+T39h0O+1D3+/gTHRPg95/4ffcaHRPI9+4dE9D37x0T4Ed1a2FNGg77UJF2+Mv4Ex0T8Pef+T73Gh0T5PfuHRPo9+8dE/BHdWthTRoO/Dn5dXcBs/ID5/l1Ffd5HfuN+XV3AbPy0PID5/l19w8d/Bz5gXcBsNwKDvwc+YF3Abv4Dgr5Ju4dDvtR+YF3AbD3E9fcCvdfFvdTCvtR+YF39+YK+SaSHfwcl3YBu/gOCsbuHQ77UZd29+YKxpId+9O9+CkBqfd5A/d/veEKDvvTvfgpAaX3eQO9+FvhHQ77Cb34KQGp+EMD93+94Qr4K/tE4QoO+wm9+CkBpfhDA734W+EdiPdE4R0O91kK91kK91kKL/fRCvhE+A8K+ETN/EQGDve8HSP30Qr4OPgPCvg4zfw4Bg73vB37xPeZ93Id95mpCg77v/dt93UBtfdyA/ct920Vxr+5zs1XuVBQV11JSL9dxh8OL0nNAbP4RAOzSRX4RM38RAYO+535gHcB29sD9zT3qvc4Hfud+YB3AfdH2wP3R/eq9zgK+7D7M/drCvmf92sKAfLUA/L3MvdFHfuw+zP3awr5n/drCgH3JNQD9234IvdECvuY+zP3cAr3CdRswBPgs/eW3gr7mPsz93AK9xjAbNQT0PfE977fHfvT6vgpAan3eQP3f+rhCg770+r4KQGl93kDvfiI4R0O+wnq+CkBqfhDA/d/6uEK+Cv7ROEKDvsJ6vgpAaX4QwO9+IjhHYj3ROEdDve8Cve8Ci/3pc0Bs/hEA7P3pRX4RM38RAYO97sd97sd+537MfpAAdvbA/c09833OB37nfsx+kAB90fbA/dH9833OAr7sPsQ92sK+Z/3awoB8tQD8vdV90Ud+7D7EPdrCvmf92sKAfck1AP3bfhF90QK+5j7EPdwCvcJ1GzAE+Cz97neCvuY+xD3cAr3GMBs1BPQ98T34d8d+CQdjfs0FcYG95/5+gVQBg734R36fFAGDvgkHffc+zQV+5/5+gVQBvef/foFDvfhHfhWUAbG9wwV+EJQ/EIHDvs5+X93EvdN0f//yoAArxPA93D5fxV2fYFxeJFjkl4fE6CSXGCgBaNaZqF0G3h9fHdnvIfbfx+6g2poBV1daHBvGnebf5usnLfMrB6itaFhBUqsnV+rG5ybl5+naKVduh9prrqTBdqXvY2xGp9+mnl2Y3ZyWR5gdpK6BRPAkbiTtJ0apXyVdx4OLvhK4zTiEvdo4jfcE1Cz+HYVcJh7raa0lJGrHr+WBXtIg2hUGmGV+xOc+2cepgac92eV9xK2GhOQw4Ote84e924KE6D3nR0TYPfjHRNQaX56cB8OLu/j947jNOIS92jiN9wTqLP3JBVwmHqtHhOwprSVkasfv5aBVwWFb4BPbRppnH2mppuZramAx4anHoC/924KE8hxYYKEax9XgAWbzZOrwhrBg6t7zB73bgoT0PedHROw9+MdaX56cHCYe60fE6imtJSRqx+/lgV7SoNqVhpVk2qbSR5XlgWRa2KVcBtpfnpwHw77BSa5+Uq4ErjRctj3Mddy0hPk94P3dBVNqE2oyBqnmKiioB6jdqt4tXgI1Wq/c1Mab35rdHQeb6JnnmebCH772RUT6PcDytbZr36ndqQfE9S9qqm2xBreVLIluR5JqVOryBqzq6/TkZGLipEeoV4FZZ6deqkboJuVpZUfxopGvi8b+wpUQkZolmukbR8T6FRrcWBXGjHNZOVgHtlmuHNUGl1qZEKFhouMhh50uAWweXicbht2eoJxgh8T5FDQV+YeDoX/Am6AAOIdpPfBxdcTUPgU90kVIosjiCYe3QaI8ovz8hr3RgcTkPfxHRNwtPtbB/te+xQm+zD7LfcC+wH3U4of+G7FBw737R33CdT3V7Vm/wAqgAD/AKGAAL0T/oDc9+UV96kd+zz7FfcL91UeWBb4DQr3Vfcu9xr3bveMHR74CPs2FT1Ww/b2xcTUm52Igp4flkMFtgaJ6gWhZGuRYBv7Azc1+wr7C9s39wgfE/2AtbOUnq8fjuoFXwaARAUT/oCDdXWIfRsO9yt8s/cKr2f3uB34MB2v90Sx9wSzEqm+93HJ9xDO9wy9E9/A+A58FfdV9y73Gvdu94wd+A0KH7ME+zz7FfcL91X3qR0f+xz3ChX3TgYTv8CsB0uSBe6bB/cUusXN2Fe8LB/7OmgGx4UFE9/A+8kHT4UF9y/30hXKp21RV29nRB9y90QGDvsl99Gq0v8AEIAA0Qqc/wBNgAD/ABGAAHqcyKoSqa7wtsC54a4T78DM+JgV8dbK5OXWTCUlQEkxMkDN8R5oFvsP5D/3AvcA59f3D/cPLtQgIS5C+w8e98Y5FXOOg7SGoHuYc5AZr5SYoaAaqW+gWx4sBhP3wHsHqIgF+zgHbogFfO+aB2+OBdKZB56YhHqOH5RgBXaPlYakG5aRjI6YHxPvwPsG90wVpph+cnWAeW4fftkGDvcK+Aunb/gECv8A6YAA/wAdgABuqBKYr8rMyrDTqPdozBNH4PfP+TEVExvgbwetiAX7eQcTh+BkhQUTF+Bv9gcTh+CnBxMX4PeMChNL4PtOB2aHBW/3H6cHZo8F93sHsI4FEyfgpyoHLvteKvdeBftP+54VYpAF93zGB5NUBa0Gid8F+5oGiTcFrAaTwgXG+3wGYoYFb/cnBw7c+AOlealtqv8A6YAA/wAdgAB4pBL/AB+AALf//9SAAMPox1D/ACaAAP8AW4AAqPdozBNVYPeq+TEVbwetiAUTNWD7eQdjhQVv9wCnB/eMChNVYPe+CisHLvteKvdeBROVYPuJ+6gVfH2OkH0fgsQFZQaISAV7pK+DrBvUt7HBsnajTaYfE0rgdJUFb5d4naEaoqKbqJaViYiWHpVTBbAGjsoFmnZsk2sbSWNmV1+pdcBxHxOVYKCBBap9mXt4GnN1eWceDvd7+y/3oR3xkB33ezr3oR33RJAdPaB290jc9xbd90V3AaT4cQP3uRa6Bqf3SAXx3DEGn/cWBfHdMvggCvsy+CAKIznmBnf7FgUkOuYGb/tIBboGp/dIBfcyBpfcFfsyBp/3FgX3MgYO+374NPdxCvkDWwoO+374PfgsCvmwtx33rR0O+374PfdvCvg9+DoKE9BtHRPgLjIFDvt++DT3SQr5IUsKE/BPCg77fviixAH3XswDq/ii9xYK+374NPcCCvg0ah37fvg093Ed+DSBCvt++YP39R34Q/cvHft++DT3Sh34llId+3742PeFHfg0gwr79PfQ99gd+OnUCvv099D3wQr46dQd+/D32vfACvfa9zAd+/D32vesHffa9y4d/Aj4NPH3+B34NBX3Dwr8FPfC99oK+FS3CvwI+DTx9xTy9/gd+RoVpqGjp6d1onBwdXRvb6Fzph/7egT3Dwr7+/jAvQG59y0DufjAFfctvfstBg77e/jAvQG5960DufjAFfetvfutBg5k+MC9Abn4bQO5+MAV+G29/G0GDvt++3H3cQp9WwoO+377aPgsCvcztx33rR0O+377aPdvCvto+DoKE9BtHRPgLjIFDvt++3H3SQqbSwoT8E8KDvt++wPEAfdezAOr+wP3Fgr7fvtx9wIK+3FqHft++3H3cR37cYEK+373Bvf1Hfti9y8d+377cfdKHfsPUh37flL3hR37cYMK+/T71ffYHWPUCvv0+9X3wQpj1B378PvL98AK+8v3MB378PvL96wd+8v3Lh38CPtx8ff4HftxFfcPCvwU++P32gr7UbcK+36C93EK91pbCg77fov4LAr4B7cd960dDvt+i/dvChb3cgoT0G0dE+AuMgUO+36C90kK93hLChPwTwoO+36L9zJSxBL3XswTYKvwFfc+BhOgJswHE2Dwy8RL94lcB/c5Cvt+gvcCCoJqHft+gvdxHYKBCvt+oHb32vf1HZH3Lx37foL3Sh3kUh37fpd29zj3hR2Cgwr79PsB99gd90DUCvv0+wH3wQr3QNQd+/Ao98AKKPcwHfvwKPesHSj3Lh38CILx9/gdghX3Dwr8FPsP99oKorcK+373iPdxCvhXWwoO+373kaj4BHeldxL3MNITsNr5BLcdE9D3rR0O+373kfdvCveR+DoKE9BtHRPgLjIFDvt+94j3SQr3MAoT8E8KDvt+9/bE94l3AfdezAOr9/b3Fgr7fveI9wIK94hqHft+94j3cR33iIEK+3741/f1HfeX9y8d+373iPdKHffqUh37fvgs94Ud94iDCvv09yT32B34PdQK+/T3JPfBCvg91B378Pcu98AK9y73MB378Pcu96wd9y73Lh38CPeI8ff4HfeIFfcPCvwU9xb32gr3qLcKmR33Hgr7Nvg9rWn/ACKAAP//3YAAr2f3uB3/AFiAAK4Sk/co6PdKEy6T+D0V9yirBlKTqOAF9ygGE06qNFGEBWz3SgcTjqoHW5H7IPgRBV8GEx77GvwNUoIF95P3FBX7DgbH90EFDvtL95cd/wClgACgdqz/AJSAAPdgHRLk0/ce0FjVE5aAq/g9FfdIBvcYusrBHxOmgMNmsjGVHhOnANeZp7K3GsRatS0e+1UGE1qA9x0KE5cA9z/38xXLq3VaV2txQB9s9ykGrPtKFROWgOGw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AXMAIwFzACwBcwAsAXMALAFzACwBcwAsAXMABQF2/9UCmwAsAlQALAJUACwCVAAsAlQALAJUACwCVAAlAlQALAJUACwDhgAnA4YAJwLfACcC3wAnAt8AJwLfACcC3wAnAt8AJwLfACcC3wAnAsMALwLDAC8CwwAvAsMALwLDAC8CwwAvAsMALwLDAC8CwwAvAsMALwLDAC8CwwAvAsMALwLDAC8CwwAvAsMALwLDAC8CwwAvAsMALwLDAC8CwwAvAsMALwLDAC8DqgAvAosALAKLACwCiwAsAosALAKLACwCiwAsAgAAKAIAACgCAAAoAgAAKAIAACgCAAAoAgAAKAKyACwCXAAUAlwAFAJcABQCXAAUAlwAFALXACcC1wAnAtcAJwLXACcC1wAnAtcAJwLXACcC1wAnAtcAJwLXACcC1wAnAtcAJwLXACcC1wAnAtcAJwLXACcC1wAnAtcAJwLXACcC1wAnAtcAJwLXACcC1wAnA8IADwPCAA8DwgAPA8IADwJ5AA8CeQAPAnkADwJ5AA8CeQAPAnkADwJ5AA8CeQAPAicAFAInABQCJwAUAicAFALGACwCYwAsApEALwH9AC0B/QAtAf0ALQH9AC0B/QAtAf0ALQH9AC0B/QAtAf0ALQH9AC0B/QAtAf0ALQH9AC0B/QAtAf0ALQH9ACUB/QAtAf0ALQH9AC0B/QAtAf0ALQH9AC0DDgAtAegAKgHoACoB6AAqAegAKgHoACoCWQAtAjcALQI3AC0CNwAtAf4ALQH+AC0B/gAtAf4ALQH+AC0B/gAtAf4ALQH+AC0B/gAtAf4ALQH+AC0B/gAtAf4ALQH+AC0B/gAtAf4ALQH+AC0CBgAkAgYAJAIGACQCBgAkAgYAJAIGACQCBgAkAlkAGQJZABkCWQAZAlkAGQEqABABKgAdASoAAwEq/+wBKgALASoAHQEqAB0BKgAKASoAHQEqAB0BKv/yASoAHQEV/60BFf+tAiMAGQItACIBKgAZAUIAGQEqABkBawAZASoAGQEqAAUBKgASASoAGQOFACIDhQAiAl4AIgJeACICXgAiAl4AIgJeACICXgAiAwQAEgJeACICXgAiAiUALQIlAC0CJQAtAiUALQIlAC0CJQAtAiUALQIlAC0CJQAtAiUALQIlAC0CJQAtAiUALQIlAC0CJQAtAiUALQIlAC0CJQAtAiUALQIlAC0CJQAtAiUALQIlAC0DZAAtAacAIgGnACIBpwAiAacAIgGnACIBpwAgAbIALwGyAC8BsgAvAbIALwGyAC8BsgAvAbIALwFYABkCUAAZAUUACQFFAAkBRQAJAUX/9AFFAAkBRQAJAkcAGQJHABkCRwAZAkcAGQJHABkCRwAZAkcAGQJHABkCRwAZAkcAGQJHABkCRwAZAkcAGQJHABkCRwAZAkcAGQJHABkCRwAZAkcAGQJHABkCRwAZAkcAGQJHABkC/AAAAvwAAAL8AAAC/AAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAAByAAdAcgAHQHIAB0ByAAdAiIALQIqAAYCBwAvAi0ALQIwAC0CaQAiAmQAIgKEACICkgAiA5gAIgOTACIC0AAbAfQAKQH0AEoB9AAsAfQALAH0ABgB9AAmAfQAKAH0ADMB9AAsAfQAHQH0ACQB9gAnAaoAPwH8ADMB9wAkAfEAHQH7ACkB/QAzAd8AHAH9ADECCAAuAfYAJAH0ACEB9ABJAfQAKwH0ACsB9AAYAfQAJgH0ACgB9AAuAfQALQH0ACMCJgAjAbQAPwH8ADQB9wAkAfEAHQH7ACkB/QAzAd8AHAH9ADECCAAuAfQAKAH0AEoB9AAsAfQALAH0ABgB9AAmAfQAJwH0ADIB9AAsAfQAHQEsAE8BLAAGASwATwEsAAYDhABPASEAUAEhAFABIQBQAaAAQgGgAEIBoABCALcAKAFjACgA1AAlANQAEgGfACUBnwASANQAEgGfABIBHQAeAR0AGgHnAB4B5wAaATgAKAE4ACgBOAAoAgAAKAMsACgB9AAoAywAKAEsAE8BMQAqAgAAKAFTAFABUwAZAUAAZAFAAB0BWAAoAVgAHgEdAB4BHQAaAecAHgHnABoBOAAoATgAKAIAACgDLAAoAywAKAFTAFABUwAZAUAAZAFAAB0BWAAoAVgAHgFKAAIA+wBgAUoAAgD7AGABtwAUAf8AKAH/ACgB6wAtAlYAGQLzAB4C8wAeAcsAHgLSAAwCrQAeA0MAIwNDACMCDgAZAXIALQFyAEIBcgAwAXIALQFyACABcgAvAXIAMQFyADgBcgAxAXIAKQD8ADUA/AAlAQAAVgEAACgA6ABDANwAIwDoAEMA9QAuAXUALgI1AC4BcgAtAXIAQgFyADABcgAtAXIAIAFyAC8BcgAxAXIAOAFyADEBcgApAPwANQD8ACUBAABWAQAAKADoAEMA3AAjAXIALQFyAEIBcgAwAXIALQFyACABcgAvAXIAMQFyADgBcgAxAXIAKQD8ADUA/AAlAQAAVgEAACgA6ABDANwAIwFyAC0BcgBCAXIAMAFyAC0BcgAgAXIALwFyADEBcgA4AXIAMQFyACkA/AA1APwAJQEAAFYBAAAoAOgAQwDcACMBXwAcAXkAHAG6AAgBpQAgAaIAIgHWACABkAAgAYEAIAHDACICBwAgAPsAIAD//+EBvgAgAYsAIAJTABoB5gAdAdQAIgGLACAB1AAiAbQAIAFZAB0BlQARAeMAHQG+AA0CfQANAbAACwGjAA0BcQARAV8AHAGNABABTAAeAYYAHQFfAB4A5wAWAWUAEwGcABAAzQAVAMH/wQF2ABAAzAAQAmkAFwGgABcBeQAcAZEAFwGAAB4BJQAXAS0AIQDiAAcBkQASAV0AAAIPAAABXgAHAVz//QE1ABEBXwAeAV8AHgFIACUB9gAdAfQAMwH0ACsB9AAjAfT/9QH0/+gB9AAUAfQAIwH0AAAB9AAKAfT/9AH0ACUB9AALAfQABwH0AAoB9AAhAfQAFwH0ADIB9AAwAfQAGgH0AAcB9AAUAfQAGwCM/04AjP9OAIz/TgDpAAAB9AAAAIUAAACFAAADXQBFBKwARQNdAEMDXQA7A10ATgNdAEEDXQA9A10AQANdADwDXQA/A10AVQITAB0CEwAdAhMAKwITAB0BLABPAhMAHQITADkCEwA5AhMAHQITAB0CEwAdAhMAWAITAB0CEwAxAhMAMQITABgDEQAoAjkATwISACgBZ/+wAi4AKwJ+ABkC1wAmAjEAFAMGACgB0wAfAyAALgKUABQClABnApQAJQKUAFUClAAUApQAVQKUACUClABnAtAANwLsABQBvgAYA3UANwJGABoCRgAaAkYAUgJGAFICRgAaAkYAGgJGACoCRgAqAyAANwMgADcCXAA7AfkAIgJGAFIA+QBBAbAAQQDUACUA1AASAKcAGgCnABoAdAAWAZAARQGQAI0BkABMAHQAFgGQAEsBkACMAZAAMwGQAD0BkAAnAZAAJAGQAEUBkAAxAZAAXwGQAEUBkACFAZAAaQAZ/+8AAP/CAZAAYgAA/4IAAP+BAAD/xQAA/70AAP9rAAD/bAAA/10AAP9MAAD/fQAA/2kAAP9pAAD/cAAA/70AAP+9AAD/XAAA/1YAAP+XAAD/oAAA/5AAAP+QAAD/dQAA/3UAAP+tAAD/vQAA/58AAP/cAAD/aQAA/1wAAP+9AAD/xgAA/8YAAP/2AAD/fQAA/2IAAP9WAAD/YgAA/1YAAP9cAAD/VgAA/1wAAP9WAAD/bAAA/2wAAP8kAAD/EAAA/2wAAP9sAAD/XQAA/10AAP9wAAD/cAAA/3AAAP9wAAD/cAAA/3AAAP9dAAD/XQKYAAUCdQAsAjAALAJ+ABkCWwAsAicAFAMVACwCwwAvAXMALAKbACwClwAFA4YAJwLfACcCSQAjAsMALwMBACwCTQAsAh0AFAJcABQCeQAPAs0AJAKIAAoDAgAJAtcAJgKuABsCxv/3A37/9wHd//cBcwAQAwf/9wMB//cCeQAPAxL/8wIuACcCNwBPAesAAAIHACcBogAoAaQALQImABcB/wAxAR8AYgISABcCFQAUAjkATwHrAAABtgAoAggAJwJRABMCHwBFAlMAJwHsABMCHgAXArwAJwHoAAUC1AAXAt0AJwHJACwCLgAnAaIAKAImABcBHwBiAR//6wIIACcCHgAXAh4AFwLdACcBH//zAh4AFwKCAA8CBAAnAbsAJgGdAE8CQwAqATsACwEsAE8BLABPAPkAQQD5AEYBkAClAEP/4wGQABUAAP/dAAD/TQKYAAUCagAsAnUALAIwACwCswAFAlsALAOWAAICJgAeAx0ALAMdACwCjQAsArMACQOGACcDFQAsAsMALwMHACwCTQAsAncALwJcABQCeAAOAtEAHQKIAAoDAgAsAr0AGAQTACoEFAAqAtcAFAOSACwCYQAsAmQAKQPjACwCggAAAlsALAJbACwCxgAUAjAALAJnAC8CAAAoAXMALAFzABABdv/VA34ACQPMACwDBwAUAo0ALAMdACwCeAAOAwEALALCABQCwwAvAqoADwIwACwCMAAsA7QAAgImAB4CsQAsAwsAFAMZACwCdwAvAnkADwJ5AA8CowAKAsEAGALCACwBcwAsA5YAAgKYAAUDmAAFAlsALAKbAC8DHQAsAsMALwLDAC8CeAAOAngADgH9AC0CHwA3AgUALAG/ACwCNwATAf4ALQL2AA8BrgAjAoUALAKFACwCGgAsAkAAEALmACwCeQAsAiUALQJyACwCRwAjAegAKgIQABkCAAAAAt8AJwIOAAoCbQAsAioACgNYACwDWQAsAmIAHgLuACwB+AAsAeAAKQMfACwCFAAKAf4ALQH+AC0CFwAeAb8ALAHoAC8BsgAvASoAHQEq/+wBFf+tAvEAEAMgACwCWQAZAhoALAKFACwCAAAAAnoALAJdABkCJQAtAhQAAAHEACwByAAsAwwADwGuACMCMQAsAokAHgJ6ACwB6AAqAgMAAAIDAAACJwAKAisACgJZABkC9gAPASoAGQH9AC0DDgAtAf4ALQIHAC8ChQAsAiUALQIlAC0CAAAAAgAAAAIfADQD8QAKAAD/WQAA/1UAAP+kBgcAKAjjACgC8wAeAtIADgLSAAoCWABPAi4AUAMXAEICrQBCAqwAUAJNAAUCUQA3AkkAOgKTADcCMQA3AhoANwJuADoC1gA3AWsANwFo/+kCXQA3AjUANwM4ADICpQAyApIAOgIfADcCkgA6AlIANwHfADACIwAaApgAMQJeABYDVAAUAkAACwIzABEB8QAYAk0ABQJNAAUCTQAFAk0ABQJNAAUCTQAFAk0ABQJNAAUCTQAFAk0ABQJNAAUCTQAFAk0ABQJNAAUCTQAFAk0ABQJNAAUCTQAFAk0ABQJNAAUCTQAFAk0ABQM4AAUCSQA6AkkAOgJJADoCSQA6AkkAOgKTADcCkwA3ApMANwKTADcCMQA3AjEANwIxADcCMQA3AjEANwIxADcCMQA3AjEANwIxADcCMQA3AjEANwIxADcCMQA3AjEANwIxADcCMQA3AjEANwJuADoCbgA6Am4AOgJuADoCbgA6AncANwJuADoCbgA6AsoAJgLWADcC1gA3AtYANwFrADcBawA3AWsAIgFrAAwBawAfAWsANwFrADcBawArAWsANwFrADcBawACAWj/6QJdADcCNQA3AjUANwI1ADcCNQA3AjUANwI1ACACNQA3AjUANwM4ADIDOAAyAqUAMgKlADICpQAyAqUAMgKlADICpQAyAqUAMgKlADICkgA6ApIAOgKSADoCkgA6ApIAOgKSADoCkgA6ApIAOgKSADoCkgA6ApIAOgKSADoCkgA6ApIAOgKSADoCkgA6ApIAOgKSADoCkgA6ApIAOgKSADoCkgA6ApIAOgNaADoCUgA3AlIANwJSADcCUgA3AlIANwJSADcB3wAwAd8AMAHfADAB3wAwAd8AMAHfADAB3wAwAiMAGgIjABoCIwAaAiMAGgIjABoCIwAaApgAMQKYADECmAAxApgAMQKYADECmAAxApgAMQKYADECmAAxApgAMQKYADECmAAxApgAMQKYADECmAAxApgAMQKBADECgQAxAoEAMQKBADECgQAxAoEAMQKYADEDVAAUA1QAFANUABQDVAAUAjMAEQIzABECMwARAjMAEQIzABECMwARAjMAEQIzABEB8QAYAfEAGAHxABgB8QAYApMANwI1ADcCZgA6Ak0ABQJRADcCCAA3AkUAHAIxADcB8QAYAtYANwKSADoBawA3Al0ANwJMAAgDOAAyAqUAMgIdACsCkgA6AsIANwIfADcB6wAZAiMAGgIzABECkwArAkAACwK2ABMClQAvAWsADAIzABEDtQAwA3sANwRFADcClQAeAdYAMgHtAF8B2QA5AdcAOQHGAB0B1wAyAdYAMQHZAEIB2wA4AdUAIQFGAGYBRgBlAa4AVAGuAFwAtwAoAWMAKADUACUA1AASAZ8AJQGfABIBNAA1AeQANQLpADUBWgBmAVoAIgFRAIMBUQAgAUoANQFKACcCTQAFAkIANwJRADcCCAA3AmkAAwIxADcDIwADAgEAJgLdADcC3QA3AksANwJxAAwDOAAyAtYANwKSADoCyQA3Ah8ANwJJADoCIwAaAkIAFAKUACYCQAALAsAANwKAABwDsAA0A60ANAKQABoDSAA3AjEANwI4ADIDjwA3Ajz/+wIxADcCMQA3An4AGgIIADcCOgA6Ad8AMAFrADcBawAMAWj/6QMZAAwDbQA3ArcAGgJLADcC3QA3AkIAFALEADcCfgAVApIAOgJcABYCCAA3AggALwM+AAMCAQAmAmwANwKvABoC1gA3AkkAOgIzABECMwARAlgACwKAABwChgA3AWsANwMjAAMCTQAFAzgABQIxADcCcAA6At0ANwKSADoCkgA6AkIAFAAUAAAAAQAAAAwAAAAAAg4AAgBVAAIADQABAA8ANQABAEsATAABAF0AXQABAG0AbQACAHgAeAABAKEAoQABAKcAqAABAMMAwwABAMwAzAABAOUA5QABAPsA/AABAQIBAgACAQ0BDQABARkBGQACAR0BHQACAScBJwACAS0BLgABATMBMwACAVUBVQABAVsBXAABAWwBbAACAXkBeQABAYIBggABAZoBnQABAZ4BowACAwcDBwABAwwDDAABAxIDEgADAxQDTAADA24DbgABA3IDcgABA3QDdAABA3YDdgABA3wDfAABA34DfgABA4EDgQABA4UDhQABA5MDkwABA5UDlQABA58DoAADA6EDoQABA6QDpAABA6YDpwABA6kDqQABA6sDqwABA68DrwABA7QDtAABA7cDuAABA7wDvAABA74DwAABA9ID0gABA9wD3QABA+kD6QABA+wD7AABA+8D7wABA/ED8gABA/QD9AABA/YD9gABA/oD+gABA/8D/wABBAIEAwABBAcEBwABBAkECwABBBAEEAABBB0EHQABBCcEKAABBDQENAABBDkEOgADBEYEUQABBFMEXwABBHYEdgABBNIE0wABBO4E7gABBPcE9wABBRAFEAABBVIFUgABBVQFVAABBVYFVgABBV8FXwABBWIFYwABBWcFZwABBWkFawABBX0FfQABBYgFiAABAAIAGwMSAxIAAQMUAxQAAQMWAxYAAQMYAxgAAQMaAxoAAQMcAxwAAQMeAx4AAQMgAyAAAQMiAyIAAQMkAyQAAQMmAyYAAQMoAygAAQMxAzEAAQM1AzUAAQM3AzcAAQM5AzkAAQM7AzsAAQM9Az0AAQM/Az8AAQNBA0EAAQNDA0MAAQNFA0UAAQNHA0cAAQNJA0kAAQNLA0sAAQOfA6AAAQQ5BDkAAQABAAAACgG0CWIABERGTFQAGmN5cmwASGdyZWsAuGxhdG4A5gAEAAAAAP//ABIAAAAIABAAGAAgACgAMAA4AEYATgBWAF4AZgBuAHYAfgCGAI4AEAACTUtEIAA8U1JCIABEAAD//wATAAEACQARABkAIQApADEAOQBAAEcATwBXAF8AZwBvAHcAfwCHAI8AAP//AAEAQQAA//8AEwACAAoAEgAaACIAKgAyADoAQgBIAFAAWABgAGgAcAB4AIAAiACQAAQAAAAA//8AEgADAAsAEwAbACMAKwAzADsASQBRAFkAYQBpAHEAeQCBAIkAkQAWAANBWkUgAEBDUlQgAGxUUksgAJgAAP//ABIABAAMABQAHAAkACwANAA8AEoAUgBaAGIAagByAHoAggCKAJIAAP//ABMABQANABUAHQAlAC0ANQA9AEMASwBTAFsAYwBrAHMAewCDAIsAkwAA//8AEwAGAA4AFgAeACYALgA2AD4ARABMAFQAXABkAGwAdAB8AIQAjACUAAD//wATAAcADwAXAB8AJwAvADcAPwBFAE0AVQBdAGUAbQB1AH0AhQCNAJUAlmFhbHQDhmFhbHQDjmFhbHQDlmFhbHQDnmFhbHQDpmFhbHQDrmFhbHQDtmFhbHQDvmMyc2MDxmMyc2MD0GMyc2MD2mMyc2MD5GMyc2MD7mMyc2MD+GMyc2MEAmMyc2MEDGNhc2UEFmNhc2UEHGNhc2UEImNhc2UEKGNhc2UELmNhc2UENGNhc2UEOmNhc2UEQGNjbXAERmNjbXAETmNjbXAEVmNjbXAEXmNjbXAEZmNjbXAEbmNjbXAEdmNjbXAEfmRub20EhmRub20EjGRub20EkmRub20EmGRub20EnmRub20EpGRub20EqmRub20EsGZyYWMEtmZyYWMEwGZyYWMEymZyYWME1GZyYWME3mZyYWME6GZyYWME8mZyYWME/GxpZ2EFBmxpZ2EFDGxpZ2EFEmxpZ2EFGGxpZ2EFHmxpZ2EFJGxpZ2EFKmxpZ2EFMGxudW0FNmxudW0FPGxudW0FQmxudW0FSGxudW0FTmxudW0FVGxudW0FWmxudW0FYGxvY2wFZmxvY2wFbGxvY2wFdGxvY2wFfGxvY2wFgmxvY2wFiG51bXIFjm51bXIFlG51bXIFmm51bXIFoG51bXIFpm51bXIFrG51bXIFsm51bXIFuG9udW0Fvm9udW0FxG9udW0Fym9udW0F0G9udW0F1m9udW0F3G9udW0F4m9udW0F6G9yZG4F7m9yZG4F9G9yZG4F+m9yZG4GAG9yZG4GBm9yZG4GDG9yZG4GEm9yZG4GGHBudW0GHnBudW0GJHBudW0GKnBudW0GMHBudW0GNnBudW0GPHBudW0GQnBudW0GSHNpbmYGTnNpbmYGVHNpbmYGWnNpbmYGYHNpbmYGZnNpbmYGbHNpbmYGcnNpbmYGeHNtY3AGfnNtY3AGhnNtY3AGjnNtY3AGlnNtY3AGnnNtY3AGpnNtY3AGrnNtY3AGtnN1YnMGvnN1YnMGxHN1YnMGynN1YnMG0HN1YnMG1nN1YnMG3HN1YnMG4nN1YnMG6HN1cHMG7nN1cHMG+nN1cHMHBnN1cHMHEnN1cHMHHnN1cHMHKnN1cHMHNnN1cHMHQnRudW0HTnRudW0HVHRudW0HWnRudW0HYHRudW0HZnRudW0HbHRudW0HcnRudW0HeHplcm8Hfnplcm8HhHplcm8Hinplcm8HkHplcm8Hlnplcm8HnHplcm8Honplcm8HqAAAAAIAAAABAAAAAgAAAAEAAAACAAAAAQAAAAIAAAABAAAAAgAAAAEAAAACAAAAAQAAAAIAAAABAAAAAgAAAAEAAAADAAgACQAKAAAAAwAIAAkACgAAAAMACAAJAAoAAAADAAgACQAKAAAAAwAIAAkACgAAAAMACAAJAAoAAAADAAgACQAKAAAAAwAIAAkACgAAAAEABwAAAAEABwAAAAEABwAAAAEABwAAAAEABwAAAAEABwAAAAEABwAAAAEABwAAAAIABQAGAAAAAgAFAAYAAAACAAUABgAAAAIABQAGAAAAAgAFAAYAAAACAAUABgAAAAIABQAGAAAAAgAFAAYAAAABAA0AAAABAA0AAAABAA0AAAABAA0AAAABAA0AAAABAA0AAAABAA0AAAABAA0AAAADAAwADgAPAAAAAwAMAA4ADwAAAAMADAAOAA8AAAADAAwADgAPAAAAAwAMAA4ADwAAAAMADAAOAA8AAAADAAwADgAPAAAAAwAMAA4ADwAAAAEAGgAAAAEAGgAAAAEAGgAAAAEAGgAAAAEAGgAAAAEAGgAAAAEAGgAAAAEAGgAAAAEAGAAAAAEAGAAAAAEAGAAAAAEAGAAAAAEAGAAAAAEAGAAAAAEAGAAAAAEAGAAAAAEAAwAAAAIAAwAEAAAAAgADAAQAAAABAAIAAAABAAIAAAABAAIAAAABAAwAAAABAAwAAAABAAwAAAABAAwAAAABAAwAAAABAAwAAAABAAwAAAABAAwAAAABABYAAAABABYAAAABABYAAAABABYAAAABABYAAAABABYAAAABABYAAAABABYAAAABABAAAAABABAAAAABABAAAAABABAAAAABABAAAAABABAAAAABABAAAAABABAAAAABABcAAAABABcAAAABABcAAAABABcAAAABABcAAAABABcAAAABABcAAAABABcAAAABABQAAAABABQAAAABABQAAAABABQAAAABABQAAAABABQAAAABABQAAAABABQAAAACAAkACwAAAAIACQALAAAAAgAJAAsAAAACAAkACwAAAAIACQALAAAAAgAJAAsAAAACAAkACwAAAAIACQALAAAAAQAUAAAAAQAUAAAAAQAUAAAAAQAUAAAAAQAUAAAAAQAUAAAAAQAUAAAAAQAUAAAABAAQABEAEgATAAAABAAQABEAEgATAAAABAAQABEAEgATAAAABAAQABEAEgATAAAABAAQABEAEgATAAAABAAQABEAEgATAAAABAAQABEAEgATAAAABAAQABEAEgATAAAAAQAVAAAAAQAVAAAAAQAVAAAAAQAVAAAAAQAVAAAAAQAVAAAAAQAVAAAAAQAVAAAAAQAZAAAAAQAZAAAAAQAZAAAAAQAZAAAAAQAZAAAAAQAZAAAAAQAZAAAAAQAZABwAOgBCAEoAUgBaAGIAagB0AHwAhACMAJQAnACkAKwAtADAAMgA0ADYAOAA6ADwAPgBAAEIARABGAABAAAAAQlYAAMAAAABDiQAAQAAAAEA1gABAAAAAQDUAAEAAAABANIABAAAAAEA0AAGAAAAAgFyAYQAAQAAAAEBjAABAAAAAQHEAAEAAAABBC4AAQAAAAEELAABAAAAAQRSAAEAAAABBtIAAQAAAAEG8AABAAAAAQcOAAYAAAADBwwHHgcwAAEAAAABBzgAAQAAAAEHbgABAAAAAQdsAAEAAAABB4oAAQAAAAEHkAABAAAAAQeuAAEAAAABB9QAAQAAAAEH+gABAAAAAQggAAEAAAABCEYABAAAAAEIRAABAAAAARB2AAEQrgEEAAEQrgEbAAEQsABKAAEQsAANACAAKgA0AD4ASABSAFwAZgBwAIIAjACWAKAAAQAEAEsAAgMsAAEABABdAAIDLAABAAQAbQACAxoAAQAEAHgAAgMsAAEABADDAAIDLAABAAQA+wACAywAAQAEAQIAAgMoAAEABAENAAIDLAACAAYADAEdAAIDGgEZAAIDKwABAAQBJwACAywAAQAEATMAAgMoAAEABAFsAAIDKAABAAQBeQACAywAAwABECQAARBeAAAAAQAAABsAAwABEGYAARBMAAAAAQAAABsAAhBuAB0BzwHQAdEB0gHTAdQB1QHWAdcB2AHgAeMCAAIBAgICAwIEAgUCBgIHAggCCQIKAgsCDAINAg4CHgOZAAIQaAE2BEYERwRIBEkESgRLBEwETQROBE8EUARRBFIEUwRUBFUEVgRXBFgEWQRaBFsEXARdBF4EXwRgBGEEYgRjBGQEZQRmBGcEaARpBGoEawRsBG0EbgRvBHAEcQRyBHMEdAR1BHYEdwR4BHkEegR7BHwEfQR+BH8EgASBBIIEgwSEBIUEhgSHBIgEiQSKBIsEjASNBI4EjwSQBJEEkgSTBJQElQSXBJgEmQSaBJsEnASdBJ4EnwSgBKEEogSjBKQEpQSmBKcEqASpBKoEqwSsBK0ErgSvBLAEsQSyBLMEtAS2BLUEtwS4BLkEugS7BLwEvQS+BL8EwATBBMIEwwTEBMUExgTHBMgEyQTKBMsEzATNBM4EzwTQBNEE0gTTBNQE1QTWBNcE2ATZBNoE2wTcBN0E3gTfBOAElgThBOIE4wTlBOYE5wToBOkE6gTrBOwE7QTuBO8E8ATxBPIE8wT0BPUE9gT3BPgE+QT6BPsE/AT9BP4E/wUABQEFAgUDBQQFBQUGBQcFCAUJBQoFCwUMBQ0FDgUPBRAFEQUSBRMFFAUVBRYFFwUYBRkFGgUbBRwFHQUeBR8FIAUhBSIFIwUkBSUFJgUnBSgFEQUVBRcFGQUpBR8FJAUqBSgFTAVNBU4FTwVQBVEFUgVTBVQFVQVWBVcFWAVZBVoFWwVcBV0FXgVfBWAFYQViBWMFZAVlBWYFZwVoBWkFagVrBWwFbQVuBW8FcAVxBXIFcwV0BXUFdgV3BXgFeQV6BXsFfAV9BX4FfwWABYEFggWDBYQFhQWGBYcFiAWJBYoFiwWMBY0FjgWPBZAFkQWSBZMFlAWVBZYAAQ4SA4oAAg4WABQFLgU5BToFOwU8BT0FPgU/BUAFQQVCBUMFRAVFBUYFRwVIBUkFSgVLAAIOFAFBBEYERwRIBEkESgRLBEwETQROBE8EUARRBFIEUwRUBFUEVgRXBFgEWQRaBFsEXARdBF4EXwRgBGEEYgRjBGQEZQRmBGcEaARpBGoEawRsBG0EbgRvBHAEcQRyBHMEdAR1BHYEdwR4BHkEegR7BHwEfQR+BH8EgASBBIIEgwSEBIUEhgSHBIgEiQSKBIsEjASNBI4EjwSQBJEEkgSTBJQElQSXBJgEmQSaBJsEnASdBJ4EnwSgBKEEowSiBKQEpQSmBKcETgRPBKgEqQRQBKoEqwSsBK0ErgSvBLAEsQSyBLMEtAS2BLUEtwS4BLkEugS7BLwEvQS+BL8EwATBBMIEwwTEBMUExgTHBMgEyQTKBMsEzATNBM4EzwTQBNEE0gTTBNQE1gTVBNcE2ATZBNoE2wTcBN0E3gTfBOAEWAUrBOEE4gTjBOQE5QTmBOcE6ATpBOoE6wTsBO0E7gTvBPAE8QTyBPME9AT1BPYE9wT4BPkE+gT7BPwE/QT+BP8FAAUBBQIFAwUEBQUFBgUHBQgFCQUKBQsFDAUNBQ4FDwUQBSwFLQURBRIFEwUUBRUFFgUXBRgFGQUaBRsFHAUdBR4FHwUgBSEFIgUjBSQFJQUmBScFKAUiBREFFQUXBRkFKQUfBSQFKgUoBSkFKgVMBU0FTgVPBVAFUQVSBVMFVAVVBVYFVwVYBVkFWgVbBVwFXQVeBV8FYAVhBWIFYwVkBWUFZgVnBWgFaQVqBWsFbAVtBW4FbwVwBXEFcgVzBXQFdQV2BXcFeAV5BXoFewV8BX0FfgV/BYAFgQWCBYMFhAWFBYYFhwWIBYkFigWLBY0FjAWOBY8FkAWRBZIFkwWUBZUFlgVNAAILtAAQAlQCVQJWAlcCWAJZAloCWwJcAl0CYgJjAl4CXwJgAmEAAguOABACRAJFAkYCRwJIAkkCSgJLAkwCTQJSAlMCTgJPAlACUQABC34ApwADAAELfgABC4gAAAABAAAAGwADAAELfgABC44AAAABAAAAGwADAAILkAuGAAELfAAAAAEAAAAbAAILhAAcAoACgQKCAoMChAKFAoYChwKIAokCigKLAowCjQKOAo8CkAKRApICkwKUApUClgKXApgCmQKaApsAAQtWAmQAAgrmABACIAIhAiICIwIkAiUCJgInAigCKQIuAi8CKgIrAiwCLQACCzQABAIwAjECMgIzAAIKsgAQAjQCNQI2AjcCOAI5AjoCOwI8Aj0CQgJDAj4CPwJAAkEAAgsMABQBpQGmAacBqAGpAaoBqwGsAa0BrgG7AbwBvQG+Ab8BwAHBAcIBwwHEAAIK7gAUAbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcoBywHMAc0BzgACCtAAFAGwAbEBsgGzAbQBtQG2AbcBuAG5AcUBxgHHAcgByQHKAcsBzAHNAc4AAgqyABQBpQGmAacBqAGpAaoBqwGsAa0BrgGwAbEBsgGzAbQBtQG2AbcBuAG5AAEKjgAKAAEKkAABAAgABgAOABYAHgAkACoAMAGiAAMAIQAkAaMAAwAhACcBoQACACEBngACACQBnwACACcBoAACAC8AAgpYAmcEYARhBGIEYwRkBGUEZgRnBGgEaQRqBGsEbARtBG4EbwRwBHEEcgRzBHQEdQR2BHcEeAR5BHoEewR8BH0EfgR/BIAEgQSCBIMEhASFBIYEhwSIBIkEigSLBIwEjQSOBI8EkASRBJIEkwSUBJUElwSYBJkEmgSbBJwEnQSeBJ8EoAShBKIEowSkBKUEpgSnBKgEqQSqBKsErAStBK4ErwSwBLEEsgSzBLQEtgS1BLcEuAS5BLoEuwS8BL0EvgS/BMAEwQTCBMMExATFBMYExwTIBMkEygTLBMwEzQTOBM8E0ATRBNIE0wTUBNUE1gTXBNgE2QTaBNsE3ATdBN4E3wTgBJYE4QTiBOME5QTmBOcE6ATpBOoE6wTsBO0E7gTvBPAE8QTyBPME9AT1BPYE9wT4BPkE+gT7BPwE/QT+BP8FAAUBBQIFAwUEBQUFBgUHBQgFCQUKBQsFDAUNBQ4FDwUQBGAEYQRiBGMEZARlBGYEZwRoBGkEagRrBGwEbQRuBG8EcARxBHIEcwR0BHUEdgR3BHgEeQR6BHsEfAR9BH4EfwSCBIMEhASFBIYEhwSIBIkEigSLBIwEjQSOBI8EkASRBJIEkwSUBJUElwSYBJkEmgSbBJwEnQSeBJ8EoAShBKMEogSkBKUEpgSnBE4ETwSoBKkEUASqBKsErAStBK4ErwSwBLEEsgSzBLQEtgS1BLcEuAS5BLoEuwS8BL0EvgS/BMAEwQTCBMMExATFBMYExwTIBMkEygTLBMwEzQTOBM8E0ATRBNIE0wTUBNYE1QTXBNgE2QTaBNsE3ATdBN4E3wTgBFgFKwThBOIE4wTkBOUE5gTnBOgE6QTqBOsE7ATtBO4E7wTwBPEE8gTzBPQE9QT2BPcE+AT5BPoE+wT8BP0E/gT/BQAFAQUCBQMFBAUFBQYFBwUIBQkFCgULBQwFDQUOBQ8FEAUsBS0FLgHGAccByAHJAcoBywHMAc0BzgHFAcYBxwHIAckBygHLAcwBzQHOAjAFOQU7BT0FPgU/BUAFQQVCAgACAQICAgMCBQIIAh4EOQQ6BREFEgUTBRQFFQUWBRcFGAUZBRoFGwUcBR0FHgUfBSAFIQUiBSMFJAUlBSYFJwUoBREFFQUXBRkFKQUfBSQFKgUoBREFEgUTBRQFFQUWBRcFGAUZBRoFGwUcBR0FHgUfBSAFIQUiBSMFJAUl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AAEI2AAGAQAAAQlqAAIAAAAMCgAg4i8CPuJPZl7kcVCC7pMQopSyGMCwAGQAAAAAAAAAAAABx6bH4gABAAwAfgAcAAABAgAAAQIAAAECAAABAgAAAQIAAAECAAABAgAAAQIAAAECAAABAgAAAQIAAAECAAABAgAAAQIAAAECAAABAgAAAQIAAAECAAABAgAAAQIAAAECAAABAgAAAQIAAAECAAABAgAAAQIAAAECAAABAgBHAJYAnACiAKgArgC0ALoAwADGAMwA0gDYAN4A5ACiAOoA8AD2APwBAgEIAQ4BFAEaASABJgCWASwBMgE4AT4AogCiAUQBCAEIAUoBUAFWAQgBXAFiAWgBbgF0AXoBdAGAAYYBjACiAZIAlgGYAK4BngGkAQgAogEgAaoBsAG2AbwBwgEIARoAogEOAQ4AogABAAAB+wABAPUB+wABAIQC4gABARIB+wABAY4C4gABARQB+wABASYC7gABAQMB+wABAIoC4gABAJkCwwABAJgCwwABAJYC4gABAJAC4gABAcQB+wABATYB+wABATAB+wABAS0B+wABAPIB+wABAOIB+wABAKICfgABARsB+wABAQgB+wABAYgB+wABAQ0B+wABAQ8B+wABAO8B+wABAZEB+wABAQkB+wABAJQB+wABAJoB9wABAccB+wABAQ8C4gABAP0B9wABASAB+wABAMgC3gABAMgCyQABAR8B+wABAOUB+wABARUB+wABAJEB+wABASkB+wABARgB8QABAW4B+wABAPwB+wABAP4B+wABAXsB+wABAUIB+wABATgB+wABAQAB+wABAXgB8QABAOQB+wABAYMB+wABxi7GZAABAAwAcgAZAAABKAAAASgAAAEoAAABKAAAASgAAAEoAAABKAAAASgAAAEoAAABKAAAASgAAAEoAAABKAAAASgAAAEoAAABKAAAASgAAAEoAAABKAAAASgAAAEoAAABKAAAASgAAAEoAAABKABgAMgAzgDUANoA4ADmAOwA8gD4AP4BBAEKARABFgEcARYBIgEoAS4BNAE6AUABRgFMAVIAyAFYAOAA+AFeARYBZAE0AWoA4ADIAOYA4AFwAXYBfAEWAYIBiAGOAZQBmgGgAQQBFgGmAaYBFgGsAawBsgG4Ab4BuAHEAcoB0AHWAdwB1gHiAegB7gH0AfoCAAIGAgwCEgIY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/9AAu//QANP/xwDU/8cA1f/HANb/xwDX/8cA2P/HANn/xwDa/8cA2//HANz/xwDd/8cA3v/HAeT/vAHl/7wB5gAAAecAAQHoAAAB6QABAhP/xgIa/8YCG///Ahz//wIg/70CIf+9AiL/vQIj/70CJP+9AiX/vQIm/70CJ/+9Aij/vQIp/70CZP/HAmX/xwJm/8YCZ//GAmj/xwJp/8YCav/GAmv/xgJs/8cCbf/GAm7/xgJw/8YCcf/GAnL/xgJz/8YCdP/HAnX/xgJ2/8cCd//GAnj/xwJ5/9ECev/HAnv/0QJ8/9ECff/GAn7/0QJ//8YCgP/HAoH/xgKC/8cCg//HAoT/xwKF/8YChv/HAof/xgKI/8YCiv/GAov/xgKM/8YCjf/GAo7/xwKP/8cCkP/HApH/xgKS/8cCk//HApT/xwKV/9EClv/RApf/xgKY/8cCmf/GApr/xwKb/8cEP///BED//wABASQAAAABASQAAAABAST//wABAST//wABAST//wABAST//wABAST//wABAST//wABAST//wABAST//wABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAABASQAAAAFAOn/0ADq//4BJAAAASUAKAEmAAEABQDp/9AA6v/+ASQAAAElACgBJgABAAUA6f/QAOr//gEkAAABJQAoASYAAQAFAOn/0ADq//4BJAAAASUAKAEmAAEABADp/8YA6v/+ASL/7QEk/+0ABADp/8YA6v/+ASL/7QEk/+0ABADp/8YA6v/+ASL/7QEk/+0ABADp/8YA6v/+ASL/7QEk/+0ABADp/8YA6v/+ASL/7QEk/+0ABADp/8YA6v/+ASL/7QEk/+0ABADp/8YA6v/+ASL/7QEk/+0ABADp/8YA6v/+ASL/7QEk/+0ADAAX/8QAGf/EAEz/sAGa/+wBsf/tAbL/9QGz/+wBt//hAfn/cwIP/+ECEf/rAh4AEwAGADEAAQAyAAEBiQABAYoAAQGLAAEBjAABAAYA6gAC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AbT/7QIP/9oABAGx//YBt//1Abn/9gHG//YABQGx/+MBs//2Abf/7QG5/+0Byv/tAAUBs//2AbT/4wG3//YBuf/2Ac7/7AACAbcAEwHK//YACQG0/80BtwATAcX/7AHG/+MBx//ZAcj/2QHJ/6YByv/XAc7/7AABAcwAEwALAbL/9gGz/+wBtP/OAbX/6wG5/+wBxf/rAcf/7AHI/+wByf/sAcr/7AHO/+IACAGx/+wBsv/tAbf/4QG5/+wBx//sAcj/7AHK/+0BzP/ZAAIBtP/tAc7/7QACAbf/4gHM/+MAAwG3/+IBuf/2Acz/7QACAbT/2AHJ/7sAEgGx/+wBsv/sAbP/9gG3//UBuf/2Afn/6gIP/+sCEf/sA1L/9gNe//YDX//sA2L/4gNj/84Db//2A3j/9gOA/+IDg//1A5n/7AAJAbn/9gH4/+wCHgAKA1//9gNh/+IDY//sA4D/2AOD/+EDmP/sAAoBuf/rAfj/zgIe/+wDUgAKA2H/zANk//YDcf/2A4D/xAOD/80DmP/DAF8BsP//AbH/4gGy/+sBs//rAbT/4QG1/+sBtv/rAbj/9QG5/+wBuv//Acv/6wHN//UB2f/hAdr/4QHb//YB3P/2Ad3/4QHt//UB7//1AfD//wHy//8B8///AfT//wH1//8B9v//Aff/9gH5/8QB+v//Afz//wH+//8CAf/1AgP/9QIE//8CBv//Agf//wII//8CCf//Agv//wIN//8CD//gAh7/9gI0/9YCNf/WAjb/1gI3/9YCOP/WAjn/1gI6/9YCO//WAjz/1gI9/9YCbwAeAokAHgLK//YDTf/XA07/9gNP//YDUP/XA1H/9gNT//YDVP/sA1X/9gNW//YDV//XA1v/7ANc//YDXf/2A2L/9gNp//YDbv/0A3D/6wN0//UDd//1A3r/6wN8//QDf//0A4H/6wOC//QDg//rA4T/6wOF//QDhv/0A4f/9AOJ//UDjP/0A43/6wOO/+sDj//0A5H/6wOT//QDlP/0A5f/9gOY//YEPP//BD3//wARAbT/6wH5/3ICD//NAhEACgIeAAkDUgAJA17/9gNfAAoDYv/sA2P/9gNk//YDcf/sA3P/7AN4/+wDfv/YA4MAFAOXAAoADwGx/+wBsv/1AbP/7AG3/+EB+f9zAg//4QIR/+sCHgATA1L/9QNe/+ADX//0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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7P/y//b/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/7EAAAAA//YAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4gAAAAD/uv/s//b/xAAAAAAAAAAA/+IACv/2/+v/9v/Y/+z/6wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/r//X/2P/2//UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/1/+IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/s//YAAAAA//YAAP/2/+v/7AAzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/s/+L/4v/rAAAAAP/s//b/9v/2//b/9v/2/+z/9QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAA//b/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/uv/iAAAAAAAAAAD/zP+6/+wARgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoAAAAKAAAAAAAA//b/1//OAAAAAAAAAAD/zP/Y/+v/7P/O//YAAAAAAAAAAAAAAAr/4QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/2AAAAAAAAAAAAAAAAAAAAAAAAP/W/+EAAAAA/+L/9f/2ABT/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/5v/9gAAAAoAHgAU/4j/9QAAAB8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAKAAAAAAAAAAAAAAAAAAD/7AAAABQAAAAA/8L/sAAK//b/7AAAAAAACgAAAAAAAAAA/8MAAAAAAAAAAAAA/+IACv/2ABQAFAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAD/zAAAAAAAAP+6ABQAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+4//YAAAAA//YACgAAAAAAAAAA/+IAAP/r/+v/6/+mAAD/4gAKABQACv+IAAAAAAAVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+z/9f/rAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAHf/X/8T/9QAU/+v/1//T/+L/4f/1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/xAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/xAAA/+wAAAAAAAD/zgAAAAAAHgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAP/2AAD/7AAAAAAAAAAA/+H/4gAAAAD/1//1AAAAAAAAAAD/4f/i/+sAAAAA//b/4QAAAAAAAAAAAAD/4v/6/+IAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+v/7P/m/+sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACnWQABAAAqhqqnAAWAFwAAAAK/+L/9v/s/83/7AAU/+z/4f/q//b/4v+w/+wAEgAS//UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABP/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoAAAAAAAAAAP/1ABMAAAAAAAD/wv/2//YACgAK/+z/9v/sAAn/7AAK//b/7AATAAoAFAAK/5v/9gAKABQAFAAU/4gAHwAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/XABMAE//2//YAEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/1gAK/7oAAAAAAAAAAAAAAAAACgAAAAoAAAAA/7oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/sP/iAAAAAAAAAAD/zABGAAAAAAAAAAAAAAAAAAD/4f/q/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/gABMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+v/9P/EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+S/+wAAP/NAAD/xAAe/9j/uwAA/+wAAAAA/+sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9v+vAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/X/+L/6wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/5z/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/r//b/2P+x/+sAAAAAAAAAAAAAAAAAAAAAAAD/9v/2AAAAAAAKAAAAAAAA/+L/4v+6/87/9gAAAAAAAAAAAAD/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/iAAAAAAAAAAAAAAAAAAAAAP/t//b/2AAA/8//7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+r/4QAK/+z/4f/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/0/+sAFP/2/+sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKNtAAEAACiBKKkABsATgAA//b/9v/i//b/6//2ACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/wwAAAAAAAAAAAAD/xP/D//b/9v/2/8T/4v/D/8P/9v/2/+v/4v/r/+0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4P/2//3//f/2//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAr/4gAAAAAAAAAAAAAACv/iAAAAAP/2AAr/9v/s/+IAAAAAAAAAAAAAAAD//AAA//z//AAAAAD/9gAK//X/9v/2AAoACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+L/sf/rAAD/2P+wAAD/w/+xAAAAAABH/8P/zf+m/7EAAAAT/+H/6wAA/+0AAAAAAAAAAAAAAAAAAP/iAAAAAAAA/+IAAAAd/+sAXP/1/+sAHf+w/7AAE//sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/1//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/2AAAAAAAAAAAAAD/7P/YAAAAAP/t/+wAAP/h/9gAAAAAAAAAAP/XAAD/4AAA/+D/4AAAAAAAAAAA/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAUAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9v/2//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAP/rAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2ACj/4v+nAAAAAAAAAAAAAAAAAAAAAP/sAAAAAP/1AAD/9v/2AAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/rAAAAAAAAAAAAAAAAAAD/9v/2/7n/4v/s/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAAAAAAAP/1/+L/4v/h/+EAAP/iAAAACv/2AAAAAAAAAAD/4f/3AAAAAAAAAAAAAP/sAAAAAAAAAAAACQAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAA/+z/7AAAAAAACf/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAW//X/7P/X/8T/9gAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAIAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//b/9v/1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9v/1AAD/9gAAADwAAP/2AAAAAAAAAAD/9v/2//YAAP/aAAAAAAAA//b/7AAA/+z/7AAAAAAAAAAAAAAAAAAAAAAAAP/2//YAAAAA//b/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAAAAAAAP/2AAD/9gAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/0AAAAB8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+IAAAAAAAAAAAAAAAAAAAAA//b/9v/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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/+wAAP/2/+z/9gAAAAAAAAAA//b/9v/s/+wAAP/2AAD/2f/j//b/4/+y/+P/xP/O/9j/z//s/7z/z/+n/7L/vP/O//b/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//b/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+z/9QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAA/7sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/zv/Y/7H/9gAAAAAAAAATAAAAAAAAAAAAAP/2AAAAAAAA/+z/7AAA/+wAAAAAAAD/w//iAAD/7AAhABIAAAAA/+wAIP/s//YACgAfAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/8UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/iQAAAAAAAAAAAAAAAP/XAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAP/X//b/9gAAAAAAAAAAAAAAAAAAAAAAAAAA/+L/2P/F/+z/7P/s//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKQAAAAAAAAAAABYAAP/2AAAAAAAA//X/9v/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/rAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+4//b/uP/2/7j/9gAA/9gAAAAAAAD/4f/Y//b/9gAA/9f/9v/1AAD/9gAA/+H/2P/r//b/9v/s/+cAAP/2AAD/zv/E/8//6wAAAAAAFAAA/9gAAAAAAAAAAAAAAAAAAP+RAAAAAAAAAAAAAAAAAAAAKf/s//b/4f/s/9b/zQAU/+L/7P/iABP/4v+bAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7AAKAAAAAP/1//YAAAAAAAD/9gAAAAAAAAAAAAD/9f/2AAAAAAAAAAAAAAAAAAD/7P/s/+z/4//2AAAAFQATABP/9QAAAAD/2gAAAAAAEwAA/68AAAAAAAAAAAAA//YAAAAzAAAAAAAAAAAAAP/rAAAAAAAAAAAAAAAA/7D/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/zgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+5AAD/uQAA/7kAAAAK/+EAAAAAAAD/4f/iAAAAAAAA/+IAAP/1AAAAAAAA/+H/4v/1AAAAAAAA//YAAAAAAAD/1v/E/+EAAAAAAAAAAAAA/+IAAAAAAAAAAAAAAAAAAP91AAAAAAAAAAAAAAAAAAAAAP/9AAD/6//rAAAAAAAe/+z/9f/sAB7/7AAAAAD//f+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+IAAAAA/+3/4gAAAAAAAAAA/+IAAAAAAAD/7QAA/+IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//f/7f/t/+P/4wAA/+L/4v/s/+MAAP/t//f/sf/P/+z/4gAA/+0AAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/6wAAAAAAAP/iAAD/9gAAAAD/4v/2AAD/9gAA/+v/4gAA//YAAAAAAAAAAAAAAAD/9gAA/+z/2f/ZAAAAAAAAAAAAAAAAAAAAAP/iAAAAAAAAAAD/9gAAAAAAAAAAAAAAAAAAACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+0AAP/t/+P/7f/sAAAAAP/tAAD/7f/t/7H/z//tAAAAAAAAAAAAAAAAAAAAAAAA//YAFgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/zQAA/80AAP/N/3MAAP/N/67/kv/1/87/xv+5/5L/zv+5/9j/rv+c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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//IAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAP/sAAD/1wAA/9cAAP/sAAAAAAAAAAAAAP/sABQACwAUAAAAAAAAAAAAAAAAAAoAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAAAAD/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/uAAAAAoAAP/2AAAAAP/W/8T/uv/E/9f/2AAA/87/1v/sAAD/2AAdABUAHgAU/+oACgAUAB0AEwAUABwAAP/2AAAAAAAUAAD/7P/Y/80AAAAAAAoAAP/gAAAAAAAAAAAAAAAAAAAAAAAA/80AAP/EAAAAAAAnAAAAAAAA/67/uf+v/+D/zf+c//b/r/91/+v//f/h/7D/1v/t/6YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/wgAAABMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/D/3//9QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//EAAP/sAAD/7P/s/+sAAAAAAAAAAAAA/+sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//X/7AAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAA/+IAAP/2//b/uf/s/9f/zv/D/+r/4f/iAAAAAP+wAAAAAAAAAAD/7AAAAAAAEgAAAAAAEv/1/9gAAP/iAAD/4v/O/+IAAAAA/+sAAAAA/9cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAP/sAAAAAP/iAAD/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/2AAA//b/6AAK/+H/2AAAAAAAAAAAAAAAAAAKAAoACgAA/+wAAP/jAAAAAP/2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AAAAAAAAAAAAAAAA//L/9gAAAAAAAAAAAAAAAAAAAAAAAAAKAAD/zgAA//YAAP+wAAD/4gAA/+z/9v/sAAAAAP/2AAAAAAAA/8T/zv/i/9j/9v/Y/+P/kv/E/9j/zgAAAAAAAAAA/9gAAP/2AAD/7AAA/+L/6wAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYAAP/tAAAAAAAAAAD/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+z/6wACXCwABAAAhx6I/AAVAGsAAP/2/+z/7P/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAD/9//2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAA//YAAP/1/9j/9f/E/+z/7P/2/8T/6wAz//b/9f/s/+z/9P/rAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+H/zv/iAAAAAAAAAAAAAAAA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AAAAAAAA/+wAAAAAAAAACv/2//b/2f+m/+z/w//s/+z/7P/X//X/7v/E/+D/nP/D/7v/kv/2/83/9v/D/+z/9QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFP/j/7D/4f+m/80AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAD/9QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//EAAP/1AAAAAAAA//YAAAAA/+v/5//2AAAAAAAAAAD/6wAA/+IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/+//xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFQAAAAD/2P/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/1AAAAAAAA//YAAP/2AAAAAAAAAAD/9gAA/+wAAAAAAAAAAP/sAAAAAAAAAAAAAAAA/+gAAP/s/9j/7AAA/+z/4gAAAAAAAP/hAAAAAAAAAAAAAP/i//b/zv/2AAAAAAAAAAAAAAAAAAD/7P/2//b/9v/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+P/8gAA/+sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+vAAAAAAAAAAAAAAAAAAAAAAAUAB0AEwAnAAAAAP/NAAAACv+uAAAAAAAAAB0AAAAAAAAAAP/WAAAAHgAU/68ACgAUABwAAAAUAAAAAAAA/9YAAAAAAAAAAAAAABQAAAAA/+wAAAAAAAAAAAAA/+r//f/rAAD/sAAAAAD/9gAA/8T/6//OAAv/zv/hAAD/7P/Y/9cAAAAKAAAAAP/2/+v/9f/OAAAAAAAAAAAAAAAAAAAAAP/gAAD/4v/Y/6b/4gAJ/+3/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/ugAAAAD/4QAAABQAAAAAAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/rAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAA/8QAAAAAAAAAAAAAAAAAAAAAAAAAAP/Y/+wAAP/OAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/YAAAAAAAAAAAAAAAAAAAAAAAA/87/9QA0AAAAAAAA//YAAP/OAAAAAAAA/+MAAAAAAAAAAAAK/+wAAP/2/9gAAAAKAAAAAP/2AAAAAAAA/+3/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAD/2P/o/+wACv/ZAAAAAAAAAAAAAAAAAAoAAAAAAAD/7P/2AAD/4gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+L/7AAU//UAAksoAAQAAH1WfnQAEQB5AAD/4v/y//YAFP/j/+z/9v/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/pv/O/6v/uf+6/8T/ugAe/7r/sP/F/53/2f/Y/8T/sf/P/6j/uv+cABQACv/h/7r/zP/W/8T/zf/FAAv/2P/O/7D/4v/Y/6//2f/j/8T/xf+m/6b/4/+m/+L/4v/i/5L/7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/7AAAAAA/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/9YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoABQAAAAAAAAAAP/sAAAAAAAV//sAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAD/7AAAAAAAAAAAAAAAAAAUABQACgAKABUAFQAVABUAKQAVAAoAHgAeAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9v/2AAAAAAAAAAAAAAAAAAoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/i//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/8wAAAAAAAAAAAAFAAAAAAAAAAAAAP/EAAAAAAAJ//YAAAAAAAD/rv/iAAAACgAAAAD/9AAA//YAAAAAAAAAAAAJAAD/9f/1AAr/7AAAAAD/9v/XAAAAAAAA//X/9v+4AAAAAP/r/9wAFAAUAAAACgAKAAAAJwAT/87//QAAAAD/6//r/87/9f/h//QAEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/2AAAAAAAAAAAAAAAAAAAAAD/9gAA/+wAAAAAAAAACgAAAAAAAP/i/6b/4gAAAAAAAAAA//YAAAAA/+sAAAAA//YAAP/2AAAAAP/jAAAAAAAA/+wAAP/sAAD/9v/2/84AAAAA//X/9f/O/+z/6//tAAD/zgA9/+P/6//EAAD/1//2/+z/sP/2//b/1//s//X/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAA/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/iAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9QAAAAD/4v/u/8T/7AAA/2r/pP/1AAAAAAAAAAAAAAAA/8QAAP/hAAAAAAAA/9n/6wAAAAAAAAAAAAAAAAAAAAD/9gAAAAAAAAAAAAD/4v+I/5L/kv+c/6b/dAAA/5IAAAAAAAD/hwAAAAAAAAAAAAD/4QAAAAAAAAAK//b/8f/2/9n/w/+7/53/pv/7//b/7P/s/+v/xP/O/+L/f//i/+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAT//v/4//N/8X/p/+w/4kAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAACwAUAAAAAAAAAAAAKAAKAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9v/2/+0AAAAAAAAAAP/2AAAAAAAA//b/9gAAAAAAAAAAAAAAAAAAAAAAAP/tAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAAAAD/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/2AAKAAAAAAAAAAAAAAAA/87/2AAAAAAAAAAAAAAAAAATABP/7AAAAAAAAAAAAAD/9gAA//YAAAAAAAD/4gAAAAAAAP/2/+z/uQAAAAAAAP/s/+0AAAAAAAAAAP/sADQAAAAAAAAAAAAAAAAAAAAAAAAAAP/1AAAAAAAA/8T/4v/2/+wACv/s/+z/z//FAAAAAAAAAAAAAAAAAAAAAP/P//YAAAAAAAAAAAAAAAAAAAAAAAD/sAAA//b/9v/2//b/2P/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/84AAAAU//b/9v/Z/8//2QAA/7sAAAAAAAAAAAAAAAD/7P/2/+IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAeAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/x//H/8QAAAAAAAAAA//b/6//sAAD/8f/sAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//YAAAAAAAAAAAAAAAAAAAACO6wABAAAdQp2agAXAFYAAP/7//v/+//7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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AGECAgICAGACAwIDAGECBAIEADUCBgIIADUCCQIJADYCCgIKABECCwILADYCDAIMABECDQINADYCDgIOABECEwITABUCGAIZADMCGgIaABUCGwIcAFcCIAIpABgCNAI9ABYCZAJlAFYCaAJoAFYCbAJsAFYCbwJvABkCdAJ0AFYCdgJ2AFYCeAJ4AFYCeQJ5ABcCegJ6AFYCewJ8ABcCfgJ+ABcCgAKAAFYCggKEAFYCiQKJABkCjgKOAFYCkAKQAFYCkgKUAFYClQKWABcCmgKbAFYCygLKABIDTQNNACIDTgNPACMDUANQACIDUQNRACMDUwNTACMDVANUACUDVQNWACMDVwNXACIDWANZACQDWwNbACUDXANdACMDYANgACYDaQNpACMDbANsACYDbgNuADADcANwACgDcgNyACcDdgN2ACkDeQN5ACoDegN6ACgDfAN8ADADfwN/ADADgQOBACsDggOCADADhAOEACsDhQOHADADiAOIACcDigOKACkDiwOLADEDjAOMADADjQOOACsDjwOPADADkAOQADEDkQORACsDkwOUADADlQOVACoDoQOhAEADogOkAEMDpQOlAEEDpgOmAEMDpwOnAEQDqQOrAEMDrAOsAEEDrQOuAEMDrwOvAEsDsAOxAEMDsgOyAEsDswOzAEIDtAO0ADoDtgO2AEQDtwO3AEMDuAO4ADkDuQO6AEMDuwO7AEIDvAO9AEMDvwO/AEMDwQPCAEMDwwPDAEIDxAPEAEMDxQPFAEsDxwPIAEMDygPKAEEDywPLAEMDzAPMAEIDzQPOAEMDzwPPADoD0APQAEMD0gPSAEsD1APVAEMD1gPWAEQD2APYAEMD2QPZAEID2gPaAEMD2wPbAEsD3APdADsD3gPeAEQD3wPfADkD4APhAEMD4gPiAEQD4wPjAEAD5QPlAEMD5gPmAEsD5wPnAEMD6APpAEsD6gPrADoD7APsAGID7gPvAFQD8QPxAFID8gPyAEgD8wPzAGMD9AP2AFQD9wP3AEwD+AP5AFQD+gP6AFID+wP7AFQD/QP9AFID/gP+AEYD/wP/AD0EAAQAAFIEAQQBAEgEAgQCAFQEAwQDADwEBAQFAFQEBgQGAEYEBwQIAFQECQQJAGMECgQKAFQEDAQNAFIEDgQOAEUEDwQPAFQEEAQQAFIEEgQTAFMEFQQVAEwEFgQWAFQEFwQXAEUEGAQZAFQEGgQaAD0EGwQbAFQEHQQdAFIEHgQeAEcEHwQgAFQEIQQhAEgEIgQiAGMEIwQjAFQEJAQkAEYEJQQlAFQEJgQmAFIEJwQoAEcEKQQpAEgEKgQqADwEKwQrAEUELAQsAEgELQQtAEUELgQvAGIEMAQxAFIEMgQyAFQEMwQ0AFIENQQ2AD0EPAQ9ADUEPgQ+ADMEPwRAAFcERgRGABoERwRHABsESQRLABsETQROABsETwRPABwEUARRABsEUgRTAB0EVQRVABsEVwRXABsEWQRZAB4EWgRaAB8EXARcACAEXgReACEEYAR1ABoEfASQABsEmQSnABsEqASoABwEqQSxABsEsgS7AB0E1ATZABsE4QTmAB4E5wT9AB8E/gUBACAFAgUJACEFDgUPABsFEQURACwFEgUTAC0FFAUUACwFFQUVAC0FFwUXAC0FGAUYADgFGQUaAC0FGwUbACwFHAUdAC4FHwUfADgFIAUhAC0FJAUkAC8FKQUpAC0FKgUqAC8FTAVMAEkFTQVPAE8FUAVQAE0FUQVRAE8FUgVSAFEFVAVWAE8FVwVXAE0FWAVZAE8FWgVaAFAFWwVcAE8FXQVdAFAFXgVeAE4FXwVfAEoFYQVhAFEFYgViAE8FYwVjAD4FZAVlAE8FZgVmAE4FZwVoAE8FagVqAE8FbAVtAE8FbgVuAE4FbwVvAE8FcAVwAFAFcgVzAE8FdQV1AE0FdgV2AE8FdwV3AE4FeAV5AE8FegV6AEoFewV7AE8FfQV9AFAFfwWAAE8FgQWBAFEFgwWDAE8FhAWEAE4FhQWFAE8FhgWGAFAFhwWIAD8FiQWJAFEFigWKAD4FiwWMAE8FjQWNAFEFjgWOAEkFkAWQAE8FkQWRAFAFkgWSAE8FkwWUAFAFlQWWAEoAAgAVABEAEQACABcAFwAQABkAGQASAOQA5AAMA10DXQAIA2EDYQAEA2MDYwAGA8wDzAAOA9ED0QAUA+AD4AAKBFUEVQADBFsEWwARBF0EXQATBQ8FDwANBRoFGgABBSEFIQAJBSUFJQAFBScFJwAHBXcFdwAPBXwFfAAVBYsFiwALAAIBNgACAAIAFAADAAMAFQAEAAQATAAFAAcAFQAIAAgATAAJAAoAFQALAAsAFgAMAA0AFQAOAA8ASwAQABAATAARABEAFQASABIATAATABMAFQAUABQAFwAVABUAGAAWABYAGQAYABgAGgAaABoAGwAbABsAHAAcABwAUgAdAB0ATQAeACAAIAAhACEAUwAiACIAHQAjACMATQAkACQAVAAlACUAVQAmACcATQAoACkAHwAqACoAIAAsACwAIAAtAC0AHwAuAC4AVgAvAC8AIQAwADAAVwAxADIAIgA0ADQAIwA1ADUAWAA2AEsAFABNAFEATABSAGYAFQBnAG0ATABuAHwAFQB9AH0AFgB+AIYAFQCHAJAASwCRAKgATACpAK4AFQCvALUAFwC3ALsAGAC8ANIAGQDTANYAGgDXAN4AGwDfAOIAHADjAOQAFQDlAOUATADmAPwAUgD9ARYAIAEXAR0AHQEeASEATQEiASMAVAEkASYAHgEnASgAVAEpASkAHgEqASsAVAEsASwAHgEtAS0AHwEuAS8AVQEwATAATQExATEAHwEyATkATQE6AUEAHwFDAUQAHwFFAVwAIAFdAWIAHwFjAWkAVgFqAWsAUwFsAXEAIQFyAYgAVwGJAYwAIgGNAZQAIwGVAZgAWAGZAZkAIAGbAZsAIAGeAaMAUwGwAbAAEQG2AbYADgG4AbgACwG6AboAEQHLAcsADgHNAc0ACwHZAdoAJQHbAdwAJAHdAd0AJQHkAeUAJwHmAeYAKAHnAecAKQHoAegAKAHpAekAKQHsAewAWQHtAe0APAHuAe4AWQHvAe8APAHwAfAADAHyAfYADAH3AfcADQH6AfoAWgH7AfsAJgH8AfwAWgH9Af0AJgH+Af4AWgH/Af8AJgIAAgAAWQIBAgEAPAICAgIAWQIDAgMAPAIEAgQADAIGAggADAIJAgkAWgIKAgoAJgILAgsAWgIMAgwAJgINAg0AWgIOAg4AJgITAhMAKgIYAhkACgIaAhoAKgIbAhwAEAIgAikANgI0Aj0AKwJkAmUALQJoAmgALQJsAmwALQJvAm8ALAJ0AnQALQJ2AnYALQJ4AngALQJ5AnkADwJ6AnoALQJ7AnwADwJ+An4ADwKAAoAALQKCAoQALQKJAokALAKOAo4ALQKQApAALQKSApQALQKVApYADwKaApsALQLKAsoADQNNA00AAQNOA08ANANQA1AAAQNRA1EANANTA1MANANUA1QAAgNVA1YANANXA1cAAQNYA1kANQNbA1sAAgNcA10ANANgA2AAAwNpA2kANANsA2wAAwNuA24ABANwA3AABQNyA3IAOgN0A3QAOwN2A3YABgN3A3cAOwN5A3kACAN6A3oABQN8A3wABAN/A38ABAOBA4EACQOCA4IABAOEA4QACQOFA4cABAOIA4gAOgOJA4kAOwOKA4oABgOLA4sABwOMA4wABAONA44ACQOPA48ABAOQA5AABwORA5EACQOTA5QABAOVA5UACAOiA6QAWwOmA6YAWwOpA6sAWwOtA64AWwOvA68APwOwA7EAWwOyA7IAPwOzA7MAPgO0A7QAQAO3A7cAWwO4A7gAPQO5A7oAWwO7A7sAPgO8A70AWwO/A78AWwPBA8IAWwPDA8MAPgPEA8QAWwPFA8UAPwPHA8gAWwPLA8sAWwPMA8wAPgPNA84AWwPPA88AQAPQA9AAWwPSA9IAPwPUA9UAWwPYA9gAWwPZA9kAPgPaA9oAWwPbA9sAPwPcA90AQQPfA98APQPgA+EAWwPlA+UAWwPmA+YAPwPnA+cAWwPoA+kAPwPqA+sAQAP+A/4AQwP/A/8ARAQDBAMAQgQGBAYAQwQaBBoARAQeBB4ARQQkBCQAQwQnBCgARQQqBCoAQgQ1BDYARAQ8BD0ADAQ+BD4ACgQ/BEAAEARGBEYALgRHBEcATgRIBEgAUARJBEsATgRMBEwAUARNBE4ATgRQBFEATgRSBFMATwRUBFQAUARVBFUATgRWBFYAUARXBFcATgRYBFgALwRZBFkAMARaBFoAMQRcBFwAUQReBF4AMgRfBF8AMwRgBHUALgR3BHsAUAR8BJAATgSRBJUAUASXBJgAUASZBKcATgSpBLEATgSyBLsATwS8BNMAUATUBNkATgTaBOAALwThBOYAMATnBP0AMQT+BQEAUQUCBQkAMgUKBQ0AMwUOBQ8ATgUQBRAAUAURBREAEgUSBRMANwUUBRQAEgUVBRUANwUXBRcANwUYBRgAEwUZBRoANwUbBRsAEgUcBR0AOAUfBR8AEwUgBSEANwUkBSQAOQUpBSkANwUqBSoAOQUrBSsALwVaBVoASAVdBV0ASAVeBV4ARwVfBV8ASQVjBWMARgVmBWYARwVuBW4ARwVwBXAASAV3BXcARwV6BXoASQV9BX0ASAWEBYQARwWGBYYASAWHBYgASgWKBYoARgWRBZEASAWTBZQASAWVBZYASQACABoBawFrABQBmQGZAAwBpAGkAAEBtAG0ABIBtQG1AA8BuQG5ABkByQHJABMBygHKABABzgHOABoB3wHfAA0B4AHgAA4B+AH4AAYCEQIRAAQCHQIdAAICHgIeAAMCnwKfAAcCogKiABEDbwNvAAUDcQNxAAkDdwN3ABcDeAN4ABgDgwODAAgEDgQOAAoEEQQRAAsEFAQUABYEHgQeABUAAgElAAIAAgAaAAMAAwAhAAQABAAiAAUABwAhAAgACAAiAAkACgAhAAsACwAMAAwADQAhAA4ADwBMABAAEAAiABEAEQAhABIAEgAiABMAEwAhABUAFQANABYAFgAOABgAGAAPABoAGgAQABsAGwAjABwAHAA6AB0AHQAcAB4AIAARACEAIQA7ACIAIgAbACMAIwAcACQAJAA4ACUAJQAmACYAJwAcACgAKQBNACoAKgARACwALAARAC0ALQBNAC8ALwAnADAAMAA8ADEAMgAoADQANAApADYASwAaAE0AUQAiAFIAZgAhAGcAbQAiAG4AfAAhAH0AfQAMAH4AhgAhAIcAkABMAJEAqAAiAKkArgAhALcAuwANALwA0gAOANMA1gAPANcA3gAQAN8A4gAjAOMA5AAhAOUA5QAiAOYA/AA6AP0BFgARARcBHQAbAR4BIQAcASIBIwA4AScBKAA4ASoBKwA4AS0BLQBNAS4BLwAmATABMAAcATEBMQBNATIBOQAcAToBQQBNAUMBRABNAUUBXAARAV0BYgBNAWoBawA7AWwBcQAnAXIBiAA8AYkBjAAoAY0BlAApAZkBmQARAZsBmwARAZ4BowA7AbABsAAtAbYBtgAWAbgBuAAuAboBugAtAcsBywAWAc0BzQAuAdkB2gASAdsB3ABHAd0B3QASAeQB5QAqAeYB5gAGAecB5wArAegB6AAGAekB6QArAeoB6wAsAewB7AATAe4B7gATAfAB8AAUAfIB9gAUAfcB9wAFAfoB+gBBAfsB+wAVAfwB/ABBAf0B/QAVAf4B/gBBAf8B/wAVAgACAAATAgICAgATAgQCBAAUAgYCCAAUAgkCCQBBAgoCCgAVAgsCCwBBAgwCDAAVAg0CDQBBAg4CDgAVAhMCEwAzAhoCGgAzAhsCHAA3AiACKQA1AjQCPQA5AmQCZQA2AmYCZwBCAmgCaAA2AmkCawBCAmwCbAA2Am0CbgBCAm8CbwAHAnACcwBC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ADgCAAIAACECAQIBADoCAgICACECAwIDADoCBAIEACICBgIIACICCQIJAEgCCgIKADgCCwILAEgCDAIMADgCDQINAEgCDgIOADgCEwITACgCGgIaACgCGwIcAC8CIAIpAC0CNAI9AEYCZAJlAC4CZgJnACoCaAJoAC4CaQJrACoCbAJsAC4CbQJuACoCbwJvADkCcAJzACoCdAJ0AC4CdQJ1ACoCdgJ2AC4CdwJ3ACoCeAJ4AC4CeQJ5ACwCegJ6AC4CewJ8ACwCfQJ9ACoCfgJ+ACwCfwJ/ACoCgAKAAC4CgQKBACoCggKEAC4ChQKFACoChgKGACsChwKIACoCiQKJADkCigKNACoCjgKOAC4CjwKPACsCkAKQAC4CkQKRACoCkgKUAC4ClQKWACwClwKXACoCmAKYACsCmQKZACoCmgKbAC4CuwLFAB8CxgLHACQCyALIACACyQLJACQCygLKACMCywLLAB4CzALMACQCzQLNACAC0gLSAB4C0wLTACQC1ALUAB4C1QLVACQDTQNNAAMDUANQAAMDVANUAAQDVwNXAAMDWwNbAAQDYANgABADbANsABADbgNuABEDcANwABIDcgNyAE0DdAN0AEMDdgN2AE4DdwN3AEMDegN6ABIDfAN8ABEDfwN/ABEDgQOBABMDggOCABEDhAOEABMDhQOHABEDiAOIAE0DiQOJAEMDigOKAE4DiwOLAEwDjAOMABEDjQOOABMDjwOPABEDkAOQAEwDkQORABMDkwOUABEDoQOhAAEDpQOlAD4DrAOsAD4DrwOvAAIDsgOyAAIDswOzAAoDuwO7AAoDwwPDAAoDxQPFAAIDygPKAD4DzAPMAAoD0gPSAAID2QPZAAoD2wPbAAID3APdAAsD4wPjAAED5gPmAAID6APpAAID7APsAAwD7gPvAEED8QPxAA0D8gPyAEID9AP2AEED9wP3AD8D+AP5AEED+gP6AA0D+wP7AEED/QP9AA0D/gP+ADMD/wP/AA4EAAQAAA0EAQQBAEIEAgQCAEEEAwQDADIEBAQFAEEEBgQGADMEBwQIAEEECgQKAEEEDAQNAA0EDgQOAEcEDwQPAEEEEAQQAA0EEgQTAEAEFQQVAD8EFgQWAEEEFwQXAEcEGAQZAEEEGgQaAA4EGwQbAEEEHQQdAA0EHgQeAA8EHwQgAEEEIQQhAEIEIwQj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AGICAwIDABcCBAIEABgCBgIIABgCCQIJABkCCgIKADwCCwILABkCDAIMADwCDQINABkCDgIOADwCDwIPADICEQIRACYCEwITAD8CGAIZABUCGgIaAD8CGwIcAB4CHQIdACQCHgIeACUCIAIpAEICNAI9ABwCZAJlAEQCZgJnAEACaAJoAEQCaQJrAEACbAJsAEQCbQJuAEACbwJvAEMCcAJzAEACdAJ0AEQCdQJ1AEACdgJ2AEQCdwJ3AEACeAJ4AEQCeQJ5AB0CegJ6AEQCewJ8AB0CfQJ9AEACfgJ+AB0CfwJ/AEACgAKAAEQCgQKBAEACggKEAEQChQKFAEAChgKGAEEChwKIAEACiQKJAEMCigKNAEACjgKOAEQCjwKPAEECkAKQAEQCkQKRAEACkgKUAEQClQKWAB0ClwKXAEACmAKYAEECmQKZAEACmgKbAEQCygLKABoDTQNNAAkDTgNPAEoDUANQAAkDUQNRAEoDUgNSAEcDUwNTAEoDVANUAAoDVQNWAEoDVwNXAAkDWANZADsDWwNbAAoDXANdAEoDXwNfAEYDYANgAEsDYQNhACEDYgNiAEUDZANkACADaQNpAEoDbANsAEsDbgNuAAsDbwNvACcDcANwAA4DcQNxACoDcgNyAAwDcwNzADkDdAN0AA0DdQN1ADUDdgN2AA8DdwN3AA0DeAN4AEkDeQN5ABEDegN6AA4DfAN8AAsDfQN9AC8DfgN+ADEDfwN/AAsDgAOAADQDgQOBABIDggOCAAsDgwODACkDhAOEABIDhQOHAAsDiAOIAAwDiQOJAA0DigOKAA8DiwOLABADjAOMAAsDjQOOABIDjwOPAAsDkAOQABADkQORABIDkwOUAAsDlQOVABEDlwOXADADmAOYACMEPAQ9ABgEPgQ+ABUEPwRAAB4ERgRGAGYERwRHAHYESARIAGgESQRLAHYETARMAGgETQROAHYETwRPAGcEUARRAHYEUgRTAHcEVARUAGgEVQRVAHYEVgRWAGgEVwRXAHYEWQRZAGkEWgRaAGoEWwRbAG0EXARcAGsEXQRdAHgEXgReAGwEYAR1AGYEdgR2AG8EdwR7AGgEfASQAHYEkQSVAGgElwSYAGgEmQSnAHYEqASoAGcEqQSxAHYEsgS7AHcEvATTAGgE1ATZAHYE4QTmAGkE5wT9AGoE/gUBAGsFAgUJAGwFDgUPAHYFEAUQAGgFEQURAAEFEgUTAAIFFAUUAAEFFQUVAAIFFwUXAAIFGAUYAAQFGQUaAAIFGwUbAAEFHAUdAAMFHwUfAAQFIAUhAAIFIgUiAAgFJAUkAAUFJQUlADoFJgUmAAYFJwUnAAcFKQUpAAIFKgUqAAUAAgA6AAgACAABAAkACgADAAsACwAFAAwADAAHAA0ADQAJAA4ADgADAA8ADwALABAAEAANABIAEgANABMAEwAPABQAFAARABUAFQATABYAFgAVAGcAbQABAG4AfAADAH0AfQAFAH4AfgAHAH8AgQAJAIMAhgAJAIcAiAADAIkAkAALAJEApwANAKkArgAPAK8AtQARALcAuwATALwA0gAVAOUA5QANBEwETAACBE0ETgAEBE8ETwAGBFAEUAAIBFEEUQAKBFIEUgAEBFMEUwAMBFQEVAAOBFYEVgAOBFcEVwAQBFgEWAASBFkEWQAUBFoEWgAWBJEElQACBJcEmAACBJkEpwAEBKgEqAAGBKkEqQAIBKoErAAKBK4EsQAKBLIEswAEBLQEuwAMBLwE0gAOBNQE2QAQBNoE4AASBOEE5gAUBOcE/QAWBRAFEAAOBSsFKwASBSwFLAADBS0FLQAKAAIA6gABAAEAVQACAAIABQADAAMABgAEAAQABwAFAAcABgAIAAgABwAJAAoABgALAAsAPgAMAA0ABgAOAA8AQwAQABAABwARABEABgASABIABwATABMABgAUABQANAAVABUACAAWABYACQAXABcAFwAYABgACgAZABkAGAAaABoACwAbABsADAAcABwAJAAdAB0AUwAeACAAKAAhACEAJQAiACIAJgAjACMAUwAkACQANQAlACUANgAmACcAUwAoACkANwAqACoAKAArACsAHAAsACwAKAAtAC0ANwAuAC4AKQAvAC8AKgAwADAAKwAxADIALAAzADMAPAA0ADQALQA1ADUAOAA2AEsABQBMAEwAFgBNAFEABwBSAGYABgBnAG0ABwBuAHwABgB9AH0APgB+AIYABgCHAJAAQwCRAKgABwCpAK4ABgCvALUANAC3ALsACAC8ANIACQDTANYACgDXAN4ACwDfAOIADADjAOQABgDlAOUABwDmAPwAJAD9ARYAKAEXAR0AJgEeASEAUwEiASMANQEkASYAJwEnASgANQEpASkAJwEqASsANQEsASwAJwEtAS0ANwEuAS8ANgEwATAAUwExATEANwEyATkAUwE6AUEANwFDAUQANwFFAVwAKAFdAWIANwFjAWkAKQFqAWsAJQFsAXEAKgFyAYgAKwGJAYwALAGNAZQALQGVAZgAOAGZAZkAKAGaAZoATQGbAZsAKAGeAaMAJQGkAaQAVAGwAbAAMAGxAbEAGwGyAbIAHwGzAbMAHgG0AbQAMgG1AbUAMQG2AbYALwG3AbcATAG4AbgALgG5AbkAMwG6AboAMAHLAcsALwHNAc0ALgHZAdoADQHbAdwAOQHdAd0ADQHkAeUARAHmAeYARQHnAecARgHoAegARQHpAekARgHsAewADgHtAe0AOgHuAe4ADgHvAe8AOgHwAfAADwHyAfYADwH3AfcAOwH4AfgAQQH5AfkAIAH6AfoAEAH7AfsAEQH8AfwAEAH9Af0AEQH+Af4AEAH/Af8AEQIAAgAADgIBAgEAOgICAgIADgIDAgMAOgIEAgQADwIGAggADwIJAgkAEAIKAgoAEQILAgsAEAIMAgwAEQINAg0AEAIOAg4AEQIPAg8AHQIRAhEASwITAhMARwIYAhkAPwIaAhoARwIbAhwAQAIdAh0AGQIeAh4AGgIgAikAFAI0Aj0AEgJkAmUASgJmAmcASAJoAmgASgJpAmsASAJsAmwASgJtAm4ASAJvAm8AFQJwAnMASAJ0AnQASgJ1AnUASAJ2AnYASgJ3AncASAJ4AngASgJ5AnkAEwJ6AnoASgJ7AnwAEwJ9An0ASAJ+An4AEwJ/An8ASAKAAoAASgKBAoEASAKCAoQASgKFAoUASAKGAoYASQKHAogASAKJAokAFQKKAo0ASAKOAo4ASgKPAo8ASQKQApAASgKRApEASAKSApQASgKVApYAEwKXApcASAKYApgASQKZApkASAKaApsASgLKAsoAOwQ8BD0ADwQ+BD4APwQ/BEAAQARGBEYAPQRHBEcATgRIBEgAIQRJBEsATgRMBEwAIQRNBE4ATgRPBE8ATwRQBFEATgRSBFMAUgRUBFQAIQRVBFUATgRWBFYAIQRXBFcATgRYBFgAUARZBFkAUQRaBFoAAQRbBFsABARcBFwAAgRdBF0AIwReBF4AAwRfBF8AQgRgBHUAPQR2BHYAIgR3BHsAIQR8BJAATgSRBJUAIQSXBJgAIQSZBKcATgSoBKgATwSpBLEATgSyBLsAUgS8BNMAIQTUBNkATgTaBOAAUAThBOYAUQTnBP0AAQT+BQEAAgUCBQkAAwUKBQ0AQgUOBQ8ATgUQBRAAIQUrBSsAUAACAEMAGgAaAAIAGwAbAAQAHAAcAAYAHQAdAAcAHgAeAAgAHwAfABIAIAAgAAoAIQAhAAsAIgAiAAwAIwAjAA0AJAAkAA4AJQAlABAAJgAmABEAJwAnABIAKAApAA0AKgArAAcALQAtABMALgAuABQALwAvABUAMAAwABYA1wDeAAIA3wDiAAQA5gD7AAYA/AD8AAoA/QEBAAgBAgECAAkBAwEFABIBBgEWAAoBFwEdAAwBHgEhAA0BIgEjAA4BJAEmAA8BJwEoAA4BKQEpAA8BKgErAA4BLAEsAA8BLQEtAA4BLgEvABABMAExABEBMgEyABIBMwEzAAkBNAE0ABIBNgE5ABIBOgFBAA0BQwFEAA0BRQFUAAcBWwFbAAcBXAFcAAoBXQFiABMBYwFpABQBagFqAAsBbAFxABUBcgGBABYBiAGIABYBmgGbAAcBngGeAA4BnwGfABIBoAGgABUBoQGhAAsBogGiAA4BowGjABIEXARcAAEEXgReAAMEXwRfAAUE/gUBAAEFAgUJAAMFCgUNAAUAAgDaAAEAAQAwAAIAAgABAAMAAwBLAAQABAADAAUABwBLAAgACAADAAkACgBLAAsACwBAAAwADQBLAA4ADwACABAAEAADABEAEQBLABIAEgADABMAEwBLABQAFAAEABUAFQA6ABYAFgAFABcAFwA+ABgAGAA7ABkAGQBOABoAGgA8ABsAGwAGABwAHAAHAB0AHQBMAB4AIAANACEAIQAIACIAIgAJACMAIwBMACQAJAAKACUAJQALACYAJwBMACgAKQAMACoAKgANACsAKwAuACwALAANAC0ALQAMAC4ALgAOAC8ALwAPADAAMAAQADEAMgARADMAMwA0ADQANAASADUANQATADYASwABAEwATAAkAE0AUQADAFIAZgBLAGcAbQADAG4AfABLAH0AfQBAAH4AhgBLAIcAkAACAJEAqAADAKkArgBLAK8AtQAEALcAuwA6ALwA0gAFANMA1gA7ANcA3gA8AN8A4gAGAOMA5ABLAOUA5QADAOYA/AAHAP0BFgANARcBHQAJAR4BIQBMASIBIwAKASQBJgA5AScBKAAKASkBKQA5ASoBKwAKASwBLAA5AS0BLQAMAS4BLwALATABMABMATEBMQAMATIBOQBMAToBQQAMAUMBRAAMAUUBXAANAV0BYgAMAWMBaQAOAWoBawAIAWwBcQAPAXIBiAAQAYkBjAARAY0BlAASAZUBmAATAZkBmQANAZoBmgBKAZsBmwANAZ4BowAIAaQBpAAlAbABsAAjAbEBsQAtAbIBsgAyAbMBswAxAbQBtAArAbUBtQAqAbYBtgAeAbcBtwBIAbgBuAAXAbkBuQAsAboBugAjAcYBxgBVAccBxwBSAcgByABRAckByQBQAcoBygBPAcsBywAeAcwBzABJAc0BzQAXAc4BzgBHAdkB2gAVAdsB3AAUAd0B3QAVAd4B3gBTAeEB4QBUAeQB5QBBAeYB5gA9AecB5wAdAegB6AA9AekB6QAdAewB7AAYAe0B7QAZAe4B7gAYAe8B7wAZAfAB8AAaAfIB9gAaAfcB9wAcAfgB+AApAfkB+QAzAfoB+gAbAfsB+wBNAfwB/AAbAf0B/QBNAf4B/gAbAf8B/wBNAgACAAAYAgECAQAZAgICAgAYAgMCAwAZAgQCBAAaAgYCCAAaAgkCCQAbAgoCCgBNAgsCCwAbAgwCDABNAg0CDQAbAg4CDgBNAg8CDwAvAhECEQAoAhMCEwBCAhgCGQAWAhoCGgBCAhsCHAAiAh0CHQAmAh4CHgAnAiACKQBFAjQCPQAfAmQCZQBGAmYCZwBDAmgCaABGAmkCawBDAmwCbABGAm0CbgBDAm8CbwAhAnACcwBDAnQCdABGAnUCdQBDAnYCdgBGAncCdwBDAngCeABGAnkCeQAgAnoCegBGAnsCfAAgAn0CfQBDAn4CfgAgAn8CfwBDAoACgABGAoECgQBDAoIChABGAoUChQBDAoYChgBEAocCiABDAokCiQAhAooCjQBDAo4CjgBGAo8CjwBEApACkABGApECkQBDApIClABGApUClgAgApcClwBDApgCmABEApkCmQBDApoCmwBGAsoCygAcBDwEPQAaBD4EPgAWBD8EQAAiBEYERgA1BEgESAA2BEwETAA2BFQEVAA2BFYEVgA2BFgEWAA3BFoEWgA/BGAEdQA1BHYEdgA4BHcEewA2BJEElQA2BJcEmAA2BLwE0wA2BNoE4AA3BOcE/QA/BRAFEAA2BSsFKwA3AAIALgA1ADUAAQGVAZgAAQGzAbMABQG4AbgABQHNAc0ABQHZAdoAAwHbAdwAAgHdAd0AAwHsAewABwHtAe0ACAHuAe4ABwHvAe8ACAHwAfAACQHyAfYACQH3AfcADQH6AfoACwH7AfsADAH8AfwACwH9Af0ADAH+Af4ACwH/Af8ADAIAAgAABwIBAgEACAICAgIABwIDAgMACAIEAgQACQIGAggACQIJAgkACwIKAgoADAILAgsACwIMAgwADAINAg0ACwIOAg4ADAIYAhkABALGAscADgLIAsgACgLJAskADgLKAsoADQLLAssABgLMAswACgLNAs0ADgLSAtIABgLTAtMADgLUAtUABgQ8BD0ACQQ+BD4ABAACAVMAAgACAAEAAwADAAIABAAEAD8ABQAHAAIACAAIAD8ACQAKAAIACwALAAMADAANAAIADgAPAAQAEAAQAD8AEQARAAIAEgASAD8AEwATAAIAFAAUAG8AFQAVAAUAFgAWAAYAFwAXAB8AGAAYAAcAGQAZACAAGgAaAAgAGwAbAHAAHAAcAAkAHQAdAAsAHgAgAAwAIQAhAFwAIgAiAAoAIwAjAAsAJQAlAEAAJgAnAAsAKAApAHkAKgAqAAwAKwArAC8ALAAsAAwALQAtAHkALgAuAA0ALwAvAA4AMAAwAEEAMQAyAA8AMwAzAHUANAA0ABAANQA1AEIANgBLAAEATABMAB4ATQBRAD8AUgBmAAIAZwBtAD8AbgB8AAIAfQB9AAMAfgCGAAIAhwCQAAQAkQCoAD8AqQCuAAIArwC1AG8AtwC7AAUAvADSAAYA0wDWAAcA1wDeAAgA3wDiAHAA4wDkAAIA5QDlAD8A5gD8AAkA/QEWAAwBFwEdAAoBHgEhAAsBJAEmAHgBKQEpAHgBLAEsAHgBLQEtAHkBLgEvAEABMAEwAAsBMQExAHkBMgE5AAsBOgFBAHkBQwFEAHkBRQFcAAwBXQFiAHkBYwFpAA0BagFrAFwBbAFxAA4BcgGIAEEBiQGMAA8BjQGUABABlQGYAEIBmQGZAAwBmgGaADABmwGbAAwBngGjAFwBpAGkACEBsAGwAEcBsQGxACgBsgGyAFMBswGzACwBtAG0ACUBtQG1ACMBtgG2ABcBtwG3ACkBuAG4AEMBuQG5ACcBugG6AEcBxQHFAFUBxgHGAFEBxwHHAFQByAHIAC0ByQHJACYBygHKACQBywHLABcBzAHMACoBzQHNAEMBzgHOAFAB2QHaABEB2wHcAHoB3QHdABEB3gHeAHMB4gHiAHQB5AHlAEUB5gHmABUB5wHnABYB6AHoABUB6QHpABYB7AHsABIB7QHtAHEB7gHuABIB7wHvAHEB8AHwABMB8gH2ABMB9wH3AF8B+AH4AGIB+QH5AC4B+gH6AEQB+wH7ABQB/AH8AEQB/QH9ABQB/gH+AEQB/wH/ABQCAAIAABICAQIBAHECAgICABICAwIDAHECBAIEABMCBgIIABMCCQIJAEQCCgIKABQCCwILAEQCDAIMABQCDQINAEQCDgIOABQCDwIPACsCEQIRAEsCEwITAEYCGgIaAEYCHQIdACICHwIfAHsCIAIpAGECNAI9ABgCZAJlAB0CZgJnABkCaAJoAB0CaQJrABkCbAJsAB0CbQJuABkCbwJvABwCcAJzABkCdAJ0AB0CdQJ1ABkCdgJ2AB0CdwJ3ABkCeAJ4AB0CeQJ5ABsCegJ6AB0CewJ8ABsCfQJ9ABkCfgJ+ABsCfwJ/ABkCgAKAAB0CgQKBABkCggKEAB0ChQKFABkChgKGABoChwKIABkCiQKJABwCigKNABkCjgKOAB0CjwKPABoCkAKQAB0CkQKRABkCkgKUAB0ClQKWABsClwKXABkCmAKYABoCmQKZABkCmgKbAB0CnAKcAGQCngKeAGUCnwKfAGMCrwKvAGcCuwLFAF0CxgLHAGACyALIAF4CyQLJAGACygLKAF8CzALMAGACzQLNAF4C0wLTAGAC1QLVAGADTQNNAFcDTgNPAFkDUANQAFcDUQNRAFkDUgNSAHYDUwNTAFkDVANUADsDVQNWAFkDVwNXAFcDWANZAFoDWwNbADsDXANdAFkDXwNfAEoDYANgADMDYQNhAEgDYgNiADQDYwNjAEkDaQNpAFkDbANsADMDbgNuADwDcANwAD0DcQNxAE0DdAN0AFsDdwN3AFsDeAN4AGYDegN6AD0DfAN8ADwDfwN/ADwDgAOAAFIDgQOBAD4DggOCADwDgwODAEwDhAOEAD4DhQOHADwDiQOJAFsDjAOMADwDjQOOAD4DjwOPADwDkQORAD4DkwOUADwDoQOhAFYDogOkAFgDpgOmAFgDpwOnADIDqQOrAFgDrQOuAFgDrwOvADYDsAOxAFgDsgOyADYDswOzADUDtAO0AGkDtgO2ADIDtwO3AFgDuAO4AGgDuQO6AFgDuwO7ADUDvAO9AFgDvwO/AFgDwQPCAFgDwwPDADUDxAPEAFgDxQPFADYDxgPGAHIDxwPIAFgDywPLAFgDzAPMADUDzQPOAFgDzwPPAGkD0APQAFgD0gPSADYD0wPTAGsD1APVAFgD1gPWADID2APYAFgD2QPZADUD2gPaAFgD2wPbADYD3APdADED3gPeADID3wPfAGgD4APhAFgD4gPiADID4wPjAFYD5QPlAFgD5gPmADYD5wPnAFgD6APpADYD6gPrAGkD7APsADcD7gPvAHcD8APwAGwD8QPxADgD8gPyAG4D9AP2AHcD+AP5AHcD+gP6ADgD+wP7AHcD/QP9ADgD/wP/ADkEAAQAADgEAQQBAG4EAgQCAHcEBAQFAHcEBwQIAHcECgQKAHcEDAQNADgEDgQOAG0EDwQPAHcEEAQQADgEEQQRAE4EEgQTAGoEFAQUAE8EFgQWAHcEFwQXAG0EGAQZAHcEGgQaADkEGwQbAHcEHQQdADgEHgQeADoEHwQgAHcEIQQhAG4EIwQjAHcEJQQlAHcEJgQmADgEJwQoADoEKQQpAG4EKwQrAG0ELAQsAG4ELQQtAG0ELgQvADcEMAQxADgEMgQyAHcEMwQ0ADgENQQ2ADkEPAQ9ABMAAgALAbABsAAGAbYBtgAFAboBugAGAcsBywAFAeYB5gABAecB5wACAegB6AABAekB6QACAeoB6wADAhMCEwAEAhoCGgAEAAIBVAACAAIADgADAAMAPQAEAAQAEAAFAAcAPQAIAAgAEAAJAAoAPQALAAsADwAMAA0APQAQABAAEAARABEAPQASABIAEAATABMAPQAUABQAEQAVABUAEgAWABYAEwAXABcAbQAYABgAVgAZABkAbgAaABoAaAAbABsAPgAcABwAFAAeACAAGAAhACEAVwAiACIAFQAkACQAfQAlACUAWAAoACkAFwAqACoAGAArACsALQAsACwAGAAtAC0AFwAuAC4AGQAvAC8APwAwADAAWQAxADIAQAAzADMAVAA0ADQAQQA1ADUAGgA2AEsADgBMAEwAHgBNAFEAEABSAGYAPQBnAG0AEABuAHwAPQB9AH0ADwB+AIYAPQCRAKgAEACpAK4APQCvALUAEQC3ALsAEgC8ANIAEwDTANYAVgDXAN4AaADfAOIAPgDjAOQAPQDlAOUAEADmAPwAFAD9ARYAGAEXAR0AFQEiASMAfQEkASYAFgEnASgAfQEpASkAFgEqASsAfQEsASwAFgEtAS0AFwEuAS8AWAExATEAFwE6AUEAFwFDAUQAFwFFAVwAGAFdAWIAFwFjAWkAGQFqAWsAVwFsAXEAPwFyAYgAWQGJAYwAQAGNAZQAQQGVAZgAGgGZAZkAGAGaAZoAMQGbAZsAGAGeAaMAVwGkAaQASAGwAbAAXAGxAbEAXwGyAbIAYAGzAbMAUgG0AbQAKQG1AbUAJwG2AbYAHQG3AbcAUAG4AbgAQgG5AbkAXgG6AboAXAHFAcUANQHGAcYALAHHAccAMwHIAcgAMgHJAckAKgHKAcoAKAHLAcsAHQHMAcwAUQHNAc0AQgHOAc4AKwHZAdoAGwHdAd0AGwHeAd4ATAHfAd8ATQHhAeEATwHiAeIALgHmAeYARgHnAecAfwHoAegARgHpAekAfwHqAesAWwHsAewAHAHtAe0AQwHuAe4AHAHvAe8AQwHwAfAARAHyAfYARAH3AfcAWgH4AfgASgH5AfkAUwH6AfoARQH7AfsAfgH8AfwARQH9Af0AfgH+Af4ARQH/Af8AfgIAAgAAHAIBAgEAQwICAgIAHAIDAgMAQwIEAgQARAIGAggARAIJAgkARQIKAgoAfgILAgsARQIMAgwAfgINAg0ARQIOAg4AfgIPAg8AMAIdAh0ASQIfAh8ATgIgAikAdgI0Aj0AcwJkAmUAeAJmAmcAdAJoAmgAeAJpAmsAdAJsAmwAeAJtAm4AdAJvAm8AdwJwAnMAdAJ0AnQAeAJ1AnUAdAJ2AnYAeAJ3AncAdAJ4AngAeAJ5AnkAdQJ6AnoAeAJ7AnwAdQJ9An0AdAJ+An4AdQJ/An8AdAKAAoAAeAKBAoEAdAKCAoQAeAKFAoUAdAKGAoYAgAKHAogAdAKJAokAdwKKAo0AdAKOAo4AeAKPAo8AgAKQApAAeAKRApEAdAKSApQAeAKVApYAdQKXApcAdAKYApgAgAKZApkAdAKaApsAeAKcApwAeQKeAp4AegKiAqIAewKvAq8AfALIAsgAcgLKAsoAWgLNAs0AcgNNA00ACQNOA08AOwNQA1AACQNRA1EAOwNSA1IARwNTA1MAOwNUA1QACgNVA1YAOwNXA1cACQNb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"

/***/ }),

/***/ "./node_modules/base64-loader/index.js!./node_modules/scratch-render-fonts/src/handlee-regular.ttf":
/*!************************************************************************************************!*\
  !*** ./node_modules/base64-loader!./node_modules/scratch-render-fonts/src/handlee-regular.ttf ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "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AEj/5gBK//AAUv/yAFP/7wBU//AAVwAXAFsABgB8/7IAngAjAJ8AFACgACEAoQAfAAQAFP/nABX/6AAW/+0AGv/YAAEATQAIABUAFP/bABX/2QAW/+AAGP/yABr/ywAb/+0ALf+7ADD/+AA2/+4AN/+yADn/5AA7/8wAPP+6AD3/4wBJ/+YATv/4AFb/9QBZ//UAW//3AF3/0QB8/98AFAAF/48ACv+jABT/4QAX/+oAGv/pABz/zgAm//MAKv/yADL/7gA0/+sAN/+4ADj/7AA5/8gAPP/QAEn/8QBZ/98Auf+iALr/oQC8/48Avf+PACMAEv8lABP/7gAV//QAF//wABj/8QAZ/+IAG//yACT/4QAm/+cAJ//0ACr/6QAt/8gAMv/qADT/7AA6//UARP/TAEb/1QBH/9kASP/SAEr/1wBQ/90AUf/lAFL/2ABT/9YAVP/VAFX/6gBW/90AWP/gAFn/8gBa/9sAW//tAFz/5ABd/+oAfP/EAJH/7AANAAz/7wAR/+kAEv/jABX/7gAa//UAN//tADv/8wA8//AAPf/wAD//7QBA/+YAYP/uAHz/8gABABL/7wARAAr/8wAO//UAEP/hABUACAAX/+wAHP/xACD/6wAy//YANP/1ADf/7wA4//UAOf/vADz/7gA//+UAbP/1AHH/4QB8AAsABAAM//UAEv/rAD//9QBA//IAEgAK//QADP/wABH/8AAS/+gAFP/1ABX/9AAW//UAGv/xAC3/9QA3//QAOf/1ADz/7gA9//UAP//rAED/7gBg//AAbP/0AHz/9gACABL/7QBA//YADAAK/+QADP/1ABL/8QAU/+oAGv/hADf/4wA5/+4APP/kAD//4ABA/+YAYP/tAGz/4QALAAb/7gAO/+4AEP/jABH/xwAS/84AIP/1ACT/9AAt/9gAY//wAHH/9AB8/9UABAAQ/+cAEv/uACD/9gBx/+cABgAM//YAEv/zADf/8QA8//MAP//uAED/9QADADf/twA5/+4APP/ZAAQAFP/jABX/5QAW/+oAGv/VAAUACv/wADf/twA5/+cAPP/UALr/5QAjAAr/9AAN//EAFP/xABr/8AAi//YAN//aADj/+QA5/+wAPP/cAD//4gBF//kARv/7AEj/+wBJ//MASv/7AEv/+gBM//oATf/6AE7/+wBP//kAUP/7AFH/+gBS//sAVP/7AFX/+QBX//cAWP/5AFn/8QBa//kAW//7AFz/+QCR//sAuf/sALr/8ADF/+sAGAAS/+0ALf/7ADf/4gA7/+kAPP/4AD3/+QA///UAQP/tAEn/+ABN//sATv/7AFH/+wBV//sAVv/5AFf/+ABZ//kAW//4AFz/+wBd//MAYP/2AHz/+wCR//sAoAAXAKEAFQASAA3/8wAm//sAKv/6ADL/+QA0//kANv/5ADf/3AA4//sAOf/7ADr/+gA7/94APP/6AD//8wBJ//cAV//4AFn/9gBb//gAoAATACUADP/uABH/2wAS/94AFf/qACL/9QAk//sALf/gADf/2QA5//oAO//fADz/8AA9/+YAP//vAED/5QBE//YARf/6AEb/+ABH//kASP/3AEr/+QBL//oATP/5AE3/+gBO//gAT//6AFD/+gBR//sAUv/6AFP/9wBU//kAVv/6AFr/+gBg/+4AfP/dAJH/+ACgAAkAoQAGAB8AEP/rABf/9QAc//IAJv/pACr/6QAy/+YANP/mADb/+gA4//YAOv/0AEX/+QBG//kAR//6AEj/+QBJ//AASv/4AE//+ABQ//gAUf/1AFL/9wBT//sAVP/6AFX/8gBX/+0AWP/yAFn/4gBa//QAW//2AFz/7gCR//sAr//4ADcACf/1AA0AFwAQ/+MAEf/EABL/xAAV//EAFv/yABj/9gAZ//EAG//wAB3/5wAj/+IAJP/dACb/3wAn//gAKv/gAC3/eQAy/+EANP/lADX/+wA2/+YAOP/3ADr/7wBE/70ARf/4AEb/xABH/8cASP+/AEn/8QBK/8cAS//6AE7/9wBP//YAUP/IAFH/0ABS/8sAU/+8AFT/xQBV/9kAVv/PAFf/7wBY/9UAWf/nAFr/xgBb/98AXP/RAF3/2wBr//YAfP+GAJH/3wCeABMAr//IAML/8wDD//EAxQALAAoAEf/xABL/6wA3//YAO//qADz/+QA9//UAQP/1AEn/+QB8//sAoAAJABwAEv/zAET/9QBF//cARv/0AEf/9gBI//MASv/2AEv/+QBM//kATf/5AE7/+QBP//gAUP/5AFH/+QBS//YAU//2AFT/9gBV//gAVv/3AFj/9wBZ//oAWv/3AFv/+QBc//cAXf/5AJH/+QCgAAoAoQANAB4AEP/4ABL/9QBE//QARf/3AEb/9ABH//YASP/yAEn/+wBK//UAS//5AEz/+ABN//gATv/5AE//+ABQ//gAUf/4AFL/9QBT//YAVP/2AFX/+ABW//cAWP/2AFn/+QBa//cAW//4AFz/9wBd//gAkf/5AKAACwChAA0AHwAR//cAEv/rADv/+wBE//gARf/4AEb/+ABH//kASP/4AEr/+QBL//kATP/5AE3/+QBO//kAT//4AFD/+ABR//kAUv/5AFP/9gBU//kAVf/4AFb/+ABY//oAWf/7AFr/+ABb//oAXP/3AF3/+QB8//sAkf/5AKAABgChAAcAIwAQ/9sAFQASABf/8AAc//AAJv/dACr/3QAy/94ANP/gADb/+wA4//MAOv/0AEAACABE//oARf/0AEb/7gBH//QASP/tAEn/6gBK/+4AS//6AE//8ABQ//oAUf/1AFL/7ABU//EAVf/xAFf/2wBY/+EAWf/XAFr/6gBc/+EAYAALAGv/8gChABEAwv/lACwACf/wAAr/owAN/6IAEP+rABT/5QAVAAsAF//HABr/6gAc/7YAIv/yACb/4gAq/+AAMv/XADT/0QA3/4YAOP/YADn/qwA6//YAPP/DAD//uABF//EARv/1AEf/+gBI//UASf/iAEr/9gBL//kAT//wAFH/+ABS//IAVP/4AFX/9ABX/6UAWP/mAFn/rgBa//UAXP/lAGv/4gBx/5YAuf+kALr/pADC/8UAw//sAMX/oQAdABL/8gBE//UARf/4AEb/9QBH//cASP/0AEn/+wBK//YAS//5AEz/+QBN//kATv/5AE//+ABQ//kAUf/5AFL/9gBT//cAVP/2AFX/+QBW//cAWP/3AFn/+gBa//gAW//5AFz/9wBd//gAkf/5AKAACgChAAwAHQAS//YARP/1AEX/+ABG//QAR//3AEj/8wBJ//sASv/2AEv/+QBM//kATf/5AE7/+QBP//gAUP/5AFH/+QBS//YAU//3AFT/9gBV//kAVv/3AFj/9wBZ//oAWv/4AFv/+QBc//cAXf/5AJH/+QCgAAwAoQAOACYADP/uABH/6AAS/+IAFf/tABr/8gAi//IALf/wADf/0AA5//gAO//gADz/6QA9/+gAP//sAED/4wBE//gARf/7AEb/+gBH//oASP/5AEr/+gBL//oATP/6AE3/+gBO//kAT//7AFD/+wBR//sAUv/7AFP/+ABU//oAVf/7AFb/+wBa//oAXP/7AGD/7QB8/+wAkf/4AKAAAwAbABD/8wAR/9MAEv/SABX/8wAj//YAJP/5AC3/qgA7/+sAPf/1AET/7wBG//IAR//0AEj/7wBK//QATP/7AE7/+wBQ//kAUv/1AFP/8QBU//IAVv/6AFr/9wB8/7IAkf/5AJ8AGACgADgAoQA0AB0ALf/2ADf/2QA5//kAO//3ADz/8AA//+4ARP/5AEX/+gBG//kAR//6AEj/9wBK//kAS//6AEz/+gBN//sATv/6AE//+gBQ//sAUf/7AFL/+gBT//kAVP/5AFX/+wBW//sAWv/5AFz/+gCR//oAoAAIAKEACQAHABUAIAA3/94AQAANAGAAFQCfAAoAoAAhAKEAHgAWABL/9AA7//cASf/3AEv/+wBM//sATv/7AE//+gBQ//oAUf/5AFP/+wBV//kAV//2AFj/+wBZ//UAWv/7AFv/9wBc//gAXf/4AJH/+gCfABEAoAAeAKEAJwBMAAn/7QANABsAEP+3ABH/vAAS/8EAE//wABf/9gAZ/9MAG//vABz/9AAd/7sAIgAPACP/ugAk/8sAJv/HACf/9wAq/8oAK//7AC3/ngAy/8gAM//6ADT/2QA1//sANv/5ADr/+AA/AAkAQAAgAET/cwBF/+UARv9zAEf/dABI/3EASf/OAEr/dABL/+QATP/tAE7/3wBP//gAUP9zAFH/dQBS/3QAU/9wAFT/cwBV/4cAVv96AFf/zwBY/3YAWf+hAFr/cABb/40AXP9yAF3/gABgABEAa//kAHz/qgCR/88Akv+VAJP/ggCU/4YAlf+BAJf/lgCa/48AnP9+AJ4AMACg//UAof/iAKL/nwCj/68Apf+FAKb/hQCq/8wArP+GAK//nADC/70Aw//AAMUAHQAiAAz/9gAR/+MAEv/gABX/9gAk//sALf/qADv/6gA9//gARP/1AEX/+QBG//YAR//3AEj/9QBK//cAS//6AEz/9wBN//oATv/4AE//+QBQ//kAUf/6AFL/+ABT//QAVP/2AFX/+wBW//kAWP/7AFr/+ABc//oAfP/mAJH/9wCf//0AoAAcAKEAHwAuAAn/9gANABQAEP/hABH/ywAS/8sAGf/uAB3/6QAj/+AAJP/sACb/7gAn//sAKv/wAC3/yQAy//MANP/0ADr/+wBAABUARP/RAEb/0gBH/9UASP/OAEn/+gBK/9QATv/7AFD/1wBR/9kAUv/TAFP/1ABU/9UAVf/jAFb/1QBX//gAWP/WAFn/8wBa/9YAW//sAFz/2QBd/+gAfP+8AJH/4gCeABUAnwAJAKAAHAChACkAr//ZAML/6wAgABH/5wAS/+EAJP/6AC3/7gA7//MAPf/6AET/8wBF//gARv/0AEf/9QBI//MASv/1AEv/+ABM//gATf/6AE7/9gBP//cAUP/2AFH/+ABS//YAU//yAFT/9QBV//kAVv/2AFj/+QBa//UAXP/4AF3/+wB8/+kAkf/0AKAAGwChABsAIAAK//YAEP/cABUAGQAX/+wAHP/pACb/4wAq/+IAMv/iADT/5AA4/+0AOv/0AEAAEABF//MARv/2AEf/+gBI//YASf/oAEr/9wBL//sAT//wAFH/+wBS//QAVP/4AFX/9wBX/9gAWP/qAFn/0gBa//MAXP/qAGAADgBr//UAwv/kAEAACf/sAA0AIQAQ/8QAEf+zABL/vgAT//AAF//zABj/9QAZ/+EAG//zAB3/1QAj/80AJP/bACb/2gAn//UAKP/6ACr/2gAr//kALf+yADL/3gAz//kANP/kADX/+QA2//oAOv/3AEAAEwBE/6oARf/7AEb/rgBH/7UASP+mAEn/9ABK/7QAS//7AE7/+QBP//oAUP+2AFH/vQBS/7YAU/+vAFT/sQBV/88AVv+pAFf/8ABY/7YAWf/hAFr/uABb/9YAXP+6AF3/zgBgAAsAa//rAHz/oQCR/9kAkv+wAJr/sACeABwAoAARAKEAIQCj/8IAqv/JAK//uwDC/9kAw//uACEACf/2ABD/6QAX/+4AHP/tACb/7wAq/+8AMv/sADT/7AA4//cAOv/7AEX/+QBG//kAR//7AEj/+gBJ/+4ASv/5AEv/+gBO//sAT//4AFD/+QBR//YAUv/4AFT/+gBV//MAV//rAFj/8wBZ/+EAWv/2AFv/+QBc//AAa//wAJH/+wChABIAIgAT/+sAFv/1ABf/5QAY//QAGf/iABv/7QAc/+QAJv/fACr/4AAt/+8AMv/gADT/4gA3ABoAOv/2AET/8wBG/+YAR//rAEj/5QBJ//UASv/nAFD/8wBR/+8AUv/mAFT/6ABV/+8AVv/wAFf/7wBY/+MAWf/nAFr/5QBc/+UAXv/tAJ4ADgChAA4AGwAK/8IAE//yABT/3wAX/+QAGf/0ABr/5AAc/9kAJf/2ACb/7wAq/+4AMv/sADT/6wA3/8IAOP/pADn/zwA6//MAPP/YAEX/9QBJ/+wAT//0AFX/9gBX/+IAWP/wAFn/3wBa//UAXP/wALr/vAAIACMACAA3/4IAOf/hADz/xAA//+kAQAALAGAAEgDF//gAJAAK//gADP/tAA3/9AAR//YAEv/oACL/7AAk//oAJf/2ACf/9wAo//gAKf/2ACv/+AAs//YALf/4AC7/9gAv//YAMP/0ADH/9QAz//UANf/4ADb/9wA3/3EAOP/4ADn/1gA6//oAO//SADz/tAA9/+kAP//fAED/5gBJ//wAYP/sAHz/8gC5/+cAuv/tAMX/6QAfAAz/9gAQ/+UAEv/0ACL/7wAl//oAJv/5ACr/+QAs//oALv/7AC//+wAw//gAMf/6ADL/+QAz//sANP/5ADb/+QA3/2kAOP/0ADn/2AA6//gAO//eADz/sQA9//gAP//dAED/8ABW//wAWP/8AFv/+gBg//QAuf/2AMX/7gAWABD/9wAl//oAJv/6ACf/+gAo//oAKf/5ACr/+gAr//oALP/5AC7/+QAv//kAMP/5ADH/+QAy//kAM//5ADT/+QA1//oAOP/4ADr/+gA9//sAoAAVAKEAGQAeAAz/9QAQ/+sAEv/0ACL/7gAl//gAJ//6ACj/+gAp//oAK//7ACz/+QAu//gAL//4ADD/9wAx//gAMv/7ADP/+AA0//sANf/6ADf/aAA4//QAOf/VADr/+gA7/+sAPP+zAD3/+gA//9wAQP/wAEn//ABg//UAxf/tADEABQAhAAoAFwAMABUADQA6ABD/3wAR/+4AEv/lAB3/8gAiAC4AI//vACT/9QAlAAYAJv/6ACr/+wAt/+EAMAAHADMACgA3AGMAOQBCADsAMwA8AEEAPQAwAD8AGABAAEEARP/tAEb/7QBH//EASP/oAEr/8ABMAAwAUP/wAFL/8ABT/+4AVP/tAFb/9wBY//sAWv/1AF8AFwBgADsAfP/hAJ4AUwCfAAMAoAAUAKEAQgCv//sAuQArALoADgDC/+8AxQA2ACAADf/1ACL/7gAl//YAJv/7ACf/+AAo//gAKf/4ACr/+wAr//gALP/4AC7/9wAv//cAMP/2ADH/9wAy//oAM//3ADT/+QA1//gANv/7ADf/XQA4//EAOf/SADr/+AA8/7cAPf/6AD//1ABJ//UAV//8AFn/+QC5/+wAuv/yAMX/5wASAAQADgAK//YADf/yAA8ABwARABIAHQAKAB4AAQAjABQAN/+CADn/3QA8/8QAP//iAFn/+wC5/+YAuv/tALsABwC+AAcAxf/lABoAEv/0ACT/+wAl//kAJv/7ACf/+gAo//oAKf/6ACr/+wAr//oALP/6AC7/+QAv//kAMP/4ADH/+QAy//oAM//5ADT/+wA1//oANv/7ADf/4wA4//YAOv/7ADv/+wA8//sAPf/2AKEABwAXACX/+QAm//sAJ//6ACj/+gAp//oAKv/7ACv/+wAs//oALv/5AC//+gAw//gAMf/5ADL/+gAz//kANP/6ADX/+gA2//sAN//3ADj/9AA5//kAOv/6ADz/9wA9//sAGQAQ/9oAJf/6ACb/6QAq/+oAMv/qADT/6gA3/5AAOP/wADn/6gA6//QAPP/cAD//7ABE//wARv/wAEf/9gBI/+8ASv/xAE///ABS/+8AVP/zAFb/+gBY//MAWv/wAML/6QDF/+8AAwBAAAUAYAAJAHH/4wAOAAQADgAPAAgAEQAaACMAEwA3/4kAOP/6ADn/3gA8/8gAP//jAEAADwBgABMAuwAIAL4ACADF//IACgAQ//gAJf/7ADT/+wA3/2wAOP/3ADn/1wA8/7gAP//bALn/+ADF/+wAIwAM/+0ADf/3ABL/6gAi/+wAJP/7ACX/9QAn//cAKP/3ACn/9gAr//gALP/2AC7/9gAv//YAMP/zADH/9AAz//UANf/3ADb/+AA3/10AOP/1ADn/0wA6//oAO//WADz/sAA9/+8AP//WAED/5wBJ//QAWf/8AF3/+ABg/+wAfP/4ALn/7QC6//MAxf/qACEADP/uABL/6wAi/+0AJP/7ACX/9QAn//cAKP/3ACn/9gAr//kALP/2AC7/9QAv//UAMP/0ADH/9AAz//UANf/4ADb/+QA3/14AOP/1ADn/1AA6//oAO//WADz/swA9/+8AP//XAED/5wBJ//cAXf/6AGD/7AB8//gAuf/wALr/9wDF/+sAIwAN//YADwAJACL/7QAl//YAJv/6ACf/+AAo//gAKf/4ACr/+gAr//gALP/4AC7/9wAv//cAMP/2ADH/9wAy//kAM//3ADT/+QA1//gANv/6ADf/WQA4//EAOf/RADr/9wA8/7QAPf/4AD//1ABJ//MAV//8AFn/+QC5/+4Auv/0ALsACQC+AAkAxf/pACcADP/uAA0ABQAQ/8sAEf/HABL/1AAi/+wAI//yACT/8gAl//oAJ//4ACj/+QAp//YAK//4ACz/+AAt/6AALv/4AC//+AAw//YAMf/3ADP/+AA1//kANv/6ADf/kgA5//QAO/+1ADz/2wA9/9QAP//uAED/4wBE//QARv/3AEf/+wBI/+8ASv/6AFL//ABT//kAVP/5AGD/7QB8/7sAHgAM//UAEP/yABL/9AAi/+8AJf/4ACf/+gAo//kAKf/5ACv/+wAs//kALv/4AC//+AAw//cAMf/3ADL/+wAz//gANP/7ADX/+QA3/2UAOP/1ADn/1gA6//oAO//tADz/sQA9//oAP//cAED/8QBJ//sAYP/2AMX/7gAIABD/4AA3/5cAOP/6ADn/7gA8/+AAP//tAML/7gDF//UAHwAM/+4AEf/3ABL/6AAi/+4AJP/6ACX/9wAn//gAKP/4ACn/9wAr//gALP/3AC3/+QAu//cAL//3ADD/9gAx//YAM//3ADX/+AA2//kAN/9qADj/+AA5/90AOv/6ADv/1QA8/78APf/rAD//4gBA/+cAYP/tAHz/8wDF//MAJwAM//EADQAPABD/6QAR/+EAEv/ZAB3/+AAi//MAI//vACT/8gAn//sAKf/5ACv/+wAs//sALf/PAC7/+wAv//sAMP/5ADH/+wA1//sAN/+XADn/+wA7/9UAPP/uAD3/5gA///UAQP/sAET/8ABG//MAR//2AEj/7ABK//YAUP/7AFL/9wBT//MAVP/zAFb//ABa//oAYP/yAHz/zgAhAAz/8QAN//YAEv/wACL/7QAl//YAJ//4ACj/+AAp//gAK//5ACz/9wAu//YAL//2ADD/9QAx//YAM//2ADX/+AA2//sAN/9gADj/9AA5/9YAOv/6ADv/4AA8/7YAPf/0AD//1gBA/+0ASf/3AFn/+wBd//sAYP/wALn/7QC6//QAxf/oABQABAAUAAwACAAPAA8AEP/pABEAGAAdABIAHgABACMAGwAm//gAKv/2ADL/8gA0//IAN/+eADn/4wA8/98AP//wAEAADQBgAA0AuwAPAL4ADwAaABD/+AAi//AAJf/4ACb/+gAn//oAKP/6ACn/+gAq//oAK//6ACz/+gAu//kAL//5ADD/+AAx//kAMv/5ADP/+QA0//kANf/6ADf/cQA4//QAOf/YADr/+QA8/8IAPf/7AD//4ADF/+8AGgAQ/+UAIv/yACX/9wAm//kAJ//6ACj/+QAp//oAKv/5ACv/+gAs//kALv/4AC//+AAw//cAMf/4ADL/+AAz//gANP/4ADX/+QA3/2wAOP/yADn/1gA6//gAO//7ADz/xAA//98Axf/vABIAC//2ABP/9AAX/+cAGf/xABz/5gAm/+0AKv/tADL/6wA0/+sAOP/0ADsAFgBJ//YAV//vAFj/8wBZ/+oAXP/zAF7/7wB8AA0AAgCgABEAoQATAAEADP/2AAMAN/++ADz/7gBNACUAAgAX//EAGv/xAAYALf/uADf/4AA7/+sAPP/sAD3/6gB8/+sAAQAZ//IABQAU/+IAFf/RABb/4AAa/9sAT//jADIAJP/pACX/6wAm/+wAJ//rACj/6wAp/+wAKv/tACv/6wAs/+wALf/dAC7/6wAv/+sAMP/rADH/7gAy/+0AM//tADT/7QA1/+0ANv/uADf/sAA4/+wAOf/jADr/7AA7/+wAPP/dAD3/5ABE/+gARf/rAEb/6ABH/+gASP/nAEn/9ABKAAYAS//rAEz/6QBO/+sAT//qAFD/6QBR/+wAUv/pAFT/5wBV/+0AVv/mAFf/8QBY/+sAWf/xAFr/6QBb//AAXf/sAHz/4AABAAwACAACAAwAOAA/ADIAAgAMAB4APwANACIACv/2AAz/9gAN//IAEv/yACX/9QAn//gAKP/3ACn/+AAr//kALP/2AC7/9gAv//UAMP/0ADH/9QAy//oAM//1ADT/+gA1//gAN//aADj/8QA5/+gAOv/5ADv/5gA8/+IAPf/3AD//7ABJ//cAV//5AFn/+ABb//sAXf/5ALn/9gC6//gAxf/1AAIADQAZAMUABwABAMUAFgAGAA0AIgAiAAkAQAArAGAAHAC5AA4AxQAQAA8ABAATAAUAMgAKADAADQAUACIADgBFABkASwAZAE4AFQBPAAcAXwAqAGAABwBrAAcAuQAnALoAOADFACAAEwAEABQABQAyAAoALAAMAA8ADQAsACIAPAA/ABsAQAAkAEUAGgBLABkATAAUAE0AGQBOABUATwAHAF8ALABgAC4AuQA1ALoALwDFAFIADwAR/6IAJP/uAC3/swBE/+kARv/sAEf/3wBI/+YASv/wAFL/8gBT//AAVP/wAHz/sACfAA4AoAAtAKEALgATABH/oQAS/7oAI//VACT/6wAm//UAKv/3AC3/swBE/+UARv/pAEf/2wBI/+IASv/sAFL/7gBT/+wAVP/tAHz/rQCgAB0AoQAmAML/9AAEABH/jwCfAAsAoAAqAKEAKAADABH/jwCgABoAoQAkAAIABf+CAE0ACAADADf/uwA5//AAPP/nAAkALf/wADf/twA5/+sAO//cADz/zgA9//YASf/0AF3/7wB8/+4AAwAX//YAGv/2ABz/8AAIACT/9wAt/68ANwAKAEf/9gB8/8QAnwAVAKAANAChADQAAgASAAUABgAAAAkACwACAA0AHQAFACAAIAAWACMAPwAXAEQAYAA0AGIAYgBRAGQAZABSAGsAbABTAHEAcQBVAHUAdQBWAIIAggBXAIQAhQBYAJEAkQBaAJUAlQBbAJ4AoQBcALkAvgBgAMIAxQBmAAAAAAABAAAAAMmJbzEAAAAAywVUGwAAAADLBcTm"

/***/ }),

/***/ "./node_modules/btoa/index.js":
/*!************************************!*\
  !*** ./node_modules/btoa/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function () {
  "use strict";

  function btoa(str) {
    var buffer;

    if (str instanceof Buffer) {
      buffer = str;
    } else {
      buffer = Buffer.from(str.toString(), 'binary');
    }

    return buffer.toString('base64');
  }

  module.exports = btoa;
}());


/***/ }),

/***/ "./node_modules/canvas-toBlob/canvas-toBlob.js":
/*!*****************************************************!*\
  !*** ./node_modules/canvas-toBlob/canvas-toBlob.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* canvas-toBlob.js
 * A canvas.toBlob() implementation.
 * 2016-05-26
 * 
 * By Eli Grey, http://eligrey.com and Devin Samarin, https://github.com/eboyjr
 * License: MIT
 *   See https://github.com/eligrey/canvas-toBlob.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */

/*! @source http://purl.eligrey.com/github/canvas-toBlob.js/blob/master/canvas-toBlob.js */

(function(view) {
"use strict";
var
	  Uint8Array = view.Uint8Array
	, HTMLCanvasElement = view.HTMLCanvasElement
	, canvas_proto = HTMLCanvasElement && HTMLCanvasElement.prototype
	, is_base64_regex = /\s*;\s*base64\s*(?:;|$)/i
	, to_data_url = "toDataURL"
	, base64_ranks
	, decode_base64 = function(base64) {
		var
			  len = base64.length
			, buffer = new Uint8Array(len / 4 * 3 | 0)
			, i = 0
			, outptr = 0
			, last = [0, 0]
			, state = 0
			, save = 0
			, rank
			, code
			, undef
		;
		while (len--) {
			code = base64.charCodeAt(i++);
			rank = base64_ranks[code-43];
			if (rank !== 255 && rank !== undef) {
				last[1] = last[0];
				last[0] = code;
				save = (save << 6) | rank;
				state++;
				if (state === 4) {
					buffer[outptr++] = save >>> 16;
					if (last[1] !== 61 /* padding character */) {
						buffer[outptr++] = save >>> 8;
					}
					if (last[0] !== 61 /* padding character */) {
						buffer[outptr++] = save;
					}
					state = 0;
				}
			}
		}
		// 2/3 chance there's going to be some null bytes at the end, but that
		// doesn't really matter with most image formats.
		// If it somehow matters for you, truncate the buffer up outptr.
		return buffer;
	}
;
if (Uint8Array) {
	base64_ranks = new Uint8Array([
		  62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1
		, -1, -1,  0, -1, -1, -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9
		, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25
		, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35
		, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
	]);
}
if (HTMLCanvasElement && (!canvas_proto.toBlob || !canvas_proto.toBlobHD)) {
	if (!canvas_proto.toBlob)
	canvas_proto.toBlob = function(callback, type /*, ...args*/) {
		  if (!type) {
			type = "image/png";
		} if (this.mozGetAsFile) {
			callback(this.mozGetAsFile("canvas", type));
			return;
		} if (this.msToBlob && /^\s*image\/png\s*(?:$|;)/i.test(type)) {
			callback(this.msToBlob());
			return;
		}

		var
			  args = Array.prototype.slice.call(arguments, 1)
			, dataURI = this[to_data_url].apply(this, args)
			, header_end = dataURI.indexOf(",")
			, data = dataURI.substring(header_end + 1)
			, is_base64 = is_base64_regex.test(dataURI.substring(0, header_end))
			, blob
		;
		if (Blob.fake) {
			// no reason to decode a data: URI that's just going to become a data URI again
			blob = new Blob
			if (is_base64) {
				blob.encoding = "base64";
			} else {
				blob.encoding = "URI";
			}
			blob.data = data;
			blob.size = data.length;
		} else if (Uint8Array) {
			if (is_base64) {
				blob = new Blob([decode_base64(data)], {type: type});
			} else {
				blob = new Blob([decodeURIComponent(data)], {type: type});
			}
		}
		callback(blob);
	};

	if (!canvas_proto.toBlobHD && canvas_proto.toDataURLHD) {
		canvas_proto.toBlobHD = function() {
			to_data_url = "toDataURLHD";
			var blob = this.toBlob();
			to_data_url = "toDataURL";
			return blob;
		}
	} else {
		canvas_proto.toBlobHD = canvas_proto.toBlob;
	}
}
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));


/***/ }),

/***/ "./node_modules/dompurify/dist/purify.es.js":
/*!**************************************************!*\
  !*** ./node_modules/dompurify/dist/purify.es.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/*! @license DOMPurify | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.2.2/LICENSE */

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var hasOwnProperty = Object.hasOwnProperty,
    setPrototypeOf = Object.setPrototypeOf,
    isFrozen = Object.isFrozen,
    getPrototypeOf = Object.getPrototypeOf,
    getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var freeze = Object.freeze,
    seal = Object.seal,
    create = Object.create; // eslint-disable-line import/no-mutable-exports

var _ref = typeof Reflect !== 'undefined' && Reflect,
    apply = _ref.apply,
    construct = _ref.construct;

if (!apply) {
  apply = function apply(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}

if (!freeze) {
  freeze = function freeze(x) {
    return x;
  };
}

if (!seal) {
  seal = function seal(x) {
    return x;
  };
}

if (!construct) {
  construct = function construct(Func, args) {
    return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();
  };
}

var arrayForEach = unapply(Array.prototype.forEach);
var arrayPop = unapply(Array.prototype.pop);
var arrayPush = unapply(Array.prototype.push);

var stringToLowerCase = unapply(String.prototype.toLowerCase);
var stringMatch = unapply(String.prototype.match);
var stringReplace = unapply(String.prototype.replace);
var stringIndexOf = unapply(String.prototype.indexOf);
var stringTrim = unapply(String.prototype.trim);

var regExpTest = unapply(RegExp.prototype.test);

var typeErrorCreate = unconstruct(TypeError);

function unapply(func) {
  return function (thisArg) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return apply(func, thisArg, args);
  };
}

function unconstruct(func) {
  return function () {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return construct(func, args);
  };
}

/* Add properties to a lookup table */
function addToSet(set, array) {
  if (setPrototypeOf) {
    // Make 'in' and truthy checks like Boolean(set.constructor)
    // independent of any properties defined on Object.prototype.
    // Prevent prototype setters from intercepting set as a this value.
    setPrototypeOf(set, null);
  }

  var l = array.length;
  while (l--) {
    var element = array[l];
    if (typeof element === 'string') {
      var lcElement = stringToLowerCase(element);
      if (lcElement !== element) {
        // Config presets (e.g. tags.js, attrs.js) are immutable.
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }

        element = lcElement;
      }
    }

    set[element] = true;
  }

  return set;
}

/* Shallow clone an object */
function clone(object) {
  var newObject = create(null);

  var property = void 0;
  for (property in object) {
    if (apply(hasOwnProperty, object, [property])) {
      newObject[property] = object[property];
    }
  }

  return newObject;
}

/* IE10 doesn't support __lookupGetter__ so lets'
 * simulate it. It also automatically checks
 * if the prop is function or getter and behaves
 * accordingly. */
function lookupGetter(object, prop) {
  while (object !== null) {
    var desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }

      if (typeof desc.value === 'function') {
        return unapply(desc.value);
      }
    }

    object = getPrototypeOf(object);
  }

  function fallbackValue(element) {
    console.warn('fallback value for', element);
    return null;
  }

  return fallbackValue;
}

var html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);

// SVG
var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);

var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);

// List of SVG elements that are disallowed by default.
// We still need to know them so that we can do namespace
// checks properly in case one wants to add them to
// allow-list.
var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'feimage', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);

var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);

// Similarly to SVG, we want to know all MathML elements,
// even those that we disallow by default.
var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);

var text = freeze(['#text']);

var html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns']);

var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);

var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);

var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

// eslint-disable-next-line unicorn/better-regex
var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape
var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
);

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var getGlobal = function getGlobal() {
  return typeof window === 'undefined' ? null : window;
};

/**
 * Creates a no-op policy for internal use only.
 * Don't export this function outside this module!
 * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
 * @param {Document} document The document object (to determine policy name suffix)
 * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
 * are not supported).
 */
var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
  if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
    return null;
  }

  // Allow the callers to control the unique policy name
  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
  // Policy creation with duplicate names throws in Trusted Types.
  var suffix = null;
  var ATTR_NAME = 'data-tt-policy-suffix';
  if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
    suffix = document.currentScript.getAttribute(ATTR_NAME);
  }

  var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML: function createHTML(html$$1) {
        return html$$1;
      }
    });
  } catch (_) {
    // Policy creation failed (most likely another DOMPurify script has
    // already run). Skip creating the policy, as this will only cause errors
    // if TT are enforced.
    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
    return null;
  }
};

function createDOMPurify() {
  var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

  var DOMPurify = function DOMPurify(root) {
    return createDOMPurify(root);
  };

  /**
   * Version label, exposed for easier checks
   * if DOMPurify is up to date or not
   */
  DOMPurify.version = '2.2.7';

  /**
   * Array of elements that DOMPurify removed during sanitation.
   * Empty if nothing was removed.
   */
  DOMPurify.removed = [];

  if (!window || !window.document || window.document.nodeType !== 9) {
    // Not running in a browser, provide a factory function
    // so that you can pass your own Window
    DOMPurify.isSupported = false;

    return DOMPurify;
  }

  var originalDocument = window.document;

  var document = window.document;
  var DocumentFragment = window.DocumentFragment,
      HTMLTemplateElement = window.HTMLTemplateElement,
      Node = window.Node,
      Element = window.Element,
      NodeFilter = window.NodeFilter,
      _window$NamedNodeMap = window.NamedNodeMap,
      NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
      Text = window.Text,
      Comment = window.Comment,
      DOMParser = window.DOMParser,
      trustedTypes = window.trustedTypes;


  var ElementPrototype = Element.prototype;

  var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
  var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
  var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
  var getParentNode = lookupGetter(ElementPrototype, 'parentNode');

  // As per issue #47, the web-components registry is inherited by a
  // new document created via createHTMLDocument. As per the spec
  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
  // a new empty registry is used when creating a template contents owner
  // document, so we use that as our parent document to ensure nothing
  // is inherited.
  if (typeof HTMLTemplateElement === 'function') {
    var template = document.createElement('template');
    if (template.content && template.content.ownerDocument) {
      document = template.content.ownerDocument;
    }
  }

  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
  var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';

  var _document = document,
      implementation = _document.implementation,
      createNodeIterator = _document.createNodeIterator,
      getElementsByTagName = _document.getElementsByTagName,
      createDocumentFragment = _document.createDocumentFragment;
  var importNode = originalDocument.importNode;


  var documentMode = {};
  try {
    documentMode = clone(document).documentMode ? document.documentMode : {};
  } catch (_) {}

  var hooks = {};

  /**
   * Expose whether this browser supports running the full DOMPurify.
   */
  DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;

  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,
      ERB_EXPR$$1 = ERB_EXPR,
      DATA_ATTR$$1 = DATA_ATTR,
      ARIA_ATTR$$1 = ARIA_ATTR,
      IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,
      ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;

  /**
   * We consider the elements and attributes below to be safe. Ideally
   * don't add any new ones but feel free to remove unwanted ones.
   */

  /* allowed element names */

  var ALLOWED_TAGS = null;
  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));

  /* Allowed attribute names */
  var ALLOWED_ATTR = null;
  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));

  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
  var FORBID_TAGS = null;

  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
  var FORBID_ATTR = null;

  /* Decide if ARIA attributes are okay */
  var ALLOW_ARIA_ATTR = true;

  /* Decide if custom data attributes are okay */
  var ALLOW_DATA_ATTR = true;

  /* Decide if unknown protocols are okay */
  var ALLOW_UNKNOWN_PROTOCOLS = false;

  /* Output should be safe for common template engines.
   * This means, DOMPurify removes data attributes, mustaches and ERB
   */
  var SAFE_FOR_TEMPLATES = false;

  /* Decide if document with <html>... should be returned */
  var WHOLE_DOCUMENT = false;

  /* Track whether config is already set on this instance of DOMPurify. */
  var SET_CONFIG = false;

  /* Decide if all elements (e.g. style, script) must be children of
   * document.body. By default, browsers might move them to document.head */
  var FORCE_BODY = false;

  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
   * string (or a TrustedHTML object if Trusted Types are supported).
   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
   */
  var RETURN_DOM = false;

  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
   * string  (or a TrustedHTML object if Trusted Types are supported) */
  var RETURN_DOM_FRAGMENT = false;

  /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM
   * `Node` is imported into the current `Document`. If this flag is not enabled the
   * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by
   * DOMPurify.
   *
   * This defaults to `true` starting DOMPurify 2.2.0. Note that setting it to `false`
   * might cause XSS from attacks hidden in closed shadowroots in case the browser
   * supports Declarative Shadow: DOM https://web.dev/declarative-shadow-dom/
   */
  var RETURN_DOM_IMPORT = true;

  /* Try to return a Trusted Type object instead of a string, return a string in
   * case Trusted Types are not supported  */
  var RETURN_TRUSTED_TYPE = false;

  /* Output should be free from DOM clobbering attacks? */
  var SANITIZE_DOM = true;

  /* Keep element content when removing element? */
  var KEEP_CONTENT = true;

  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
   * of importing it into a new Document and returning a sanitized copy */
  var IN_PLACE = false;

  /* Allow usage of profiles like html, svg and mathMl */
  var USE_PROFILES = {};

  /* Tags to ignore content of when KEEP_CONTENT is true */
  var FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);

  /* Tags that are safe for data: URIs */
  var DATA_URI_TAGS = null;
  var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);

  /* Attributes safe for values like "javascript:" */
  var URI_SAFE_ATTRIBUTES = null;
  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'summary', 'title', 'value', 'style', 'xmlns']);

  /* Keep a reference to config to pass to hooks */
  var CONFIG = null;

  /* Ideally, do not touch anything below this line */
  /* ______________________________________________ */

  var formElement = document.createElement('form');

  /**
   * _parseConfig
   *
   * @param  {Object} cfg optional config literal
   */
  // eslint-disable-next-line complexity
  var _parseConfig = function _parseConfig(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }

    /* Shield configuration object from tampering */
    if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {
      cfg = {};
    }

    /* Shield configuration object from prototype pollution */
    cfg = clone(cfg);

    /* Set configuration parameters */
    ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
    URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
    FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
    FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
    USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
    RETURN_DOM = cfg.RETURN_DOM || false; // Default false
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
    RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false; // Default true
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
    FORCE_BODY = cfg.FORCE_BODY || false; // Default false
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
    IN_PLACE = cfg.IN_PLACE || false; // Default false
    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }

    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }

    /* Parse profile info */
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html);
        addToSet(ALLOWED_ATTR, html$1);
      }

      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }

      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }

      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl);
        addToSet(ALLOWED_ATTR, mathMl$1);
        addToSet(ALLOWED_ATTR, xml);
      }
    }

    /* Merge configuration parameters */
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }

      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
    }

    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }

      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
    }

    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
    }

    /* Add #text in case KEEP_CONTENT is set to true */
    if (KEEP_CONTENT) {
      ALLOWED_TAGS['#text'] = true;
    }

    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
    }

    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ['tbody']);
      delete FORBID_TAGS.tbody;
    }

    // Prevent further manipulation of configuration.
    // Not available in IE8, Safari 5, etc.
    if (freeze) {
      freeze(cfg);
    }

    CONFIG = cfg;
  };

  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);

  var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);

  /* Keep track of all possible SVG and MathML tags
   * so that we can perform the namespace checks
   * correctly. */
  var ALL_SVG_TAGS = addToSet({}, svg);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);

  var ALL_MATHML_TAGS = addToSet({}, mathMl);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);

  var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
  var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
  var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';

  /**
   *
   *
   * @param  {Element} element a DOM element whose namespace is being checked
   * @returns {boolean} Return false if the element has a
   *  namespace that a spec-compliant parser would never
   *  return. Return true otherwise.
   */
  var _checkValidNamespace = function _checkValidNamespace(element) {
    var parent = getParentNode(element);

    // In JSDOM, if we're inside shadow DOM, then parentNode
    // can be null. We just simulate parent in this case.
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: HTML_NAMESPACE,
        tagName: 'template'
      };
    }

    var tagName = stringToLowerCase(element.tagName);
    var parentTagName = stringToLowerCase(parent.tagName);

    if (element.namespaceURI === SVG_NAMESPACE) {
      // The only way to switch from HTML namespace to SVG
      // is via <svg>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'svg';
      }

      // The only way to switch from MathML to SVG is via
      // svg if parent is either <annotation-xml> or MathML
      // text integration points.
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }

      // We only allow elements that are defined in SVG
      // spec. All others are disallowed in SVG namespace.
      return Boolean(ALL_SVG_TAGS[tagName]);
    }

    if (element.namespaceURI === MATHML_NAMESPACE) {
      // The only way to switch from HTML namespace to MathML
      // is via <math>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'math';
      }

      // The only way to switch from SVG to MathML is via
      // <math> and HTML integration points
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
      }

      // We only allow elements that are defined in MathML
      // spec. All others are disallowed in MathML namespace.
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }

    if (element.namespaceURI === HTML_NAMESPACE) {
      // The only way to switch from SVG to HTML is via
      // HTML integration points, and from MathML to HTML
      // is via MathML text integration points
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }

      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }

      // Certain elements are allowed in both SVG and HTML
      // namespace. We need to specify them explicitly
      // so that they don't get erronously deleted from
      // HTML namespace.
      var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']);

      // We disallow tags that are specific for MathML
      // or SVG and should never appear in HTML namespace
      return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);
    }

    // The code should never reach this place (this means
    // that the element somehow got namespace that is not
    // HTML, SVG or MathML). Return false just in case.
    return false;
  };

  /**
   * _forceRemove
   *
   * @param  {Node} node a DOM node
   */
  var _forceRemove = function _forceRemove(node) {
    arrayPush(DOMPurify.removed, { element: node });
    try {
      node.parentNode.removeChild(node);
    } catch (_) {
      try {
        node.outerHTML = emptyHTML;
      } catch (_) {
        node.remove();
      }
    }
  };

  /**
   * _removeAttribute
   *
   * @param  {String} name an Attribute name
   * @param  {Node} node a DOM node
   */
  var _removeAttribute = function _removeAttribute(name, node) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node.getAttributeNode(name),
        from: node
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node
      });
    }

    node.removeAttribute(name);

    // We void attribute values for unremovable "is"" attributes
    if (name === 'is' && !ALLOWED_ATTR[name]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node);
        } catch (_) {}
      } else {
        try {
          node.setAttribute(name, '');
        } catch (_) {}
      }
    }
  };

  /**
   * _initDocument
   *
   * @param  {String} dirty a string of dirty markup
   * @return {Document} a DOM, filled with the dirty markup
   */
  var _initDocument = function _initDocument(dirty) {
    /* Create a HTML document */
    var doc = void 0;
    var leadingWhitespace = void 0;

    if (FORCE_BODY) {
      dirty = '<remove></remove>' + dirty;
    } else {
      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
      var matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }

    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    /* Use the DOMParser API by default, fallback later if needs be */
    try {
      doc = new DOMParser().parseFromString(dirtyPayload, 'text/html');
    } catch (_) {}

    /* Use createHTMLDocument in case DOMParser is not available */
    if (!doc || !doc.documentElement) {
      doc = implementation.createHTMLDocument('');
      var _doc = doc,
          body = _doc.body;

      body.parentNode.removeChild(body.parentNode.firstElementChild);
      body.outerHTML = dirtyPayload;
    }

    if (dirty && leadingWhitespace) {
      doc.body.insertBefore(document.createTextNode(leadingWhitespace), doc.body.childNodes[0] || null);
    }

    /* Work on whole document or just its body */
    return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
  };

  /**
   * _createIterator
   *
   * @param  {Document} root document/fragment to create iterator for
   * @return {Iterator} iterator instance
   */
  var _createIterator = function _createIterator(root) {
    return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, function () {
      return NodeFilter.FILTER_ACCEPT;
    }, false);
  };

  /**
   * _isClobbered
   *
   * @param  {Node} elm element to check for clobbering attacks
   * @return {Boolean} true if clobbered, false if safe
   */
  var _isClobbered = function _isClobbered(elm) {
    if (elm instanceof Text || elm instanceof Comment) {
      return false;
    }

    if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function') {
      return true;
    }

    return false;
  };

  /**
   * _isNode
   *
   * @param  {Node} obj object to check whether it's a DOM node
   * @return {Boolean} true is object is a DOM node
   */
  var _isNode = function _isNode(object) {
    return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
  };

  /**
   * _executeHook
   * Execute user configurable hooks
   *
   * @param  {String} entryPoint  Name of the hook's entry point
   * @param  {Node} currentNode node to work on with the hook
   * @param  {Object} data additional hook parameters
   */
  var _executeHook = function _executeHook(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }

    arrayForEach(hooks[entryPoint], function (hook) {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };

  /**
   * _sanitizeElements
   *
   * @protect nodeName
   * @protect textContent
   * @protect removeChild
   *
   * @param   {Node} currentNode to check for permission to exist
   * @return  {Boolean} true if node was killed, false if left alive
   */
  var _sanitizeElements = function _sanitizeElements(currentNode) {
    var content = void 0;

    /* Execute a hook if present */
    _executeHook('beforeSanitizeElements', currentNode, null);

    /* Check if element is clobbered or can clobber */
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Check if tagname contains Unicode */
    if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Now let's check the element's type and name */
    var tagName = stringToLowerCase(currentNode.nodeName);

    /* Execute a hook if present */
    _executeHook('uponSanitizeElement', currentNode, {
      tagName: tagName,
      allowedTags: ALLOWED_TAGS
    });

    /* Detect mXSS attempts abusing namespace confusion */
    if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Remove element if anything forbids its presence */
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      /* Keep content except for bad-listed elements */
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        var parentNode = getParentNode(currentNode);
        var childNodes = getChildNodes(currentNode);

        if (childNodes && parentNode) {
          var childCount = childNodes.length;

          for (var i = childCount - 1; i >= 0; --i) {
            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
          }
        }
      }

      _forceRemove(currentNode);
      return true;
    }

    /* Check whether element has a valid namespace */
    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }

    if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }

    /* Sanitize element content to be template-safe */
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      /* Get the element's text content */
      content = currentNode.textContent;
      content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');
      content = stringReplace(content, ERB_EXPR$$1, ' ');
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
        currentNode.textContent = content;
      }
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeElements', currentNode, null);

    return false;
  };

  /**
   * _isValidAttribute
   *
   * @param  {string} lcTag Lowercase tag name of containing element.
   * @param  {string} lcName Lowercase attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid, otherwise false.
   */
  // eslint-disable-next-line complexity
  var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
    /* Make sure attribute cannot clobber */
    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
      return false;
    }

    /* Allow valid data-* attributes: At least one character after "-"
        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
        We don't need to check the value; it's always URI safe. */
    if (ALLOW_DATA_ATTR && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      return false;

      /* Check value is safe. First, is attr inert? If so, is safe */
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {
      return false;
    }

    return true;
  };

  /**
   * _sanitizeAttributes
   *
   * @protect attributes
   * @protect nodeName
   * @protect removeAttribute
   * @protect setAttribute
   *
   * @param  {Node} currentNode to sanitize
   */
  var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
    var attr = void 0;
    var value = void 0;
    var lcName = void 0;
    var l = void 0;
    /* Execute a hook if present */
    _executeHook('beforeSanitizeAttributes', currentNode, null);

    var attributes = currentNode.attributes;

    /* Check if we have attributes; if not we might have a text node */

    if (!attributes) {
      return;
    }

    var hookEvent = {
      attrName: '',
      attrValue: '',
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l = attributes.length;

    /* Go backwards over all attributes; safely remove bad ones */
    while (l--) {
      attr = attributes[l];
      var _attr = attr,
          name = _attr.name,
          namespaceURI = _attr.namespaceURI;

      value = stringTrim(attr.value);
      lcName = stringToLowerCase(name);

      /* Execute a hook if present */
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
      _executeHook('uponSanitizeAttribute', currentNode, hookEvent);
      value = hookEvent.attrValue;
      /* Did the hooks approve of the attribute? */
      if (hookEvent.forceKeepAttr) {
        continue;
      }

      /* Remove attribute */
      _removeAttribute(name, currentNode);

      /* Did the hooks approve of the attribute? */
      if (!hookEvent.keepAttr) {
        continue;
      }

      /* Work around a security issue in jQuery 3.0 */
      if (regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }

      /* Sanitize attribute content to be template-safe */
      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');
        value = stringReplace(value, ERB_EXPR$$1, ' ');
      }

      /* Is `value` valid for this attribute? */
      var lcTag = currentNode.nodeName.toLowerCase();
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }

      /* Handle invalid data-* attribute set by try-catching it */
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
          currentNode.setAttribute(name, value);
        }

        arrayPop(DOMPurify.removed);
      } catch (_) {}
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeAttributes', currentNode, null);
  };

  /**
   * _sanitizeShadowDOM
   *
   * @param  {DocumentFragment} fragment to iterate over recursively
   */
  var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
    var shadowNode = void 0;
    var shadowIterator = _createIterator(fragment);

    /* Execute a hook if present */
    _executeHook('beforeSanitizeShadowDOM', fragment, null);

    while (shadowNode = shadowIterator.nextNode()) {
      /* Execute a hook if present */
      _executeHook('uponSanitizeShadowNode', shadowNode, null);

      /* Sanitize tags and elements */
      if (_sanitizeElements(shadowNode)) {
        continue;
      }

      /* Deep shadow DOM detected */
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(shadowNode.content);
      }

      /* Check attributes, sanitize if necessary */
      _sanitizeAttributes(shadowNode);
    }

    /* Execute a hook if present */
    _executeHook('afterSanitizeShadowDOM', fragment, null);
  };

  /**
   * Sanitize
   * Public method providing core sanitation functionality
   *
   * @param {String|Node} dirty string or DOM node
   * @param {Object} configuration object
   */
  // eslint-disable-next-line complexity
  DOMPurify.sanitize = function (dirty, cfg) {
    var body = void 0;
    var importedNode = void 0;
    var currentNode = void 0;
    var oldNode = void 0;
    var returnNode = void 0;
    /* Make sure we have a string to sanitize.
      DO NOT return early, as this will return the wrong type if
      the user has requested a DOM object rather than a string */
    if (!dirty) {
      dirty = '<!-->';
    }

    /* Stringify, in case dirty is an object */
    if (typeof dirty !== 'string' && !_isNode(dirty)) {
      // eslint-disable-next-line no-negated-condition
      if (typeof dirty.toString !== 'function') {
        throw typeErrorCreate('toString is not a function');
      } else {
        dirty = dirty.toString();
        if (typeof dirty !== 'string') {
          throw typeErrorCreate('dirty is not a string, aborting');
        }
      }
    }

    /* Check we can run. Otherwise fall back or ignore */
    if (!DOMPurify.isSupported) {
      if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
        if (typeof dirty === 'string') {
          return window.toStaticHTML(dirty);
        }

        if (_isNode(dirty)) {
          return window.toStaticHTML(dirty.outerHTML);
        }
      }

      return dirty;
    }

    /* Assign config vars */
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }

    /* Clean up removed elements */
    DOMPurify.removed = [];

    /* Check if dirty is correctly typed for IN_PLACE */
    if (typeof dirty === 'string') {
      IN_PLACE = false;
    }

    if (IN_PLACE) ; else if (dirty instanceof Node) {
      /* If dirty is a DOM element, append to an empty document to avoid
         elements being stripped by the parser */
      body = _initDocument('<!---->');
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
        /* Node is already a body, use as is */
        body = importedNode;
      } else if (importedNode.nodeName === 'HTML') {
        body = importedNode;
      } else {
        // eslint-disable-next-line unicorn/prefer-node-append
        body.appendChild(importedNode);
      }
    } else {
      /* Exit directly if we have nothing to do */
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
      // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf('<') === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }

      /* Initialize the document to work on */
      body = _initDocument(dirty);

      /* Check we have a DOM node from the data */
      if (!body) {
        return RETURN_DOM ? null : emptyHTML;
      }
    }

    /* Remove first element node (ours) if FORCE_BODY is set */
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }

    /* Get node iterator */
    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);

    /* Now start iterating over the created document */
    while (currentNode = nodeIterator.nextNode()) {
      /* Fix IE's strange behavior with manipulated textNodes #89 */
      if (currentNode.nodeType === 3 && currentNode === oldNode) {
        continue;
      }

      /* Sanitize tags and elements */
      if (_sanitizeElements(currentNode)) {
        continue;
      }

      /* Shadow DOM detected, sanitize it */
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }

      /* Check attributes, sanitize if necessary */
      _sanitizeAttributes(currentNode);

      oldNode = currentNode;
    }

    oldNode = null;

    /* If we sanitized `dirty` in-place, return it. */
    if (IN_PLACE) {
      return dirty;
    }

    /* Return sanitized string or DOM */
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);

        while (body.firstChild) {
          // eslint-disable-next-line unicorn/prefer-node-append
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }

      if (RETURN_DOM_IMPORT) {
        /*
          AdoptNode() is not used because internal state is not reset
          (e.g. the past names map of a HTMLFormElement), this is safe
          in theory but we would rather not risk another attack vector.
          The state that is cloned by importNode() is explicitly defined
          by the specs.
        */
        returnNode = importNode.call(originalDocument, returnNode, true);
      }

      return returnNode;
    }

    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;

    /* Sanitize final string template-safe */
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');
    }

    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };

  /**
   * Public method to set the configuration once
   * setConfig
   *
   * @param {Object} cfg configuration object
   */
  DOMPurify.setConfig = function (cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };

  /**
   * Public method to remove the configuration
   * clearConfig
   *
   */
  DOMPurify.clearConfig = function () {
    CONFIG = null;
    SET_CONFIG = false;
  };

  /**
   * Public method to check if an attribute value is valid.
   * Uses last set config, if any. Otherwise, uses config defaults.
   * isValidAttribute
   *
   * @param  {string} tag Tag name of containing element.
   * @param  {string} attr Attribute name.
   * @param  {string} value Attribute value.
   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
   */
  DOMPurify.isValidAttribute = function (tag, attr, value) {
    /* Initialize shared config vars if necessary. */
    if (!CONFIG) {
      _parseConfig({});
    }

    var lcTag = stringToLowerCase(tag);
    var lcName = stringToLowerCase(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };

  /**
   * AddHook
   * Public method to add DOMPurify hooks
   *
   * @param {String} entryPoint entry point for the hook to add
   * @param {Function} hookFunction function to execute
   */
  DOMPurify.addHook = function (entryPoint, hookFunction) {
    if (typeof hookFunction !== 'function') {
      return;
    }

    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };

  /**
   * RemoveHook
   * Public method to remove a DOMPurify hook at a given entryPoint
   * (pops it from the stack of hooks if more are present)
   *
   * @param {String} entryPoint entry point for the hook to remove
   */
  DOMPurify.removeHook = function (entryPoint) {
    if (hooks[entryPoint]) {
      arrayPop(hooks[entryPoint]);
    }
  };

  /**
   * RemoveHooks
   * Public method to remove all DOMPurify hooks at a given entryPoint
   *
   * @param  {String} entryPoint entry point for the hooks to remove
   */
  DOMPurify.removeHooks = function (entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };

  /**
   * RemoveAllHooks
   * Public method to remove all DOMPurify hooks
   *
   */
  DOMPurify.removeAllHooks = function () {
    hooks = {};
  };

  return DOMPurify;
}

var purify = createDOMPurify();

/* harmony default export */ __webpack_exports__["default"] = (purify);
//# sourceMappingURL=purify.es.js.map


/***/ }),

/***/ "./node_modules/scratch-render-fonts/src/index.js":
/*!********************************************************!*\
  !*** ./node_modules/scratch-render-fonts/src/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Synchronously load TTF fonts.
// First, have Webpack load their data as Base 64 strings.
let FONTS;

const getFonts = function () {
    if (FONTS) return FONTS;
    /* eslint-disable global-require */
    FONTS = {
        'Sans Serif': __webpack_require__(/*! base64-loader!./NotoSans-Medium.ttf */ "./node_modules/base64-loader/index.js!./node_modules/scratch-render-fonts/src/NotoSans-Medium.ttf"),
        'Serif': __webpack_require__(/*! base64-loader!./SourceSerifPro-Regular.otf */ "./node_modules/base64-loader/index.js!./node_modules/scratch-render-fonts/src/SourceSerifPro-Regular.otf"),
        'Handwriting': __webpack_require__(/*! base64-loader!./handlee-regular.ttf */ "./node_modules/base64-loader/index.js!./node_modules/scratch-render-fonts/src/handlee-regular.ttf"),
        'Marker': __webpack_require__(/*! base64-loader!./Knewave.ttf */ "./node_modules/base64-loader/index.js!./node_modules/scratch-render-fonts/src/Knewave.ttf"),
        'Curly': __webpack_require__(/*! base64-loader!./Griffy-Regular.ttf */ "./node_modules/base64-loader/index.js!./node_modules/scratch-render-fonts/src/Griffy-Regular.ttf"),
        'Pixel': __webpack_require__(/*! base64-loader!./Grand9K-Pixel.ttf */ "./node_modules/base64-loader/index.js!./node_modules/scratch-render-fonts/src/Grand9K-Pixel.ttf"),
        'Scratch': __webpack_require__(/*! base64-loader!./Scratch.ttf */ "./node_modules/base64-loader/index.js!./node_modules/scratch-render-fonts/src/Scratch.ttf")
    };
    /* eslint-enable global-require */

    // For each Base 64 string,
    // 1. Replace each with a usable @font-face tag that points to a Data URI.
    // 2. Inject the font into a style on `document.body`, so measurements
    //    can be accurately taken in SvgRenderer._transformMeasurements.
    for (const fontName in FONTS) {
        const fontData = FONTS[fontName];
        FONTS[fontName] = '@font-face {' +
            `font-family: "${fontName}";src: url("data:application/x-font-ttf;charset=utf-8;base64,${fontData}");}`;
    }

    if (!document.getElementById('scratch-font-styles')) {
    	const documentStyleTag = document.createElement('style');
    	documentStyleTag.id = 'scratch-font-styles';
    	for (const fontName in FONTS) {
    	    documentStyleTag.textContent += FONTS[fontName];
    	}
    	document.body.insertBefore(documentStyleTag, document.body.firstChild);
    }

    return FONTS;
}

module.exports = getFonts;


/***/ }),

/***/ "./node_modules/scratch-sb1-converter/playground/main.js":
/*!***************************************************************!*\
  !*** ./node_modules/scratch-sb1-converter/playground/main.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! exports provided: SB1File, AssertionError, ValidationError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _src_sb1_file__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/sb1-file */ \"./src/sb1-file.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SB1File\", function() { return _src_sb1_file__WEBPACK_IMPORTED_MODULE_0__[\"SB1File\"]; });\n\n/* harmony import */ var _src_util_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/util/assert */ \"./src/util/assert.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AssertionError\", function() { return _src_util_assert__WEBPACK_IMPORTED_MODULE_1__[\"AssertionError\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ValidationError\", function() { return _src_util_assert__WEBPACK_IMPORTED_MODULE_1__[\"ValidationError\"]; });\n\n\n\n\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "./node_modules/js-md5/src/md5.js":
/*!****************************************!*\
  !*** ./node_modules/js-md5/src/md5.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/**\n * [js-md5]{@link https://github.com/emn178/js-md5}\n *\n * @namespace md5\n * @version 0.7.3\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2014-2017\n * @license MIT\n */\n(function () {\n  'use strict';\n\n  var ERROR = 'input is invalid type';\n  var WINDOW = typeof window === 'object';\n  var root = WINDOW ? window : {};\n  if (root.JS_MD5_NO_WINDOW) {\n    WINDOW = false;\n  }\n  var WEB_WORKER = !WINDOW && typeof self === 'object';\n  var NODE_JS = !root.JS_MD5_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;\n  if (NODE_JS) {\n    root = global;\n  } else if (WEB_WORKER) {\n    root = self;\n  }\n  var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && typeof module === 'object' && module.exports;\n  var AMD =  true && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\");\n  var ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';\n  var HEX_CHARS = '0123456789abcdef'.split('');\n  var EXTRA = [128, 32768, 8388608, -2147483648];\n  var SHIFT = [0, 8, 16, 24];\n  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'buffer', 'arrayBuffer', 'base64'];\n  var BASE64_ENCODE_CHAR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n  var blocks = [], buffer8;\n  if (ARRAY_BUFFER) {\n    var buffer = new ArrayBuffer(68);\n    buffer8 = new Uint8Array(buffer);\n    blocks = new Uint32Array(buffer);\n  }\n\n  if (root.JS_MD5_NO_NODE_JS || !Array.isArray) {\n    Array.isArray = function (obj) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n  }\n\n  if (ARRAY_BUFFER && (root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {\n    ArrayBuffer.isView = function (obj) {\n      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;\n    };\n  }\n\n  /**\n   * @method hex\n   * @memberof md5\n   * @description Output hash as hex string\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {String} Hex string\n   * @example\n   * md5.hex('The quick brown fox jumps over the lazy dog');\n   * // equal to\n   * md5('The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method digest\n   * @memberof md5\n   * @description Output hash as bytes array\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {Array} Bytes array\n   * @example\n   * md5.digest('The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method array\n   * @memberof md5\n   * @description Output hash as bytes array\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {Array} Bytes array\n   * @example\n   * md5.array('The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method arrayBuffer\n   * @memberof md5\n   * @description Output hash as ArrayBuffer\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {ArrayBuffer} ArrayBuffer\n   * @example\n   * md5.arrayBuffer('The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method buffer\n   * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.\n   * @memberof md5\n   * @description Output hash as ArrayBuffer\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {ArrayBuffer} ArrayBuffer\n   * @example\n   * md5.buffer('The quick brown fox jumps over the lazy dog');\n   */\n  /**\n   * @method base64\n   * @memberof md5\n   * @description Output hash as base64 string\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {String} base64 string\n   * @example\n   * md5.base64('The quick brown fox jumps over the lazy dog');\n   */\n  var createOutputMethod = function (outputType) {\n    return function (message) {\n      return new Md5(true).update(message)[outputType]();\n    };\n  };\n\n  /**\n   * @method create\n   * @memberof md5\n   * @description Create Md5 object\n   * @returns {Md5} Md5 object.\n   * @example\n   * var hash = md5.create();\n   */\n  /**\n   * @method update\n   * @memberof md5\n   * @description Create and update Md5 object\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {Md5} Md5 object.\n   * @example\n   * var hash = md5.update('The quick brown fox jumps over the lazy dog');\n   * // equal to\n   * var hash = md5.create();\n   * hash.update('The quick brown fox jumps over the lazy dog');\n   */\n  var createMethod = function () {\n    var method = createOutputMethod('hex');\n    if (NODE_JS) {\n      method = nodeWrap(method);\n    }\n    method.create = function () {\n      return new Md5();\n    };\n    method.update = function (message) {\n      return method.create().update(message);\n    };\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createOutputMethod(type);\n    }\n    return method;\n  };\n\n  var nodeWrap = function (method) {\n    var crypto = eval(\"require('crypto')\");\n    var Buffer = eval(\"require('buffer').Buffer\");\n    var nodeMethod = function (message) {\n      if (typeof message === 'string') {\n        return crypto.createHash('md5').update(message, 'utf8').digest('hex');\n      } else {\n        if (message === null || message === undefined) {\n          throw ERROR;\n        } else if (message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        }\n      }\n      if (Array.isArray(message) || ArrayBuffer.isView(message) ||\n        message.constructor === Buffer) {\n        return crypto.createHash('md5').update(new Buffer(message)).digest('hex');\n      } else {\n        return method(message);\n      }\n    };\n    return nodeMethod;\n  };\n\n  /**\n   * Md5 class\n   * @class Md5\n   * @description This is internal class.\n   * @see {@link md5.create}\n   */\n  function Md5(sharedMemory) {\n    if (sharedMemory) {\n      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n      blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n      blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n      blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      this.blocks = blocks;\n      this.buffer8 = buffer8;\n    } else {\n      if (ARRAY_BUFFER) {\n        var buffer = new ArrayBuffer(68);\n        this.buffer8 = new Uint8Array(buffer);\n        this.blocks = new Uint32Array(buffer);\n      } else {\n        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n      }\n    }\n    this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;\n    this.finalized = this.hashed = false;\n    this.first = true;\n  }\n\n  /**\n   * @method update\n   * @memberof Md5\n   * @instance\n   * @description Update hash\n   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n   * @returns {Md5} Md5 object.\n   * @see {@link md5.update}\n   */\n  Md5.prototype.update = function (message) {\n    if (this.finalized) {\n      return;\n    }\n\n    var notString, type = typeof message;\n    if (type !== 'string') {\n      if (type === 'object') {\n        if (message === null) {\n          throw ERROR;\n        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        } else if (!Array.isArray(message)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n            throw ERROR;\n          }\n        }\n      } else {\n        throw ERROR;\n      }\n      notString = true;\n    }\n    var code, index = 0, i, length = message.length, blocks = this.blocks;\n    var buffer8 = this.buffer8;\n\n    while (index < length) {\n      if (this.hashed) {\n        this.hashed = false;\n        blocks[0] = blocks[16];\n        blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n        blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n        blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      }\n\n      if (notString) {\n        if (ARRAY_BUFFER) {\n          for (i = this.start; index < length && i < 64; ++index) {\n            buffer8[i++] = message[index];\n          }\n        } else {\n          for (i = this.start; index < length && i < 64; ++index) {\n            blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n          }\n        }\n      } else {\n        if (ARRAY_BUFFER) {\n          for (i = this.start; index < length && i < 64; ++index) {\n            code = message.charCodeAt(index);\n            if (code < 0x80) {\n              buffer8[i++] = code;\n            } else if (code < 0x800) {\n              buffer8[i++] = 0xc0 | (code >> 6);\n              buffer8[i++] = 0x80 | (code & 0x3f);\n            } else if (code < 0xd800 || code >= 0xe000) {\n              buffer8[i++] = 0xe0 | (code >> 12);\n              buffer8[i++] = 0x80 | ((code >> 6) & 0x3f);\n              buffer8[i++] = 0x80 | (code & 0x3f);\n            } else {\n              code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n              buffer8[i++] = 0xf0 | (code >> 18);\n              buffer8[i++] = 0x80 | ((code >> 12) & 0x3f);\n              buffer8[i++] = 0x80 | ((code >> 6) & 0x3f);\n              buffer8[i++] = 0x80 | (code & 0x3f);\n            }\n          }\n        } else {\n          for (i = this.start; index < length && i < 64; ++index) {\n            code = message.charCodeAt(index);\n            if (code < 0x80) {\n              blocks[i >> 2] |= code << SHIFT[i++ & 3];\n            } else if (code < 0x800) {\n              blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];\n              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n            } else if (code < 0xd800 || code >= 0xe000) {\n              blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];\n              blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n            } else {\n              code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n              blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];\n              blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];\n              blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n            }\n          }\n        }\n      }\n      this.lastByteIndex = i;\n      this.bytes += i - this.start;\n      if (i >= 64) {\n        this.start = i - 64;\n        this.hash();\n        this.hashed = true;\n      } else {\n        this.start = i;\n      }\n    }\n    if (this.bytes > 4294967295) {\n      this.hBytes += this.bytes / 4294967296 << 0;\n      this.bytes = this.bytes % 4294967296;\n    }\n    return this;\n  };\n\n  Md5.prototype.finalize = function () {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    var blocks = this.blocks, i = this.lastByteIndex;\n    blocks[i >> 2] |= EXTRA[i & 3];\n    if (i >= 56) {\n      if (!this.hashed) {\n        this.hash();\n      }\n      blocks[0] = blocks[16];\n      blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n      blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n      blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n      blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n    }\n    blocks[14] = this.bytes << 3;\n    blocks[15] = this.hBytes << 3 | this.bytes >>> 29;\n    this.hash();\n  };\n\n  Md5.prototype.hash = function () {\n    var a, b, c, d, bc, da, blocks = this.blocks;\n\n    if (this.first) {\n      a = blocks[0] - 680876937;\n      a = (a << 7 | a >>> 25) - 271733879 << 0;\n      d = (-1732584194 ^ a & 2004318071) + blocks[1] - 117830708;\n      d = (d << 12 | d >>> 20) + a << 0;\n      c = (-271733879 ^ (d & (a ^ -271733879))) + blocks[2] - 1126478375;\n      c = (c << 17 | c >>> 15) + d << 0;\n      b = (a ^ (c & (d ^ a))) + blocks[3] - 1316259209;\n      b = (b << 22 | b >>> 10) + c << 0;\n    } else {\n      a = this.h0;\n      b = this.h1;\n      c = this.h2;\n      d = this.h3;\n      a += (d ^ (b & (c ^ d))) + blocks[0] - 680876936;\n      a = (a << 7 | a >>> 25) + b << 0;\n      d += (c ^ (a & (b ^ c))) + blocks[1] - 389564586;\n      d = (d << 12 | d >>> 20) + a << 0;\n      c += (b ^ (d & (a ^ b))) + blocks[2] + 606105819;\n      c = (c << 17 | c >>> 15) + d << 0;\n      b += (a ^ (c & (d ^ a))) + blocks[3] - 1044525330;\n      b = (b << 22 | b >>> 10) + c << 0;\n    }\n\n    a += (d ^ (b & (c ^ d))) + blocks[4] - 176418897;\n    a = (a << 7 | a >>> 25) + b << 0;\n    d += (c ^ (a & (b ^ c))) + blocks[5] + 1200080426;\n    d = (d << 12 | d >>> 20) + a << 0;\n    c += (b ^ (d & (a ^ b))) + blocks[6] - 1473231341;\n    c = (c << 17 | c >>> 15) + d << 0;\n    b += (a ^ (c & (d ^ a))) + blocks[7] - 45705983;\n    b = (b << 22 | b >>> 10) + c << 0;\n    a += (d ^ (b & (c ^ d))) + blocks[8] + 1770035416;\n    a = (a << 7 | a >>> 25) + b << 0;\n    d += (c ^ (a & (b ^ c))) + blocks[9] - 1958414417;\n    d = (d << 12 | d >>> 20) + a << 0;\n    c += (b ^ (d & (a ^ b))) + blocks[10] - 42063;\n    c = (c << 17 | c >>> 15) + d << 0;\n    b += (a ^ (c & (d ^ a))) + blocks[11] - 1990404162;\n    b = (b << 22 | b >>> 10) + c << 0;\n    a += (d ^ (b & (c ^ d))) + blocks[12] + 1804603682;\n    a = (a << 7 | a >>> 25) + b << 0;\n    d += (c ^ (a & (b ^ c))) + blocks[13] - 40341101;\n    d = (d << 12 | d >>> 20) + a << 0;\n    c += (b ^ (d & (a ^ b))) + blocks[14] - 1502002290;\n    c = (c << 17 | c >>> 15) + d << 0;\n    b += (a ^ (c & (d ^ a))) + blocks[15] + 1236535329;\n    b = (b << 22 | b >>> 10) + c << 0;\n    a += (c ^ (d & (b ^ c))) + blocks[1] - 165796510;\n    a = (a << 5 | a >>> 27) + b << 0;\n    d += (b ^ (c & (a ^ b))) + blocks[6] - 1069501632;\n    d = (d << 9 | d >>> 23) + a << 0;\n    c += (a ^ (b & (d ^ a))) + blocks[11] + 643717713;\n    c = (c << 14 | c >>> 18) + d << 0;\n    b += (d ^ (a & (c ^ d))) + blocks[0] - 373897302;\n    b = (b << 20 | b >>> 12) + c << 0;\n    a += (c ^ (d & (b ^ c))) + blocks[5] - 701558691;\n    a = (a << 5 | a >>> 27) + b << 0;\n    d += (b ^ (c & (a ^ b))) + blocks[10] + 38016083;\n    d = (d << 9 | d >>> 23) + a << 0;\n    c += (a ^ (b & (d ^ a))) + blocks[15] - 660478335;\n    c = (c << 14 | c >>> 18) + d << 0;\n    b += (d ^ (a & (c ^ d))) + blocks[4] - 405537848;\n    b = (b << 20 | b >>> 12) + c << 0;\n    a += (c ^ (d & (b ^ c))) + blocks[9] + 568446438;\n    a = (a << 5 | a >>> 27) + b << 0;\n    d += (b ^ (c & (a ^ b))) + blocks[14] - 1019803690;\n    d = (d << 9 | d >>> 23) + a << 0;\n    c += (a ^ (b & (d ^ a))) + blocks[3] - 187363961;\n    c = (c << 14 | c >>> 18) + d << 0;\n    b += (d ^ (a & (c ^ d))) + blocks[8] + 1163531501;\n    b = (b << 20 | b >>> 12) + c << 0;\n    a += (c ^ (d & (b ^ c))) + blocks[13] - 1444681467;\n    a = (a << 5 | a >>> 27) + b << 0;\n    d += (b ^ (c & (a ^ b))) + blocks[2] - 51403784;\n    d = (d << 9 | d >>> 23) + a << 0;\n    c += (a ^ (b & (d ^ a))) + blocks[7] + 1735328473;\n    c = (c << 14 | c >>> 18) + d << 0;\n    b += (d ^ (a & (c ^ d))) + blocks[12] - 1926607734;\n    b = (b << 20 | b >>> 12) + c << 0;\n    bc = b ^ c;\n    a += (bc ^ d) + blocks[5] - 378558;\n    a = (a << 4 | a >>> 28) + b << 0;\n    d += (bc ^ a) + blocks[8] - 2022574463;\n    d = (d << 11 | d >>> 21) + a << 0;\n    da = d ^ a;\n    c += (da ^ b) + blocks[11] + 1839030562;\n    c = (c << 16 | c >>> 16) + d << 0;\n    b += (da ^ c) + blocks[14] - 35309556;\n    b = (b << 23 | b >>> 9) + c << 0;\n    bc = b ^ c;\n    a += (bc ^ d) + blocks[1] - 1530992060;\n    a = (a << 4 | a >>> 28) + b << 0;\n    d += (bc ^ a) + blocks[4] + 1272893353;\n    d = (d << 11 | d >>> 21) + a << 0;\n    da = d ^ a;\n    c += (da ^ b) + blocks[7] - 155497632;\n    c = (c << 16 | c >>> 16) + d << 0;\n    b += (da ^ c) + blocks[10] - 1094730640;\n    b = (b << 23 | b >>> 9) + c << 0;\n    bc = b ^ c;\n    a += (bc ^ d) + blocks[13] + 681279174;\n    a = (a << 4 | a >>> 28) + b << 0;\n    d += (bc ^ a) + blocks[0] - 358537222;\n    d = (d << 11 | d >>> 21) + a << 0;\n    da = d ^ a;\n    c += (da ^ b) + blocks[3] - 722521979;\n    c = (c << 16 | c >>> 16) + d << 0;\n    b += (da ^ c) + blocks[6] + 76029189;\n    b = (b << 23 | b >>> 9) + c << 0;\n    bc = b ^ c;\n    a += (bc ^ d) + blocks[9] - 640364487;\n    a = (a << 4 | a >>> 28) + b << 0;\n    d += (bc ^ a) + blocks[12] - 421815835;\n    d = (d << 11 | d >>> 21) + a << 0;\n    da = d ^ a;\n    c += (da ^ b) + blocks[15] + 530742520;\n    c = (c << 16 | c >>> 16) + d << 0;\n    b += (da ^ c) + blocks[2] - 995338651;\n    b = (b << 23 | b >>> 9) + c << 0;\n    a += (c ^ (b | ~d)) + blocks[0] - 198630844;\n    a = (a << 6 | a >>> 26) + b << 0;\n    d += (b ^ (a | ~c)) + blocks[7] + 1126891415;\n    d = (d << 10 | d >>> 22) + a << 0;\n    c += (a ^ (d | ~b)) + blocks[14] - 1416354905;\n    c = (c << 15 | c >>> 17) + d << 0;\n    b += (d ^ (c | ~a)) + blocks[5] - 57434055;\n    b = (b << 21 | b >>> 11) + c << 0;\n    a += (c ^ (b | ~d)) + blocks[12] + 1700485571;\n    a = (a << 6 | a >>> 26) + b << 0;\n    d += (b ^ (a | ~c)) + blocks[3] - 1894986606;\n    d = (d << 10 | d >>> 22) + a << 0;\n    c += (a ^ (d | ~b)) + blocks[10] - 1051523;\n    c = (c << 15 | c >>> 17) + d << 0;\n    b += (d ^ (c | ~a)) + blocks[1] - 2054922799;\n    b = (b << 21 | b >>> 11) + c << 0;\n    a += (c ^ (b | ~d)) + blocks[8] + 1873313359;\n    a = (a << 6 | a >>> 26) + b << 0;\n    d += (b ^ (a | ~c)) + blocks[15] - 30611744;\n    d = (d << 10 | d >>> 22) + a << 0;\n    c += (a ^ (d | ~b)) + blocks[6] - 1560198380;\n    c = (c << 15 | c >>> 17) + d << 0;\n    b += (d ^ (c | ~a)) + blocks[13] + 1309151649;\n    b = (b << 21 | b >>> 11) + c << 0;\n    a += (c ^ (b | ~d)) + blocks[4] - 145523070;\n    a = (a << 6 | a >>> 26) + b << 0;\n    d += (b ^ (a | ~c)) + blocks[11] - 1120210379;\n    d = (d << 10 | d >>> 22) + a << 0;\n    c += (a ^ (d | ~b)) + blocks[2] + 718787259;\n    c = (c << 15 | c >>> 17) + d << 0;\n    b += (d ^ (c | ~a)) + blocks[9] - 343485551;\n    b = (b << 21 | b >>> 11) + c << 0;\n\n    if (this.first) {\n      this.h0 = a + 1732584193 << 0;\n      this.h1 = b - 271733879 << 0;\n      this.h2 = c - 1732584194 << 0;\n      this.h3 = d + 271733878 << 0;\n      this.first = false;\n    } else {\n      this.h0 = this.h0 + a << 0;\n      this.h1 = this.h1 + b << 0;\n      this.h2 = this.h2 + c << 0;\n      this.h3 = this.h3 + d << 0;\n    }\n  };\n\n  /**\n   * @method hex\n   * @memberof Md5\n   * @instance\n   * @description Output hash as hex string\n   * @returns {String} Hex string\n   * @see {@link md5.hex}\n   * @example\n   * hash.hex();\n   */\n  Md5.prototype.hex = function () {\n    this.finalize();\n\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;\n\n    return HEX_CHARS[(h0 >> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +\n      HEX_CHARS[(h0 >> 12) & 0x0F] + HEX_CHARS[(h0 >> 8) & 0x0F] +\n      HEX_CHARS[(h0 >> 20) & 0x0F] + HEX_CHARS[(h0 >> 16) & 0x0F] +\n      HEX_CHARS[(h0 >> 28) & 0x0F] + HEX_CHARS[(h0 >> 24) & 0x0F] +\n      HEX_CHARS[(h1 >> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +\n      HEX_CHARS[(h1 >> 12) & 0x0F] + HEX_CHARS[(h1 >> 8) & 0x0F] +\n      HEX_CHARS[(h1 >> 20) & 0x0F] + HEX_CHARS[(h1 >> 16) & 0x0F] +\n      HEX_CHARS[(h1 >> 28) & 0x0F] + HEX_CHARS[(h1 >> 24) & 0x0F] +\n      HEX_CHARS[(h2 >> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +\n      HEX_CHARS[(h2 >> 12) & 0x0F] + HEX_CHARS[(h2 >> 8) & 0x0F] +\n      HEX_CHARS[(h2 >> 20) & 0x0F] + HEX_CHARS[(h2 >> 16) & 0x0F] +\n      HEX_CHARS[(h2 >> 28) & 0x0F] + HEX_CHARS[(h2 >> 24) & 0x0F] +\n      HEX_CHARS[(h3 >> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +\n      HEX_CHARS[(h3 >> 12) & 0x0F] + HEX_CHARS[(h3 >> 8) & 0x0F] +\n      HEX_CHARS[(h3 >> 20) & 0x0F] + HEX_CHARS[(h3 >> 16) & 0x0F] +\n      HEX_CHARS[(h3 >> 28) & 0x0F] + HEX_CHARS[(h3 >> 24) & 0x0F];\n  };\n\n  /**\n   * @method toString\n   * @memberof Md5\n   * @instance\n   * @description Output hash as hex string\n   * @returns {String} Hex string\n   * @see {@link md5.hex}\n   * @example\n   * hash.toString();\n   */\n  Md5.prototype.toString = Md5.prototype.hex;\n\n  /**\n   * @method digest\n   * @memberof Md5\n   * @instance\n   * @description Output hash as bytes array\n   * @returns {Array} Bytes array\n   * @see {@link md5.digest}\n   * @example\n   * hash.digest();\n   */\n  Md5.prototype.digest = function () {\n    this.finalize();\n\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;\n    return [\n      h0 & 0xFF, (h0 >> 8) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 24) & 0xFF,\n      h1 & 0xFF, (h1 >> 8) & 0xFF, (h1 >> 16) & 0xFF, (h1 >> 24) & 0xFF,\n      h2 & 0xFF, (h2 >> 8) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 24) & 0xFF,\n      h3 & 0xFF, (h3 >> 8) & 0xFF, (h3 >> 16) & 0xFF, (h3 >> 24) & 0xFF\n    ];\n  };\n\n  /**\n   * @method array\n   * @memberof Md5\n   * @instance\n   * @description Output hash as bytes array\n   * @returns {Array} Bytes array\n   * @see {@link md5.array}\n   * @example\n   * hash.array();\n   */\n  Md5.prototype.array = Md5.prototype.digest;\n\n  /**\n   * @method arrayBuffer\n   * @memberof Md5\n   * @instance\n   * @description Output hash as ArrayBuffer\n   * @returns {ArrayBuffer} ArrayBuffer\n   * @see {@link md5.arrayBuffer}\n   * @example\n   * hash.arrayBuffer();\n   */\n  Md5.prototype.arrayBuffer = function () {\n    this.finalize();\n\n    var buffer = new ArrayBuffer(16);\n    var blocks = new Uint32Array(buffer);\n    blocks[0] = this.h0;\n    blocks[1] = this.h1;\n    blocks[2] = this.h2;\n    blocks[3] = this.h3;\n    return buffer;\n  };\n\n  /**\n   * @method buffer\n   * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.\n   * @memberof Md5\n   * @instance\n   * @description Output hash as ArrayBuffer\n   * @returns {ArrayBuffer} ArrayBuffer\n   * @see {@link md5.buffer}\n   * @example\n   * hash.buffer();\n   */\n  Md5.prototype.buffer = Md5.prototype.arrayBuffer;\n\n  /**\n   * @method base64\n   * @memberof Md5\n   * @instance\n   * @description Output hash as base64 string\n   * @returns {String} base64 string\n   * @see {@link md5.base64}\n   * @example\n   * hash.base64();\n   */\n  Md5.prototype.base64 = function () {\n    var v1, v2, v3, base64Str = '', bytes = this.array();\n    for (var i = 0; i < 15;) {\n      v1 = bytes[i++];\n      v2 = bytes[i++];\n      v3 = bytes[i++];\n      base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] +\n        BASE64_ENCODE_CHAR[(v1 << 4 | v2 >>> 4) & 63] +\n        BASE64_ENCODE_CHAR[(v2 << 2 | v3 >>> 6) & 63] +\n        BASE64_ENCODE_CHAR[v3 & 63];\n    }\n    v1 = bytes[i];\n    base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] +\n      BASE64_ENCODE_CHAR[(v1 << 4) & 63] +\n      '==';\n    return base64Str;\n  };\n\n  var exports = createMethod();\n\n  if (COMMON_JS) {\n    module.exports = exports;\n  } else {\n    /**\n     * @method md5\b\n     * @description Md5 hash function, export to global in browsers.\n     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash\n     * @returns {String} md5 hashes\n     * @example\n     * md5(''); // d41d8cd98f00b204e9800998ecf8427e\n     * md5('The quick brown fox jumps over the lazy dog'); // 9e107d9d372bb6826bd81d3542a419d6\n     * md5('The quick brown fox jumps over the lazy dog.'); // e4d909c290d0fb1ca068ffaddf22cbd0\n     *\n     * // It also supports UTF-8 encoding\n     * md5(''); // a7bac2239fcdcb3a067903d8077c4a07\n     *\n     * // It also supports byte `Array`, `Uint8Array`, `ArrayBuffer`\n     * md5([]); // d41d8cd98f00b204e9800998ecf8427e\n     * md5(new Uint8Array([])); // d41d8cd98f00b204e9800998ecf8427e\n     */\n    root.md5 = exports;\n    if (AMD) {\n      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n        return exports;\n      }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n  }\n})();\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\"), __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/js-md5/src/md5.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))\n\n//# sourceURL=webpack:///(webpack)/buildin/amd-options.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/coders/adler32.js":
/*!*******************************!*\
  !*** ./src/coders/adler32.js ***!
  \*******************************/
/*! exports provided: Adler32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Adler32\", function() { return Adler32; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Adler32 =\n/*#__PURE__*/\nfunction () {\n  function Adler32() {\n    _classCallCheck(this, Adler32);\n\n    this.adler = 1;\n  }\n\n  _createClass(Adler32, [{\n    key: \"update\",\n    value: function update(uint8a, position, length) {\n      var a = this.adler & 0xffff;\n      var b = this.adler >>> 16;\n\n      for (var i = 0; i < length; i++) {\n        a = (a + uint8a[position + i]) % 65521;\n        b = (b + a) % 65521;\n      }\n\n      this.adler = b << 16 | a;\n      return this;\n    }\n  }, {\n    key: \"digest\",\n    get: function get() {\n      return this.adler;\n    }\n  }]);\n\n  return Adler32;\n}();\n\n\n\n//# sourceURL=webpack:///./src/coders/adler32.js?");

/***/ }),

/***/ "./src/coders/byte-packets.js":
/*!************************************!*\
  !*** ./src/coders/byte-packets.js ***!
  \************************************/
/*! exports provided: Packet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Packet\", function() { return Packet; });\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * @typedef {function} PacketConstructor\n */\n\n/**\n * A packet of bytes represented with getter/setter properties for decoding and\n * encoding values mapped to names, located at known offsets.\n *\n * ```js\n * // Defining a subclass:\n * import {Packet} from '../coders/byte-packets';\n * import {Uint8, Uint16LE} from '../coders/byte-primitives';\n *\n * class MyIdentifiedUint16 extends Packet.extend({\n *     binaryType: Uint8,\n *     value: Uint16LE\n * }) {}\n *\n * Packet.initConstructor(MyIdentifiedUint16);\n *\n * // One way to use it:\n * const indentifiedUint16 = new MyIdentifiedUint16(uint8a, position);\n * indentifiedUint16.binaryType = IDENTIFIED_UINT_16;\n * indentifiedUint16.value = value;\n * ```\n */\nvar Packet =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {Uint8Array=} [uint8a=new Uint8Array(this.size)] - byte array to\n   * encode to and decode from\n   * @param {number=} offset - offset in addition to the member offsets to\n   * encode to and decode from\n   */\n  function Packet() {\n    var uint8a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array(this.size);\n    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, Packet);\n\n    /**\n     * Byte array to encode to and decode from.\n     * @type {Uint8Array}\n     */\n    this.uint8a = uint8a;\n    /**\n     * Offset in addition to the member offsets to encode to and decode\n     * from.\n     * @type {number}\n     */\n\n    this.offset = offset;\n  }\n  /**\n   * Check that the decoded values of this Packet match the values in other.\n   * @param {object} other - object to match against\n   * @returns {boolean} true if all keys in other match values in this packet\n   */\n\n\n  _createClass(Packet, [{\n    key: \"equals\",\n    value: function equals(other) {\n      for (var key in other) {\n        if (this[key] !== other[key]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"view\",\n    value: function view() {\n      var className = this.constructor.name;\n      var obj = {\n        toString: function toString() {\n          return className;\n        }\n      };\n\n      for (var key in this.shape) {\n        obj[key] = this[key];\n      }\n\n      return obj;\n    }\n    /**\n     * Initialize the Packet subclass constructor for easy access to static\n     * members like size.\n     * @param {function} PacketConstructor - constuctor function for the Packet\n     * subclass\n     * @returns {function} initialized constructor\n     */\n\n  }], [{\n    key: \"initConstructor\",\n    value: function initConstructor(PacketConstructor) {\n      PacketConstructor.size = PacketConstructor.prototype.size;\n      return PacketConstructor;\n    }\n    /**\n     * Extend a subclass of Packet with given BytePrimitive members.\n     * @param {object} shape - shape of the packet defined with BytePrimitives\n     * @returns {function} Packet subclass constructor\n     */\n\n  }, {\n    key: \"extend\",\n    value: function extend(shape) {\n      var DefinedPacket =\n      /*#__PURE__*/\n      function (_Packet) {\n        _inherits(DefinedPacket, _Packet);\n\n        function DefinedPacket() {\n          _classCallCheck(this, DefinedPacket);\n\n          return _possibleConstructorReturn(this, _getPrototypeOf(DefinedPacket).apply(this, arguments));\n        }\n\n        _createClass(DefinedPacket, [{\n          key: \"shape\",\n          get: function get() {\n            return shape;\n          }\n        }]);\n\n        return DefinedPacket;\n      }(Packet);\n\n      var position = 0;\n      Object.keys(shape).forEach(function (key) {\n        Object.defineProperty(DefinedPacket.prototype, key, shape[key].asPropertyObject(position));\n\n        if (shape[key].size === 0) {\n          throw new Error('Packet cannot be defined with variable sized members.');\n        }\n\n        position += shape[key].size;\n      });\n      DefinedPacket.prototype.size = position;\n      DefinedPacket.size = position;\n      return DefinedPacket;\n    }\n  }]);\n\n  return Packet;\n}();\n\n\n\n//# sourceURL=webpack:///./src/coders/byte-packets.js?");

/***/ }),

/***/ "./src/coders/byte-primitives.js":
/*!***************************************!*\
  !*** ./src/coders/byte-primitives.js ***!
  \***************************************/
/*! exports provided: IS_HOST_LITTLE_ENDIAN, BytePrimitive, Uint8, Uint16BE, Int16BE, Int32BE, Uint32BE, Uint16LE, Uint32LE, DoubleBE, FixedAsciiString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IS_HOST_LITTLE_ENDIAN\", function() { return IS_HOST_LITTLE_ENDIAN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BytePrimitive\", function() { return BytePrimitive; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint8\", function() { return Uint8; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint16BE\", function() { return Uint16BE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Int16BE\", function() { return Int16BE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Int32BE\", function() { return Int32BE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint32BE\", function() { return Uint32BE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint16LE\", function() { return Uint16LE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Uint32LE\", function() { return Uint32LE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DoubleBE\", function() { return DoubleBE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FixedAsciiString\", function() { return FixedAsciiString; });\n/* harmony import */ var _util_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/assert */ \"./src/util/assert.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar notImplemented = function notImplemented() {\n  throw new Error('Not implemented');\n};\n/**\n * Is the host computer little or big endian.\n * @const IS_HOST_LITTLE_ENDIAN\n * @type {boolean}\n */\n\n\nvar IS_HOST_LITTLE_ENDIAN = function () {\n  var ab16 = new Uint16Array(1);\n  var ab8 = new Uint8Array(ab16.buffer);\n  ab16[0] = 0xaabb;\n  return ab8[0] === 0xbb;\n}();\n/**\n * @callback BytePrimitive~sizeOfCallback\n * @param {Uint8Array} uint8a\n * @param {number} position\n * @returns {number}\n */\n\n/**\n * @callback BytePrimitive~writeSizeOfCallback\n * @param {Uint8Array} uint8a\n * @param {number} position\n * @param {*} value\n * @returns {number}\n */\n\n/**\n * @callback BytePrimitive~writeCallback\n * @param {Uint8Array} uint8a\n * @param {number} position\n * @param {*} value\n */\n\n/**\n * An interface for reading and writing binary values to typed arrays.\n *\n * Combined with {@link Packet Packet} this makes reading and writing packets\n * of binary values easy.\n */\n\n\nvar BytePrimitive =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @constructor\n   * @param {object} options - Options to initialize BytePrimitive instance\n   * with.\n   * @param {number} [options.size=0] - Fixed size of the BytePrimitive.\n   * Should be 0 if the primitive has a variable size.\n   * @param {BytePrimitive~sizeOfCallback} [options.sizeOf=() => size] -\n   * Variable size of the primitive depending on its value stored in the\n   * array.\n   * @param {BytePrimitive~writeSizeOfCallback} [options.writeSizeOf] -\n   * Variable size of the primitive depending on the value being written.\n   * @param {TypedArray} [options.toBytes=new Uint8Array(1)] - Temporary\n   * space to copy bytes to/from to translate between a value and its\n   * representative byte set.\n   * @param {BytePrimitive#read} options.read - How is a value read\n   * at the given position of the array.\n   * @param {BytePrimitive~writeCallback} [options.write] - How to write a\n   * value to the array at the given position.\n   */\n  function BytePrimitive(_ref) {\n    var _ref$size = _ref.size,\n        size = _ref$size === void 0 ? 0 : _ref$size,\n        _ref$sizeOf = _ref.sizeOf,\n        sizeOf = _ref$sizeOf === void 0 ? function () {\n      return size;\n    } : _ref$sizeOf,\n        _ref$writeSizeOf = _ref.writeSizeOf,\n        writeSizeOf = _ref$writeSizeOf === void 0 ? notImplemented : _ref$writeSizeOf,\n        _ref$toBytes = _ref.toBytes,\n        toBytes = _ref$toBytes === void 0 ? new Uint8Array(1) : _ref$toBytes,\n        read = _ref.read,\n        _ref$write = _ref.write,\n        write = _ref$write === void 0 ? notImplemented : _ref$write;\n\n    _classCallCheck(this, BytePrimitive);\n\n    this.size = size;\n    this.sizeOf = sizeOf;\n    this.writeSizeOf = writeSizeOf;\n    this.toBytes = toBytes;\n    this.bytes = new Uint8Array(toBytes.buffer);\n    this.read = read;\n    this.write = write;\n  }\n  /**\n   * Create an object that can be used with `Object.defineProperty` to read\n   * and write values offset by `position` and the object's `this.offset`\n   * from `this.uint8a` by getting or setting the property.\n   * @param {number} position - Additional offset with `this.offset` to read\n   * from or write to.\n   * @returns {object} - A object that can be passed as the third argument to\n   * `Object.defineProperty`.\n   */\n\n\n  _createClass(BytePrimitive, [{\n    key: \"asPropertyObject\",\n    value: function asPropertyObject(position) {\n      var _this = this;\n\n      return {\n        get: function get() {\n          return _this.read(this.uint8a, position + this.offset);\n        },\n        set: function set(value) {\n          return _this.write(this.uint8a, position + this.offset, value);\n        },\n        enumerable: true\n      };\n    }\n    /**\n     * Read a value from `position` in `uint8a`.\n     * @param {Uint8Array} uint8a - Array to read from.\n     * @param {number} position - Position in `uint8a` to read from.\n     * @returns {*} - Value read from `uint8a` at `position`.\n     */\n\n  }, {\n    key: \"read\",\n    value: function read() {\n      return null;\n    }\n  }]);\n\n  return BytePrimitive;\n}();\n/**\n * @const Uint8\n * @type {BytePrimitive}\n */\n\n\nvar Uint8 = new BytePrimitive({\n  size: 1,\n  read: function read(uint8a, position) {\n    return uint8a[position];\n  },\n  write: function write(uint8a, position, value) {\n    uint8a[position] = value;\n    return value;\n  }\n});\nvar HOSTLE_BE16 = {\n  size: 2,\n  // toBytes: Defined by instance.\n  read: function read(uint8a, position) {\n    this.bytes[1] = uint8a[position + 0];\n    this.bytes[0] = uint8a[position + 1];\n    return this.toBytes[0];\n  },\n  write: function write(uint8a, position, value) {\n    this.toBytes[0] = value;\n    uint8a[position + 0] = this.bytes[1];\n    uint8a[position + 1] = this.bytes[0];\n    return value;\n  }\n};\nvar HOSTBE_BE16 = {\n  size: 2,\n  // toBytes: Defined by instance.\n  read: function read(uint8a, position) {\n    this.bytes[0] = uint8a[position + 0];\n    this.bytes[1] = uint8a[position + 1];\n    return this.toBytes[0];\n  },\n  write: function write(uint8a, position, value) {\n    this.toBytes[0] = value;\n    uint8a[position + 0] = this.bytes[0];\n    uint8a[position + 1] = this.bytes[1];\n    return value;\n  }\n};\nvar BE16;\n\nif (IS_HOST_LITTLE_ENDIAN) {\n  BE16 = HOSTLE_BE16;\n} else {\n  BE16 = HOSTBE_BE16;\n}\n/**\n * @const Uint16BE\n * @type {BytePrimitive}\n */\n\n\nvar Uint16BE = new BytePrimitive(Object.assign({}, BE16, {\n  toBytes: new Uint16Array(1)\n}));\n/**\n * @const Int16BE\n * @type {BytePrimitive}\n */\n\nvar Int16BE = new BytePrimitive(Object.assign({}, BE16, {\n  toBytes: new Int16Array(1)\n}));\nvar HOSTLE_BE32 = {\n  size: 4,\n  // toBytes: Defined by instance.\n  read: function read(uint8a, position) {\n    this.bytes[3] = uint8a[position + 0];\n    this.bytes[2] = uint8a[position + 1];\n    this.bytes[1] = uint8a[position + 2];\n    this.bytes[0] = uint8a[position + 3];\n    return this.toBytes[0];\n  },\n  write: function write(uint8a, position, value) {\n    this.toBytes[0] = value;\n    uint8a[position + 0] = this.bytes[3];\n    uint8a[position + 1] = this.bytes[2];\n    uint8a[position + 2] = this.bytes[1];\n    uint8a[position + 3] = this.bytes[0];\n    return value;\n  }\n};\nvar HOSTBE_BE32 = {\n  size: 4,\n  // toBytes: Defined by instance.\n  read: function read(uint8a, position) {\n    this.bytes[0] = uint8a[position + 0];\n    this.bytes[1] = uint8a[position + 1];\n    this.bytes[2] = uint8a[position + 2];\n    this.bytes[3] = uint8a[position + 3];\n    return this.toBytes[0];\n  },\n  write: function write(uint8a, position, value) {\n    this.toBytes[0] = value;\n    uint8a[position + 0] = this.bytes[0];\n    uint8a[position + 1] = this.bytes[1];\n    uint8a[position + 2] = this.bytes[2];\n    uint8a[position + 3] = this.bytes[3];\n    return value;\n  }\n};\nvar BE32;\n\nif (IS_HOST_LITTLE_ENDIAN) {\n  BE32 = HOSTLE_BE32;\n} else {\n  BE32 = HOSTBE_BE32;\n}\n/**\n * @const Int32BE\n * @type {BytePrimitive}\n */\n\n\nvar Int32BE = new BytePrimitive(Object.assign({}, BE32, {\n  toBytes: new Int32Array(1)\n}));\n/**\n * @const Uint32BE\n * @type {BytePrimitive}\n */\n\nvar Uint32BE = new BytePrimitive(Object.assign({}, BE32, {\n  toBytes: new Uint32Array(1)\n}));\nvar LE16;\n\nif (IS_HOST_LITTLE_ENDIAN) {\n  LE16 = HOSTBE_BE16;\n} else {\n  LE16 = HOSTLE_BE16;\n}\n/**\n * @const Uint16LE\n * @type {BytePrimitive}\n */\n\n\nvar Uint16LE = new BytePrimitive(Object.assign({}, LE16, {\n  toBytes: new Uint16Array(1)\n}));\nvar LE32;\n\nif (IS_HOST_LITTLE_ENDIAN) {\n  LE32 = HOSTBE_BE32;\n} else {\n  LE32 = HOSTLE_BE32;\n}\n/**\n * @const Uint32LE\n * @type {BytePrimitive}\n */\n\n\nvar Uint32LE = new BytePrimitive(Object.assign({}, LE32, {\n  toBytes: new Uint32Array(1)\n}));\nvar HOSTLE_BEDOUBLE = {\n  size: 8,\n  read: function read(uint8a, position) {\n    this.bytes[7] = uint8a[position + 0];\n    this.bytes[6] = uint8a[position + 1];\n    this.bytes[5] = uint8a[position + 2];\n    this.bytes[4] = uint8a[position + 3];\n    this.bytes[3] = uint8a[position + 4];\n    this.bytes[2] = uint8a[position + 5];\n    this.bytes[1] = uint8a[position + 6];\n    this.bytes[0] = uint8a[position + 7];\n    return this.toBytes[0];\n  }\n};\nvar HOSTBE_BEDOUBLE = {\n  size: 8,\n  read: function read(uint8a, position) {\n    this.bytes[7] = uint8a[position + 0];\n    this.bytes[6] = uint8a[position + 1];\n    this.bytes[5] = uint8a[position + 2];\n    this.bytes[4] = uint8a[position + 3];\n    this.bytes[3] = uint8a[position + 4];\n    this.bytes[2] = uint8a[position + 5];\n    this.bytes[1] = uint8a[position + 6];\n    this.bytes[0] = uint8a[position + 7];\n    return this.toBytes[0];\n  }\n};\nvar BEDOUBLE;\n\nif (IS_HOST_LITTLE_ENDIAN) {\n  BEDOUBLE = HOSTLE_BEDOUBLE;\n} else {\n  BEDOUBLE = HOSTBE_BEDOUBLE;\n}\n/**\n * @const DoubleBE\n * @type {BytePrimitive}\n */\n\n\nvar DoubleBE = new BytePrimitive(Object.assign({}, BEDOUBLE, {\n  toBytes: new Float64Array(1)\n}));\n/**\n * @extends BytePrimitive\n */\n\nvar FixedAsciiString =\n/*#__PURE__*/\nfunction (_BytePrimitive) {\n  _inherits(FixedAsciiString, _BytePrimitive);\n\n  /**\n   * @param {number} size - Number of bytes the FixedAsciiString uses.\n   */\n  function FixedAsciiString(size) {\n    _classCallCheck(this, FixedAsciiString);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(FixedAsciiString).call(this, {\n      size: size,\n      read: function read(uint8a, position) {\n        var str = '';\n\n        for (var i = 0; i < size; i++) {\n          var code = uint8a[position + i];\n          Object(_util_assert__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(code <= 127, 'Non-ascii character in FixedAsciiString');\n          str += String.fromCharCode(code);\n        }\n\n        return str;\n      },\n      write: function write(uint8a, position, value) {\n        for (var i = 0; i < size; i++) {\n          var code = value.charCodeAt(i);\n          Object(_util_assert__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(code <= 127, 'Non-ascii character in FixedAsciiString');\n          uint8a[position + i] = code;\n        }\n\n        return value;\n      }\n    }));\n  }\n\n  return FixedAsciiString;\n}(BytePrimitive);\n\n\n\n//# sourceURL=webpack:///./src/coders/byte-primitives.js?");

/***/ }),

/***/ "./src/coders/byte-stream.js":
/*!***********************************!*\
  !*** ./src/coders/byte-stream.js ***!
  \***********************************/
/*! exports provided: ByteStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ByteStream\", function() { return ByteStream; });\n/* harmony import */ var _util_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/assert */ \"./src/util/assert.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n/**\n * Read and write a stream of {@link BytePrimitive}s, {@link Packet}s, or byte\n * arrays to an ArrayBuffer.\n */\n\nvar ByteStream =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {ArrayBuffer} buffer - The ArrayBuffer to read from or write to.\n   * @param {number=} [position=0] - The position to start reading or writing\n   * from in the ArrayBuffer.\n   */\n  function ByteStream(buffer) {\n    var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, ByteStream);\n\n    /**\n     * The ArrayBuffer to read from or write to.\n     * @type {ArrayBuffer}\n     */\n    this.buffer = buffer;\n    /**\n     * The position to start reading or writing from in the ArrayBuffer.\n     * @type {number}\n     */\n\n    this.position = position;\n    /**\n     * The typed array view of the buffer to read and write with.\n     * @type {Uint8Array}\n     */\n\n    this.uint8a = new Uint8Array(this.buffer);\n  }\n  /**\n   * Read one instance of a given BytePrimitive and increment position based\n   * on the size of that value.\n   * @param {BytePrimitive} member - BytePrimitive to read and increment size\n   * with.\n   * @returns {*} Return the value produced by the BytePrimitive.\n   */\n\n\n  _createClass(ByteStream, [{\n    key: \"read\",\n    value: function read(member) {\n      var value = member.read(this.uint8a, this.position);\n\n      if (member.size === 0) {\n        this.position += member.sizeOf(this.uint8a, this.position);\n      } else {\n        this.position += member.size;\n      }\n\n      return value;\n    }\n    /**\n     * Read one instance of a given Packet subclass and increment position\n     * based on the size of that value.\n     * @param {PacketConstructor} StructType - Packet subclass constructor that\n     * can read from the current stream position.\n     * @returns {Packet} Instance of a Packet pointed at the position of the\n     * stream before calling readStruct.\n     */\n\n  }, {\n    key: \"readStruct\",\n    value: function readStruct(StructType) {\n      var obj = new StructType(this.uint8a, this.position);\n      this.position += StructType.size;\n      return obj;\n    }\n    /**\n     * Resize the internal buffer to allow for the needed amount of space.\n     * @param {number} needed - How many bytes need to fit in the buffer.\n     * @private\n     */\n\n  }, {\n    key: \"resize\",\n    value: function resize(needed) {\n      if (this.buffer.byteLength < needed) {\n        var uint8a = this.uint8a;\n        var nextPowerOf2 = Math.pow(2, Math.ceil(Math.log(needed) / Math.log(2)));\n        this.buffer = new ArrayBuffer(nextPowerOf2);\n        this.uint8a = new Uint8Array(this.buffer);\n        this.uint8a.set(uint8a);\n      }\n    }\n    /**\n     * Write a value to the stream (with a BytePrimitive defining how to do so)\n     * and increment the position.\n     * @param {BytePrimitive} member - BytePrimitive to define how to write the\n     * value.\n     * @param {*} value - Value to write.\n     * @returns {*} Value passed to the method.\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(member, value) {\n      if (member.size === 0) {\n        this.resize(this.position + member.writeSizeOf(value));\n      } else {\n        this.resize(this.position + member.size);\n      }\n\n      member.write(this.uint8a, this.position, value);\n\n      if (member.size === 0) {\n        this.position += member.writeSizeOf(this.uint8a, this.position);\n      } else {\n        this.position += member.size;\n      }\n\n      return value;\n    }\n    /**\n     * Write data to the stream structured by a given Packet subclass\n     * constructor and increment the position.\n     * @param {PacketConstructor} StructType - The Packet subclass constructor\n     * defining how to write the data.\n     * @param {object} data - Data to write.\n     * @returns {Packet} - Constructed packet after writing data.\n     */\n\n  }, {\n    key: \"writeStruct\",\n    value: function writeStruct(StructType, data) {\n      this.resize(this.position + StructType.size);\n      var st = Object.assign(new StructType(this.uint8a, this.position), data);\n      this.position += StructType.size;\n      return st;\n    }\n    /**\n     * Write bytes from the given Uint8Array array to the stream and increment\n     * the position.\n     * @param {Uint8Array} bytes - Bytes to write to the stream.\n     * @param {number=} [start=0] - Where in bytes to start writing from.\n     * @param {number=} [end=bytes.length] - Where in bytes to stop writing, excluding position at bytes[end].\n     * @returns {Uint8Array} Passed bytes Uint8Array.\n     */\n\n  }, {\n    key: \"writeBytes\",\n    value: function writeBytes(bytes) {\n      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : bytes.length;\n      Object(_util_assert__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(bytes instanceof Uint8Array, 'writeBytes must be passed an Uint8Array');\n      this.resize(this.position + (end - start));\n\n      for (var i = start; i < end; i++) {\n        this.uint8a[this.position + i - start] = bytes[i];\n      }\n\n      this.position += end - start;\n      return bytes;\n    }\n  }]);\n\n  return ByteStream;\n}();\n\n\n\n//# sourceURL=webpack:///./src/coders/byte-stream.js?");

/***/ }),

/***/ "./src/coders/crc32.js":
/*!*****************************!*\
  !*** ./src/coders/crc32.js ***!
  \*****************************/
/*! exports provided: CRC32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CRC32\", function() { return CRC32; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar CRC32 =\n/*#__PURE__*/\nfunction () {\n  function CRC32() {\n    _classCallCheck(this, CRC32);\n\n    this.bit = new Uint32Array(1);\n    this.crc = 0;\n    this.c = 0;\n    this.table = [];\n    var c;\n\n    for (var i = 0; i < 256; i++) {\n      c = i;\n\n      for (var j = 0; j < 8; j++) {\n        c = c & 1 ? 0xedb88320 ^ c >>> 1 : c >>> 1;\n      }\n\n      this.table[i] = c >>> 0;\n    }\n  }\n\n  _createClass(CRC32, [{\n    key: \"update\",\n    value: function update(uint8a) {\n      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : uint8a.length;\n      var crc = ~this.crc >>> 0;\n\n      for (var i = 0; i < length; i++) {\n        crc = crc >>> 8 ^ this.table[(crc ^ uint8a[position + i]) & 0xff];\n      }\n\n      this.crc = ~crc >>> 0;\n      return this;\n    }\n  }, {\n    key: \"digest\",\n    get: function get() {\n      return this.crc;\n    }\n  }]);\n\n  return CRC32;\n}();\n\n\n\n//# sourceURL=webpack:///./src/coders/crc32.js?");

/***/ }),

/***/ "./src/coders/deflate-packets.js":
/*!***************************************!*\
  !*** ./src/coders/deflate-packets.js ***!
  \***************************************/
/*! exports provided: DEFLATE_BLOCK_SIZE_MAX, DeflateHeader, DeflateChunkStart, DeflateEnd */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFLATE_BLOCK_SIZE_MAX\", function() { return DEFLATE_BLOCK_SIZE_MAX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DeflateHeader\", function() { return DeflateHeader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DeflateChunkStart\", function() { return DeflateChunkStart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DeflateEnd\", function() { return DeflateEnd; });\n/* harmony import */ var _byte_packets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./byte-packets */ \"./src/coders/byte-packets.js\");\n/* harmony import */ var _byte_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./byte-primitives */ \"./src/coders/byte-primitives.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\nvar DEFLATE_BLOCK_SIZE_MAX = 0xffff;\n\n\nvar DeflateHeader =\n/*#__PURE__*/\nfunction (_Packet$extend) {\n  _inherits(DeflateHeader, _Packet$extend);\n\n  function DeflateHeader() {\n    _classCallCheck(this, DeflateHeader);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(DeflateHeader).apply(this, arguments));\n  }\n\n  return DeflateHeader;\n}(_byte_packets__WEBPACK_IMPORTED_MODULE_0__[\"Packet\"].extend({\n  cmf: _byte_primitives__WEBPACK_IMPORTED_MODULE_1__[\"Uint8\"],\n  flag: _byte_primitives__WEBPACK_IMPORTED_MODULE_1__[\"Uint8\"]\n}));\n\n_byte_packets__WEBPACK_IMPORTED_MODULE_0__[\"Packet\"].initConstructor(DeflateHeader);\n\n\nvar DeflateChunkStart =\n/*#__PURE__*/\nfunction (_Packet$extend2) {\n  _inherits(DeflateChunkStart, _Packet$extend2);\n\n  function DeflateChunkStart() {\n    _classCallCheck(this, DeflateChunkStart);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(DeflateChunkStart).apply(this, arguments));\n  }\n\n  return DeflateChunkStart;\n}(_byte_packets__WEBPACK_IMPORTED_MODULE_0__[\"Packet\"].extend({\n  lastPacket: _byte_primitives__WEBPACK_IMPORTED_MODULE_1__[\"Uint8\"],\n  length: _byte_primitives__WEBPACK_IMPORTED_MODULE_1__[\"Uint16LE\"],\n  lengthCheck: _byte_primitives__WEBPACK_IMPORTED_MODULE_1__[\"Uint16LE\"]\n}));\n\n_byte_packets__WEBPACK_IMPORTED_MODULE_0__[\"Packet\"].initConstructor(DeflateChunkStart);\n\n\nvar DeflateEnd =\n/*#__PURE__*/\nfunction (_Packet$extend3) {\n  _inherits(DeflateEnd, _Packet$extend3);\n\n  function DeflateEnd() {\n    _classCallCheck(this, DeflateEnd);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(DeflateEnd).apply(this, arguments));\n  }\n\n  return DeflateEnd;\n}(_byte_packets__WEBPACK_IMPORTED_MODULE_0__[\"Packet\"].extend({\n  checksum: _byte_primitives__WEBPACK_IMPORTED_MODULE_1__[\"Uint32LE\"]\n}));\n\n_byte_packets__WEBPACK_IMPORTED_MODULE_0__[\"Packet\"].initConstructor(DeflateEnd);\n\n\n//# sourceURL=webpack:///./src/coders/deflate-packets.js?");

/***/ }),

/***/ "./src/coders/deflate-stream.js":
/*!**************************************!*\
  !*** ./src/coders/deflate-stream.js ***!
  \**************************************/
/*! exports provided: DeflateStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DeflateStream\", function() { return DeflateStream; });\n/* harmony import */ var _adler32__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adler32 */ \"./src/coders/adler32.js\");\n/* harmony import */ var _deflate_packets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./deflate-packets */ \"./src/coders/deflate-packets.js\");\n/* harmony import */ var _proxy_stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./proxy-stream */ \"./src/coders/proxy-stream.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\nvar DeflateStream =\n/*#__PURE__*/\nfunction (_ProxyStream) {\n  _inherits(DeflateStream, _ProxyStream);\n\n  function DeflateStream(stream) {\n    var _this;\n\n    _classCallCheck(this, DeflateStream);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DeflateStream).call(this, stream));\n\n    _this.stream.writeStruct(_deflate_packets__WEBPACK_IMPORTED_MODULE_1__[\"DeflateHeader\"], {\n      cmf: 8,\n      flag: 29\n    });\n\n    _this.adler = new _adler32__WEBPACK_IMPORTED_MODULE_0__[\"Adler32\"]();\n    _this.chunk = _this.stream.writeStruct(_deflate_packets__WEBPACK_IMPORTED_MODULE_1__[\"DeflateChunkStart\"], {\n      lastPacket: 0,\n      length: 0,\n      lengthCheck: 0 ^ 0xffff\n    });\n    return _this;\n  }\n\n  _createClass(DeflateStream, [{\n    key: \"writeStruct\",\n    value: function writeStruct(StructType, data) {\n      this.writeBytes(Object.assign(new StructType(), data).uint8a);\n    }\n  }, {\n    key: \"writeBytes\",\n    value: function writeBytes(bytes) {\n      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : bytes.length;\n      var chunkStart = start;\n\n      while (end - chunkStart > 0) {\n        if (this._deflateIndex === _deflate_packets__WEBPACK_IMPORTED_MODULE_1__[\"DEFLATE_BLOCK_SIZE_MAX\"]) {\n          this.chunk = this.stream.writeStruct(_deflate_packets__WEBPACK_IMPORTED_MODULE_1__[\"DeflateChunkStart\"], {\n            lastPacket: 0,\n            length: 0,\n            lengthCheck: 0 ^ 0xffff\n          });\n        }\n\n        var chunkLength = Math.min(end - chunkStart, _deflate_packets__WEBPACK_IMPORTED_MODULE_1__[\"DEFLATE_BLOCK_SIZE_MAX\"] - this._deflateIndex);\n        this.stream.writeBytes(bytes, chunkStart, chunkStart + chunkLength);\n        this._deflateIndex += chunkLength;\n        chunkStart += chunkLength;\n      }\n\n      this.adler.update(bytes, start, end - start);\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.chunk.lastPacket = 1;\n      this.stream.writeStruct(_deflate_packets__WEBPACK_IMPORTED_MODULE_1__[\"DeflateEnd\"], {\n        checksum: this.adler.digest\n      });\n    }\n  }, {\n    key: \"_deflateIndex\",\n    get: function get() {\n      return this.chunk.length;\n    },\n    set: function set(value) {\n      this.chunk.length = value;\n      this.chunk.lengthCheck = value ^ 0xffff;\n      return this.chunk.length;\n    }\n  }], [{\n    key: \"estimateSize\",\n    value: function estimateSize(bodySize) {\n      var packets = Math.ceil(bodySize / _deflate_packets__WEBPACK_IMPORTED_MODULE_1__[\"DEFLATE_BLOCK_SIZE_MAX\"]);\n      return _deflate_packets__WEBPACK_IMPORTED_MODULE_1__[\"DeflateHeader\"].size + packets * _deflate_packets__WEBPACK_IMPORTED_MODULE_1__[\"DeflateChunkStart\"].size + _deflate_packets__WEBPACK_IMPORTED_MODULE_1__[\"DeflateEnd\"].size + bodySize;\n    }\n  }]);\n\n  return DeflateStream;\n}(_proxy_stream__WEBPACK_IMPORTED_MODULE_2__[\"ProxyStream\"]);\n\n\n\n//# sourceURL=webpack:///./src/coders/deflate-stream.js?");

/***/ }),

/***/ "./src/coders/png-chunk-stream.js":
/*!****************************************!*\
  !*** ./src/coders/png-chunk-stream.js ***!
  \****************************************/
/*! exports provided: PNGChunkStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PNGChunkStream\", function() { return PNGChunkStream; });\n/* harmony import */ var _byte_primitives__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./byte-primitives */ \"./src/coders/byte-primitives.js\");\n/* harmony import */ var _crc32__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./crc32 */ \"./src/coders/crc32.js\");\n/* harmony import */ var _png_packets__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./png-packets */ \"./src/coders/png-packets.js\");\n/* harmony import */ var _proxy_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proxy-stream */ \"./src/coders/proxy-stream.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\nvar PNGChunkStream =\n/*#__PURE__*/\nfunction (_ProxyStream) {\n  _inherits(PNGChunkStream, _ProxyStream);\n\n  function PNGChunkStream(stream) {\n    var _this;\n\n    var chunkType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'IHDR';\n\n    _classCallCheck(this, PNGChunkStream);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(PNGChunkStream).call(this, stream));\n    _this.start = _this.stream.writeStruct(_png_packets__WEBPACK_IMPORTED_MODULE_2__[\"PNGChunkStart\"], {\n      length: 0,\n      chunkType: chunkType\n    });\n    _this.crc = new _crc32__WEBPACK_IMPORTED_MODULE_1__[\"CRC32\"]();\n    return _this;\n  }\n\n  _createClass(PNGChunkStream, [{\n    key: \"finish\",\n    value: function finish() {\n      var crcStart = this.start.offset + this.start.size;\n      var length = this.position - crcStart;\n      this.start.length = length;\n      this.crc.update(this.stream.uint8a, crcStart - _byte_primitives__WEBPACK_IMPORTED_MODULE_0__[\"Uint32BE\"].size, length + _byte_primitives__WEBPACK_IMPORTED_MODULE_0__[\"Uint32BE\"].size);\n      this.stream.writeStruct(_png_packets__WEBPACK_IMPORTED_MODULE_2__[\"PNGChunkEnd\"], {\n        checksum: this.crc.digest\n      });\n    }\n  }], [{\n    key: \"size\",\n    value: function size(bodySize) {\n      return _png_packets__WEBPACK_IMPORTED_MODULE_2__[\"PNGChunkStart\"].size + bodySize + _png_packets__WEBPACK_IMPORTED_MODULE_2__[\"PNGChunkEnd\"].size;\n    }\n  }]);\n\n  return PNGChunkStream;\n}(_proxy_stream__WEBPACK_IMPORTED_MODULE_3__[\"ProxyStream\"]);\n\n\n\n//# sourceURL=webpack:///./src/coders/png-chunk-stream.js?");

/***/ }),

/***/ "./src/coders/png-file.js":
/*!********************************!*\
  !*** ./src/coders/png-file.js ***!
  \********************************/
/*! exports provided: PNGFile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PNGFile\", function() { return PNGFile; });\n/* harmony import */ var _byte_stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./byte-stream */ \"./src/coders/byte-stream.js\");\n/* harmony import */ var _png_packets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./png-packets */ \"./src/coders/png-packets.js\");\n/* harmony import */ var _deflate_stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./deflate-stream */ \"./src/coders/deflate-stream.js\");\n/* harmony import */ var _png_chunk_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./png-chunk-stream */ \"./src/coders/png-chunk-stream.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\nvar PNGFile =\n/*#__PURE__*/\nfunction () {\n  function PNGFile() {\n    _classCallCheck(this, PNGFile);\n  }\n\n  _createClass(PNGFile, [{\n    key: \"encode\",\n    value: function encode(width, height, pixelsUint8) {\n      var rowSize = width * 4 + _png_packets__WEBPACK_IMPORTED_MODULE_1__[\"PNGFilterMethodByte\"].size;\n      var bodySize = rowSize * height;\n      var size = _png_packets__WEBPACK_IMPORTED_MODULE_1__[\"PNGSignature\"].size + // IHDR\n      _png_chunk_stream__WEBPACK_IMPORTED_MODULE_3__[\"PNGChunkStream\"].size(_png_packets__WEBPACK_IMPORTED_MODULE_1__[\"PNGIHDRChunkBody\"].size) + // IDAT\n      _png_chunk_stream__WEBPACK_IMPORTED_MODULE_3__[\"PNGChunkStream\"].size(_deflate_stream__WEBPACK_IMPORTED_MODULE_2__[\"DeflateStream\"].estimateSize(bodySize)) + // IEND\n      _png_chunk_stream__WEBPACK_IMPORTED_MODULE_3__[\"PNGChunkStream\"].size(0);\n      var stream = new _byte_stream__WEBPACK_IMPORTED_MODULE_0__[\"ByteStream\"](new ArrayBuffer(size));\n      stream.writeStruct(_png_packets__WEBPACK_IMPORTED_MODULE_1__[\"PNGSignature\"], {\n        support8Bit: 0x89,\n        png: 'PNG',\n        dosLineEnding: '\\r\\n',\n        dosEndOfFile: '\\x1a',\n        unixLineEnding: '\\n'\n      });\n      var pngIhdr = new _png_chunk_stream__WEBPACK_IMPORTED_MODULE_3__[\"PNGChunkStream\"](stream, 'IHDR');\n      pngIhdr.writeStruct(_png_packets__WEBPACK_IMPORTED_MODULE_1__[\"PNGIHDRChunkBody\"], {\n        width: width,\n        height: height,\n        bitDepth: 8,\n        colorType: 6,\n        compressionMethod: 0,\n        filterMethod: 0,\n        interlaceMethod: 0\n      });\n      pngIhdr.finish();\n      var pngIdat = new _png_chunk_stream__WEBPACK_IMPORTED_MODULE_3__[\"PNGChunkStream\"](stream, 'IDAT');\n      var deflate = new _deflate_stream__WEBPACK_IMPORTED_MODULE_2__[\"DeflateStream\"](pngIdat);\n      var pixelsIndex = 0;\n\n      while (pixelsIndex < pixelsUint8.length) {\n        deflate.writeStruct(_png_packets__WEBPACK_IMPORTED_MODULE_1__[\"PNGFilterMethodByte\"], {\n          method: 0\n        });\n        var partialLength = Math.min(pixelsUint8.length - pixelsIndex, rowSize - _png_packets__WEBPACK_IMPORTED_MODULE_1__[\"PNGFilterMethodByte\"].size);\n        deflate.writeBytes(pixelsUint8, pixelsIndex, pixelsIndex + partialLength);\n        pixelsIndex += partialLength;\n      }\n\n      deflate.finish();\n      pngIdat.finish();\n      var pngIend = new _png_chunk_stream__WEBPACK_IMPORTED_MODULE_3__[\"PNGChunkStream\"](stream, 'IEND');\n      pngIend.finish();\n      return stream.buffer;\n    }\n  }], [{\n    key: \"encode\",\n    value: function encode(width, height, pixels) {\n      return new PNGFile().encode(width, height, pixels);\n    }\n  }]);\n\n  return PNGFile;\n}();\n\n\n\n//# sourceURL=webpack:///./src/coders/png-file.js?");

/***/ }),

/***/ "./src/coders/png-packets.js":
/*!***********************************!*\
  !*** ./src/coders/png-packets.js ***!
  \***********************************/
/*! exports provided: PNGSignature, PNGChunkStart, PNGChunkEnd, PNGIHDRChunkBody, PNGFilterMethodByte */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PNGSignature\", function() { return PNGSignature; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PNGChunkStart\", function() { return PNGChunkStart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PNGChunkEnd\", function() { return PNGChunkEnd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PNGIHDRChunkBody\", function() { return PNGIHDRChunkBody; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PNGFilterMethodByte\", function() { return PNGFilterMethodByte; });\n/* harmony import */ var _util_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/assert */ \"./src/util/assert.js\");\n/* harmony import */ var _byte_packets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./byte-packets */ \"./src/coders/byte-packets.js\");\n/* harmony import */ var _byte_primitives__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./byte-primitives */ \"./src/coders/byte-primitives.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\nvar PNGSignature =\n/*#__PURE__*/\nfunction (_Packet$extend) {\n  _inherits(PNGSignature, _Packet$extend);\n\n  function PNGSignature() {\n    _classCallCheck(this, PNGSignature);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PNGSignature).apply(this, arguments));\n  }\n\n  _createClass(PNGSignature, null, [{\n    key: \"validate\",\n    value: function validate() {\n      Object(_util_assert__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(this.equals({\n        support8Bit: 0x89,\n        png: 'PNG',\n        dosLineEnding: '\\r\\n',\n        dosEndOfFile: '\\x1a',\n        unixLineEnding: '\\n'\n      }), 'PNGSignature does not match the expected values');\n    }\n  }]);\n\n  return PNGSignature;\n}(_byte_packets__WEBPACK_IMPORTED_MODULE_1__[\"Packet\"].extend({\n  support8Bit: _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint8\"],\n  png: new _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"FixedAsciiString\"](3),\n  dosLineEnding: new _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"FixedAsciiString\"](2),\n  dosEndOfFile: new _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"FixedAsciiString\"](1),\n  unixLineEnding: new _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"FixedAsciiString\"](1)\n}));\n\n_byte_packets__WEBPACK_IMPORTED_MODULE_1__[\"Packet\"].initConstructor(PNGSignature);\n\n\nvar PNGChunkStart =\n/*#__PURE__*/\nfunction (_Packet$extend2) {\n  _inherits(PNGChunkStart, _Packet$extend2);\n\n  function PNGChunkStart() {\n    _classCallCheck(this, PNGChunkStart);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PNGChunkStart).apply(this, arguments));\n  }\n\n  return PNGChunkStart;\n}(_byte_packets__WEBPACK_IMPORTED_MODULE_1__[\"Packet\"].extend({\n  length: _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"],\n  chunkType: new _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"FixedAsciiString\"](4)\n}));\n\n_byte_packets__WEBPACK_IMPORTED_MODULE_1__[\"Packet\"].initConstructor(PNGChunkStart);\n\n\nvar PNGChunkEnd =\n/*#__PURE__*/\nfunction (_Packet$extend3) {\n  _inherits(PNGChunkEnd, _Packet$extend3);\n\n  function PNGChunkEnd() {\n    _classCallCheck(this, PNGChunkEnd);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PNGChunkEnd).apply(this, arguments));\n  }\n\n  return PNGChunkEnd;\n}(_byte_packets__WEBPACK_IMPORTED_MODULE_1__[\"Packet\"].extend({\n  checksum: _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"]\n}));\n\n_byte_packets__WEBPACK_IMPORTED_MODULE_1__[\"Packet\"].initConstructor(PNGChunkEnd);\n\n\nvar PNGIHDRChunkBody =\n/*#__PURE__*/\nfunction (_Packet$extend4) {\n  _inherits(PNGIHDRChunkBody, _Packet$extend4);\n\n  function PNGIHDRChunkBody() {\n    _classCallCheck(this, PNGIHDRChunkBody);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PNGIHDRChunkBody).apply(this, arguments));\n  }\n\n  return PNGIHDRChunkBody;\n}(_byte_packets__WEBPACK_IMPORTED_MODULE_1__[\"Packet\"].extend({\n  width: _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"],\n  height: _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"],\n  bitDepth: _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint8\"],\n  colorType: _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint8\"],\n  compressionMethod: _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint8\"],\n  filterMethod: _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint8\"],\n  interlaceMethod: _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint8\"]\n}));\n\n_byte_packets__WEBPACK_IMPORTED_MODULE_1__[\"Packet\"].initConstructor(PNGIHDRChunkBody);\n\n\nvar PNGFilterMethodByte =\n/*#__PURE__*/\nfunction (_Packet$extend5) {\n  _inherits(PNGFilterMethodByte, _Packet$extend5);\n\n  function PNGFilterMethodByte() {\n    _classCallCheck(this, PNGFilterMethodByte);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PNGFilterMethodByte).apply(this, arguments));\n  }\n\n  return PNGFilterMethodByte;\n}(_byte_packets__WEBPACK_IMPORTED_MODULE_1__[\"Packet\"].extend({\n  method: _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint8\"]\n}));\n\n_byte_packets__WEBPACK_IMPORTED_MODULE_1__[\"Packet\"].initConstructor(PNGFilterMethodByte);\n\n\n//# sourceURL=webpack:///./src/coders/png-packets.js?");

/***/ }),

/***/ "./src/coders/proxy-stream.js":
/*!************************************!*\
  !*** ./src/coders/proxy-stream.js ***!
  \************************************/
/*! exports provided: ProxyStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ProxyStream\", function() { return ProxyStream; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar ProxyStream =\n/*#__PURE__*/\nfunction () {\n  function ProxyStream(stream) {\n    _classCallCheck(this, ProxyStream);\n\n    this.stream = stream;\n  }\n\n  _createClass(ProxyStream, [{\n    key: \"writeStruct\",\n    value: function writeStruct(StructType, data) {\n      return this.stream.writeStruct(StructType, data);\n    }\n  }, {\n    key: \"writeBytes\",\n    value: function writeBytes(bytes) {\n      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : bytes.length;\n      return this.stream.writeBytes(bytes, start, end);\n    }\n  }, {\n    key: \"uint8a\",\n    get: function get() {\n      return this.stream.uint8a;\n    },\n    set: function set(value) {\n      this.stream.uint8a = value;\n      return this.stream.uint8a;\n    }\n  }, {\n    key: \"position\",\n    get: function get() {\n      return this.stream.position;\n    },\n    set: function set(value) {\n      this.stream.position = value;\n      return this.stream.position;\n    }\n  }]);\n\n  return ProxyStream;\n}();\n\n\n\n//# sourceURL=webpack:///./src/coders/proxy-stream.js?");

/***/ }),

/***/ "./src/coders/squeak-image.js":
/*!************************************!*\
  !*** ./src/coders/squeak-image.js ***!
  \************************************/
/*! exports provided: SqueakImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SqueakImage\", function() { return SqueakImage; });\n/* harmony import */ var _byte_primitives__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./byte-primitives */ \"./src/coders/byte-primitives.js\");\n/* harmony import */ var _byte_stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./byte-stream */ \"./src/coders/byte-stream.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar defaultColorMap = [0x00000000, 0xFF000000, 0xFFFFFFFF, 0xFF808080, 0xFFFF0000, 0xFF00FF00, 0xFF0000FF, 0xFF00FFFF, 0xFFFFFF00, 0xFFFF00FF, 0xFF202020, 0xFF404040, 0xFF606060, 0xFF9F9F9F, 0xFFBFBFBF, 0xFFDFDFDF, 0xFF080808, 0xFF101010, 0xFF181818, 0xFF282828, 0xFF303030, 0xFF383838, 0xFF484848, 0xFF505050, 0xFF585858, 0xFF686868, 0xFF707070, 0xFF787878, 0xFF878787, 0xFF8F8F8F, 0xFF979797, 0xFFA7A7A7, 0xFFAFAFAF, 0xFFB7B7B7, 0xFFC7C7C7, 0xFFCFCFCF, 0xFFD7D7D7, 0xFFE7E7E7, 0xFFEFEFEF, 0xFFF7F7F7, 0xFF000000, 0xFF003300, 0xFF006600, 0xFF009900, 0xFF00CC00, 0xFF00FF00, 0xFF000033, 0xFF003333, 0xFF006633, 0xFF009933, 0xFF00CC33, 0xFF00FF33, 0xFF000066, 0xFF003366, 0xFF006666, 0xFF009966, 0xFF00CC66, 0xFF00FF66, 0xFF000099, 0xFF003399, 0xFF006699, 0xFF009999, 0xFF00CC99, 0xFF00FF99, 0xFF0000CC, 0xFF0033CC, 0xFF0066CC, 0xFF0099CC, 0xFF00CCCC, 0xFF00FFCC, 0xFF0000FF, 0xFF0033FF, 0xFF0066FF, 0xFF0099FF, 0xFF00CCFF, 0xFF00FFFF, 0xFF330000, 0xFF333300, 0xFF336600, 0xFF339900, 0xFF33CC00, 0xFF33FF00, 0xFF330033, 0xFF333333, 0xFF336633, 0xFF339933, 0xFF33CC33, 0xFF33FF33, 0xFF330066, 0xFF333366, 0xFF336666, 0xFF339966, 0xFF33CC66, 0xFF33FF66, 0xFF330099, 0xFF333399, 0xFF336699, 0xFF339999, 0xFF33CC99, 0xFF33FF99, 0xFF3300CC, 0xFF3333CC, 0xFF3366CC, 0xFF3399CC, 0xFF33CCCC, 0xFF33FFCC, 0xFF3300FF, 0xFF3333FF, 0xFF3366FF, 0xFF3399FF, 0xFF33CCFF, 0xFF33FFFF, 0xFF660000, 0xFF663300, 0xFF666600, 0xFF669900, 0xFF66CC00, 0xFF66FF00, 0xFF660033, 0xFF663333, 0xFF666633, 0xFF669933, 0xFF66CC33, 0xFF66FF33, 0xFF660066, 0xFF663366, 0xFF666666, 0xFF669966, 0xFF66CC66, 0xFF66FF66, 0xFF660099, 0xFF663399, 0xFF666699, 0xFF669999, 0xFF66CC99, 0xFF66FF99, 0xFF6600CC, 0xFF6633CC, 0xFF6666CC, 0xFF6699CC, 0xFF66CCCC, 0xFF66FFCC, 0xFF6600FF, 0xFF6633FF, 0xFF6666FF, 0xFF6699FF, 0xFF66CCFF, 0xFF66FFFF, 0xFF990000, 0xFF993300, 0xFF996600, 0xFF999900, 0xFF99CC00, 0xFF99FF00, 0xFF990033, 0xFF993333, 0xFF996633, 0xFF999933, 0xFF99CC33, 0xFF99FF33, 0xFF990066, 0xFF993366, 0xFF996666, 0xFF999966, 0xFF99CC66, 0xFF99FF66, 0xFF990099, 0xFF993399, 0xFF996699, 0xFF999999, 0xFF99CC99, 0xFF99FF99, 0xFF9900CC, 0xFF9933CC, 0xFF9966CC, 0xFF9999CC, 0xFF99CCCC, 0xFF99FFCC, 0xFF9900FF, 0xFF9933FF, 0xFF9966FF, 0xFF9999FF, 0xFF99CCFF, 0xFF99FFFF, 0xFFCC0000, 0xFFCC3300, 0xFFCC6600, 0xFFCC9900, 0xFFCCCC00, 0xFFCCFF00, 0xFFCC0033, 0xFFCC3333, 0xFFCC6633, 0xFFCC9933, 0xFFCCCC33, 0xFFCCFF33, 0xFFCC0066, 0xFFCC3366, 0xFFCC6666, 0xFFCC9966, 0xFFCCCC66, 0xFFCCFF66, 0xFFCC0099, 0xFFCC3399, 0xFFCC6699, 0xFFCC9999, 0xFFCCCC99, 0xFFCCFF99, 0xFFCC00CC, 0xFFCC33CC, 0xFFCC66CC, 0xFFCC99CC, 0xFFCCCCCC, 0xFFCCFFCC, 0xFFCC00FF, 0xFFCC33FF, 0xFFCC66FF, 0xFFCC99FF, 0xFFCCCCFF, 0xFFCCFFFF, 0xFFFF0000, 0xFFFF3300, 0xFFFF6600, 0xFFFF9900, 0xFFFFCC00, 0xFFFFFF00, 0xFFFF0033, 0xFFFF3333, 0xFFFF6633, 0xFFFF9933, 0xFFFFCC33, 0xFFFFFF33, 0xFFFF0066, 0xFFFF3366, 0xFFFF6666, 0xFFFF9966, 0xFFFFCC66, 0xFFFFFF66, 0xFFFF0099, 0xFFFF3399, 0xFFFF6699, 0xFFFF9999, 0xFFFFCC99, 0xFFFFFF99, 0xFFFF00CC, 0xFFFF33CC, 0xFFFF66CC, 0xFFFF99CC, 0xFFFFCCCC, 0xFFFFFFCC, 0xFFFF00FF, 0xFFFF33FF, 0xFFFF66FF, 0xFFFF99FF, 0xFFFFCCFF, 0xFFFFFFFF];\nvar defaultOneBitColorMap = [0xFFFFFFFF, 0xFF000000];\nvar VariableIntBE = new _byte_primitives__WEBPACK_IMPORTED_MODULE_0__[\"BytePrimitive\"]({\n  sizeOf: function sizeOf(uint8a, position) {\n    var count = uint8a[position];\n    if (count <= 223) return 1;\n    if (count <= 254) return 2;\n    return 5;\n  },\n  read: function read(uint8a, position) {\n    var count = uint8a[position];\n    if (count <= 223) return count;\n    if (count <= 254) return (count - 224) * 256 + uint8a[position + 1];\n    return _byte_primitives__WEBPACK_IMPORTED_MODULE_0__[\"Uint32BE\"].read(uint8a, position + 1);\n  }\n});\n\nvar SqueakImage =\n/*#__PURE__*/\nfunction () {\n  function SqueakImage() {\n    _classCallCheck(this, SqueakImage);\n  }\n\n  _createClass(SqueakImage, [{\n    key: \"decode\",\n    value: function decode(width, height, depth, bytes, colormap) {\n      var pixels = this.decodePixels(bytes, depth === 32);\n\n      if (depth <= 8) {\n        if (!colormap) {\n          colormap = depth === 1 ? defaultOneBitColorMap : defaultColorMap;\n        }\n\n        return this.unpackPixels(pixels, width, height, depth, colormap);\n      } else if (depth === 16) {\n        return this.raster16To32(pixels, width, height);\n      } else if (depth === 32) {\n        return pixels;\n      }\n\n      throw new Error('Unhandled Squeak Image depth.');\n    }\n  }, {\n    key: \"decodePixels\",\n    value: function decodePixels(bytes, withAlpha) {\n      var result; // Already decompressed\n\n      if (Array.isArray(bytes) || bytes instanceof Uint32Array) {\n        result = new Uint32Array(bytes);\n\n        if (withAlpha) {\n          for (var _i = 0; _i < result.length; _i++) {\n            if (result[_i] !== 0) {\n              result[_i] = 0xff000000 | result[_i];\n            }\n          }\n        }\n\n        return result;\n      }\n\n      var stream = new _byte_stream__WEBPACK_IMPORTED_MODULE_1__[\"ByteStream\"](bytes.buffer, bytes.byteOffset);\n      var pixelsOut = stream.read(VariableIntBE);\n      result = new Uint32Array(pixelsOut);\n      var i = 0;\n\n      while (i < pixelsOut) {\n        var runLengthAndCode = stream.read(VariableIntBE);\n        var runLength = runLengthAndCode >> 2;\n        var code = runLengthAndCode & 3;\n        var w = void 0;\n\n        switch (code) {\n          case 0:\n            i += runLength;\n            break;\n\n          case 1:\n            w = stream.read(_byte_primitives__WEBPACK_IMPORTED_MODULE_0__[\"Uint8\"]);\n            w = w << 24 | w << 16 | w << 8 | w;\n\n            if (withAlpha && w !== 0) {\n              w |= 0xff000000;\n            }\n\n            for (var j = 0; j < runLength; j++) {\n              result[i++] = w;\n            }\n\n            break;\n\n          case 2:\n            w = stream.read(_byte_primitives__WEBPACK_IMPORTED_MODULE_0__[\"Uint32BE\"]);\n\n            if (withAlpha && w !== 0) {\n              w |= 0xff000000;\n            }\n\n            for (var _j = 0; _j < runLength; _j++) {\n              result[i++] = w;\n            }\n\n            break;\n\n          case 3:\n            for (var _j2 = 0; _j2 < runLength; _j2++) {\n              w = stream.read(_byte_primitives__WEBPACK_IMPORTED_MODULE_0__[\"Uint32BE\"]);\n\n              if (withAlpha && w !== 0) {\n                w |= 0xff000000;\n              }\n\n              result[i++] = w;\n            }\n\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"unpackPixels\",\n    value: function unpackPixels(words, width, height, depth, colormap) {\n      var result = new Uint32Array(width * height);\n      var mask = (1 << depth) - 1;\n      var pixelsPerWord = 32 / depth;\n      var dst = 0;\n      var src = 0;\n\n      for (var y = 0; y < height; y++) {\n        var word = void 0;\n        var shift = -1;\n\n        for (var x = 0; x < width; x++) {\n          if (shift < 0) {\n            shift = depth * (pixelsPerWord - 1);\n            word = words[src++];\n          }\n\n          result[dst++] = colormap[word >> shift & mask];\n          shift -= depth;\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"raster16To32\",\n    value: function raster16To32(words, width, height) {\n      var result = new Uint32Array(2 * words.length);\n      var shift;\n      var word;\n      var pix;\n      var src = 0;\n      var dst = 0;\n\n      for (var y = 0; y < height; y++) {\n        shift = -1;\n\n        for (var x = 0; x < width; x++) {\n          if (shift < 0) {\n            shift = 16;\n            word = words[src++];\n          }\n\n          pix = word >> shift & 0xffff;\n\n          if (pix !== 0) {\n            var red = pix >> 7 & 248;\n            var green = pix >> 2 & 248;\n            var blue = pix << 3 & 248;\n            pix = 0xff000000 | red << 16 | green << 8 | blue;\n          }\n\n          result[dst++] = pix;\n          shift -= 16;\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"buildCustomColormap\",\n    value: function buildCustomColormap(depth, colors, table) {\n      var result = new Uint32Array(1 << depth);\n\n      for (var i = 0; i < colors.length; i++) {\n        result[i] = table[colors[i].index - 1];\n      }\n\n      return result;\n    }\n  }]);\n\n  return SqueakImage;\n}();\n\n\n\n//# sourceURL=webpack:///./src/coders/squeak-image.js?");

/***/ }),

/***/ "./src/coders/squeak-sound.js":
/*!************************************!*\
  !*** ./src/coders/squeak-sound.js ***!
  \************************************/
/*! exports provided: SqueakSound */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SqueakSound\", function() { return SqueakSound; });\n/* harmony import */ var _util_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/assert */ \"./src/util/assert.js\");\n/* harmony import */ var _byte_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./byte-primitives */ \"./src/coders/byte-primitives.js\");\n/* harmony import */ var _byte_stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./byte-stream */ \"./src/coders/byte-stream.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\nvar SQUEAK_SOUND_STEP_SIZE_TABLE = [7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 19, 21, 23, 25, 28, 31, 34, 37, 41, 45, 50, 55, 60, 66, 73, 80, 88, 97, 107, 118, 130, 143, 157, 173, 190, 209, 230, 253, 279, 307, 337, 371, 408, 449, 494, 544, 598, 658, 724, 796, 876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358, 5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899, 15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767];\nvar SQUEAK_SOUND_INDEX_TABLES = {\n  2: [-1, 2, -1, 2],\n  3: [-1, -1, 2, 4, -1, -1, 2, 4],\n  4: [-1, -1, -1, -1, 2, 4, 6, 8, -1, -1, -1, -1, 2, 4, 6, 8],\n  5: [-1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 4, 6, 8, 10, 13, 16, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 4, 6, 8, 10, 13, 16]\n};\n\nvar SqueakSound =\n/*#__PURE__*/\nfunction () {\n  function SqueakSound(bitsPerSample) {\n    _classCallCheck(this, SqueakSound);\n\n    this.bitsPerSample = bitsPerSample;\n    this.indexTable = SQUEAK_SOUND_INDEX_TABLES[bitsPerSample];\n    this.signMask = 1 << bitsPerSample - 1;\n    this.valueMask = this.signMask - 1;\n    this.valueHighBit = this.signMask >> 1;\n    this.bitPosition = 0;\n    this.currentByte = 0;\n    this.stream = null;\n    this.end = 0;\n  }\n\n  _createClass(SqueakSound, [{\n    key: \"decode\",\n    value: function decode(data) {\n      // Reset position information.\n      this.bitPosition = 0;\n      this.currentByte = 0;\n      this.stream = new _byte_stream__WEBPACK_IMPORTED_MODULE_2__[\"ByteStream\"](data.buffer, data.byteOffset);\n      this.end = data.byteOffset + data.length;\n      var size = Math.floor(data.length * 8 / this.bitsPerSample);\n      var result = new Int16Array(size);\n      var sample = 0;\n      var index = 0;\n\n      for (var i = 0; i < size; i++) {\n        var code = this.nextCode();\n        Object(_util_assert__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(code >= 0, 'Ran out of bits in Squeak Sound');\n        var step = SQUEAK_SOUND_STEP_SIZE_TABLE[index];\n        var delta = 0;\n\n        for (var bit = this.valueHighBit; bit > 0; bit = bit >> 1) {\n          if ((code & bit) !== 0) {\n            delta += step;\n          }\n\n          step = step >> 1;\n        }\n\n        delta += step;\n        sample += (code & this.signMask) === 0 ? delta : -delta;\n        index += this.indexTable[code];\n        if (index < 0) index = 0;\n        if (index > 88) index = 88;\n        if (sample > 32767) sample = 32767;\n        if (sample < -32768) sample = -32768;\n        result[i] = sample;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"nextCode\",\n    value: function nextCode() {\n      var remaining = this.bitsPerSample;\n      var shift = remaining - this.bitPosition;\n      var result = shift < 0 ? this.currentByte >> -shift : this.currentByte << shift;\n\n      while (shift > 0) {\n        remaining -= this.bitPosition;\n\n        if (this.end - this.stream.position > 0) {\n          this.currentByte = this.stream.read(_byte_primitives__WEBPACK_IMPORTED_MODULE_1__[\"Uint8\"]);\n          this.bitPosition = 8;\n        } else {\n          this.currentByte = 0;\n          this.bitPosition = 0;\n          return -1;\n        }\n\n        shift = remaining - this.bitPosition;\n        result += shift < 0 ? this.currentByte >> -shift : this.currentByte << shift;\n      }\n\n      this.bitPosition -= remaining;\n      this.currentByte = this.currentByte & 0xff >> 8 - this.bitPosition;\n      return result;\n    }\n  }], [{\n    key: \"samples\",\n    value: function samples(bitsPerSample, data) {\n      return data.length * 8 / bitsPerSample;\n    }\n  }]);\n\n  return SqueakSound;\n}();\n\n\n\n//# sourceURL=webpack:///./src/coders/squeak-sound.js?");

/***/ }),

/***/ "./src/coders/wav-file.js":
/*!********************************!*\
  !*** ./src/coders/wav-file.js ***!
  \********************************/
/*! exports provided: WAVFile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WAVFile\", function() { return WAVFile; });\n/* harmony import */ var _byte_stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./byte-stream */ \"./src/coders/byte-stream.js\");\n/* harmony import */ var _wav_packets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wav-packets */ \"./src/coders/wav-packets.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\nvar WAVFile =\n/*#__PURE__*/\nfunction () {\n  function WAVFile() {\n    _classCallCheck(this, WAVFile);\n  }\n\n  _createClass(WAVFile, [{\n    key: \"encode\",\n    value: function encode(intSamples) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref$channels = _ref.channels,\n          channels = _ref$channels === void 0 ? 1 : _ref$channels,\n          _ref$sampleRate = _ref.sampleRate,\n          sampleRate = _ref$sampleRate === void 0 ? 22050 : _ref$sampleRate;\n\n      var samplesUint8 = new Uint8Array(intSamples.buffer, intSamples.byteOffset, intSamples.byteLength);\n      var size = _wav_packets__WEBPACK_IMPORTED_MODULE_1__[\"WAVESignature\"].size + _wav_packets__WEBPACK_IMPORTED_MODULE_1__[\"WAVEChunkStart\"].size + _wav_packets__WEBPACK_IMPORTED_MODULE_1__[\"WAVEFMTChunkBody\"].size + _wav_packets__WEBPACK_IMPORTED_MODULE_1__[\"WAVEChunkStart\"].size + samplesUint8.length;\n      var stream = new _byte_stream__WEBPACK_IMPORTED_MODULE_0__[\"ByteStream\"](new ArrayBuffer(size));\n      stream.writeStruct(_wav_packets__WEBPACK_IMPORTED_MODULE_1__[\"WAVESignature\"], {\n        riff: 'RIFF',\n        length: size - 8,\n        wave: 'WAVE'\n      });\n      stream.writeStruct(_wav_packets__WEBPACK_IMPORTED_MODULE_1__[\"WAVEChunkStart\"], {\n        chunkType: 'fmt ',\n        length: _wav_packets__WEBPACK_IMPORTED_MODULE_1__[\"WAVEFMTChunkBody\"].size\n      });\n      stream.writeStruct(_wav_packets__WEBPACK_IMPORTED_MODULE_1__[\"WAVEFMTChunkBody\"], {\n        format: 1,\n        channels: channels,\n        sampleRate: sampleRate,\n        bytesPerSec: sampleRate * 2 * channels,\n        blockAlignment: channels * 2,\n        bitsPerSample: 16\n      });\n      stream.writeStruct(_wav_packets__WEBPACK_IMPORTED_MODULE_1__[\"WAVEChunkStart\"], {\n        chunkType: 'data',\n        length: size - stream.position - _wav_packets__WEBPACK_IMPORTED_MODULE_1__[\"WAVEChunkStart\"].size\n      });\n      stream.writeBytes(samplesUint8);\n      return stream.uint8a;\n    }\n  }], [{\n    key: \"encode\",\n    value: function encode(intSamples, options) {\n      return new WAVFile().encode(intSamples, options);\n    }\n  }, {\n    key: \"samples\",\n    value: function samples(bytes) {\n      var headerLength = new _wav_packets__WEBPACK_IMPORTED_MODULE_1__[\"WAVEChunkStart\"](bytes, _wav_packets__WEBPACK_IMPORTED_MODULE_1__[\"WAVESignature\"].size).length;\n      var bodyLength = new _wav_packets__WEBPACK_IMPORTED_MODULE_1__[\"WAVEChunkStart\"](bytes, _wav_packets__WEBPACK_IMPORTED_MODULE_1__[\"WAVESignature\"].size + _wav_packets__WEBPACK_IMPORTED_MODULE_1__[\"WAVEChunkStart\"].size + headerLength).length;\n      return bodyLength / 2;\n    }\n  }]);\n\n  return WAVFile;\n}();\n\n\n\n//# sourceURL=webpack:///./src/coders/wav-file.js?");

/***/ }),

/***/ "./src/coders/wav-packets.js":
/*!***********************************!*\
  !*** ./src/coders/wav-packets.js ***!
  \***********************************/
/*! exports provided: WAVESignature, WAVEChunkStart, WAVEFMTChunkBody */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WAVESignature\", function() { return WAVESignature; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WAVEChunkStart\", function() { return WAVEChunkStart; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WAVEFMTChunkBody\", function() { return WAVEFMTChunkBody; });\n/* harmony import */ var _byte_packets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./byte-packets */ \"./src/coders/byte-packets.js\");\n/* harmony import */ var _byte_primitives__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./byte-primitives */ \"./src/coders/byte-primitives.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\nvar WAVESignature =\n/*#__PURE__*/\nfunction (_Packet$extend) {\n  _inherits(WAVESignature, _Packet$extend);\n\n  function WAVESignature() {\n    _classCallCheck(this, WAVESignature);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(WAVESignature).apply(this, arguments));\n  }\n\n  return WAVESignature;\n}(_byte_packets__WEBPACK_IMPORTED_MODULE_0__[\"Packet\"].extend({\n  riff: new _byte_primitives__WEBPACK_IMPORTED_MODULE_1__[\"FixedAsciiString\"](4),\n  length: _byte_primitives__WEBPACK_IMPORTED_MODULE_1__[\"Uint32LE\"],\n  wave: new _byte_primitives__WEBPACK_IMPORTED_MODULE_1__[\"FixedAsciiString\"](4)\n}));\n\n_byte_packets__WEBPACK_IMPORTED_MODULE_0__[\"Packet\"].initConstructor(WAVESignature);\n\n\nvar WAVEChunkStart =\n/*#__PURE__*/\nfunction (_Packet$extend2) {\n  _inherits(WAVEChunkStart, _Packet$extend2);\n\n  function WAVEChunkStart() {\n    _classCallCheck(this, WAVEChunkStart);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(WAVEChunkStart).apply(this, arguments));\n  }\n\n  return WAVEChunkStart;\n}(_byte_packets__WEBPACK_IMPORTED_MODULE_0__[\"Packet\"].extend({\n  chunkType: new _byte_primitives__WEBPACK_IMPORTED_MODULE_1__[\"FixedAsciiString\"](4),\n  length: _byte_primitives__WEBPACK_IMPORTED_MODULE_1__[\"Uint32LE\"]\n}));\n\n_byte_packets__WEBPACK_IMPORTED_MODULE_0__[\"Packet\"].initConstructor(WAVEChunkStart);\n\n\nvar WAVEFMTChunkBody =\n/*#__PURE__*/\nfunction (_Packet$extend3) {\n  _inherits(WAVEFMTChunkBody, _Packet$extend3);\n\n  function WAVEFMTChunkBody() {\n    _classCallCheck(this, WAVEFMTChunkBody);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(WAVEFMTChunkBody).apply(this, arguments));\n  }\n\n  return WAVEFMTChunkBody;\n}(_byte_packets__WEBPACK_IMPORTED_MODULE_0__[\"Packet\"].extend({\n  format: _byte_primitives__WEBPACK_IMPORTED_MODULE_1__[\"Uint16LE\"],\n  channels: _byte_primitives__WEBPACK_IMPORTED_MODULE_1__[\"Uint16LE\"],\n  sampleRate: _byte_primitives__WEBPACK_IMPORTED_MODULE_1__[\"Uint32LE\"],\n  bytesPerSec: _byte_primitives__WEBPACK_IMPORTED_MODULE_1__[\"Uint32LE\"],\n  blockAlignment: _byte_primitives__WEBPACK_IMPORTED_MODULE_1__[\"Uint16LE\"],\n  bitsPerSample: _byte_primitives__WEBPACK_IMPORTED_MODULE_1__[\"Uint16LE\"]\n}));\n\n_byte_packets__WEBPACK_IMPORTED_MODULE_0__[\"Packet\"].initConstructor(WAVEFMTChunkBody);\n\n\n//# sourceURL=webpack:///./src/coders/wav-packets.js?");

/***/ }),

/***/ "./src/sb1-file-packets.js":
/*!*********************************!*\
  !*** ./src/sb1-file-packets.js ***!
  \*********************************/
/*! exports provided: SB1Signature, SB1Header */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SB1Signature\", function() { return SB1Signature; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SB1Header\", function() { return SB1Header; });\n/* harmony import */ var _util_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/assert */ \"./src/util/assert.js\");\n/* harmony import */ var _coders_byte_packets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./coders/byte-packets */ \"./src/coders/byte-packets.js\");\n/* harmony import */ var _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./coders/byte-primitives */ \"./src/coders/byte-primitives.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n/**\n * @augments Packet\n */\n\nvar SB1Signature =\n/*#__PURE__*/\nfunction (_Packet$extend) {\n  _inherits(SB1Signature, _Packet$extend);\n\n  function SB1Signature() {\n    _classCallCheck(this, SB1Signature);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SB1Signature).apply(this, arguments));\n  }\n\n  _createClass(SB1Signature, [{\n    key: \"validate\",\n\n    /**\n     * Is this a valid SB1Signature?\n     * @method\n     * @throws {AssertionError} Throws if it is not valid.\n     */\n    value: function validate() {\n      _util_assert__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].validate(this.equals({\n        version: 'ScratchV01'\n      }) || this.equals({\n        version: 'ScratchV02'\n      }), 'Invalid Scratch file signature.');\n    }\n  }]);\n\n  return SB1Signature;\n}(_coders_byte_packets__WEBPACK_IMPORTED_MODULE_1__[\"Packet\"].extend({\n  /**\n   * 10 byte ascii string equaling `'ScratchV01'` or `'ScratchV02'`.\n   * @type {string}\n   * @memberof SB1Signature#\n   */\n  version: new _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"FixedAsciiString\"](10),\n\n  /**\n   * Number of bytes in the info block.\n   * @type {number}\n   * @memberof SB1Signature#\n   */\n  infoByteLength: _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"]\n}));\n\n_coders_byte_packets__WEBPACK_IMPORTED_MODULE_1__[\"Packet\"].initConstructor(SB1Signature);\n\nvar SB1Header =\n/*#__PURE__*/\nfunction (_Packet$extend2) {\n  _inherits(SB1Header, _Packet$extend2);\n\n  function SB1Header() {\n    _classCallCheck(this, SB1Header);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SB1Header).apply(this, arguments));\n  }\n\n  _createClass(SB1Header, [{\n    key: \"validate\",\n    value: function validate() {\n      _util_assert__WEBPACK_IMPORTED_MODULE_0__[\"assert\"].validate(this.equals({\n        ObjS: 'ObjS',\n        ObjSValue: 1,\n        Stch: 'Stch',\n        StchValue: 1\n      }), 'Invalid Scratch file info packet header.');\n    }\n  }]);\n\n  return SB1Header;\n}(_coders_byte_packets__WEBPACK_IMPORTED_MODULE_1__[\"Packet\"].extend({\n  ObjS: new _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"FixedAsciiString\"](4),\n  ObjSValue: _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint8\"],\n  Stch: new _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"FixedAsciiString\"](4),\n  StchValue: _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint8\"],\n  numObjects: _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"]\n}));\n\n_coders_byte_packets__WEBPACK_IMPORTED_MODULE_1__[\"Packet\"].initConstructor(SB1Header);\n\n\n//# sourceURL=webpack:///./src/sb1-file-packets.js?");

/***/ }),

/***/ "./src/sb1-file.js":
/*!*************************!*\
  !*** ./src/sb1-file.js ***!
  \*************************/
/*! exports provided: SB1File */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SB1File\", function() { return SB1File; });\n/* harmony import */ var _coders_byte_stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./coders/byte-stream */ \"./src/coders/byte-stream.js\");\n/* harmony import */ var _squeak_byte_take_iterator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./squeak/byte-take-iterator */ \"./src/squeak/byte-take-iterator.js\");\n/* harmony import */ var _squeak_field_iterator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./squeak/field-iterator */ \"./src/squeak/field-iterator.js\");\n/* harmony import */ var _squeak_type_iterator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./squeak/type-iterator */ \"./src/squeak/type-iterator.js\");\n/* harmony import */ var _squeak_reference_fixer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./squeak/reference-fixer */ \"./src/squeak/reference-fixer.js\");\n/* harmony import */ var _squeak_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./squeak/types */ \"./src/squeak/types.js\");\n/* harmony import */ var _to_sb2_fake_zip__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./to-sb2/fake-zip */ \"./src/to-sb2/fake-zip.js\");\n/* harmony import */ var _to_sb2_json_generator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./to-sb2/json-generator */ \"./src/to-sb2/json-generator.js\");\n/* harmony import */ var _sb1_file_packets__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sb1-file-packets */ \"./src/sb1-file-packets.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n\n\n\n\n\nvar SB1File =\n/*#__PURE__*/\nfunction () {\n  function SB1File(buffer) {\n    _classCallCheck(this, SB1File);\n\n    this.buffer = buffer;\n    this.stream = new _coders_byte_stream__WEBPACK_IMPORTED_MODULE_0__[\"ByteStream\"](buffer);\n    this.signature = this.stream.readStruct(_sb1_file_packets__WEBPACK_IMPORTED_MODULE_8__[\"SB1Signature\"]);\n    this.signature.validate();\n    this.infoHeader = this.stream.readStruct(_sb1_file_packets__WEBPACK_IMPORTED_MODULE_8__[\"SB1Header\"]);\n    this.infoHeader.validate();\n    this.stream.position += this.signature.infoByteLength - _sb1_file_packets__WEBPACK_IMPORTED_MODULE_8__[\"SB1Header\"].size;\n    this.dataHeader = this.stream.readStruct(_sb1_file_packets__WEBPACK_IMPORTED_MODULE_8__[\"SB1Header\"]);\n    this.dataHeader.validate();\n  }\n\n  _createClass(SB1File, [{\n    key: \"view\",\n    value: function view() {\n      return {\n        signature: this.signature,\n        infoHeader: this.infoHeader,\n        dataHeader: this.dataHeader,\n        toString: function toString() {\n          return 'SB1File';\n        }\n      };\n    }\n  }, {\n    key: \"infoRaw\",\n    value: function infoRaw() {\n      return new _squeak_byte_take_iterator__WEBPACK_IMPORTED_MODULE_1__[\"ByteTakeIterator\"](new _squeak_field_iterator__WEBPACK_IMPORTED_MODULE_2__[\"FieldIterator\"](this.buffer, this.infoHeader.offset + _sb1_file_packets__WEBPACK_IMPORTED_MODULE_8__[\"SB1Header\"].size), this.signature.infoByteLength + _sb1_file_packets__WEBPACK_IMPORTED_MODULE_8__[\"SB1Signature\"].size);\n    }\n  }, {\n    key: \"infoTable\",\n    value: function infoTable() {\n      return new _squeak_type_iterator__WEBPACK_IMPORTED_MODULE_3__[\"TypeIterator\"](this.infoRaw());\n    }\n  }, {\n    key: \"info\",\n    value: function info() {\n      if (!this._info) {\n        this._info = new _squeak_reference_fixer__WEBPACK_IMPORTED_MODULE_4__[\"ReferenceFixer\"](this.infoTable()).table[0];\n      }\n\n      return this._info;\n    }\n  }, {\n    key: \"dataRaw\",\n    value: function dataRaw() {\n      return new _squeak_byte_take_iterator__WEBPACK_IMPORTED_MODULE_1__[\"ByteTakeIterator\"](new _squeak_field_iterator__WEBPACK_IMPORTED_MODULE_2__[\"FieldIterator\"](this.buffer, this.dataHeader.offset + _sb1_file_packets__WEBPACK_IMPORTED_MODULE_8__[\"SB1Header\"].size), this.stream.uint8a.length);\n    }\n  }, {\n    key: \"dataTable\",\n    value: function dataTable() {\n      return new _squeak_type_iterator__WEBPACK_IMPORTED_MODULE_3__[\"TypeIterator\"](this.dataRaw());\n    }\n  }, {\n    key: \"dataFixed\",\n    value: function dataFixed() {\n      if (!this._data) {\n        this._data = new _squeak_reference_fixer__WEBPACK_IMPORTED_MODULE_4__[\"ReferenceFixer\"](this.dataTable()).table;\n      }\n\n      return this._data;\n    }\n  }, {\n    key: \"data\",\n    value: function data() {\n      return this.dataFixed()[0];\n    }\n  }, {\n    key: \"images\",\n    value: function images() {\n      var unique = new Set();\n      return this.dataFixed().filter(function (obj) {\n        if (obj instanceof _squeak_types__WEBPACK_IMPORTED_MODULE_5__[\"ImageMediaData\"]) {\n          if (unique.has(obj.crc)) return false;\n          unique.add(obj.crc);\n          return true;\n        }\n\n        return false;\n      });\n    }\n  }, {\n    key: \"sounds\",\n    value: function sounds() {\n      var unique = new Set();\n      return this.dataFixed().filter(function (obj) {\n        if (obj instanceof _squeak_types__WEBPACK_IMPORTED_MODULE_5__[\"SoundMediaData\"]) {\n          if (unique.has(obj.crc)) return false;\n          unique.add(obj.crc);\n          return true;\n        }\n\n        return false;\n      });\n    }\n  }, {\n    key: \"json\",\n    get: function get() {\n      return Object(_to_sb2_json_generator__WEBPACK_IMPORTED_MODULE_7__[\"toSb2Json\"])({\n        info: this.info(),\n        stageData: this.data(),\n        images: this.images(),\n        sounds: this.sounds()\n      });\n    }\n  }, {\n    key: \"zip\",\n    get: function get() {\n      return Object(_to_sb2_fake_zip__WEBPACK_IMPORTED_MODULE_6__[\"toSb2FakeZipApi\"])({\n        // Use of this `zip` getter assumes that `json` will be used to\n        // fetch the json and not have it read from the produced \"fake\" zip.\n        images: this.images(),\n        sounds: this.sounds()\n      });\n    }\n  }]);\n\n  return SB1File;\n}();\n\n\n\n//# sourceURL=webpack:///./src/sb1-file.js?");

/***/ }),

/***/ "./src/squeak/byte-primitives.js":
/*!***************************************!*\
  !*** ./src/squeak/byte-primitives.js ***!
  \***************************************/
/*! exports provided: BUFFER_TOO_BIG, ReferenceBE, LargeInt, AsciiString, Bytes, SoundBytes, Bitmap32BE, UTF8, OpaqueColor, TranslucentColor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BUFFER_TOO_BIG\", function() { return BUFFER_TOO_BIG; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReferenceBE\", function() { return ReferenceBE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LargeInt\", function() { return LargeInt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AsciiString\", function() { return AsciiString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Bytes\", function() { return Bytes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SoundBytes\", function() { return SoundBytes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Bitmap32BE\", function() { return Bitmap32BE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UTF8\", function() { return UTF8; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OpaqueColor\", function() { return OpaqueColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TranslucentColor\", function() { return TranslucentColor; });\n/* harmony import */ var text_encoding__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! text-encoding */ \"text-encoding\");\n/* harmony import */ var text_encoding__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(text_encoding__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _util_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/assert */ \"./src/util/assert.js\");\n/* harmony import */ var _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../coders/byte-primitives */ \"./src/coders/byte-primitives.js\");\n\n\n\nvar BUFFER_TOO_BIG = 10 * 1024 * 1024;\n/**\n * @const ReferenceBE\n * @type BytePrimitive\n */\n\nvar ReferenceBE;\n\nif (_coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"IS_HOST_LITTLE_ENDIAN\"]) {\n  ReferenceBE = new _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"BytePrimitive\"]({\n    size: 3,\n    read: function read(uint8a, position) {\n      return uint8a[position + 0] << 16 | uint8a[position + 1] << 8 | uint8a[position + 2];\n    }\n  });\n} else {\n  ReferenceBE = new _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"BytePrimitive\"]({\n    size: 3,\n    read: function read(uint8a, position) {\n      return uint8a[position + 2] << 16 | uint8a[position + 1] << 8 | uint8a[position + 0];\n    }\n  });\n}\n/**\n * @const LargeInt\n * @type BytePrimitive\n */\n\n\nvar LargeInt = new _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"BytePrimitive\"]({\n  sizeOf: function sizeOf(uint8a, position) {\n    var count = _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Int16BE\"].read(uint8a, position);\n    return _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Int16BE\"].size + count;\n  },\n  read: function read(uint8a, position) {\n    var num = 0;\n    var multiplier = 0;\n    var count = _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Int16BE\"].read(uint8a, position);\n\n    for (var i = 0; i < count; i++) {\n      num = num + multiplier * _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint8\"].read(uint8a, position++);\n      multiplier *= 256;\n    }\n\n    return num;\n  }\n});\n/**\n * @const AsciiString\n * @type BytePrimitive\n */\n\nvar AsciiString = new _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"BytePrimitive\"]({\n  sizeOf: function sizeOf(uint8a, position) {\n    var count = _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].read(uint8a, position);\n    return _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].size + count;\n  },\n  read: function read(uint8a, position) {\n    var count = _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].read(uint8a, position);\n    Object(_util_assert__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(count < BUFFER_TOO_BIG, 'asciiString too big');\n    position += 4;\n    var str = '';\n\n    for (var i = 0; i < count; i++) {\n      str += String.fromCharCode(uint8a[position++]);\n    }\n\n    return str;\n  }\n});\n/**\n * @const Bytes\n * @type BytePrimitive\n */\n\nvar Bytes = new _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"BytePrimitive\"]({\n  sizeOf: function sizeOf(uint8a, position) {\n    return _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].size + _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].read(uint8a, position);\n  },\n  read: function read(uint8a, position) {\n    var count = _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].read(uint8a, position);\n    Object(_util_assert__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(count < BUFFER_TOO_BIG, 'bytes too big');\n    position += _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].size;\n    Object(_util_assert__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(count < BUFFER_TOO_BIG, 'uint8a array too big');\n    return new Uint8Array(uint8a.buffer, position, count);\n  }\n});\n/**\n * @const SoundBytes\n * @type BytePrimitive\n */\n\nvar SoundBytes = new _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"BytePrimitive\"]({\n  sizeOf: function sizeOf(uint8a, position) {\n    return _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].size + _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].read(uint8a, position) * 2;\n  },\n  read: function read(uint8a, position) {\n    var samples = _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].read(uint8a, position);\n    Object(_util_assert__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(samples < BUFFER_TOO_BIG, 'sound too big');\n    position += _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].size;\n    var count = samples * 2;\n    Object(_util_assert__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(count < BUFFER_TOO_BIG, 'uint8a array too big');\n    return new Uint8Array(uint8a.buffer, position, count);\n  }\n});\n/**\n * @const Bitmap32BE\n * @type BytePrimitive\n */\n\nvar Bitmap32BE = new _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"BytePrimitive\"]({\n  sizeOf: function sizeOf(uint8a, position) {\n    return _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].size + _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].read(uint8a, position) * _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].size;\n  },\n  read: function read(uint8a, position) {\n    var count = _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].read(uint8a, position);\n    Object(_util_assert__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(count < BUFFER_TOO_BIG, 'bitmap too big');\n    position += _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].size;\n    Object(_util_assert__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(count < BUFFER_TOO_BIG, 'uint8a array too big');\n    var value = new Uint32Array(count);\n\n    for (var i = 0; i < count; i++) {\n      value[i] = _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].read(uint8a, position);\n      position += _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].size;\n    }\n\n    return value;\n  }\n});\nvar decoder;\n/* global TextDecoder:true */\n\nif (typeof TextDecoder === 'undefined') {\n  decoder = new text_encoding__WEBPACK_IMPORTED_MODULE_0__[\"TextDecoder\"]();\n} else {\n  decoder = new TextDecoder();\n}\n/**\n * @const UTF8\n * @type BytePrimitive\n */\n\n\nvar UTF8 = new _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"BytePrimitive\"]({\n  sizeOf: function sizeOf(uint8a, position) {\n    return _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].size + _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].read(uint8a, position);\n  },\n  read: function read(uint8a, position) {\n    var count = _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].read(uint8a, position);\n    Object(_util_assert__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(count < BUFFER_TOO_BIG, 'utf8 too big');\n    position += _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].size;\n    Object(_util_assert__WEBPACK_IMPORTED_MODULE_1__[\"assert\"])(count < BUFFER_TOO_BIG, 'uint8a array too big');\n    return decoder.decode(new Uint8Array(uint8a.buffer, position, count));\n  }\n});\n/**\n * @const OpaqueColor\n * @type BytePrimitive\n */\n\nvar OpaqueColor = new _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"BytePrimitive\"]({\n  size: 4,\n  read: function read(uint8a, position) {\n    var rgb = _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].read(uint8a, position);\n    var a = 0xff;\n    var r = rgb >> 22 & 0xff;\n    var g = rgb >> 12 & 0xff;\n    var b = rgb >> 2 & 0xff;\n    return (a << 24 | r << 16 | g << 8 | b) >>> 0;\n  }\n});\n/**\n * @const TranslucentColor\n * @type BytePrimitive\n */\n\nvar TranslucentColor = new _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"BytePrimitive\"]({\n  size: 5,\n  read: function read(uint8a, position) {\n    var rgb = _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint32BE\"].read(uint8a, position);\n    var a = _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Uint8\"].read(uint8a, position);\n    var r = rgb >> 22 & 0xff;\n    var g = rgb >> 12 & 0xff;\n    var b = rgb >> 2 & 0xff;\n    return (a << 24 | r << 16 | g << 8 | b) >>> 0;\n  }\n});\n\n\n//# sourceURL=webpack:///./src/squeak/byte-primitives.js?");

/***/ }),

/***/ "./src/squeak/byte-take-iterator.js":
/*!******************************************!*\
  !*** ./src/squeak/byte-take-iterator.js ***!
  \******************************************/
/*! exports provided: ByteTakeIterator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ByteTakeIterator\", function() { return ByteTakeIterator; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\n * An iterator that only takes bytes up to a certain position.\n *\n * Take iterators constrain the number of times an inner iterator can return\n * values. Normally it constrains the number of returned values.\n * ByteTakeIterator instead constrains the number of bytes the inner iterator\n * may take from its stream before ByteTakeIterator returns done objects.\n *\n * Primarily used to wrap {@link FieldIterator}.\n */\nvar ByteTakeIterator =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {{stream: ByteStream}} iter - Iterator with `stream` member.\n   * @param {number} [maxPosition=Infinity] - Position `stream` may not go\n   * beyond when yielding the next value.\n   */\n  function ByteTakeIterator(iter) {\n    var maxPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n\n    _classCallCheck(this, ByteTakeIterator);\n\n    this.iter = iter;\n    this.maxPosition = maxPosition;\n  }\n  /**\n   * @returns {ByteTakeIterator} - Returns itself.\n   */\n\n\n  _createClass(ByteTakeIterator, [{\n    key: Symbol.iterator,\n    value: function value() {\n      return this;\n    }\n    /**\n     * @returns {{value: *, done: boolean}} - Return the next value or indicate\n     * the Iterator has reached its end.\n     */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      if (this.iter.stream.position >= this.maxPosition) {\n        return {\n          value: null,\n          done: true\n        };\n      }\n\n      return this.iter.next();\n    }\n  }]);\n\n  return ByteTakeIterator;\n}();\n\n\n\n//# sourceURL=webpack:///./src/squeak/byte-take-iterator.js?");

/***/ }),

/***/ "./src/squeak/field-iterator.js":
/*!**************************************!*\
  !*** ./src/squeak/field-iterator.js ***!
  \**************************************/
/*! exports provided: FieldIterator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FieldIterator\", function() { return FieldIterator; });\n/* harmony import */ var _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../coders/byte-primitives */ \"./src/coders/byte-primitives.js\");\n/* harmony import */ var _coders_byte_stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../coders/byte-stream */ \"./src/coders/byte-stream.js\");\n/* harmony import */ var _byte_primitives__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./byte-primitives */ \"./src/squeak/byte-primitives.js\");\n/* harmony import */ var _fields__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fields */ \"./src/squeak/fields.js\");\n/* harmony import */ var _ids__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ids */ \"./src/squeak/ids.js\");\nvar _CONSUMER_PROTOS;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n/**\n * Consume values for the byte stream with a iterator-like interface.\n */\n\nvar Consumer =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {object} options - Define the consumer.\n   * @param {function} [options.type=Value] - The {@link Field} type to\n   * create.\n   * @param {BytePrimitive} options.read - How to read the third Field\n   * argument. The third field argument is the value the field represented in\n   * the `.sb` file. It is either the Value's value, the Reference's index,\n   * or the Header's field size.\n   * @param {function} [options.value] - How to produce the third Field\n   * argument from a stream. Defaults to `stream =>\n   * stream.read(options.read)`.\n   */\n  function Consumer(_ref) {\n    var _ref$type = _ref.type,\n        type = _ref$type === void 0 ? _fields__WEBPACK_IMPORTED_MODULE_3__[\"Value\"] : _ref$type,\n        read = _ref.read,\n        _ref$value = _ref.value,\n        value = _ref$value === void 0 ? read ? function (stream) {\n      return stream.read(read);\n    } : null : _ref$value;\n\n    _classCallCheck(this, Consumer);\n\n    this.type = type;\n    this.value = value;\n  }\n  /**\n   * @param {ByteStream} stream - Stream to read from.\n   * @param {TYPES} classId - FieldObject TYPES identifying the value to read.\n   * @param {number} position - Position in the stream the classId was read\n   * from.\n   * @returns {{value: *, done: boolean}} - An iterator.next() return value.\n   */\n\n\n  _createClass(Consumer, [{\n    key: \"next\",\n    value: function next(stream, classId, position) {\n      return {\n        value: new this.type(classId, position, this.value(stream)),\n        done: false\n      };\n    }\n  }]);\n\n  return Consumer;\n}();\n/**\n * @const CONSUMER_PROTOS\n * @type {Object.<number, {type, read, value}>}\n */\n\n\nvar CONSUMER_PROTOS = (_CONSUMER_PROTOS = {}, _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].NULL, {\n  value: function value() {\n    return null;\n  }\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].TRUE, {\n  value: function value() {\n    return true;\n  }\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].FALSE, {\n  value: function value() {\n    return false;\n  }\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].SMALL_INT, {\n  read: _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_0__[\"Int32BE\"]\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].SMALL_INT_16, {\n  read: _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_0__[\"Int16BE\"]\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].LARGE_INT_POSITIVE, {\n  read: _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"LargeInt\"]\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].LARGE_INT_NEGATIVE, {\n  read: _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"LargeInt\"]\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].FLOATING, {\n  read: _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_0__[\"DoubleBE\"]\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].STRING, {\n  read: _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"AsciiString\"]\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].SYMBOL, {\n  read: _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"AsciiString\"]\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].BYTES, {\n  read: _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Bytes\"]\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].SOUND, {\n  read: _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"SoundBytes\"]\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].BITMAP, {\n  read: _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"Bitmap32BE\"]\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].UTF8, {\n  read: _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"UTF8\"]\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].ARRAY, {\n  type: _fields__WEBPACK_IMPORTED_MODULE_3__[\"Header\"],\n  read: _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_0__[\"Int32BE\"]\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].ORDERED_COLLECTION, {\n  type: _fields__WEBPACK_IMPORTED_MODULE_3__[\"Header\"],\n  read: _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_0__[\"Int32BE\"]\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].SET, {\n  type: _fields__WEBPACK_IMPORTED_MODULE_3__[\"Header\"],\n  read: _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_0__[\"Int32BE\"]\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].IDENTITY_SET, {\n  type: _fields__WEBPACK_IMPORTED_MODULE_3__[\"Header\"],\n  read: _coders_byte_primitives__WEBPACK_IMPORTED_MODULE_0__[\"Int32BE\"]\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].DICTIONARY, {\n  type: _fields__WEBPACK_IMPORTED_MODULE_3__[\"Header\"],\n  value: function value(stream) {\n    return stream.read(_coders_byte_primitives__WEBPACK_IMPORTED_MODULE_0__[\"Int32BE\"]) * 2;\n  }\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].IDENTITY_DICTIONARY, {\n  type: _fields__WEBPACK_IMPORTED_MODULE_3__[\"Header\"],\n  value: function value(stream) {\n    return stream.read(_coders_byte_primitives__WEBPACK_IMPORTED_MODULE_0__[\"Int32BE\"]) * 2;\n  }\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].COLOR, {\n  read: _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"OpaqueColor\"]\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].TRANSLUCENT_COLOR, {\n  read: _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"TranslucentColor\"]\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].POINT, {\n  type: _fields__WEBPACK_IMPORTED_MODULE_3__[\"Header\"],\n  value: function value() {\n    return 2;\n  }\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].RECTANGLE, {\n  type: _fields__WEBPACK_IMPORTED_MODULE_3__[\"Header\"],\n  value: function value() {\n    return 4;\n  }\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].FORM, {\n  type: _fields__WEBPACK_IMPORTED_MODULE_3__[\"Header\"],\n  value: function value() {\n    return 5;\n  }\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].SQUEAK, {\n  type: _fields__WEBPACK_IMPORTED_MODULE_3__[\"Header\"],\n  value: function value() {\n    return 6;\n  }\n}), _defineProperty(_CONSUMER_PROTOS, _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].OBJECT_REF, {\n  type: _fields__WEBPACK_IMPORTED_MODULE_3__[\"Reference\"],\n  read: _byte_primitives__WEBPACK_IMPORTED_MODULE_2__[\"ReferenceBE\"]\n}), _CONSUMER_PROTOS);\n/**\n * @const CONSUMERS\n * @type {Array.<Consumer|null>}\n */\n\nvar CONSUMERS = Array.from({\n  length: 256\n}, function (_, i) {\n  if (CONSUMER_PROTOS[i]) return new Consumer(CONSUMER_PROTOS[i]);\n  return null;\n});\nvar builtinConsumer = new Consumer({\n  type: _fields__WEBPACK_IMPORTED_MODULE_3__[\"BuiltinObjectHeader\"],\n  value: function value() {\n    return null;\n  }\n});\n/**\n * Field iterator.\n */\n\nvar FieldIterator =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {ArrayBuffer} buffer - Buffer to read from.\n   * @param {number} position - Position in buffer to start at.\n   */\n  function FieldIterator(buffer, position) {\n    _classCallCheck(this, FieldIterator);\n\n    this.buffer = buffer;\n    this.stream = new _coders_byte_stream__WEBPACK_IMPORTED_MODULE_1__[\"ByteStream\"](buffer, position);\n  }\n  /**\n   * @returns {FieldIterator} - Returns this.\n   */\n\n\n  _createClass(FieldIterator, [{\n    key: Symbol.iterator,\n    value: function value() {\n      return this;\n    }\n    /**\n     * @returns {{value: *, done: boolean}} - An iterator.next() value.\n     */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      if (this.stream.position >= this.stream.uint8a.length) {\n        return {\n          value: null,\n          done: true\n        };\n      }\n\n      var position = this.stream.position;\n      var classId = this.stream.read(_coders_byte_primitives__WEBPACK_IMPORTED_MODULE_0__[\"Uint8\"]);\n      var consumer = CONSUMERS[classId];\n\n      if (consumer !== null) {\n        return consumer.next(this.stream, classId, position);\n      } else if (classId < _ids__WEBPACK_IMPORTED_MODULE_4__[\"TYPES\"].OBJECT_REF) {\n        // TODO: Does this ever happen?\n        return builtinConsumer.next(this.stream, classId, position);\n      }\n\n      var classVersion = this.stream.read(_coders_byte_primitives__WEBPACK_IMPORTED_MODULE_0__[\"Uint8\"]);\n      var size = this.stream.read(_coders_byte_primitives__WEBPACK_IMPORTED_MODULE_0__[\"Uint8\"]);\n      return {\n        value: new _fields__WEBPACK_IMPORTED_MODULE_3__[\"FieldObjectHeader\"](classId, position, classVersion, size),\n        done: false\n      };\n    }\n  }]);\n\n  return FieldIterator;\n}();\n\n\n\n//# sourceURL=webpack:///./src/squeak/field-iterator.js?");

/***/ }),

/***/ "./src/squeak/field-object.js":
/*!************************************!*\
  !*** ./src/squeak/field-object.js ***!
  \************************************/
/*! exports provided: FieldObject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FieldObject\", function() { return FieldObject; });\n/* harmony import */ var _ids__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ids */ \"./src/squeak/ids.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n\n\nvar toTitleCase = function toTitleCase(str) {\n  return str.toLowerCase().replace(/_(\\w)/g, function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        letter = _ref2[1];\n\n    return letter.toUpperCase();\n  });\n};\n/**\n * A object representation of a {@link Header} collecting the given {@link\n * Header#size} in fields.\n */\n\n\nvar FieldObject =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {TYPES} classId - {@link TYPES} id that informs what the shape of\n   * this object is.\n   * @param {number} version - Version number of this object. Some items in\n   * the same class may have different content and so will be different\n   * versions.\n   * @param {Array.<Field>} fields - An array of fields in this FieldObject.\n   */\n  function FieldObject(_ref3) {\n    var classId = _ref3.classId,\n        version = _ref3.version,\n        fields = _ref3.fields;\n\n    _classCallCheck(this, FieldObject);\n\n    /** @type {number} */\n    this.classId = classId;\n    /** @type {number} */\n\n    this.version = version;\n    /** @type {Array.<Field>} */\n\n    this.fields = fields;\n  }\n  /**\n   * @type {object}\n   */\n\n\n  _createClass(FieldObject, [{\n    key: \"string\",\n    value: function string(field) {\n      return String(this.fields[field]);\n    }\n  }, {\n    key: \"number\",\n    value: function number(field) {\n      return +this.fields[field];\n    }\n  }, {\n    key: \"boolean\",\n    value: function boolean(field) {\n      return !!this.fields[field];\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (this.constructor === FieldObject) {\n        return \"\".concat(this.constructor.name, \" \").concat(this.classId, \" \").concat(_ids__WEBPACK_IMPORTED_MODULE_0__[\"TYPE_NAMES\"][this.classId]);\n      }\n\n      return this.constructor.name;\n    }\n    /**\n     * Define a FieldObject subclass by mapping field names to indices in\n     * {@link FieldObject#fields}.\n     * @param {object} FIELDS - Mapping of ALL_CAPS keys to index in {@link\n     * FieldObject#fields}.\n     * @param {function} [Super] - Parent class of the returned subclass.\n     * @returns {function} - FieldObject subclass constructor.\n     */\n\n  }, {\n    key: \"FIELDS\",\n    get: function get() {\n      return [];\n    }\n    /**\n     * @type {Array.<Field>}\n     */\n\n  }, {\n    key: \"RAW_FIELDS\",\n    get: function get() {\n      return this.fields;\n    }\n  }], [{\n    key: \"define\",\n    value: function define(FIELDS) {\n      var Super = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FieldObject;\n\n      var DefinedObject =\n      /*#__PURE__*/\n      function (_Super) {\n        _inherits(DefinedObject, _Super);\n\n        function DefinedObject() {\n          _classCallCheck(this, DefinedObject);\n\n          return _possibleConstructorReturn(this, _getPrototypeOf(DefinedObject).apply(this, arguments));\n        }\n\n        _createClass(DefinedObject, [{\n          key: \"FIELDS\",\n          get: function get() {\n            return FIELDS;\n          }\n        }], [{\n          key: \"FIELDS\",\n          get: function get() {\n            return FIELDS;\n          }\n        }]);\n\n        return DefinedObject;\n      }(Super);\n\n      Object.keys(FIELDS).forEach(function (key) {\n        var index = FIELDS[key];\n        Object.defineProperty(DefinedObject.prototype, toTitleCase(key), {\n          get: function get() {\n            return this.fields[index];\n          }\n        });\n      });\n      return DefinedObject;\n    }\n  }]);\n\n  return FieldObject;\n}();\n\n\n\n//# sourceURL=webpack:///./src/squeak/field-object.js?");

/***/ }),

/***/ "./src/squeak/fields.js":
/*!******************************!*\
  !*** ./src/squeak/fields.js ***!
  \******************************/
/*! exports provided: Field, value, Value, Header, Reference, BuiltinObjectHeader, FieldObjectHeader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Field\", function() { return Field; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"value\", function() { return valueOf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Value\", function() { return Value; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Header\", function() { return Header; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Reference\", function() { return Reference; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BuiltinObjectHeader\", function() { return BuiltinObjectHeader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FieldObjectHeader\", function() { return FieldObjectHeader; });\n/* harmony import */ var _ids__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ids */ \"./src/squeak/ids.js\");\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n/**\n * An abstract value contained in a `.sb` file.\n *\n * `.sb` files are made up of two blocks of Fields. Each field in the binary\n * file defines its \"class\" and is possibly followed by some binary data\n * depending on the class. Each class explicitly defines what follows. Knowing\n * all the possible classes each block can be broken up into a series of Field\n * objects.\n */\n\nvar Field =\n/**\n * @param {TYPES} classId - The class identifier of this Field.\n * @param {number} position - Byte position in the `.sb` file.\n */\nfunction Field(classId, position) {\n  _classCallCheck(this, Field);\n\n  /**\n   * The class identifier of this Field.\n   * @type {TYPES}\n   */\n  this.classId = classId;\n  /**\n   * Byte position in the `.sb` file.\n   * @type {number}\n   */\n\n  this.position = position;\n};\n\nvar valueOf = function valueOf(obj) {\n  if (_typeof(obj) === 'object' && obj) return obj.valueOf();\n  return obj;\n};\n/**\n * A concrete value contained in a `.sb` file.\n * @extends Field\n */\n\n\nvar Value =\n/*#__PURE__*/\nfunction (_Field) {\n  _inherits(Value, _Field);\n\n  /**\n   * @param {TYPES} classId - The class identifier of this Field.\n   * @param {number} position - Byte position in the `.sb` file.\n   * @param {*} value - A value decoded according to `classId` from an `.sb`\n   * file.\n   */\n  function Value(classId, position, value) {\n    var _this;\n\n    _classCallCheck(this, Value);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Value).call(this, classId, position));\n    /**\n     * A value decoded according to `classId` from an `.sb` file.\n     * @type {*}\n     */\n\n    _this.value = value;\n    return _this;\n  }\n\n  _createClass(Value, [{\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.value;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      if (this.classId === _ids__WEBPACK_IMPORTED_MODULE_0__[\"TYPES\"].TRANSLUCENT_COLOR || this.classId === _ids__WEBPACK_IMPORTED_MODULE_0__[\"TYPES\"].COLOR) {\n        // TODO: Can colors be 32 bit in scratch-packets?\n        return this.value & 0xffffff;\n      }\n\n      return this.value;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.value;\n    }\n  }]);\n\n  return Value;\n}(Field);\n/**\n * A header for a FieldObject representing its class and how many fields are in\n * the object.\n *\n * The `size` of a header is the number of Fields that appear in the byte\n * stream after the header that are related to the header. That set of `size`\n * length Fields make up a FieldObject of `classId` passed to this header.\n * @extends Field\n */\n\n\nvar Header =\n/*#__PURE__*/\nfunction (_Field2) {\n  _inherits(Header, _Field2);\n\n  /**\n   * @param {TYPES} classId - The class identifier of this Field.\n   * @param {number} position - Byte position in the `.sb` file.\n   * @param {number} size - The number of fields to collect.\n   */\n  function Header(classId, position, size) {\n    var _this2;\n\n    _classCallCheck(this, Header);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Header).call(this, classId, position));\n    /**\n     * The number of fields to collect.\n     * @type {number}\n     */\n\n    _this2.size = size;\n    return _this2;\n  }\n\n  return Header;\n}(Field);\n/**\n * A integer reference of an object in an array produced by TypeIterator of\n * Values and FieldObjects.\n * @extends Field\n */\n\n\nvar Reference =\n/*#__PURE__*/\nfunction (_Field3) {\n  _inherits(Reference, _Field3);\n\n  /**\n   * @param {TYPES} classId - The class identifier of this Field.\n   * @param {number} position - Byte position in the `.sb` file.\n   * @param {number} index - The index this Reference refers to.\n   */\n  function Reference(classId, position, index) {\n    var _this3;\n\n    _classCallCheck(this, Reference);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(Reference).call(this, classId, position));\n    /**\n     * The index this Reference refers to.\n     * @type {number}\n     */\n\n    _this3.index = index;\n    return _this3;\n  }\n\n  _createClass(Reference, [{\n    key: \"valueOf\",\n    value: function valueOf() {\n      return \"Ref(\".concat(this.index, \")\");\n    }\n  }]);\n\n  return Reference;\n}(Field);\n/**\n * An object header of 0 size.\n * @extends Header\n */\n\n\nvar BuiltinObjectHeader =\n/*#__PURE__*/\nfunction (_Header) {\n  _inherits(BuiltinObjectHeader, _Header);\n\n  function BuiltinObjectHeader(classId, position) {\n    _classCallCheck(this, BuiltinObjectHeader);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BuiltinObjectHeader).call(this, classId, position, 0));\n  }\n\n  return BuiltinObjectHeader;\n}(Header);\n/**\n * An object header with an id more than 99, a version, and a size. The version\n * and size appear in the `sb` file as one byte for version followed by another\n * byte for the size.\n * @extends Header\n */\n\n\nvar FieldObjectHeader =\n/*#__PURE__*/\nfunction (_Header2) {\n  _inherits(FieldObjectHeader, _Header2);\n\n  /**\n   * @param {TYPES} classId - The class identifier of this Field.\n   * @param {number} position - Byte position in the `.sb` file.\n   * @param {number} version - The version of this instance of a certain\n   * value.\n   * @param {number} size - The number of fields in this object.\n   */\n  function FieldObjectHeader(classId, position, version, size) {\n    var _this4;\n\n    _classCallCheck(this, FieldObjectHeader);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(FieldObjectHeader).call(this, classId, position, size));\n    /**\n     * The version of this instance of a certain value.\n     * @type {number}\n     */\n\n    _this4.version = version;\n    return _this4;\n  }\n\n  return FieldObjectHeader;\n}(Header);\n\n\n\n//# sourceURL=webpack:///./src/squeak/fields.js?");

/***/ }),

/***/ "./src/squeak/ids.js":
/*!***************************!*\
  !*** ./src/squeak/ids.js ***!
  \***************************/
/*! exports provided: TYPES, TYPE_NAMES */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TYPES\", function() { return TYPES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TYPE_NAMES\", function() { return TYPE_NAMES; });\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/**\n * A numeric identifier for each possible class of {@link Field} that can be in\n * a `.sb` file.\n * @enum {number}\n */\nvar TYPES = {\n  /** A `null` {@link Value}. No data is stored after the class id. */\n  NULL: 1,\n\n  /** A `true` {@link Value}. No data is stored after the class id. */\n  TRUE: 2,\n\n  /** A `false` {@link Value}. No data is stored after the class id. */\n  FALSE: 3,\n\n  /** A small integer {@link Value}. The next 4 bytes represent an integer. */\n  SMALL_INT: 4,\n\n  /** A small integer {@link Value}. The next 2 bytes represent an integer. */\n  SMALL_INT_16: 5,\n\n  /** A large integer {@link Value}. The value is a variable number of bytes.\n   * The next byte defines the number of bytes after that represent the\n   * integer. The integer's bytes are stored least value first (little\n   * endian). */\n  LARGE_INT_POSITIVE: 6,\n\n  /** A large integer {@link Value}. The value is a variable number of bytes.\n   * The next byte defines the number of bytes after that represent the\n   * integer. The integer's bytes are stored least value first (little\n   * endian). */\n  LARGE_INT_NEGATIVE: 7,\n\n  /** A floating point {@link Value}. The next 8 bytes are stored as a double\n   * precision floating point value. */\n  FLOATING: 8,\n\n  /** A ascii string {@link Value}. The next 4 bytes defines the number of\n   * following bytes that make up the string. */\n  STRING: 9,\n\n  /** A ascii string {@link Value}. The next 4 bytes defines the number of\n   * following bytes that make up the string. */\n  SYMBOL: 10,\n\n  /** A sequence of bytes ({@link Value}). The next 4 bytes defines the\n   * number of bytes in the sequence. */\n  BYTES: 11,\n\n  /** A sequence of 16 bit samples ({@link Value}). The next 4 bytes defines\n   * the number of samples in the sequence. */\n  SOUND: 12,\n\n  /** A sequence of 32 bit color integers ({@link Value}). The next 4 bytes\n   * defines the number of colors in the bitmap. */\n  BITMAP: 13,\n\n  /** A utf8 string {@link Value}. The next 4 bytes defines the number of\n   * bytes used by the string. */\n  UTF8: 14,\n\n  /** An array {@link Header}. The next 4 bytes defines the following number\n   * of fields in the array. */\n  ARRAY: 20,\n\n  /** An array {@link Header}. The next 4 bytes defines the following number\n   * of fields in the array. */\n  ORDERED_COLLECTION: 21,\n\n  /** An array {@link Header}. The next 4 bytes defines the following number\n   * of fields in the array. */\n  SET: 22,\n\n  /** An array {@link Header}. The next 4 bytes defines the following number\n   * of fields in the array. */\n  IDENTITY_SET: 23,\n\n  /** A dictionary {@link Header}. The next 4 bytes defines the following\n   * number of key/value field pairs in the dictionary. */\n  DICTIONARY: 24,\n\n  /** A dictionary {@link Header}. The next 4 bytes defines the following\n   * number of key/value field pairs in the dictionary. */\n  IDENTITY_DICTIONARY: 25,\n\n  /** A color {@link Value}. The next 4 bytes represents the color. */\n  COLOR: 30,\n\n  /** A color {@link Value}. The next 4 bytes represents the red, green, and\n   * blue subpixels. The following byte represents the alpha. */\n  TRANSLUCENT_COLOR: 31,\n\n  /** A 2 field point {@link Header}. The next 2 fields are the x and y\n   * values of this point. */\n  POINT: 32,\n\n  /** A 4 field rectangle {@link Header}. The next 4 fields are the x, y, x2,\n   * y2 values of this rectangle. */\n  RECTANGLE: 33,\n\n  /** A 5 field image {@link Header}. The next 5 fields are the width,\n   * height, bit depth, unused, and bytes. */\n  FORM: 34,\n\n  /** A 6 field image {@link Header}. The next 6 fields are the width,\n   * height, bit depth, unsued, bytes and colormap. */\n  SQUEAK: 35,\n\n  /** An object {@link Reference} to a position in the top level array of fields in a\n   * block. */\n  OBJECT_REF: 99,\n\n  /** A variable {@link FieldObjectHeader}. */\n  MORPH: 100,\n\n  /** A variable {@link FieldObjectHeader}. */\n  ALIGNMENT: 104,\n\n  /** A variable {@link FieldObjectHeader}.\n   *\n   * In Scratch 2 this is called String. To reduce confusion in the set of\n   * types, this is called STATIC_STRING in this converter. */\n  STATIC_STRING: 105,\n\n  /** A variable {@link FieldObjectHeader}. */\n  UPDATING_STRING: 106,\n\n  /** A variable {@link FieldObjectHeader}. */\n  SAMPLED_SOUND: 109,\n\n  /** A variable {@link FieldObjectHeader}. */\n  IMAGE_MORPH: 110,\n\n  /** A variable {@link FieldObjectHeader}. */\n  SPRITE: 124,\n\n  /** A variable {@link FieldObjectHeader}. */\n  STAGE: 125,\n\n  /** A variable {@link FieldObjectHeader}. */\n  WATCHER: 155,\n\n  /** A variable {@link FieldObjectHeader}. */\n  IMAGE_MEDIA: 162,\n\n  /** A variable {@link FieldObjectHeader}. */\n  SOUND_MEDIA: 164,\n\n  /** A variable {@link FieldObjectHeader}. */\n  MULTILINE_STRING: 171,\n\n  /** A variable {@link FieldObjectHeader}. */\n  WATCHER_READOUT_FRAME: 173,\n\n  /** A variable {@link FieldObjectHeader}. */\n  WATCHER_SLIDER: 174,\n\n  /** A variable {@link FieldObjectHeader}. */\n  LIST_WATCHER: 175\n};\n/**\n * A inverted map of TYPES. Map id numbers to their string names.\n * @type {object.<number, string>}\n */\n\nvar TYPE_NAMES = Object.entries(TYPES).reduce(function (carry, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      key = _ref2[0],\n      value = _ref2[1];\n\n  carry[value] = key;\n  return carry;\n}, {});\n\n\n//# sourceURL=webpack:///./src/squeak/ids.js?");

/***/ }),

/***/ "./src/squeak/reference-fixer.js":
/*!***************************************!*\
  !*** ./src/squeak/reference-fixer.js ***!
  \***************************************/
/*! exports provided: ReferenceFixer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReferenceFixer\", function() { return ReferenceFixer; });\n/* harmony import */ var _fields__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fields */ \"./src/squeak/fields.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar ReferenceFixer =\n/*#__PURE__*/\nfunction () {\n  function ReferenceFixer(table) {\n    _classCallCheck(this, ReferenceFixer);\n\n    this.table = Array.from(table);\n    this.fixed = this.fix(this.table);\n  }\n\n  _createClass(ReferenceFixer, [{\n    key: \"fix\",\n    value: function fix() {\n      var fixed = [];\n\n      for (var i = 0; i < this.table.length; i++) {\n        this.fixItem(this.table[i]);\n        fixed.push(this.table[i]);\n      }\n\n      return fixed;\n    }\n  }, {\n    key: \"fixItem\",\n    value: function fixItem(item) {\n      if (typeof item.fields !== 'undefined') {\n        item = item.fields;\n      }\n\n      if (Array.isArray(item)) {\n        for (var i = 0; i < item.length; i++) {\n          item[i] = this.deref(item[i]);\n        }\n      }\n    }\n  }, {\n    key: \"deref\",\n    value: function deref(ref) {\n      if (ref instanceof _fields__WEBPACK_IMPORTED_MODULE_0__[\"Reference\"]) {\n        return this.table[ref.index - 1];\n      }\n\n      return ref;\n    }\n  }]);\n\n  return ReferenceFixer;\n}();\n\n\n\n//# sourceURL=webpack:///./src/squeak/reference-fixer.js?");

/***/ }),

/***/ "./src/squeak/type-iterator.js":
/*!*************************************!*\
  !*** ./src/squeak/type-iterator.js ***!
  \*************************************/
/*! exports provided: TypeIterator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TypeIterator\", function() { return TypeIterator; });\n/* harmony import */ var _fields__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fields */ \"./src/squeak/fields.js\");\n/* harmony import */ var _field_object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./field-object */ \"./src/squeak/field-object.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ \"./src/squeak/types.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\nvar TypeIterator =\n/*#__PURE__*/\nfunction () {\n  function TypeIterator(valueIterator) {\n    _classCallCheck(this, TypeIterator);\n\n    this.valueIterator = valueIterator;\n  }\n\n  _createClass(TypeIterator, [{\n    key: Symbol.iterator,\n    value: function value() {\n      return this;\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      var nextHeader = this.valueIterator.next();\n\n      if (nextHeader.done) {\n        return nextHeader;\n      }\n\n      var header = nextHeader.value;\n      var classId = header.classId;\n      var value = header;\n\n      if (header instanceof _fields__WEBPACK_IMPORTED_MODULE_0__[\"Header\"]) {\n        value = [];\n\n        for (var i = 0; i < header.size; i++) {\n          value.push(this.next().value);\n        }\n      }\n\n      if (_types__WEBPACK_IMPORTED_MODULE_2__[\"FIELD_OBJECT_CONTRUCTORS\"][classId] !== null || header instanceof _fields__WEBPACK_IMPORTED_MODULE_0__[\"FieldObjectHeader\"]) {\n        var _constructor = _types__WEBPACK_IMPORTED_MODULE_2__[\"FIELD_OBJECT_CONTRUCTORS\"][header.classId] || _field_object__WEBPACK_IMPORTED_MODULE_1__[\"FieldObject\"];\n\n        value = new _constructor({\n          classId: header.classId,\n          version: header.version,\n          fields: value\n        });\n      }\n\n      return {\n        value: value,\n        done: false\n      };\n    }\n  }]);\n\n  return TypeIterator;\n}();\n\n\n\n//# sourceURL=webpack:///./src/squeak/type-iterator.js?");

/***/ }),

/***/ "./src/squeak/types.js":
/*!*****************************!*\
  !*** ./src/squeak/types.js ***!
  \*****************************/
/*! exports provided: PointData, RectangleData, ImageData, StageData, SpriteData, TextDetailsData, ImageMediaData, UncompressedData, SoundMediaData, ListWatcherData, AlignmentData, MorphData, StaticStringData, UpdatingStringData, WatcherReadoutFrameData, WATCHER_MODES, WatcherData, FIELD_OBJECT_CONTRUCTORS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PointData\", function() { return PointData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RectangleData\", function() { return RectangleData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImageData\", function() { return ImageData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StageData\", function() { return StageData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SpriteData\", function() { return SpriteData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextDetailsData\", function() { return TextDetailsData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImageMediaData\", function() { return ImageMediaData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UncompressedData\", function() { return UncompressedData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SoundMediaData\", function() { return SoundMediaData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ListWatcherData\", function() { return ListWatcherData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AlignmentData\", function() { return AlignmentData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MorphData\", function() { return MorphData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StaticStringData\", function() { return StaticStringData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UpdatingStringData\", function() { return UpdatingStringData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WatcherReadoutFrameData\", function() { return WatcherReadoutFrameData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WATCHER_MODES\", function() { return WATCHER_MODES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WatcherData\", function() { return WatcherData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FIELD_OBJECT_CONTRUCTORS\", function() { return FIELD_OBJECT_CONTRUCTORS; });\n/* harmony import */ var _coders_crc32__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../coders/crc32 */ \"./src/coders/crc32.js\");\n/* harmony import */ var _coders_squeak_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../coders/squeak-image */ \"./src/coders/squeak-image.js\");\n/* harmony import */ var _coders_squeak_sound__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../coders/squeak-sound */ \"./src/coders/squeak-sound.js\");\n/* harmony import */ var _coders_wav_file__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../coders/wav-file */ \"./src/coders/wav-file.js\");\n/* harmony import */ var _field_object__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./field-object */ \"./src/squeak/field-object.js\");\n/* harmony import */ var _fields__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fields */ \"./src/squeak/fields.js\");\n/* harmony import */ var _ids__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ids */ \"./src/squeak/ids.js\");\n/* harmony import */ var js_md5__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! js-md5 */ \"./node_modules/js-md5/src/md5.js\");\n/* harmony import */ var js_md5__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(js_md5__WEBPACK_IMPORTED_MODULE_7__);\nvar _FIELD_OBJECT_CONTRUC;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\n\n\n\n\n\n\n\n\n/**\n * @extends FieldObject\n */\n\nvar PointData =\n/*#__PURE__*/\nfunction (_FieldObject$define) {\n  _inherits(PointData, _FieldObject$define);\n\n  function PointData() {\n    _classCallCheck(this, PointData);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PointData).apply(this, arguments));\n  }\n\n  return PointData;\n}(_field_object__WEBPACK_IMPORTED_MODULE_4__[\"FieldObject\"].define({\n  /**\n   * @memberof PointData#\n   * @type {Value}\n   */\n  X: 0,\n\n  /**\n   * @memberof PointData#\n   * @type {Value}\n   */\n  Y: 1\n}));\n\n\n\nvar RectangleData =\n/*#__PURE__*/\nfunction (_FieldObject$define2) {\n  _inherits(RectangleData, _FieldObject$define2);\n\n  function RectangleData() {\n    _classCallCheck(this, RectangleData);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(RectangleData).apply(this, arguments));\n  }\n\n  _createClass(RectangleData, [{\n    key: \"width\",\n    get: function get() {\n      return this.x2 - this.x;\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.y2 - this.y;\n    }\n  }]);\n\n  return RectangleData;\n}(_field_object__WEBPACK_IMPORTED_MODULE_4__[\"FieldObject\"].define({\n  X: 0,\n  Y: 1,\n  X2: 2,\n  Y2: 3\n}));\n\n\n\nvar _bgra2rgbaInPlace = function _bgra2rgbaInPlace(uint8a) {\n  for (var i = 0; i < uint8a.length; i += 4) {\n    var r = uint8a[i + 2];\n    var b = uint8a[i + 0];\n    uint8a[i + 2] = b;\n    uint8a[i + 0] = r;\n  }\n\n  return uint8a;\n};\n/**\n * @extends FieldObject\n */\n\n\nvar ImageData =\n/*#__PURE__*/\nfunction (_FieldObject$define3) {\n  _inherits(ImageData, _FieldObject$define3);\n\n  function ImageData() {\n    _classCallCheck(this, ImageData);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ImageData).apply(this, arguments));\n  }\n\n  _createClass(ImageData, [{\n    key: \"decoded\",\n\n    /**\n     * @type {Uint8Array}\n     */\n    get: function get() {\n      if (!this._decoded) {\n        this._decoded = _bgra2rgbaInPlace(new Uint8Array(new _coders_squeak_image__WEBPACK_IMPORTED_MODULE_1__[\"SqueakImage\"]().decode(this.width.value, this.height.value, this.depth.value, this.bytes.value, this.colormap && this.colormap.map(function (color) {\n          return color.valueOf();\n        })).buffer));\n      }\n\n      return this._decoded;\n    }\n    /**\n     * @type {string}\n     */\n\n  }, {\n    key: \"extension\",\n    get: function get() {\n      return 'uncompressed';\n    }\n  }]);\n\n  return ImageData;\n}(_field_object__WEBPACK_IMPORTED_MODULE_4__[\"FieldObject\"].define({\n  /**\n   * @memberof ImageData#\n   * @type {Value}\n   */\n  WIDTH: 0,\n\n  /**\n   * @memberof ImageData#\n   * @type {Value}\n   */\n  HEIGHT: 1,\n\n  /**\n   * @memberof ImageData#\n   * @type {Value}\n   */\n  DEPTH: 2,\n\n  /**\n   * @memberof ImageData#\n   * @type {Value}\n   */\n  BYTES: 4,\n\n  /**\n   * @memberof ImageData#\n   * @type {Value}\n   */\n  COLORMAP: 5\n}));\n\n\n\nvar StageData =\n/*#__PURE__*/\nfunction (_FieldObject$define4) {\n  _inherits(StageData, _FieldObject$define4);\n\n  function StageData() {\n    _classCallCheck(this, StageData);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(StageData).apply(this, arguments));\n  }\n\n  _createClass(StageData, [{\n    key: \"spriteOrderInLibrary\",\n    get: function get() {\n      return this.fields[this.FIELDS.SPRITE_ORDER_IN_LIBRARY] || null;\n    }\n  }, {\n    key: \"tempoBPM\",\n    get: function get() {\n      return this.fields[this.FIELDS.TEMPO_BPM] || 0;\n    }\n  }, {\n    key: \"lists\",\n    get: function get() {\n      return this.fields[this.FIELDS.LISTS] || [];\n    }\n  }]);\n\n  return StageData;\n}(_field_object__WEBPACK_IMPORTED_MODULE_4__[\"FieldObject\"].define({\n  STAGE_CONTENTS: 2,\n  OBJ_NAME: 6,\n  VARS: 7,\n  BLOCKS_BIN: 8,\n  IS_CLONE: 9,\n  MEDIA: 10,\n  CURRENT_COSTUME: 11,\n  ZOOM: 12,\n  H_PAN: 13,\n  V_PAN: 14,\n  OBSOLETE_SAVED_STATE: 15,\n  SPRITE_ORDER_IN_LIBRARY: 16,\n  VOLUME: 17,\n  TEMPO_BPM: 18,\n  SCENE_STATES: 19,\n  LISTS: 20\n}));\n\n\n\nvar SpriteData =\n/*#__PURE__*/\nfunction (_FieldObject$define5) {\n  _inherits(SpriteData, _FieldObject$define5);\n\n  function SpriteData() {\n    _classCallCheck(this, SpriteData);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SpriteData).apply(this, arguments));\n  }\n\n  _createClass(SpriteData, [{\n    key: \"scratchX\",\n    get: function get() {\n      return this.box.x + this.currentCostume.rotationCenter.x - 240;\n    }\n  }, {\n    key: \"scratchY\",\n    get: function get() {\n      return 180 - (this.box.y + this.currentCostume.rotationCenter.y);\n    }\n  }, {\n    key: \"visible\",\n    get: function get() {\n      return (this.fields[this.FIELDS.VISIBLE] & 1) === 0;\n    }\n  }, {\n    key: \"tempoBPM\",\n    get: function get() {\n      return this.fields[this.FIELDS.TEMPO_BPM] || 0;\n    }\n  }, {\n    key: \"lists\",\n    get: function get() {\n      return this.fields[this.FIELDS.LISTS] || [];\n    }\n  }]);\n\n  return SpriteData;\n}(_field_object__WEBPACK_IMPORTED_MODULE_4__[\"FieldObject\"].define({\n  BOX: 0,\n  PARENT: 1,\n  COLOR: 3,\n  VISIBLE: 4,\n  OBJ_NAME: 6,\n  VARS: 7,\n  BLOCKS_BIN: 8,\n  IS_CLONE: 9,\n  MEDIA: 10,\n  CURRENT_COSTUME: 11,\n  VISIBILITY: 12,\n  SCALE_POINT: 13,\n  ROTATION_DEGREES: 14,\n  ROTATION_STYLE: 15,\n  VOLUME: 16,\n  TEMPO_BPM: 17,\n  DRAGGABLE: 18,\n  SCENE_STATES: 19,\n  LISTS: 20\n}));\n\n\n\nvar TextDetailsData =\n/*#__PURE__*/\nfunction (_FieldObject$define6) {\n  _inherits(TextDetailsData, _FieldObject$define6);\n\n  function TextDetailsData() {\n    _classCallCheck(this, TextDetailsData);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(TextDetailsData).apply(this, arguments));\n  }\n\n  return TextDetailsData;\n}(_field_object__WEBPACK_IMPORTED_MODULE_4__[\"FieldObject\"].define({\n  RECTANGLE: 0,\n  FONT: 8,\n  COLOR: 9,\n  LINES: 11\n}));\n\n\n\nvar ImageMediaData =\n/*#__PURE__*/\nfunction (_FieldObject$define7) {\n  _inherits(ImageMediaData, _FieldObject$define7);\n\n  function ImageMediaData() {\n    _classCallCheck(this, ImageMediaData);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ImageMediaData).apply(this, arguments));\n  }\n\n  _createClass(ImageMediaData, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"ImageMediaData \\\"\".concat(this.costumeName, \"\\\"\");\n    }\n  }, {\n    key: \"image\",\n    get: function get() {\n      if (this.oldComposite instanceof ImageData) {\n        return this.oldComposite;\n      }\n\n      if (this.baseLayerData.value) {\n        return null;\n      }\n\n      return this.bitmap;\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      if (this.image === null) {\n        return -1;\n      }\n\n      return this.image.width;\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      if (this.image === null) {\n        return -1;\n      }\n\n      return this.image.height;\n    }\n  }, {\n    key: \"rawBytes\",\n    get: function get() {\n      if (this.image === null) {\n        return this.baseLayerData.value.slice();\n      }\n\n      return this.image.bytes.value;\n    }\n  }, {\n    key: \"decoded\",\n    get: function get() {\n      if (this.image === null) {\n        return this.baseLayerData.value.slice();\n      }\n\n      return this.image.decoded;\n    }\n  }, {\n    key: \"crc\",\n    get: function get() {\n      if (!this._crc) {\n        var crc = new _coders_crc32__WEBPACK_IMPORTED_MODULE_0__[\"CRC32\"]().update(new Uint8Array(new Uint32Array([this.bitmap.width]).buffer)).update(new Uint8Array(new Uint32Array([this.bitmap.height]).buffer)).update(new Uint8Array(new Uint32Array([this.bitmap.depth]).buffer)).update(this.rawBytes);\n        this._crc = crc.digest;\n      }\n\n      return this._crc;\n    }\n  }, {\n    key: \"extension\",\n    get: function get() {\n      if (this.oldComposite instanceof ImageData) return 'uncompressed';\n      if (this.baseLayerData.value) return 'jpg';\n      return 'uncompressed';\n    }\n  }]);\n\n  return ImageMediaData;\n}(_field_object__WEBPACK_IMPORTED_MODULE_4__[\"FieldObject\"].define({\n  COSTUME_NAME: 0,\n  BITMAP: 1,\n  ROTATION_CENTER: 2,\n  TEXT_DETAILS: 3,\n  BASE_LAYER_DATA: 4,\n  OLD_COMPOSITE: 5\n}));\n\n\n\nvar UncompressedData =\n/*#__PURE__*/\nfunction (_FieldObject$define8) {\n  _inherits(UncompressedData, _FieldObject$define8);\n\n  function UncompressedData() {\n    _classCallCheck(this, UncompressedData);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(UncompressedData).apply(this, arguments));\n  }\n\n  return UncompressedData;\n}(_field_object__WEBPACK_IMPORTED_MODULE_4__[\"FieldObject\"].define({\n  DATA: 3,\n  RATE: 4\n}));\n\n\n\nvar reverseBytes16 = function reverseBytes16(input) {\n  var uint8a = new Uint8Array(input);\n\n  for (var i = 0; i < uint8a.length; i += 2) {\n    uint8a[i] = input[i + 1];\n    uint8a[i + 1] = input[i];\n  }\n\n  return uint8a;\n};\n\nvar SoundMediaData =\n/*#__PURE__*/\nfunction (_FieldObject$define9) {\n  _inherits(SoundMediaData, _FieldObject$define9);\n\n  function SoundMediaData() {\n    _classCallCheck(this, SoundMediaData);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SoundMediaData).apply(this, arguments));\n  }\n\n  _createClass(SoundMediaData, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"SoundMediaData \\\"\".concat(this.name, \"\\\"\");\n    }\n  }, {\n    key: \"rate\",\n    get: function get() {\n      if (this.uncompressed.data.value.length !== 0) {\n        return this.uncompressed.rate;\n      }\n\n      return this.fields[this.FIELDS.RATE];\n    }\n  }, {\n    key: \"rawBytes\",\n    get: function get() {\n      if (this.data && this.data.value) {\n        return this.data.value;\n      }\n\n      return this.uncompressed.data.value;\n    }\n  }, {\n    key: \"decoded\",\n    get: function get() {\n      if (!this._decoded) {\n        if (this.data && this.data.value) {\n          this._decoded = new _coders_squeak_sound__WEBPACK_IMPORTED_MODULE_2__[\"SqueakSound\"](this.bitsPerSample.value).decode(this.data.value);\n        } else {\n          this._decoded = new Int16Array(reverseBytes16(this.uncompressed.data.value.slice()).buffer);\n        }\n      }\n\n      return this._decoded;\n    }\n  }, {\n    key: \"crc\",\n    get: function get() {\n      if (!this._crc) {\n        this._crc = new _coders_crc32__WEBPACK_IMPORTED_MODULE_0__[\"CRC32\"]().update(new Uint32Array([this.rate])).update(this.rawBytes).digest;\n      }\n\n      return this._crc;\n    }\n  }, {\n    key: \"sampleCount\",\n    get: function get() {\n      if (this.data && this.data.value) {\n        return _coders_squeak_sound__WEBPACK_IMPORTED_MODULE_2__[\"SqueakSound\"].samples(this.bitsPerSample.value, this.data.value);\n      }\n\n      return this.uncompressed.data.value.length / 2;\n    }\n  }, {\n    key: \"extension\",\n    get: function get() {\n      return 'pcm';\n    }\n  }, {\n    key: \"wavEncodedData\",\n    get: function get() {\n      if (!this._wavEncodedData) {\n        this._wavEncodedData = new Uint8Array(_coders_wav_file__WEBPACK_IMPORTED_MODULE_3__[\"WAVFile\"].encode(this.decoded, {\n          sampleRate: this.rate && this.rate.value\n        }));\n      }\n\n      return this._wavEncodedData;\n    }\n  }, {\n    key: \"md5\",\n    get: function get() {\n      if (!this._md5) {\n        this._md5 = js_md5__WEBPACK_IMPORTED_MODULE_7___default()(this.wavEncodedData);\n      }\n\n      return this._md5;\n    }\n  }]);\n\n  return SoundMediaData;\n}(_field_object__WEBPACK_IMPORTED_MODULE_4__[\"FieldObject\"].define({\n  NAME: 0,\n  UNCOMPRESSED: 1,\n  RATE: 4,\n  BITS_PER_SAMPLE: 5,\n  DATA: 6\n}));\n\n\n\nvar ListWatcherData =\n/*#__PURE__*/\nfunction (_FieldObject$define10) {\n  _inherits(ListWatcherData, _FieldObject$define10);\n\n  function ListWatcherData() {\n    _classCallCheck(this, ListWatcherData);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ListWatcherData).apply(this, arguments));\n  }\n\n  _createClass(ListWatcherData, [{\n    key: \"x\",\n    get: function get() {\n      if (Object(_fields__WEBPACK_IMPORTED_MODULE_5__[\"value\"])(this.hiddenWhenNull) === null) return 5;\n      return this.box.x + 1;\n    }\n  }, {\n    key: \"y\",\n    get: function get() {\n      if (Object(_fields__WEBPACK_IMPORTED_MODULE_5__[\"value\"])(this.hiddenWhenNull) === null) return 5;\n      return this.box.y + 1;\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return this.box.width - 2;\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.box.height - 2;\n    }\n  }]);\n\n  return ListWatcherData;\n}(_field_object__WEBPACK_IMPORTED_MODULE_4__[\"FieldObject\"].define({\n  BOX: 0,\n  HIDDEN_WHEN_NULL: 1,\n  LIST_NAME: 8,\n  CONTENTS: 9,\n  TARGET: 10\n}));\n\n\n\nvar AlignmentData =\n/*#__PURE__*/\nfunction (_FieldObject$define11) {\n  _inherits(AlignmentData, _FieldObject$define11);\n\n  function AlignmentData() {\n    _classCallCheck(this, AlignmentData);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(AlignmentData).apply(this, arguments));\n  }\n\n  return AlignmentData;\n}(_field_object__WEBPACK_IMPORTED_MODULE_4__[\"FieldObject\"].define({\n  BOX: 0,\n  PARENT: 1,\n  FRAMES: 2,\n  COLOR: 3,\n  DIRECTION: 8,\n  ALIGNMENT: 9\n}));\n\n\n\nvar MorphData =\n/*#__PURE__*/\nfunction (_FieldObject$define12) {\n  _inherits(MorphData, _FieldObject$define12);\n\n  function MorphData() {\n    _classCallCheck(this, MorphData);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MorphData).apply(this, arguments));\n  }\n\n  return MorphData;\n}(_field_object__WEBPACK_IMPORTED_MODULE_4__[\"FieldObject\"].define({\n  BOX: 0,\n  PARENT: 1,\n  COLOR: 3\n}));\n\n\n\nvar StaticStringData =\n/*#__PURE__*/\nfunction (_FieldObject$define13) {\n  _inherits(StaticStringData, _FieldObject$define13);\n\n  function StaticStringData() {\n    _classCallCheck(this, StaticStringData);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(StaticStringData).apply(this, arguments));\n  }\n\n  return StaticStringData;\n}(_field_object__WEBPACK_IMPORTED_MODULE_4__[\"FieldObject\"].define({\n  BOX: 0,\n  COLOR: 3,\n  VALUE: 8\n}));\n\n\n\nvar UpdatingStringData =\n/*#__PURE__*/\nfunction (_FieldObject$define14) {\n  _inherits(UpdatingStringData, _FieldObject$define14);\n\n  function UpdatingStringData() {\n    _classCallCheck(this, UpdatingStringData);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(UpdatingStringData).apply(this, arguments));\n  }\n\n  return UpdatingStringData;\n}(_field_object__WEBPACK_IMPORTED_MODULE_4__[\"FieldObject\"].define({\n  BOX: 0,\n  READOUT_FRAME: 1,\n  COLOR: 3,\n  FONT: 6,\n  VALUE: 8,\n  TARGET: 10,\n  CMD: 11,\n  PARAM: 13\n}));\n\n\n\nvar WatcherReadoutFrameData =\n/*#__PURE__*/\nfunction (_FieldObject$define15) {\n  _inherits(WatcherReadoutFrameData, _FieldObject$define15);\n\n  function WatcherReadoutFrameData() {\n    _classCallCheck(this, WatcherReadoutFrameData);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(WatcherReadoutFrameData).apply(this, arguments));\n  }\n\n  return WatcherReadoutFrameData;\n}(_field_object__WEBPACK_IMPORTED_MODULE_4__[\"FieldObject\"].define({\n  BOX: 0\n}));\n\n\nvar WATCHER_MODES = {\n  NORMAL: 1,\n  LARGE: 2,\n  SLIDER: 3,\n  TEXT: 4\n};\n\n\nvar WatcherData =\n/*#__PURE__*/\nfunction (_FieldObject$define16) {\n  _inherits(WatcherData, _FieldObject$define16);\n\n  function WatcherData() {\n    _classCallCheck(this, WatcherData);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(WatcherData).apply(this, arguments));\n  }\n\n  _createClass(WatcherData, [{\n    key: \"x\",\n    get: function get() {\n      return this.box.x;\n    }\n  }, {\n    key: \"y\",\n    get: function get() {\n      return this.box.y;\n    }\n  }, {\n    key: \"mode\",\n    get: function get() {\n      if (Object(_fields__WEBPACK_IMPORTED_MODULE_5__[\"value\"])(this.slider) === null) {\n        if (this.readoutFrame.box.height <= 14) {\n          return WATCHER_MODES.NORMAL;\n        }\n\n        return WATCHER_MODES.LARGE;\n      }\n\n      return WATCHER_MODES.SLIDER;\n    }\n  }, {\n    key: \"isDiscrete\",\n    get: function get() {\n      return Math.floor(this.sliderMin) === this.sliderMin && Math.floor(this.sliderMax) === this.sliderMax && Math.floor(this.readout.value) === this.readout.value;\n    }\n  }]);\n\n  return WatcherData;\n}(_field_object__WEBPACK_IMPORTED_MODULE_4__[\"FieldObject\"].define({\n  BOX: 0,\n  TARGET: 1,\n  SHAPE: 2,\n  READOUT: 14,\n  READOUT_FRAME: 15,\n  SLIDER: 16,\n  ALIGNMENT: 17,\n  SLIDER_MIN: 20,\n  SLIDER_MAX: 21\n}));\n\n\nvar FIELD_OBJECT_CONTRUCTOR_PROTOS = (_FIELD_OBJECT_CONTRUC = {}, _defineProperty(_FIELD_OBJECT_CONTRUC, _ids__WEBPACK_IMPORTED_MODULE_6__[\"TYPES\"].POINT, PointData), _defineProperty(_FIELD_OBJECT_CONTRUC, _ids__WEBPACK_IMPORTED_MODULE_6__[\"TYPES\"].RECTANGLE, RectangleData), _defineProperty(_FIELD_OBJECT_CONTRUC, _ids__WEBPACK_IMPORTED_MODULE_6__[\"TYPES\"].FORM, ImageData), _defineProperty(_FIELD_OBJECT_CONTRUC, _ids__WEBPACK_IMPORTED_MODULE_6__[\"TYPES\"].SQUEAK, ImageData), _defineProperty(_FIELD_OBJECT_CONTRUC, _ids__WEBPACK_IMPORTED_MODULE_6__[\"TYPES\"].SAMPLED_SOUND, UncompressedData), _defineProperty(_FIELD_OBJECT_CONTRUC, _ids__WEBPACK_IMPORTED_MODULE_6__[\"TYPES\"].SPRITE, SpriteData), _defineProperty(_FIELD_OBJECT_CONTRUC, _ids__WEBPACK_IMPORTED_MODULE_6__[\"TYPES\"].STAGE, StageData), _defineProperty(_FIELD_OBJECT_CONTRUC, _ids__WEBPACK_IMPORTED_MODULE_6__[\"TYPES\"].IMAGE_MEDIA, ImageMediaData), _defineProperty(_FIELD_OBJECT_CONTRUC, _ids__WEBPACK_IMPORTED_MODULE_6__[\"TYPES\"].SOUND_MEDIA, SoundMediaData), _defineProperty(_FIELD_OBJECT_CONTRUC, _ids__WEBPACK_IMPORTED_MODULE_6__[\"TYPES\"].ALIGNMENT, AlignmentData), _defineProperty(_FIELD_OBJECT_CONTRUC, _ids__WEBPACK_IMPORTED_MODULE_6__[\"TYPES\"].MORPH, MorphData), _defineProperty(_FIELD_OBJECT_CONTRUC, _ids__WEBPACK_IMPORTED_MODULE_6__[\"TYPES\"].WATCHER_READOUT_FRAME, WatcherReadoutFrameData), _defineProperty(_FIELD_OBJECT_CONTRUC, _ids__WEBPACK_IMPORTED_MODULE_6__[\"TYPES\"].STATIC_STRING, StaticStringData), _defineProperty(_FIELD_OBJECT_CONTRUC, _ids__WEBPACK_IMPORTED_MODULE_6__[\"TYPES\"].UPDATING_STRING, UpdatingStringData), _defineProperty(_FIELD_OBJECT_CONTRUC, _ids__WEBPACK_IMPORTED_MODULE_6__[\"TYPES\"].WATCHER, WatcherData), _defineProperty(_FIELD_OBJECT_CONTRUC, _ids__WEBPACK_IMPORTED_MODULE_6__[\"TYPES\"].LIST_WATCHER, ListWatcherData), _FIELD_OBJECT_CONTRUC);\nvar FIELD_OBJECT_CONTRUCTORS = Array.from({\n  length: 256\n}, function (_, i) {\n  return FIELD_OBJECT_CONTRUCTOR_PROTOS[i] || null;\n});\n\n\n//# sourceURL=webpack:///./src/squeak/types.js?");

/***/ }),

/***/ "./src/to-sb2/fake-zip.js":
/*!********************************!*\
  !*** ./src/to-sb2/fake-zip.js ***!
  \********************************/
/*! exports provided: FakeZipFile, FakeZip, toSb2FakeZipApi */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FakeZipFile\", function() { return FakeZipFile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FakeZip\", function() { return FakeZip; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toSb2FakeZipApi\", function() { return toSb2FakeZipApi; });\n/* harmony import */ var _util_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/assert */ \"./src/util/assert.js\");\n/* harmony import */ var _coders_png_file__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../coders/png-file */ \"./src/coders/png-file.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\nvar FakeZipFile =\n/*#__PURE__*/\nfunction () {\n  function FakeZipFile(file) {\n    _classCallCheck(this, FakeZipFile);\n\n    this.file = file;\n  }\n\n  _createClass(FakeZipFile, [{\n    key: \"async\",\n    value: function async(outputType) {\n      Object(_util_assert__WEBPACK_IMPORTED_MODULE_0__[\"assert\"])(outputType === 'uint8array', 'SB1FakeZipFile only supports uint8array');\n      return Promise.resolve(this.file.bytes);\n    }\n  }]);\n\n  return FakeZipFile;\n}();\n\n\n\nvar FakeZip =\n/*#__PURE__*/\nfunction () {\n  function FakeZip(files) {\n    _classCallCheck(this, FakeZip);\n\n    this.files = files;\n  }\n\n  _createClass(FakeZip, [{\n    key: \"file\",\n    value: function file(_file) {\n      if (_file in this.files) {\n        return new FakeZipFile(this.files[_file]);\n      }\n    }\n  }]);\n\n  return FakeZip;\n}();\n\n\n\nvar toSb2ImageExtension = function toSb2ImageExtension(imageMedia) {\n  if (imageMedia.extension === 'uncompressed') {\n    return 'png';\n  }\n\n  return 'jpg';\n};\n\nvar toSb2ImageMedia = function toSb2ImageMedia(imageMedia) {\n  if (imageMedia.extension === 'uncompressed') {\n    return new Uint8Array(_coders_png_file__WEBPACK_IMPORTED_MODULE_1__[\"PNGFile\"].encode(imageMedia.width, imageMedia.height, imageMedia.decoded));\n  }\n\n  return imageMedia.decoded;\n};\n\nvar toSb2SoundMedia = function toSb2SoundMedia(soundMedia) {\n  return soundMedia.wavEncodedData;\n};\n\nvar toSb2FakeZipApi = function toSb2FakeZipApi(_ref) {\n  var images = _ref.images,\n      sounds = _ref.sounds;\n  var files = {};\n  var index = 0;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = images[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var image = _step.value;\n      files[\"\".concat(index++, \".\").concat(toSb2ImageExtension(image))] = {\n        bytes: toSb2ImageMedia(image)\n      };\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  index = 0;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = sounds[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var sound = _step2.value;\n      files[\"\".concat(index++, \".wav\")] = {\n        bytes: toSb2SoundMedia(sound)\n      };\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return new FakeZip(files);\n};\n\n\n\n//# sourceURL=webpack:///./src/to-sb2/fake-zip.js?");

/***/ }),

/***/ "./src/to-sb2/json-generator.js":
/*!**************************************!*\
  !*** ./src/to-sb2/json-generator.js ***!
  \**************************************/
/*! exports provided: toSb2Json */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toSb2Json\", function() { return toSb2Json; });\n/* harmony import */ var _squeak_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../squeak/types */ \"./src/squeak/types.js\");\n/* harmony import */ var js_md5__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js-md5 */ \"./node_modules/js-md5/src/md5.js\");\n/* harmony import */ var js_md5__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(js_md5__WEBPACK_IMPORTED_MODULE_1__);\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/* eslint no-use-before-define:1 */\n\n // https://github.com/LLK/scratch-flash/blob/cb5f42f039ef633710faf9c63b69e8368b280372/src/blocks/BlockIO.as#L292-L308\n\nvar fixMouseEdgeRef = function fixMouseEdgeRef(block) {\n  var oldVal = String(block[block.length - 1]);\n  var last = block.length - 1;\n\n  if (oldVal === 'mouse') {\n    block[last] = '_mouse_';\n  } else if (oldVal === 'edge') {\n    block[last] = '_edge_';\n  } else if (block[block.length - 1] instanceof _squeak_types__WEBPACK_IMPORTED_MODULE_0__[\"StageData\"]) {\n    block[last] = '_stage_';\n  }\n\n  return block;\n};\n\nvar sb1SpecMap = {\n  // https://github.com/LLK/scratch-flash/blob/cb5f42f039ef633710faf9c63b69e8368b280372/src/blocks/BlockIO.as#L197-L199\n  'getParam': function getParam(_ref) {\n    var _ref2 = _slicedToArray(_ref, 4),\n        a = _ref2[0],\n        b = _ref2[1],\n        c = _ref2[2],\n        d = _ref2[3];\n\n    return [a, b, c, d || 'r'];\n  },\n  // https://github.com/LLK/scratch-flash/blob/cb5f42f039ef633710faf9c63b69e8368b280372/src/blocks/BlockIO.as#L200-L212\n  'changeVariable': function changeVariable(block) {\n    return [block[2], block[1], block[3]];\n  },\n  // https://github.com/LLK/scratch-flash/blob/cb5f42f039ef633710faf9c63b69e8368b280372/src/blocks/BlockIO.as#L213-L219\n  'EventHatMorph': function EventHatMorph(block) {\n    if (String(block[1]) === 'Scratch-StartClicked') {\n      return ['whenGreenFlag'];\n    }\n\n    return ['whenIReceive', block[1]];\n  },\n  // https://github.com/LLK/scratch-flash/blob/cb5f42f039ef633710faf9c63b69e8368b280372/src/blocks/BlockIO.as#L220-L222\n  'MouseClickEventHatMorph': function MouseClickEventHatMorph() {\n    return ['whenClicked'];\n  },\n  // https://github.com/LLK/scratch-flash/blob/cb5f42f039ef633710faf9c63b69e8368b280372/src/blocks/BlockIO.as#L223-L226\n  'KeyEventHatMorph': function KeyEventHatMorph(block) {\n    return ['whenKeyPressed', block[1]];\n  },\n  // https://github.com/LLK/scratch-flash/blob/cb5f42f039ef633710faf9c63b69e8368b280372/src/blocks/BlockIO.as#L227-L235\n  'stopScripts': function stopScripts(block) {\n    if (String(block[1]) === 'other scripts') {\n      return [block[0], 'other scripts in sprite'];\n    }\n\n    return block;\n  },\n  // https://github.com/LLK/scratch-flash/blob/cb5f42f039ef633710faf9c63b69e8368b280372/src/blocks/BlockIO.as#L249-L253\n  'abs': function abs(block) {\n    return ['computeFunction:of:', 'abs', block[1]];\n  },\n  // https://github.com/LLK/scratch-flash/blob/cb5f42f039ef633710faf9c63b69e8368b280372/src/blocks/BlockIO.as#L254-L258\n  'sqrt': function sqrt(block) {\n    return ['computeFunction:of:', 'sqrt', block[1]];\n  },\n  // https://github.com/LLK/scratch-flash/blob/cb5f42f039ef633710faf9c63b69e8368b280372/src/blocks/BlockIO.as#L137\n  '\\\\\\\\': function _(block) {\n    return ['%'].concat(_toConsumableArray(block.slice(1)));\n  },\n  // https://github.com/LLK/scratch-flash/blob/cb5f42f039ef633710faf9c63b69e8368b280372/src/blocks/BlockIO.as#L259-L262\n  'doReturn': function doReturn() {\n    return ['stopScripts', 'this script'];\n  },\n  // https://github.com/LLK/scratch-flash/blob/cb5f42f039ef633710faf9c63b69e8368b280372/src/blocks/BlockIO.as#L263-L266\n  'stopAll': function stopAll() {\n    return ['stopScripts', 'all'];\n  },\n  // https://github.com/LLK/scratch-flash/blob/cb5f42f039ef633710faf9c63b69e8368b280372/src/blocks/BlockIO.as#L267-L270\n  'showBackground:': function showBackground(block) {\n    return ['startScene', block[1]];\n  },\n  // https://github.com/LLK/scratch-flash/blob/cb5f42f039ef633710faf9c63b69e8368b280372/src/blocks/BlockIO.as#L271-L273\n  'nextBackground': function nextBackground() {\n    return ['nextScene'];\n  },\n  // https://github.com/LLK/scratch-flash/blob/cb5f42f039ef633710faf9c63b69e8368b280372/src/blocks/BlockIO.as#L274-L282\n  'doForeverIf': function doForeverIf(block) {\n    return ['doForever', [['doIf', block[1], block[2]]]];\n  },\n  'getAttribute:of:': fixMouseEdgeRef,\n  'gotoSpriteOrMouse:': fixMouseEdgeRef,\n  'distanceTo:': fixMouseEdgeRef,\n  'pointTowards:': fixMouseEdgeRef,\n  'touching:': fixMouseEdgeRef\n};\n\nvar valueOf = function valueOf(obj) {\n  if (_typeof(obj) === 'object' && obj) return obj.valueOf();\n  return obj;\n};\n\nvar toSb2Json = function toSb2Json(root) {\n  var info = root.info,\n      stageData = root.stageData,\n      images = root.images,\n      sounds = root.sounds;\n\n  var pairs = function pairs(array) {\n    var _pairs = [];\n\n    for (var i = 0; i < array.length; i += 2) {\n      _pairs.push([array[i], array[i + 1]]);\n    }\n\n    return _pairs;\n  };\n\n  var toSb2JsonVariable = function toSb2JsonVariable(_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        name = _ref4[0],\n        value = _ref4[1];\n\n    return {\n      name: name,\n      value: value,\n      isPersistent: false\n    };\n  };\n\n  var toSb2JsonList = function toSb2JsonList(_ref5) {\n    var _ref6 = _slicedToArray(_ref5, 2),\n        _ref6$ = _ref6[1],\n        listName = _ref6$.listName,\n        contents = _ref6$.contents,\n        x = _ref6$.x,\n        y = _ref6$.y,\n        width = _ref6$.width,\n        height = _ref6$.height,\n        hiddenWhenNull = _ref6$.hiddenWhenNull;\n\n    return {\n      listName: listName,\n      contents: contents,\n      isPersistent: false,\n      x: x,\n      y: y,\n      width: width,\n      height: height,\n      visible: valueOf(hiddenWhenNull) !== null\n    };\n  }; // TODO: Implement toSb2JsonWatcher\n  // const toSb2JsonWatcher = watcher => {\n  //\n  // };\n  // TODO: Implement toSb2JsonListWatcher\n  // const toSb2JsonListWatcher = listWatcher => {\n  //\n  // };\n\n\n  var toSb2JsonSound = function toSb2JsonSound(soundMediaData) {\n    var soundID = sounds.findIndex(function (sound) {\n      return sound.crc === soundMediaData.crc;\n    });\n    return {\n      soundName: soundMediaData.name,\n      soundID: soundID,\n      md5: \"\".concat(soundMediaData.md5, \".wav\"),\n      sampleCount: soundMediaData.sampleCount,\n      rate: soundMediaData.rate,\n      format: ''\n    };\n  };\n\n  var toSb2ImageExtension = function toSb2ImageExtension(imageMedia) {\n    if (imageMedia.extension === 'uncompressed') {\n      return 'png';\n    }\n\n    return 'jpg';\n  };\n\n  var toSb2JsonCostume = function toSb2JsonCostume(imageMediaData) {\n    var baseLayerID = images.findIndex(function (image) {\n      return image.crc === imageMediaData.crc;\n    });\n    return {\n      costumeName: imageMediaData.costumeName,\n      baseLayerID: baseLayerID,\n      baseLayerMD5: \"\".concat(js_md5__WEBPACK_IMPORTED_MODULE_1___default()(imageMediaData.rawBytes), \".\").concat(toSb2ImageExtension(imageMediaData)),\n      bitmapResolution: 1,\n      rotationCenterX: imageMediaData.rotationCenter.x,\n      rotationCenterY: imageMediaData.rotationCenter.y\n    };\n  };\n\n  var toSb2JsonBlock = function toSb2JsonBlock(blockData) {\n    var output = blockData.map(toSb2JsonBlockArg);\n    var spec = sb1SpecMap[output[0]];\n\n    if (spec) {\n      output = spec(output);\n    }\n\n    return output;\n  };\n\n  var toSb2JsonStack = function toSb2JsonStack(stackData) {\n    return stackData.map(toSb2JsonBlock);\n  };\n\n  var toSb2JsonBlockArg = function toSb2JsonBlockArg(argData) {\n    if (argData instanceof _squeak_types__WEBPACK_IMPORTED_MODULE_0__[\"SpriteData\"]) {\n      return argData.objName;\n    } else if (Array.isArray(argData)) {\n      if (argData.length === 0 || Array.isArray(argData[0])) {\n        return toSb2JsonStack(argData);\n      }\n\n      return toSb2JsonBlock(argData);\n    }\n\n    return argData;\n  };\n\n  var toSb2JsonScript = function toSb2JsonScript(scriptData) {\n    return [scriptData[0].x, scriptData[0].y, toSb2JsonStack(scriptData[1])];\n  };\n\n  var toSb2JsonSprite = function toSb2JsonSprite(spriteData) {\n    var rawCostumes = spriteData.media.filter(function (data) {\n      return data instanceof _squeak_types__WEBPACK_IMPORTED_MODULE_0__[\"ImageMediaData\"];\n    });\n    var rawSounds = spriteData.media.filter(function (data) {\n      return data instanceof _squeak_types__WEBPACK_IMPORTED_MODULE_0__[\"SoundMediaData\"];\n    });\n    return {\n      objName: spriteData.objName,\n      variables: pairs(spriteData.vars).map(toSb2JsonVariable),\n      lists: pairs(spriteData.lists).map(toSb2JsonList),\n      scripts: spriteData.blocksBin.map(toSb2JsonScript),\n      costumes: rawCostumes.map(toSb2JsonCostume),\n      currentCostumeIndex: rawCostumes.findIndex(function (image) {\n        return image.crc === spriteData.currentCostume.crc;\n      }),\n      sounds: rawSounds.map(toSb2JsonSound),\n      scratchX: spriteData.scratchX,\n      scratchY: spriteData.scratchY,\n      scale: spriteData.scalePoint.x,\n      direction: Math.round(spriteData.rotationDegrees * 1e6) / 1e6 - 270,\n      rotationStyle: spriteData.rotationStyle,\n      isDraggable: spriteData.draggable,\n      indexInLibrary: stageData.spriteOrderInLibrary.indexOf(spriteData),\n      visible: spriteData.visible,\n      spriteInfo: {}\n    };\n  };\n\n  var toSb2JsonChild = function toSb2JsonChild(child) {\n    if (child instanceof _squeak_types__WEBPACK_IMPORTED_MODULE_0__[\"SpriteData\"]) {\n      return toSb2JsonSprite(child);\n    }\n\n    return null;\n  };\n\n  var toSb2JsonStage = function toSb2JsonStage(_stageData) {\n    var rawCostumes = _stageData.media.filter(function (data) {\n      return data instanceof _squeak_types__WEBPACK_IMPORTED_MODULE_0__[\"ImageMediaData\"];\n    });\n\n    var rawSounds = _stageData.media.filter(function (data) {\n      return data instanceof _squeak_types__WEBPACK_IMPORTED_MODULE_0__[\"SoundMediaData\"];\n    });\n\n    return {\n      objName: _stageData.objName,\n      variables: pairs(_stageData.vars).map(toSb2JsonVariable),\n      lists: pairs(_stageData.lists).map(toSb2JsonList),\n      scripts: _stageData.blocksBin.map(toSb2JsonScript),\n      costumes: rawCostumes.map(toSb2JsonCostume),\n      currentCostumeIndex: rawCostumes.findIndex(function (image) {\n        return image.crc === _stageData.currentCostume.crc;\n      }),\n      sounds: rawSounds.map(toSb2JsonSound),\n      // TODO: Where does this come from? Is it always the same for SB1?\n      penLayerMD5: '5c81a336fab8be57adc039a8a2b33ca9.png',\n      penLayerID: 0,\n      tempoBPM: _stageData.tempoBPM,\n      videoAlpha: 0.5,\n      children: _stageData.stageContents.map(toSb2JsonChild).filter(Boolean).reverse()\n    };\n  };\n\n  var toSb2JsonInfo = function toSb2JsonInfo(_info) {\n    var obj = {};\n\n    for (var i = 0; i < _info.length; i += 2) {\n      if (String(_info[i]) === 'thumbnail') continue;\n      obj[String(_info[i])] = String(_info[i + 1]);\n    }\n\n    return obj;\n  };\n\n  return JSON.parse(JSON.stringify(Object.assign(toSb2JsonStage(stageData), {\n    info: toSb2JsonInfo(info)\n  })));\n};\n\n\n\n//# sourceURL=webpack:///./src/to-sb2/json-generator.js?");

/***/ }),

/***/ "./src/util/assert.js":
/*!****************************!*\
  !*** ./src/util/assert.js ***!
  \****************************/
/*! exports provided: assert, AssertionError, ValidationError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assert\", function() { return assert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AssertionError\", function() { return AssertionError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidationError\", function() { return ValidationError; });\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\n * A `scratch-sb1-converter` assertion.\n */\nvar AssertionError =\n/*#__PURE__*/\nfunction (_Error) {\n  _inherits(AssertionError, _Error);\n\n  function AssertionError() {\n    _classCallCheck(this, AssertionError);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(AssertionError).apply(this, arguments));\n  }\n\n  return AssertionError;\n}(_wrapNativeSuper(Error));\n/**\n * A `scratch-sb1-converter` validation error.\n */\n\n\nvar ValidationError =\n/*#__PURE__*/\nfunction (_AssertionError) {\n  _inherits(ValidationError, _AssertionError);\n\n  function ValidationError() {\n    _classCallCheck(this, ValidationError);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ValidationError).apply(this, arguments));\n  }\n\n  return ValidationError;\n}(AssertionError);\n\nvar assert = function assert(test, message) {\n  if (!test) throw new AssertionError(message);\n};\n\nassert.validate = function (test, message) {\n  if (!test) throw new ValidationError(message);\n};\n\n\n\n//# sourceURL=webpack:///./src/util/assert.js?");

/***/ }),

/***/ "text-encoding":
/*!********************************!*\
  !*** external "text-encoding" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"text-encoding\");\n\n//# sourceURL=webpack:///external_%22text-encoding%22?");

/***/ })

/******/ });

/***/ }),

/***/ "./node_modules/scratch-svg-renderer/node_modules/base64-js/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/scratch-svg-renderer/node_modules/base64-js/index.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/scratch-svg-renderer/src/bitmap-adapter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/scratch-svg-renderer/src/bitmap-adapter.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const base64js = __webpack_require__(/*! base64-js */ "./node_modules/scratch-svg-renderer/node_modules/base64-js/index.js");

/**
 * Adapts Scratch 2.0 bitmaps for use in scratch 3.0
 */
class BitmapAdapter {
    /**
     * @param {?function} makeImage HTML image constructor. Tests can provide this.
     * @param {?function} makeCanvas HTML canvas constructor. Tests can provide this.
     */
    constructor (makeImage, makeCanvas) {
        this._makeImage = makeImage ? makeImage : () => new Image();
        this._makeCanvas = makeCanvas ? makeCanvas : () => document.createElement('canvas');
    }

    /**
     * Return a canvas with the resized version of the given image, done using nearest-neighbor interpolation
     * @param {CanvasImageSource} image The image to resize
     * @param {int} newWidth The desired post-resize width of the image
     * @param {int} newHeight The desired post-resize height of the image
     * @returns {HTMLCanvasElement} A canvas with the resized image drawn on it.
     */
    resize (image, newWidth, newHeight) {
        // We want to always resize using nearest-neighbor interpolation. However, canvas implementations are free to
        // use linear interpolation (or other "smooth" interpolation methods) when downscaling:
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1360415
        // It seems we can get around this by resizing in two steps: first width, then height. This will always result
        // in nearest-neighbor interpolation, even when downscaling.
        const stretchWidthCanvas = this._makeCanvas();
        stretchWidthCanvas.width = newWidth;
        stretchWidthCanvas.height = image.height;
        let context = stretchWidthCanvas.getContext('2d');
        context.imageSmoothingEnabled = false;
        context.drawImage(image, 0, 0, stretchWidthCanvas.width, stretchWidthCanvas.height);
        const stretchHeightCanvas = this._makeCanvas();
        stretchHeightCanvas.width = newWidth;
        stretchHeightCanvas.height = newHeight;
        context = stretchHeightCanvas.getContext('2d');
        context.imageSmoothingEnabled = false;
        context.drawImage(stretchWidthCanvas, 0, 0, stretchHeightCanvas.width, stretchHeightCanvas.height);
        return stretchHeightCanvas;
    }

    /**
     * Scratch 2.0 had resolution 1 and 2 bitmaps. All bitmaps in Scratch 3.0 are equivalent
     * to resolution 2 bitmaps. Therefore, converting a resolution 1 bitmap means doubling
     * it in width and height.
     * @param {!string} dataURI Base 64 encoded image data of the bitmap
     * @param {!function} callback Node-style callback that returns updated dataURI if conversion succeeded
     */
    convertResolution1Bitmap (dataURI, callback) {
        const image = this._makeImage();
        image.src = dataURI;
        image.onload = () => {
            callback(null, this.resize(image, image.width * 2, image.height * 2).toDataURL());
        };
        image.onerror = () => {
            callback('Image load failed');
        };
    }

    /**
     * Given width/height of an uploaded item, return width/height the image will be resized
     * to in Scratch 3.0
     * @param {!number} oldWidth original width
     * @param {!number} oldHeight original height
     * @return {object} Array of new width, new height
     */
    getResizedWidthHeight (oldWidth, oldHeight) {
        const STAGE_WIDTH = 480;
        const STAGE_HEIGHT = 360;
        const STAGE_RATIO = STAGE_WIDTH / STAGE_HEIGHT;

        // If both dimensions are smaller than or equal to corresponding stage dimension,
        // double both dimensions
        if ((oldWidth <= STAGE_WIDTH) && (oldHeight <= STAGE_HEIGHT)) {
            return {width: oldWidth * 2, height: oldHeight * 2};
        }

        // If neither dimension is larger than 2x corresponding stage dimension,
        // this is an in-between image, return it as is
        if ((oldWidth <= STAGE_WIDTH * 2) && (oldHeight <= STAGE_HEIGHT * 2)) {
            return {width: oldWidth, height: oldHeight};
        }

        const imageRatio = oldWidth / oldHeight;
        // Otherwise, figure out how to resize
        if (imageRatio >= STAGE_RATIO) {
            // Wide Image
            return {width: STAGE_WIDTH * 2, height: STAGE_WIDTH * 2 / imageRatio};
        }
        // In this case we have either:
        // - A wide image, but not with as big a ratio between width and height,
        // making it so that fitting the width to double stage size would leave
        // the height too big to fit in double the stage height
        // - A square image that's still larger than the double at least
        // one of the stage dimensions, so pick the smaller of the two dimensions (to fit)
        // - A tall image
        // In any of these cases, resize the image to fit the height to double the stage height
        return {width: STAGE_HEIGHT * 2 * imageRatio, height: STAGE_HEIGHT * 2};
    }

    /**
     * Given bitmap data, resize as necessary.
     * @param {ArrayBuffer | string} fileData Base 64 encoded image data of the bitmap
     * @param {string} fileType The MIME type of this file
     * @returns {Promise} Resolves to resized image data Uint8Array
     */
    importBitmap (fileData, fileType) {
        let dataURI = fileData;
        if (fileData instanceof ArrayBuffer) {
            dataURI = this.convertBinaryToDataURI(fileData, fileType);
        }
        return new Promise((resolve, reject) => {
            const image = this._makeImage();
            image.src = dataURI;
            image.onload = () => {
                const newSize = this.getResizedWidthHeight(image.width, image.height);
                if (newSize.width === image.width && newSize.height === image.height) {
                    // No change
                    resolve(this.convertDataURIToBinary(dataURI));
                } else {
                    const resizedDataURI = this.resize(image, newSize.width, newSize.height).toDataURL();
                    resolve(this.convertDataURIToBinary(resizedDataURI));
                }
            };
            image.onerror = () => {
                reject('Image load failed');
            };
        });
    }

    // TODO consolidate with scratch-vm/src/util/base64-util.js
    // From https://gist.github.com/borismus/1032746
    convertDataURIToBinary (dataURI) {
        const BASE64_MARKER = ';base64,';
        const base64Index = dataURI.indexOf(BASE64_MARKER) + BASE64_MARKER.length;
        const base64 = dataURI.substring(base64Index);
        const raw = window.atob(base64);
        const rawLength = raw.length;
        const array = new Uint8Array(new ArrayBuffer(rawLength));

        for (let i = 0; i < rawLength; i++) {
            array[i] = raw.charCodeAt(i);
        }
        return array;
    }

    convertBinaryToDataURI (arrayBuffer, contentType) {
        return `data:${contentType};base64,${base64js.fromByteArray(new Uint8Array(arrayBuffer))}`;
    }
}

module.exports = BitmapAdapter;


/***/ }),

/***/ "./node_modules/scratch-svg-renderer/src/fixup-svg-string.js":
/*!*******************************************************************!*\
  !*** ./node_modules/scratch-svg-renderer/src/fixup-svg-string.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Fixup svg string prior to parsing.
 * @param {!string} svgString String of the svg to fix.
 * @returns {!string} fixed svg that should be parseable.
 */
module.exports = function (svgString) {
    // Add root svg namespace if it does not exist.
    const svgAttrs = svgString.match(/<svg [^>]*>/);
    if (svgAttrs && svgAttrs[0].indexOf('xmlns=') === -1) {
        svgString = svgString.replace('<svg ', '<svg xmlns="http://www.w3.org/2000/svg" ');
    }

    // There are some SVGs from Illustrator that use undeclared entities.
    // Just replace those entities with fake namespace references to prevent
    // DOMParser from crashing
    if (svgAttrs && svgAttrs[0].indexOf('&ns_') !== -1 && svgString.indexOf('<!DOCTYPE') === -1) {
        svgString = svgString.replace(svgAttrs[0],
            svgAttrs[0].replace(/&ns_[^;]+;/g, 'http://ns.adobe.com/Extensibility/1.0/'));
    }

    // Some SVGs exported from Photoshop have been found to have an invalid mime type
    // Chrome and Safari won't render these SVGs, so we correct it here
    if (svgString.includes('data:img/png')) {
        svgString = svgString.replace(
            // capture entire image tag with xlink:href=and the quote - dont capture data: bit
            /(<image[^>]+?xlink:href=["'])data:img\/png/g,
            // use the captured <image ..... xlink:href=" then append the right data uri mime type
            ($0, $1) => `${$1}data:image/png`
        );
    }

    // Some SVGs from Inkscape attempt to bind a prefix to a reserved namespace name.
    // This will cause SVG parsing to fail, so replace these with a dummy namespace name.
    // This namespace name is only valid for "xml", and if we bind "xmlns:xml" to the dummy namespace,
    // parsing will fail yet again, so exclude "xmlns:xml" declarations.
    const xmlnsRegex = /(<[^>]+?xmlns:(?!xml=)[^ ]+=)"http:\/\/www.w3.org\/XML\/1998\/namespace"/g;
    if (svgString.match(xmlnsRegex) !== null) {
        svgString = svgString.replace(
            // capture the entire attribute
            xmlnsRegex,
            // use the captured attribute name; replace only the URL
            ($0, $1) => `${$1}"http://dummy.namespace"`
        );
    }

    // Strip `svg:` prefix (sometimes added by Inkscape) from all tags. They interfere with DOMPurify (prefixed tag
    // names are not recognized) and the paint editor.
    // This matches opening and closing tags--the capture group captures the slash if it exists, and it is reinserted
    // in the replacement text.
    svgString = svgString.replace(/<(\/?)\s*svg:/g, '<$1');

    // The <metadata> element is not needed for rendering and sometimes contains
    // unparseable garbage from Illustrator :( Empty out the contents.
    // Note: [\s\S] matches everything including newlines, which .* does not
    svgString = svgString.replace(/<metadata>[\s\S]*<\/metadata>/, '<metadata></metadata>');

    // Empty script tags and javascript executing
    svgString = svgString.replace(/<script[\s\S]*>[\s\S]*<\/script>/, '<script></script>');

    return svgString;
};


/***/ }),

/***/ "./node_modules/scratch-svg-renderer/src/font-converter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/scratch-svg-renderer/src/font-converter.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @fileOverview Convert 2.0 fonts to 3.0 fonts.
 */

/**
 * Given an SVG, replace Scratch 2.0 fonts with new 3.0 fonts. Add defaults where there are none.
 * @param {SVGElement} svgTag The SVG dom object
 * @return {void}
 */
const convertFonts = function (svgTag) {
    // Collect all text elements into a list.
    const textElements = [];
    const collectText = domElement => {
        if (domElement.localName === 'text') {
            textElements.push(domElement);
        }
        for (let i = 0; i < domElement.childNodes.length; i++) {
            collectText(domElement.childNodes[i]);
        }
    };
    collectText(svgTag);
    // If there's an old font-family, switch to the new one.
    for (const textElement of textElements) {
        // If there's no font-family provided, provide one.
        if (!textElement.getAttribute('font-family') ||
            textElement.getAttribute('font-family') === 'Helvetica') {
            textElement.setAttribute('font-family', 'Sans Serif');
        } else if (textElement.getAttribute('font-family') === 'Mystery') {
            textElement.setAttribute('font-family', 'Curly');
        } else if (textElement.getAttribute('font-family') === 'Gloria') {
            textElement.setAttribute('font-family', 'Handwriting');
        } else if (textElement.getAttribute('font-family') === 'Donegal') {
            textElement.setAttribute('font-family', 'Serif');
        }
    }
};

module.exports = convertFonts;


/***/ }),

/***/ "./node_modules/scratch-svg-renderer/src/font-inliner.js":
/*!***************************************************************!*\
  !*** ./node_modules/scratch-svg-renderer/src/font-inliner.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileOverview Import bitmap data into Scratch 3.0, resizing image as necessary.
 */
const getFonts = __webpack_require__(/*! scratch-render-fonts */ "./node_modules/scratch-render-fonts/src/index.js");

/**
 * Given SVG data, inline the fonts. This allows them to be rendered correctly when set
 * as the source of an HTMLImageElement. Here is a note from tmickel:
 *   // Inject fonts that are needed.
 *   // It would be nice if there were another way to get the SVG-in-canvas
 *   // to render the correct font family, but I couldn't find any other way.
 *   // Other things I tried:
 *   // Just injecting the font-family into the document: no effect.
 *   // External stylesheet linked to by SVG: no effect.
 *   // Using a <link> or <style>@import</style> to link to font-family
 *   // injected into the document: no effect.
 * @param {string} svgString The string representation of the svg to modify
 * @return {string} The svg with any needed fonts inlined
 */
const inlineSvgFonts = function (svgString) {
    const FONTS = getFonts();
    // Make it clear that this function only operates on strings.
    // If we don't explicitly throw this here, the function silently fails.
    if (typeof svgString !== 'string') {
        throw new Error('SVG to be inlined is not a string');
    }

    // Collect fonts that need injection.
    const fontsNeeded = new Set();
    const fontRegex = /font-family="([^"]*)"/g;
    let matches = fontRegex.exec(svgString);
    while (matches) {
        fontsNeeded.add(matches[1]);
        matches = fontRegex.exec(svgString);
    }
    if (fontsNeeded.size > 0) {
        let str = '<defs><style>';
        for (const font of fontsNeeded) {
            if (Object.prototype.hasOwnProperty.call(FONTS, font)) {
                str += `${FONTS[font]}`;
            }
        }
        str += '</style></defs>';
        svgString = svgString.replace(/<svg[^>]*>/, `$&${str}`);
        return svgString;
    }
    return svgString;
};

module.exports = inlineSvgFonts;


/***/ }),

/***/ "./node_modules/scratch-svg-renderer/src/index.js":
/*!********************************************************!*\
  !*** ./node_modules/scratch-svg-renderer/src/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const SVGRenderer = __webpack_require__(/*! ./svg-renderer */ "./node_modules/scratch-svg-renderer/src/svg-renderer.js");
const BitmapAdapter = __webpack_require__(/*! ./bitmap-adapter */ "./node_modules/scratch-svg-renderer/src/bitmap-adapter.js");
const inlineSvgFonts = __webpack_require__(/*! ./font-inliner */ "./node_modules/scratch-svg-renderer/src/font-inliner.js");
const loadSvgString = __webpack_require__(/*! ./load-svg-string */ "./node_modules/scratch-svg-renderer/src/load-svg-string.js");
const serializeSvgToString = __webpack_require__(/*! ./serialize-svg-to-string */ "./node_modules/scratch-svg-renderer/src/serialize-svg-to-string.js");
const SvgElement = __webpack_require__(/*! ./svg-element */ "./node_modules/scratch-svg-renderer/src/svg-element.js");
const convertFonts = __webpack_require__(/*! ./font-converter */ "./node_modules/scratch-svg-renderer/src/font-converter.js");
// /**
//  * Export for NPM & Node.js
//  * @type {RenderWebGL}
//  */
module.exports = {
    BitmapAdapter: BitmapAdapter,
    convertFonts: convertFonts,
    inlineSvgFonts: inlineSvgFonts,
    loadSvgString: loadSvgString,
    serializeSvgToString: serializeSvgToString,
    SvgElement: SvgElement,
    SVGRenderer: SVGRenderer
};


/***/ }),

/***/ "./node_modules/scratch-svg-renderer/src/load-svg-string.js":
/*!******************************************************************!*\
  !*** ./node_modules/scratch-svg-renderer/src/load-svg-string.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const DOMPurify = __webpack_require__(/*! dompurify */ "./node_modules/dompurify/dist/purify.es.js");
const SvgElement = __webpack_require__(/*! ./svg-element */ "./node_modules/scratch-svg-renderer/src/svg-element.js");
const convertFonts = __webpack_require__(/*! ./font-converter */ "./node_modules/scratch-svg-renderer/src/font-converter.js");
const fixupSvgString = __webpack_require__(/*! ./fixup-svg-string */ "./node_modules/scratch-svg-renderer/src/fixup-svg-string.js");
const transformStrokeWidths = __webpack_require__(/*! ./transform-applier */ "./node_modules/scratch-svg-renderer/src/transform-applier.js");

/**
 * @param {SVGElement} svgTag the tag to search within
 * @param {string} [tagName] svg tag to search for (or collect all elements if not given)
 * @return {Array} a list of elements with the given tagname
 */
const collectElements = (svgTag, tagName) => {
    const elts = [];
    const collectElementsInner = domElement => {
        if ((domElement.localName === tagName || typeof tagName === 'undefined') && domElement.getAttribute) {
            elts.push(domElement);
        }
        for (let i = 0; i < domElement.childNodes.length; i++) {
            collectElementsInner(domElement.childNodes[i]);
        }
    };
    collectElementsInner(svgTag);
    return elts;
};

/**
 * Fix SVGs to comply with SVG spec. Scratch 2 defaults to x2 = 0 when x2 is missing, but
 * SVG defaults to x2 = 1 when missing.
 * @param {SVGSVGElement} svgTag the SVG tag to apply the transformation to
 */
const transformGradients = svgTag => {
    const linearGradientElements = collectElements(svgTag, 'linearGradient');

    // For each gradient element, supply x2 if necessary.
    for (const gradientElement of linearGradientElements) {
        if (!gradientElement.getAttribute('x2')) {
            gradientElement.setAttribute('x2', '0');
        }
    }
};

/**
 * Fix SVGs to match appearance in Scratch 2, which used nearest neighbor scaling for bitmaps
 * within SVGs.
 * @param {SVGSVGElement} svgTag the SVG tag to apply the transformation to
 */
const transformImages = svgTag => {
    const imageElements = collectElements(svgTag, 'image');

    // For each image element, set image rendering to pixelated
    const pixelatedImages = 'image-rendering: optimizespeed; image-rendering: pixelated;';
    for (const elt of imageElements) {
        if (elt.getAttribute('style')) {
            elt.setAttribute('style',
                `${pixelatedImages} ${elt.getAttribute('style')}`);
        } else {
            elt.setAttribute('style', pixelatedImages);
        }
    }
};

/**
 * Transforms an SVG's text elements for Scratch 2.0 quirks.
 * These quirks include:
 * 1. `x` and `y` properties are removed/ignored.
 * 2. Alignment is set to `text-before-edge`.
 * 3. Line-breaks are converted to explicit <tspan> elements.
 * 4. Any required fonts are injected.
 * @param {SVGSVGElement} svgTag the SVG tag to apply the transformation to
 */
const transformText = svgTag => {
    // Collect all text elements into a list.
    const textElements = [];
    const collectText = domElement => {
        if (domElement.localName === 'text') {
            textElements.push(domElement);
        }
        for (let i = 0; i < domElement.childNodes.length; i++) {
            collectText(domElement.childNodes[i]);
        }
    };
    collectText(svgTag);
    convertFonts(svgTag);
    // For each text element, apply quirks.
    for (const textElement of textElements) {
        // Remove x and y attributes - they are not used in Scratch.
        textElement.removeAttribute('x');
        textElement.removeAttribute('y');
        // Set text-before-edge alignment:
        // Scratch renders all text like this.
        textElement.setAttribute('alignment-baseline', 'text-before-edge');
        textElement.setAttribute('xml:space', 'preserve');
        // If there's no font size provided, provide one.
        if (!textElement.getAttribute('font-size')) {
            textElement.setAttribute('font-size', '18');
        }
        let text = textElement.textContent;

        // Fix line breaks in text, which are not natively supported by SVG.
        // Only fix if text does not have child tspans.
        // @todo this will not work for font sizes with units such as em, percent
        // However, text made in scratch 2 should only ever export size 22 font.
        const fontSize = parseFloat(textElement.getAttribute('font-size'));
        const tx = 2;
        let ty = 0;
        let spacing = 1.2;
        // Try to match the position and spacing of Scratch 2.0's fonts.
        // Different fonts seem to use different line spacing.
        // Scratch 2 always uses alignment-baseline=text-before-edge
        // However, most SVG readers don't support this attribute
        // or don't support it alongside use of tspan, so the translations
        // here are to make up for that.
        if (textElement.getAttribute('font-family') === 'Handwriting') {
            spacing = 2;
            ty = -11 * fontSize / 22;
        } else if (textElement.getAttribute('font-family') === 'Scratch') {
            spacing = 0.89;
            ty = -3 * fontSize / 22;
        } else if (textElement.getAttribute('font-family') === 'Curly') {
            spacing = 1.38;
            ty = -6 * fontSize / 22;
        } else if (textElement.getAttribute('font-family') === 'Marker') {
            spacing = 1.45;
            ty = -6 * fontSize / 22;
        } else if (textElement.getAttribute('font-family') === 'Sans Serif') {
            spacing = 1.13;
            ty = -3 * fontSize / 22;
        } else if (textElement.getAttribute('font-family') === 'Serif') {
            spacing = 1.25;
            ty = -4 * fontSize / 22;
        }

        if (textElement.transform.baseVal.numberOfItems === 0) {
            const transform = svgTag.createSVGTransform();
            textElement.transform.baseVal.appendItem(transform);
        }

        // Right multiply matrix by a translation of (tx, ty)
        const mtx = textElement.transform.baseVal.getItem(0).matrix;
        mtx.e += (mtx.a * tx) + (mtx.c * ty);
        mtx.f += (mtx.b * tx) + (mtx.d * ty);

        if (text && textElement.childElementCount === 0) {
            textElement.textContent = '';
            const lines = text.split('\n');
            text = '';
            for (const line of lines) {
                const tspanNode = SvgElement.create('tspan');
                tspanNode.setAttribute('x', '0');
                tspanNode.setAttribute('style', 'white-space: pre');
                tspanNode.setAttribute('dy', `${spacing}em`);
                tspanNode.textContent = line ? line : ' ';
                textElement.appendChild(tspanNode);
            }
        }
    }
};

/**
 * Find the largest stroke width in the svg. If a shape has no
 * `stroke` property, it has a stroke-width of 0. If it has a `stroke`,
 * it is by default a stroke-width of 1.
 * This is used to enlarge the computed bounding box, which doesn't take
 * stroke width into account.
 * @param {SVGSVGElement} rootNode The root SVG node to traverse.
 * @return {number} The largest stroke width in the SVG.
 */
const findLargestStrokeWidth = rootNode => {
    let largestStrokeWidth = 0;
    const collectStrokeWidths = domElement => {
        if (domElement.getAttribute) {
            if (domElement.getAttribute('stroke')) {
                largestStrokeWidth = Math.max(largestStrokeWidth, 1);
            }
            if (domElement.getAttribute('stroke-width')) {
                largestStrokeWidth = Math.max(
                    largestStrokeWidth,
                    Number(domElement.getAttribute('stroke-width')) || 0
                );
            }
        }
        for (let i = 0; i < domElement.childNodes.length; i++) {
            collectStrokeWidths(domElement.childNodes[i]);
        }
    };
    collectStrokeWidths(rootNode);
    return largestStrokeWidth;
};

/**
 * Transform the measurements of the SVG.
 * In Scratch 2.0, SVGs are drawn without respect to the width,
 * height, and viewBox attribute on the tag. The exporter
 * does output these properties - but they appear to be incorrect often.
 * To address the incorrect measurements, we append the DOM to the
 * document, and then use SVG's native `getBBox` to find the real
 * drawn dimensions. This ensures things drawn in negative dimensions,
 * outside the given viewBox, etc., are all eventually drawn to the canvas.
 * I tried to do this several other ways: stripping the width/height/viewBox
 * attributes and then drawing (Firefox won't draw anything),
 * or inflating them and then measuring a canvas. But this seems to be
 * a natural and performant way.
 * @param {SVGSVGElement} svgTag the SVG tag to apply the transformation to
 */
const transformMeasurements = svgTag => {
    // Append the SVG dom to the document.
    // This allows us to use `getBBox` on the page,
    // which returns the full bounding-box of all drawn SVG
    // elements, similar to how Scratch 2.0 did measurement.
    const svgSpot = document.createElement('span');
    // Since we're adding user-provided SVG to document.body,
    // sanitizing is required. This should not affect bounding box calculation.
    // outerHTML is attribute of Element (and not HTMLElement), so use it instead of
    // calling serializer or toString()
    // NOTE: svgTag remains untouched!
    const rawValue = svgTag.outerHTML;
    const sanitizedValue = DOMPurify.sanitize(rawValue, {
        // Use SVG profile (no HTML elements)
        USE_PROFILES: {svg: true},
        // Remove some tags that Scratch does not use.
        FORBID_TAGS: ['a', 'audio', 'canvas', 'video'],
        // Allow data URI in image tags (e.g. SVGs converted from bitmap)
        ADD_DATA_URI_TAGS: ['image']
    });
    let bbox;
    try {
        // Insert sanitized value.
        svgSpot.innerHTML = sanitizedValue;
        document.body.appendChild(svgSpot);
        // Take the bounding box. We have to get elements via svgSpot
        // because we added it via innerHTML.
        bbox = svgSpot.children[0].getBBox();
    } finally {
        // Always destroy the element, even if, for example, getBBox throws.
        document.body.removeChild(svgSpot);
    }

    // Enlarge the bbox from the largest found stroke width
    // This may have false-positives, but at least the bbox will always
    // contain the full graphic including strokes.
    // If the width or height is zero however, don't enlarge since
    // they won't have a stroke width that needs to be enlarged.
    let halfStrokeWidth;
    if (bbox.width === 0 || bbox.height === 0) {
        halfStrokeWidth = 0;
    } else {
        halfStrokeWidth = findLargestStrokeWidth(svgTag) / 2;
    }
    const width = bbox.width + (halfStrokeWidth * 2);
    const height = bbox.height + (halfStrokeWidth * 2);
    const x = bbox.x - halfStrokeWidth;
    const y = bbox.y - halfStrokeWidth;

    // Set the correct measurements on the SVG tag
    svgTag.setAttribute('width', width);
    svgTag.setAttribute('height', height);
    svgTag.setAttribute('viewBox',
        `${x} ${y} ${width} ${height}`);
};

/**
 * Find all instances of a URL-referenced `stroke` in the svg. In 2.0, all gradient strokes
 * have a round `stroke-linejoin` and `stroke-linecap`... for some reason.
 * @param {SVGSVGElement} svgTag the SVG tag to apply the transformation to
 */
const setGradientStrokeRoundedness = svgTag => {
    const elements = collectElements(svgTag);

    for (const elt of elements) {
        if (!elt.style) continue;
        const stroke = elt.style.stroke || elt.getAttribute('stroke');
        if (stroke && stroke.match(/^url\(#.*\)$/)) {
            elt.style['stroke-linejoin'] = 'round';
            elt.style['stroke-linecap'] = 'round';
        }
    }
};

/**
 * In-place, convert passed SVG to something consistent that will be rendered the way we want them to be.
 * @param {SVGSvgElement} svgTag root SVG node to operate upon
 * @param {boolean} [fromVersion2] True if we should perform conversion from version 2 to version 3 svg.
 */
const normalizeSvg = (svgTag, fromVersion2) => {
    if (fromVersion2) {
        // Fix gradients. Scratch 2 exports no x2 when x2 = 0, but
        // SVG default is that x2 is 1. This must be done before
        // transformStrokeWidths since transformStrokeWidths affects
        // gradients.
        transformGradients(svgTag);
    }
    transformStrokeWidths(svgTag, window);
    transformImages(svgTag);
    if (fromVersion2) {
        // Transform all text elements.
        transformText(svgTag);
        // Transform measurements.
        transformMeasurements(svgTag);
        // Fix stroke roundedness.
        setGradientStrokeRoundedness(svgTag);
    } else if (!svgTag.getAttribute('viewBox')) {
        // Renderer expects a view box.
        transformMeasurements(svgTag);
    } else if (!svgTag.getAttribute('width') || !svgTag.getAttribute('height')) {
        svgTag.setAttribute('width', svgTag.viewBox.baseVal.width);
        svgTag.setAttribute('height', svgTag.viewBox.baseVal.height);
    }
};

/**
 * Load an SVG string and normalize it. All the steps before drawing/measuring.
 * Currently, this will normalize stroke widths (see transform-applier.js) and render all embedded images pixelated.
 * The returned SVG will be guaranteed to always have a `width`, `height` and `viewBox`.
 * In addition, if the `fromVersion2` parameter is `true`, several "quirks-mode" transformations will be applied which
 * mimic Scratch 2.0's SVG rendering.
 * @param {!string} svgString String of SVG data to draw in quirks-mode.
 * @param {boolean} [fromVersion2] True if we should perform conversion from version 2 to version 3 svg.
 * @return {SVGSVGElement} The normalized SVG element.
 */
const loadSvgString = (svgString, fromVersion2) => {
    // Parse string into SVG XML.
    const parser = new DOMParser();
    svgString = fixupSvgString(svgString);
    const svgDom = parser.parseFromString(svgString, 'text/xml');
    if (svgDom.childNodes.length < 1 ||
        svgDom.documentElement.localName !== 'svg') {
        throw new Error('Document does not appear to be SVG.');
    }
    const svgTag = svgDom.documentElement;
    normalizeSvg(svgTag, fromVersion2);
    return svgTag;
};

module.exports = loadSvgString;


/***/ }),

/***/ "./node_modules/scratch-svg-renderer/src/serialize-svg-to-string.js":
/*!**************************************************************************!*\
  !*** ./node_modules/scratch-svg-renderer/src/serialize-svg-to-string.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const inlineSvgFonts = __webpack_require__(/*! ./font-inliner */ "./node_modules/scratch-svg-renderer/src/font-inliner.js");

/**
 * Serialize a given SVG DOM to a string.
 * @param {SVGSVGElement} svgTag The SVG element to serialize.
 * @param {?boolean} shouldInjectFonts True if fonts should be included in the SVG as
 *     base64 data.
 * @returns {string} String representing current SVG data.
 */
const serializeSvgToString = (svgTag, shouldInjectFonts) => {
    const serializer = new XMLSerializer();
    let string = serializer.serializeToString(svgTag);
    if (shouldInjectFonts) {
        string = inlineSvgFonts(string);
    }
    return string;
};

module.exports = serializeSvgToString;


/***/ }),

/***/ "./node_modules/scratch-svg-renderer/src/svg-element.js":
/*!**************************************************************!*\
  !*** ./node_modules/scratch-svg-renderer/src/svg-element.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* Adapted from
 * Paper.js - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2016, Juerg Lehni & Jonathan Puckey
 * http://scratchdisk.com/ & http://jonathanpuckey.com/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 */

/**
 * @name SvgElement
 * @namespace
 * @private
 */
class SvgElement {
    // SVG related namespaces
    static get svg () {
        return 'http://www.w3.org/2000/svg';
    }
    static get xmlns () {
        return 'http://www.w3.org/2000/xmlns';
    }
    static get xlink () {
        return 'http://www.w3.org/1999/xlink';
    }

    // Mapping of attribute names to required namespaces:
    static attributeNamespace () {
        return {
            'href': SvgElement.xlink,
            'xlink': SvgElement.xmlns,
            // Only the xmlns attribute needs the trailing slash. See #984
            'xmlns': `${SvgElement.xmlns}/`,
            // IE needs the xmlns namespace when setting 'xmlns:xlink'. See #984
            'xmlns:xlink': `${SvgElement.xmlns}/`
        };
    }

    static create (tag, attributes, formatter) {
        return SvgElement.set(document.createElementNS(SvgElement.svg, tag), attributes, formatter);
    }

    static get (node, name) {
        const namespace = SvgElement.attributeNamespace[name];
        const value = namespace ?
            node.getAttributeNS(namespace, name) :
            node.getAttribute(name);
        return value === 'null' ? null : value;
    }

    static set (node, attributes, formatter) {
        for (const name in attributes) {
            let value = attributes[name];
            const namespace = SvgElement.attributeNamespace[name];
            if (typeof value === 'number' && formatter) {
                value = formatter.number(value);
            }
            if (namespace) {
                node.setAttributeNS(namespace, name, value);
            } else {
                node.setAttribute(name, value);
            }
        }
        return node;
    }
}

module.exports = SvgElement;


/***/ }),

/***/ "./node_modules/scratch-svg-renderer/src/svg-renderer.js":
/*!***************************************************************!*\
  !*** ./node_modules/scratch-svg-renderer/src/svg-renderer.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const loadSvgString = __webpack_require__(/*! ./load-svg-string */ "./node_modules/scratch-svg-renderer/src/load-svg-string.js");
const serializeSvgToString = __webpack_require__(/*! ./serialize-svg-to-string */ "./node_modules/scratch-svg-renderer/src/serialize-svg-to-string.js");

/**
 * Main quirks-mode SVG rendering code.
 * @deprecated Call into individual methods exported from this library instead.
 */
class SvgRenderer {
    /**
     * Create a quirks-mode SVG renderer for a particular canvas.
     * @param {HTMLCanvasElement} [canvas] An optional canvas element to draw to. If this is not provided, the renderer
     * will create a new canvas.
     * @constructor
     */
    constructor (canvas) {
        /**
         * The canvas that this SVG renderer will render to.
         * @type {HTMLCanvasElement}
         * @private
         */
        this._canvas = canvas || document.createElement('canvas');
        this._context = this._canvas.getContext('2d');

        /**
         * A measured SVG "viewbox"
         * @typedef {object} SvgRenderer#SvgMeasurements
         * @property {number} x - The left edge of the SVG viewbox.
         * @property {number} y - The top edge of the SVG viewbox.
         * @property {number} width - The width of the SVG viewbox.
         * @property {number} height - The height of the SVG viewbox.
         */

        /**
         * The measurement box of the currently loaded SVG.
         * @type {SvgRenderer#SvgMeasurements}
         * @private
         */
        this._measurements = {x: 0, y: 0, width: 0, height: 0};

        /**
         * The `<img>` element with the contents of the currently loaded SVG.
         * @type {?HTMLImageElement}
         * @private
         */
        this._cachedImage = null;

        /**
         * True if this renderer's current SVG is loaded and can be rendered to the canvas.
         * @type {boolean}
         */
        this.loaded = false;
    }

    /**
     * @returns {!HTMLCanvasElement} this renderer's target canvas.
     */
    get canvas () {
        return this._canvas;
    }

    /**
     * @return {Array<number>} the natural size, in Scratch units, of this SVG.
     */
    get size () {
        return [this._measurements.width, this._measurements.height];
    }

    /**
     * @return {Array<number>} the offset (upper left corner) of the SVG's view box.
     */
    get viewOffset () {
        return [this._measurements.x, this._measurements.y];
    }

    /**
     * Load an SVG string and normalize it. All the steps before drawing/measuring.
     * @param {!string} svgString String of SVG data to draw in quirks-mode.
     * @param {?boolean} fromVersion2 True if we should perform conversion from
     *     version 2 to version 3 svg.
     */
    loadString (svgString, fromVersion2) {
        // New svg string invalidates the cached image
        this._cachedImage = null;
        const svgTag = loadSvgString(svgString, fromVersion2);

        this._svgTag = svgTag;
        this._measurements = {
            width: svgTag.viewBox.baseVal.width,
            height: svgTag.viewBox.baseVal.height,
            x: svgTag.viewBox.baseVal.x,
            y: svgTag.viewBox.baseVal.y
        };
    }

    /**
     * Load an SVG string, normalize it, and prepare it for (synchronous) rendering.
     * @param {!string} svgString String of SVG data to draw in quirks-mode.
     * @param {?boolean} fromVersion2 True if we should perform conversion from version 2 to version 3 svg.
     * @param {Function} [onFinish] - An optional callback to call when the SVG is loaded and can be rendered.
     */
    loadSVG (svgString, fromVersion2, onFinish) {
        this.loadString(svgString, fromVersion2);
        this._createSVGImage(onFinish);
    }

    /**
     * Creates an <img> element for the currently loaded SVG string, then calls the callback once it's loaded.
     * @param {Function} [onFinish] - An optional callback to call when the <img> has loaded.
     */
    _createSVGImage (onFinish) {
        if (this._cachedImage === null) this._cachedImage = new Image();
        const img = this._cachedImage;

        img.onload = () => {
            this.loaded = true;
            if (onFinish) onFinish();
        };
        const svgText = this.toString(true /* shouldInjectFonts */);
        img.src = `data:image/svg+xml;utf8,${encodeURIComponent(svgText)}`;
        this.loaded = false;
    }

    /**
     * Serialize the active SVG DOM to a string.
     * @param {?boolean} shouldInjectFonts True if fonts should be included in the SVG as
     *     base64 data.
     * @returns {string} String representing current SVG data.
     * @deprecated Use the standalone `serializeSvgToString` export instead.
     */
    toString (shouldInjectFonts) {
        return serializeSvgToString(this._svgTag, shouldInjectFonts);
    }

    /**
     * Synchronously draw the loaded SVG to this renderer's `canvas`.
     * @param {number} [scale] - Optionally, also scale the image by this factor.
     */
    draw (scale) {
        if (!this.loaded) throw new Error('SVG image has not finished loading');
        this._drawFromImage(scale);
    }

    /**
     * Draw to the canvas from a loaded image element.
     * @param {number} [scale] - Optionally, also scale the image by this factor.
     **/
    _drawFromImage (scale) {
        if (this._cachedImage === null) return;

        const ratio = Number.isFinite(scale) ? scale : 1;
        const bbox = this._measurements;
        this._canvas.width = bbox.width * ratio;
        this._canvas.height = bbox.height * ratio;
        // Even if the canvas at the current scale has a nonzero size, the image's dimensions are floored pre-scaling.
        // e.g. if an image has a width of 0.4 and is being rendered at 3x scale, the canvas will have a width of 1, but
        // the image's width will be rounded down to 0 on some browsers (Firefox) prior to being drawn at that scale.
        if (
            this._canvas.width <= 0 ||
            this._canvas.height <= 0 ||
            this._cachedImage.naturalWidth <= 0 ||
            this._cachedImage.naturalHeight <= 0
        ) return;
        this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
        this._context.setTransform(ratio, 0, 0, ratio, 0, 0);
        this._context.drawImage(this._cachedImage, 0, 0);
    }
}

module.exports = SvgRenderer;


/***/ }),

/***/ "./node_modules/scratch-svg-renderer/src/transform-applier.js":
/*!********************************************************************!*\
  !*** ./node_modules/scratch-svg-renderer/src/transform-applier.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Matrix = __webpack_require__(/*! transformation-matrix */ "./node_modules/transformation-matrix/build-es/index.js");
const SvgElement = __webpack_require__(/*! ./svg-element */ "./node_modules/scratch-svg-renderer/src/svg-element.js");
const log = __webpack_require__(/*! ./util/log */ "./node_modules/scratch-svg-renderer/src/util/log.js");

/**
 * @fileOverview Apply transforms to match stroke width appearance in 2.0 and 3.0
 */

// Adapted from paper.js's Path.applyTransform
const _parseTransform = function (domElement) {
    let matrix = Matrix.identity();
    const string = domElement.attributes && domElement.attributes.transform && domElement.attributes.transform.value;
    if (!string) return matrix;
    // https://www.w3.org/TR/SVG/types.html#DataTypeTransformList
    // Parse SVG transform string. First we split at /)\s*/, to separate
    // commands
    const transforms = string.split(/\)\s*/g);
    for (const transform of transforms) {
        if (!transform) break;
        // Command come before the '(', values after
        const parts = transform.split(/\(\s*/);
        const command = parts[0].trim();
        const v = parts[1].split(/[\s,]+/g);
        // Convert values to floats
        for (let j = 0; j < v.length; j++) {
            v[j] = parseFloat(v[j]);
        }
        switch (command) {
        case 'matrix':
            matrix = Matrix.compose(matrix, {a: v[0], b: v[1], c: v[2], d: v[3], e: v[4], f: v[5]});
            break;
        case 'rotate':
            matrix = Matrix.compose(matrix, Matrix.rotateDEG(v[0], v[1] || 0, v[2] || 0));
            break;
        case 'translate':
            matrix = Matrix.compose(matrix, Matrix.translate(v[0], v[1] || 0));
            break;
        case 'scale':
            matrix = Matrix.compose(matrix, Matrix.scale(v[0], v[1] || v[0]));
            break;
        case 'skewX':
            matrix = Matrix.compose(matrix, Matrix.skewDEG(v[0], 0));
            break;
        case 'skewY':
            matrix = Matrix.compose(matrix, Matrix.skewDEG(0, v[0]));
            break;
        default:
            log.error(`Couldn't parse: ${command}`);
        }
    }
    return matrix;
};

// Adapted from paper.js's Matrix.decompose
// Given a matrix, return the x and y scale factors of the matrix
const _getScaleFactor = function (matrix) {
    const a = matrix.a;
    const b = matrix.b;
    const c = matrix.c;
    const d = matrix.d;
    const det = (a * d) - (b * c);

    if (a !== 0 || b !== 0) {
        const r = Math.sqrt((a * a) + (b * b));
        return {x: r, y: det / r};
    }
    if (c !== 0 || d !== 0) {
        const s = Math.sqrt((c * c) + (d * d));
        return {x: det / s, y: s};
    }
    // a = b = c = d = 0
    return {x: 0, y: 0};
};

// Returns null if matrix is not invertible. Otherwise returns given ellipse
// transformed by transform, an object {radiusX, radiusY, rotation}.
const _calculateTransformedEllipse = function (radiusX, radiusY, theta, transform) {
    theta = -theta * Math.PI / 180;
    const a = transform.a;
    const b = -transform.c;
    const c = -transform.b;
    const d = transform.d;
    // Since other parameters determine the translation of the ellipse in SVG, we do not need to worry
    // about what e and f are.
    const det = (a * d) - (b * c);
    // Non-invertible matrix
    if (det === 0) return null;

    // rotA, rotB, and rotC represent Ax^2 + Bxy + Cy^2 = 1 coefficients for a rotated ellipse formula
    const sinT = Math.sin(theta);
    const cosT = Math.cos(theta);
    const sin2T = Math.sin(2 * theta);
    const rotA = (cosT * cosT / radiusX / radiusX) + (sinT * sinT / radiusY / radiusY);
    const rotB = (sin2T / radiusX / radiusX) - (sin2T / radiusY / radiusY);
    const rotC = (sinT * sinT / radiusX / radiusX) + (cosT * cosT / radiusY / radiusY);

    // Calculate the ellipse formula of the transformed ellipse
    // A, B, and C represent Ax^2 + Bxy + Cy^2 = 1 / det / det coefficients in a transformed ellipse formula
    // scaled by inverse det squared (to preserve accuracy)
    const A = ((rotA * d * d) - (rotB * d * c) + (rotC * c * c));
    const B = ((-2 * rotA * b * d) + (rotB * a * d) + (rotB * b * c) - (2 * rotC * a * c));
    const C = ((rotA * b * b) - (rotB * a * b) + (rotC * a * a));

    // Derive new radii and theta from the transformed ellipse formula
    const newRadiusXOverDet = Math.sqrt(2) *
        Math.sqrt(
            (A + C - Math.sqrt((A * A) + (B * B) - (2 * A * C) + (C * C))) /
            ((-B * B) + (4 * A * C))
        );
    const newRadiusYOverDet = 1 / Math.sqrt(A + C - (1 / newRadiusXOverDet / newRadiusXOverDet));
    let temp = (A - (1 / newRadiusXOverDet / newRadiusXOverDet)) /
        ((1 / newRadiusYOverDet / newRadiusYOverDet) - (1 / newRadiusXOverDet / newRadiusXOverDet));
    if (temp < 0 && Math.abs(temp) < 1e-8) temp = 0; // Fix floating point issue
    temp = Math.sqrt(temp);
    if (Math.abs(1 - temp) < 1e-8) temp = 1; // Fix floating point issue
    // Solve for which of the two possible thetas is correct
    let newTheta = Math.asin(temp);
    temp = (B / (
        (1 / newRadiusXOverDet / newRadiusXOverDet) -
        (1 / newRadiusYOverDet / newRadiusYOverDet)));
    const newTheta2 = -newTheta;
    if (Math.abs(Math.sin(2 * newTheta2) - temp) <
        Math.abs(Math.sin(2 * newTheta) - temp)) {
        newTheta = newTheta2;
    }

    return {
        radiusX: newRadiusXOverDet * det,
        radiusY: newRadiusYOverDet * det,
        rotation: -newTheta * 180 / Math.PI
    };
};

// Adapted from paper.js's PathItem.setPathData
const _transformPath = function (pathString, transform) {
    if (!transform || Matrix.toString(transform) === Matrix.toString(Matrix.identity())) return pathString;
    // First split the path data into parts of command-coordinates pairs
    // Commands are any of these characters: mzlhvcsqta
    const parts = pathString && pathString.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig);
    let coords;
    let relative = false;
    let previous;
    let control;
    let current = {x: 0, y: 0};
    let start = {x: 0, y: 0};
    let result = '';

    const getCoord = function (index, coord) {
        let val = +coords[index];
        if (relative) {
            val += current[coord];
        }
        return val;
    };

    const getPoint = function (index) {
        return {x: getCoord(index, 'x'), y: getCoord(index + 1, 'y')};
    };

    const roundTo4Places = function (num) {
        return Number(num.toFixed(4));
    };

    // Returns the transformed point as a string
    const getString = function (point) {
        const transformed = Matrix.applyToPoint(transform, point);
        return `${roundTo4Places(transformed.x)} ${roundTo4Places(transformed.y)} `;
    };

    for (let i = 0, l = parts && parts.length; i < l; i++) {
        const part = parts[i];
        const command = part[0];
        const lower = command.toLowerCase();
        // Match all coordinate values
        coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
        const length = coords && coords.length;
        relative = command === lower;
        // Fix issues with z in the middle of SVG path data, not followed by
        // a m command, see paper.js#413:
        if (previous === 'z' && !/[mz]/.test(lower)) {
            result += `M ${current.x} ${current.y} `;
        }
        switch (lower) {
        case 'm': // Move to
        case 'l': // Line to
        {
            let move = lower === 'm';
            for (let j = 0; j < length; j += 2) {
                result += move ? 'M ' : 'L ';
                current = getPoint(j);
                result += getString(current);
                if (move) {
                    start = current;
                    move = false;
                }
            }
            control = current;
            break;
        }
        case 'h': // Horizontal line
        case 'v': // Vertical line
        {
            const coord = lower === 'h' ? 'x' : 'y';
            current = {x: current.x, y: current.y}; // Clone as we're going to modify it.
            for (let j = 0; j < length; j++) {
                current[coord] = getCoord(j, coord);
                result += `L ${getString(current)}`;
            }
            control = current;
            break;
        }
        case 'c':
            // Cubic Bezier curve
            for (let j = 0; j < length; j += 6) {
                const handle1 = getPoint(j);
                control = getPoint(j + 2);
                current = getPoint(j + 4);
                result += `C ${getString(handle1)}${getString(control)}${getString(current)}`;
            }
            break;
        case 's':
            // Smooth cubic Bezier curve
            for (let j = 0; j < length; j += 4) {
                const handle1 = /[cs]/.test(previous) ?
                    {x: (current.x * 2) - control.x, y: (current.y * 2) - control.y} :
                    current;
                control = getPoint(j);
                current = getPoint(j + 2);

                result += `C ${getString(handle1)}${getString(control)}${getString(current)}`;
                previous = lower;
            }
            break;
        case 'q':
            // Quadratic Bezier curve
            for (let j = 0; j < length; j += 4) {
                control = getPoint(j);
                current = getPoint(j + 2);
                result += `Q ${getString(control)}${getString(current)}`;
            }
            break;
        case 't':
            // Smooth quadratic Bezier curve
            for (let j = 0; j < length; j += 2) {
                control = /[qt]/.test(previous) ?
                    {x: (current.x * 2) - control.x, y: (current.y * 2) - control.y} :
                    current;
                current = getPoint(j);

                result += `Q ${getString(control)}${getString(current)}`;
                previous = lower;
            }
            break;
        case 'a':
            // Elliptical arc curve
            for (let j = 0; j < length; j += 7) {
                current = getPoint(j + 5);
                const rx = +coords[j];
                const ry = +coords[j + 1];
                const rotation = +coords[j + 2];
                const largeArcFlag = +coords[j + 3];
                let clockwiseFlag = +coords[j + 4];
                const newEllipse = _calculateTransformedEllipse(rx, ry, rotation, transform);
                const matrixScale = _getScaleFactor(transform);
                if (newEllipse) {
                    if ((matrixScale.x > 0 && matrixScale.y < 0) ||
                        (matrixScale.x < 0 && matrixScale.y > 0)) {
                        clockwiseFlag = clockwiseFlag ^ 1;
                    }
                    result += `A ${roundTo4Places(Math.abs(newEllipse.radiusX))} ` +
                        `${roundTo4Places(Math.abs(newEllipse.radiusY))} ` +
                        `${roundTo4Places(newEllipse.rotation)} ${largeArcFlag} ` +
                        `${clockwiseFlag} ${getString(current)}`;
                } else {
                    result += `L ${getString(current)}`;
                }
            }
            break;
        case 'z':
            // Close path
            result += `Z `;
            // Correctly handle relative m commands, see paper.js#1101:
            current = start;
            break;
        }
        previous = lower;
    }
    return result;
};

const GRAPHICS_ELEMENTS = ['circle', 'ellipse', 'image', 'line', 'path', 'polygon', 'polyline', 'rect', 'text', 'use'];
const CONTAINER_ELEMENTS = ['a', 'defs', 'g', 'marker', 'glyph', 'missing-glyph', 'pattern', 'svg', 'switch', 'symbol'];
const _isContainerElement = function (element) {
    return element.tagName && CONTAINER_ELEMENTS.includes(element.tagName.toLowerCase());
};
const _isGraphicsElement = function (element) {
    return element.tagName && GRAPHICS_ELEMENTS.includes(element.tagName.toLowerCase());
};
const _isPathWithTransformAndStroke = function (element, strokeWidth) {
    if (!element.attributes) return false;
    strokeWidth = element.attributes['stroke-width'] ?
        Number(element.attributes['stroke-width'].value) : Number(strokeWidth);
    return strokeWidth &&
        element.tagName && element.tagName.toLowerCase() === 'path' &&
        element.attributes.d && element.attributes.d.value;
};
const _quadraticMean = function (a, b) {
    return Math.sqrt(((a * a) + (b * b)) / 2);
};

const _createGradient = function (gradientId, svgTag, bbox, matrix) {
    // Adapted from Paper.js's SvgImport.getValue
    const getValue = function (node, name, isString, allowNull, allowPercent, defaultValue) {
        // Interpret value as number. Never return NaN, but 0 instead.
        // If the value is a sequence of numbers, parseFloat will
        // return the first occurring number, which is enough for now.
        let value = SvgElement.get(node, name);
        let res;
        if (value === null) {
            if (defaultValue) {
                res = defaultValue;
                if (/%\s*$/.test(res)) {
                    value = defaultValue;
                    res = parseFloat(value);
                }
            } else if (allowNull) {
                res = null;
            } else if (isString) {
                res = '';
            } else {
                res = 0;
            }
        } else if (isString) {
            res = value;
        } else {
            res = parseFloat(value);
        }
        // Support for dimensions in percentage of the root size. If root-size
        // is not set (e.g. during <defs>), just scale the percentage value to
        // 0..1, as required by gradients with gradientUnits="objectBoundingBox"
        if (/%\s*$/.test(value)) {
            const size = allowPercent ? 1 : bbox[/x|^width/.test(name) ? 'width' : 'height'];
            return res / 100 * size;
        }
        return res;
    };
    const getPoint = function (node, x, y, allowNull, allowPercent, defaultX, defaultY) {
        x = getValue(node, x || 'x', false, allowNull, allowPercent, defaultX);
        y = getValue(node, y || 'y', false, allowNull, allowPercent, defaultY);
        return allowNull && (x === null || y === null) ? null : {x, y};
    };

    let defs = svgTag.getElementsByTagName('defs');
    if (defs.length === 0) {
        defs = SvgElement.create('defs');
        svgTag.appendChild(defs);
    } else {
        defs = defs[0];
    }

    // Clone the old gradient. We'll make a new one, since the gradient might be reused elsewhere
    // with different transform matrix
    const oldGradient = svgTag.getElementById(gradientId);
    if (!oldGradient) return;

    const radial = oldGradient.tagName.toLowerCase() === 'radialgradient';
    const newGradient = svgTag.getElementById(gradientId).cloneNode(true /* deep */);

    // Give the new gradient a new ID
    let matrixString = Matrix.toString(matrix);
    matrixString = matrixString.substring(8, matrixString.length - 1);
    const newGradientId = `${gradientId}-${matrixString}`;
    newGradient.setAttribute('id', newGradientId);

    // This gradient already exists and was transformed before. Just reuse the already-transformed one.
    if (svgTag.getElementById(newGradientId)) {
        // This is the same code as in the end of the function, but I don't feel like wrapping the next 80 lines
        // in an `if (!svgTag.getElementById(newGradientId))` block
        return `url(#${newGradientId})`;
    }

    const scaleToBounds = getValue(newGradient, 'gradientUnits', true) !==
                'userSpaceOnUse';
    let origin;
    let destination;
    let radius;
    let focal;
    if (radial) {
        origin = getPoint(newGradient, 'cx', 'cy', false, scaleToBounds, '50%', '50%');
        radius = getValue(newGradient, 'r', false, false, scaleToBounds, '50%');
        focal = getPoint(newGradient, 'fx', 'fy', true, scaleToBounds);
    } else {
        origin = getPoint(newGradient, 'x1', 'y1', false, scaleToBounds);
        destination = getPoint(newGradient, 'x2', 'y2', false, scaleToBounds, '1');
        if (origin.x === destination.x && origin.y === destination.y) {
            // If it's degenerate, use the color of the last stop, as described by
            // https://www.w3.org/TR/SVG/pservers.html#LinearGradientNotes
            const stops = newGradient.getElementsByTagName('stop');
            if (!stops.length || !stops[stops.length - 1].attributes ||
                    !stops[stops.length - 1].attributes['stop-color']) {
                return null;
            }
            return stops[stops.length - 1].attributes['stop-color'].value;
        }
    }

    // Transform points
    // Emulate SVG's gradientUnits="objectBoundingBox"
    if (scaleToBounds) {
        const boundsMatrix = Matrix.compose(Matrix.translate(bbox.x, bbox.y), Matrix.scale(bbox.width, bbox.height));
        origin = Matrix.applyToPoint(boundsMatrix, origin);
        if (destination) destination = Matrix.applyToPoint(boundsMatrix, destination);
        if (radius) {
            radius = _quadraticMean(bbox.width, bbox.height) * radius;
        }
        if (focal) focal = Matrix.applyToPoint(boundsMatrix, focal);
    }

    if (radial) {
        origin = Matrix.applyToPoint(matrix, origin);
        const matrixScale = _getScaleFactor(matrix);
        radius = _quadraticMean(matrixScale.x, matrixScale.y) * radius;
        if (focal) focal = Matrix.applyToPoint(matrix, focal);
    } else {
        const dot = (a, b) => (a.x * b.x) + (a.y * b.y);
        const multiply = (coefficient, v) => ({x: coefficient * v.x, y: coefficient * v.y});
        const add = (a, b) => ({x: a.x + b.x, y: a.y + b.y});
        const subtract = (a, b) => ({x: a.x - b.x, y: a.y - b.y});

        // The line through origin and gradientPerpendicular is the line at which the gradient starts
        let gradientPerpendicular = Math.abs(origin.x - destination.x) < 1e-8 ?
            add(origin, {x: 1, y: (origin.x - destination.x) / (destination.y - origin.y)}) :
            add(origin, {x: (destination.y - origin.y) / (origin.x - destination.x), y: 1});

        // Transform points
        gradientPerpendicular = Matrix.applyToPoint(matrix, gradientPerpendicular);
        origin = Matrix.applyToPoint(matrix, origin);
        destination = Matrix.applyToPoint(matrix, destination);

        // Calculate the direction that the gradient has changed to
        const originToPerpendicular = subtract(gradientPerpendicular, origin);
        const originToDestination = subtract(destination, origin);
        const gradientDirection = Math.abs(originToPerpendicular.x) < 1e-8 ?
            {x: 1, y: -originToPerpendicular.x / originToPerpendicular.y} :
            {x: -originToPerpendicular.y / originToPerpendicular.x, y: 1};

        // Set the destination so that the gradient moves in the correct direction, by projecting the destination vector
        // onto the gradient direction vector
        const projectionCoeff = dot(originToDestination, gradientDirection) / dot(gradientDirection, gradientDirection);
        const projection = multiply(projectionCoeff, gradientDirection);
        destination = {x: origin.x + projection.x, y: origin.y + projection.y};
    }

    // Put values back into svg
    if (radial) {
        newGradient.setAttribute('cx', Number(origin.x.toFixed(4)));
        newGradient.setAttribute('cy', Number(origin.y.toFixed(4)));
        newGradient.setAttribute('r', Number(radius.toFixed(4)));
        if (focal) {
            newGradient.setAttribute('fx', Number(focal.x.toFixed(4)));
            newGradient.setAttribute('fy', Number(focal.y.toFixed(4)));
        }
    } else {
        newGradient.setAttribute('x1', Number(origin.x.toFixed(4)));
        newGradient.setAttribute('y1', Number(origin.y.toFixed(4)));
        newGradient.setAttribute('x2', Number(destination.x.toFixed(4)));
        newGradient.setAttribute('y2', Number(destination.y.toFixed(4)));
    }
    newGradient.setAttribute('gradientUnits', 'userSpaceOnUse');
    defs.appendChild(newGradient);

    return `url(#${newGradientId})`;
};

// Adapted from paper.js's SvgImport.getDefinition
const _parseUrl = (value, windowRef) => {
    // When url() comes from a style property, '#'' seems to be missing on
    // WebKit. We also get variations of quotes or no quotes, single or
    // double, so handle it all with one regular expression:
    const match = value && value.match(/\((?:["'#]*)([^"')]+)/);
    const name = match && match[1];
    const res = name && windowRef ?
        // This is required by Firefox, which can produce absolute
        // urls for local gradients, see paperjs#1001:
        name.replace(`${windowRef.location.href.split('#')[0]}#`, '') :
        name;
    return res;
};

/**
 * Scratch 2.0 displays stroke widths in a "normalized" way, that is,
 * if a shape with a stroke width has a transform applied, it will be
 * rendered with a stroke that is the same width all the way around,
 * instead of stretched looking.
 *
 * The vector paint editor also prefers to normalize the stroke width,
 * rather than keep track of transforms at the group level, as this
 * simplifies editing (e.g. stroke width 3 always means the same thickness)
 *
 * This function performs that normalization process, pushing transforms
 * on groups down to the leaf level and averaging out the stroke width
 * around the shapes. Note that this doens't just change stroke widths, it
 * changes path data and attributes throughout the SVG.
 *
 * @param {SVGElement} svgTag The SVG dom object
 * @param {Window} windowRef The window to use. Need to pass in for
 *     tests to work, as they get angry at even the mention of window.
 * @param {object} bboxForTesting The bounds to use. Need to pass in for
 *     tests only, because getBBox doesn't work in Node. This should
 *     be the bounds of the svgTag without including stroke width or transforms.
 * @return {void}
 */
const transformStrokeWidths = function (svgTag, windowRef, bboxForTesting) {
    const inherited = Matrix.identity();

    const applyTransforms = (element, matrix, strokeWidth, fill, stroke) => {
        if (_isContainerElement(element)) {
            // Push fills and stroke width down to leaves
            if (element.attributes['stroke-width']) {
                strokeWidth = element.attributes['stroke-width'].value;
            }
            if (element.attributes) {
                if (element.attributes.fill) fill = element.attributes.fill.value;
                if (element.attributes.stroke) stroke = element.attributes.stroke.value;
            }

            // If any child nodes don't take attributes, leave the attributes
            // at the parent level.
            for (let i = 0; i < element.childNodes.length; i++) {
                applyTransforms(
                    element.childNodes[i],
                    Matrix.compose(matrix, _parseTransform(element)),
                    strokeWidth,
                    fill,
                    stroke
                );
            }
            element.removeAttribute('transform');
            element.removeAttribute('stroke-width');
            element.removeAttribute('fill');
            element.removeAttribute('stroke');
        } else if (_isPathWithTransformAndStroke(element, strokeWidth)) {
            if (element.attributes['stroke-width']) {
                strokeWidth = element.attributes['stroke-width'].value;
            }
            if (element.attributes.fill) fill = element.attributes.fill.value;
            if (element.attributes.stroke) stroke = element.attributes.stroke.value;
            matrix = Matrix.compose(matrix, _parseTransform(element));
            if (Matrix.toString(matrix) === Matrix.toString(Matrix.identity())) {
                element.removeAttribute('transform');
                element.setAttribute('stroke-width', strokeWidth);
                if (fill) element.setAttribute('fill', fill);
                if (stroke) element.setAttribute('stroke', stroke);
                return;
            }

            // Transform gradient
            const fillGradientId = _parseUrl(fill, windowRef);
            const strokeGradientId = _parseUrl(stroke, windowRef);

            if (fillGradientId || strokeGradientId) {
                const doc = windowRef.document;
                // Need path bounds to transform gradient
                const svgSpot = doc.createElement('span');
                let bbox;
                if (bboxForTesting) {
                    bbox = bboxForTesting;
                } else {
                    try {
                        doc.body.appendChild(svgSpot);
                        const svg = SvgElement.set(doc.createElementNS(SvgElement.svg, 'svg'));
                        const path = SvgElement.set(doc.createElementNS(SvgElement.svg, 'path'));
                        path.setAttribute('d', element.attributes.d.value);
                        svg.appendChild(path);
                        svgSpot.appendChild(svg);
                        // Take the bounding box.
                        bbox = svg.getBBox();
                    } finally {
                        // Always destroy the element, even if, for example, getBBox throws.
                        doc.body.removeChild(svgSpot);
                    }
                }

                if (fillGradientId) {
                    const newFillRef = _createGradient(fillGradientId, svgTag, bbox, matrix);
                    if (newFillRef) fill = newFillRef;
                }

                if (strokeGradientId) {
                    const newStrokeRef = _createGradient(strokeGradientId, svgTag, bbox, matrix);
                    if (newStrokeRef) stroke = newStrokeRef;
                }
            }

            // Transform path data
            element.setAttribute('d', _transformPath(element.attributes.d.value, matrix));
            element.removeAttribute('transform');

            // Transform stroke width
            const matrixScale = _getScaleFactor(matrix);
            element.setAttribute('stroke-width', _quadraticMean(matrixScale.x, matrixScale.y) * strokeWidth);
            if (fill) element.setAttribute('fill', fill);
            if (stroke) element.setAttribute('stroke', stroke);
        } else if (_isGraphicsElement(element)) {
            // Push stroke width, fill, and stroke down to leaves
            if (strokeWidth && !element.attributes['stroke-width']) {
                element.setAttribute('stroke-width', strokeWidth);
            }
            if (fill && !element.attributes.fill) {
                element.setAttribute('fill', fill);
            }
            if (stroke && !element.attributes.stroke) {
                element.setAttribute('stroke', stroke);
            }

            // Push transform down to leaves
            matrix = Matrix.compose(matrix, _parseTransform(element));
            if (Matrix.toString(matrix) === Matrix.toString(Matrix.identity())) {
                element.removeAttribute('transform');
            } else {
                element.setAttribute('transform', Matrix.toString(matrix));
            }
        }
    };
    applyTransforms(svgTag, inherited, 1 /* default SVG stroke width */);
};

module.exports = transformStrokeWidths;


/***/ }),

/***/ "./node_modules/scratch-svg-renderer/src/util/log.js":
/*!***********************************************************!*\
  !*** ./node_modules/scratch-svg-renderer/src/util/log.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const minilog = __webpack_require__(/*! minilog */ "minilog");
minilog.enable();

module.exports = minilog('scratch-svg-render');


/***/ }),

/***/ "./node_modules/scratch-translate-extension-languages/languages.json":
/*!***************************************************************************!*\
  !*** ./node_modules/scratch-translate-extension-languages/languages.json ***!
  \***************************************************************************/
/*! exports provided: menuMap, nameMap, scratchToGoogleMap, previouslySupported, spokenLanguages, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"menuMap\":{\"cs\":[{\"code\":\"am\",\"name\":\"amhartina\"},{\"code\":\"en\",\"name\":\"anglitina\"},{\"code\":\"ar\",\"name\":\"arabtina\"},{\"code\":\"az\",\"name\":\"zerbjdntina\"},{\"code\":\"eu\",\"name\":\"baskitina\"},{\"code\":\"bg\",\"name\":\"bulhartina\"},{\"code\":\"cs\",\"name\":\"etina\"},{\"code\":\"zh-tw\",\"name\":\"ntina (tradin)\"},{\"code\":\"zh-cn\",\"name\":\"ntina (zjednoduen)\"},{\"code\":\"da\",\"name\":\"dntina\"},{\"code\":\"et\",\"name\":\"estontina\"},{\"code\":\"fi\",\"name\":\"fintina\"},{\"code\":\"fr\",\"name\":\"francouztina\"},{\"code\":\"gl\",\"name\":\"galicijtina\"},{\"code\":\"he\",\"name\":\"hebrejtina\"},{\"code\":\"nl\",\"name\":\"holandtina\"},{\"code\":\"hr\",\"name\":\"chorvattina\"},{\"code\":\"id\",\"name\":\"indontina\"},{\"code\":\"ga\",\"name\":\"irtina\"},{\"code\":\"is\",\"name\":\"islandtina\"},{\"code\":\"it\",\"name\":\"italtina\"},{\"code\":\"ja\",\"name\":\"japontina\"},{\"code\":\"ca\",\"name\":\"katalntina\"},{\"code\":\"ko\",\"name\":\"korejtina\"},{\"code\":\"lt\",\"name\":\"litevtina\"},{\"code\":\"lv\",\"name\":\"lotytina\"},{\"code\":\"hu\",\"name\":\"maartina\"},{\"code\":\"mi\",\"name\":\"maortina\"},{\"code\":\"de\",\"name\":\"nmina\"},{\"code\":\"nb\",\"name\":\"nortina\"},{\"code\":\"fa\",\"name\":\"pertina\"},{\"code\":\"pl\",\"name\":\"poltina\"},{\"code\":\"pt\",\"name\":\"portugaltina\"},{\"code\":\"ro\",\"name\":\"rumuntina\"},{\"code\":\"ru\",\"name\":\"rutina\"},{\"code\":\"el\",\"name\":\"etina\"},{\"code\":\"gd\",\"name\":\"skotsk gaeltina\"},{\"code\":\"sk\",\"name\":\"sloventina\"},{\"code\":\"sl\",\"name\":\"slovintina\"},{\"code\":\"sr\",\"name\":\"srbtina\"},{\"code\":\"es\",\"name\":\"panltina\"},{\"code\":\"sv\",\"name\":\"vdtina\"},{\"code\":\"th\",\"name\":\"thajtina\"},{\"code\":\"tr\",\"name\":\"turetina\"},{\"code\":\"uk\",\"name\":\"ukrajintina\"},{\"code\":\"cy\",\"name\":\"veltina\"},{\"code\":\"vi\",\"name\":\"vietnamtina\"},{\"code\":\"zu\",\"name\":\"zulu\"}],\"da\":[{\"code\":\"am\",\"name\":\"Amharisk\"},{\"code\":\"ar\",\"name\":\"Arabisk\"},{\"code\":\"az\",\"name\":\"Aserbajdsjansk\"},{\"code\":\"eu\",\"name\":\"Baskisk\"},{\"code\":\"bg\",\"name\":\"Bulgarsk\"},{\"code\":\"da\",\"name\":\"Dansk\"},{\"code\":\"en\",\"name\":\"Engelsk\"},{\"code\":\"et\",\"name\":\"Estisk\"},{\"code\":\"fi\",\"name\":\"Finsk\"},{\"code\":\"fr\",\"name\":\"Fransk\"},{\"code\":\"gl\",\"name\":\"Galicisk\"},{\"code\":\"el\",\"name\":\"Grsk\"},{\"code\":\"he\",\"name\":\"Hebraisk\"},{\"code\":\"nl\",\"name\":\"Hollandsk\"},{\"code\":\"id\",\"name\":\"Indonesisk\"},{\"code\":\"ga\",\"name\":\"Irsk\"},{\"code\":\"is\",\"name\":\"Islandsk\"},{\"code\":\"it\",\"name\":\"Italiensk\"},{\"code\":\"ja\",\"name\":\"Japansk\"},{\"code\":\"ca\",\"name\":\"Katalansk\"},{\"code\":\"zh-cn\",\"name\":\"Kinesisk (forenklet)\"},{\"code\":\"zh-tw\",\"name\":\"Kinesisk (traditionelt)\"},{\"code\":\"ko\",\"name\":\"Koreansk\"},{\"code\":\"hr\",\"name\":\"Kroatisk\"},{\"code\":\"lv\",\"name\":\"Lettisk\"},{\"code\":\"lt\",\"name\":\"Litauisk\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nb\",\"name\":\"Norsk\"},{\"code\":\"fa\",\"name\":\"Persisk\"},{\"code\":\"pl\",\"name\":\"Polsk\"},{\"code\":\"pt\",\"name\":\"Portugisisk\"},{\"code\":\"ro\",\"name\":\"Rumnsk\"},{\"code\":\"ru\",\"name\":\"Russisk\"},{\"code\":\"sr\",\"name\":\"Serbisk\"},{\"code\":\"gd\",\"name\":\"Skotsk glisk\"},{\"code\":\"sk\",\"name\":\"Slovakisk\"},{\"code\":\"sl\",\"name\":\"Slovensk\"},{\"code\":\"es\",\"name\":\"Spansk\"},{\"code\":\"sv\",\"name\":\"Svensk\"},{\"code\":\"th\",\"name\":\"Thailandsk\"},{\"code\":\"cs\",\"name\":\"Tjekkisk\"},{\"code\":\"tr\",\"name\":\"Tyrkisk\"},{\"code\":\"de\",\"name\":\"Tysk\"},{\"code\":\"uk\",\"name\":\"Ukrainsk\"},{\"code\":\"hu\",\"name\":\"Ungarsk\"},{\"code\":\"vi\",\"name\":\"Vietnamesisk\"},{\"code\":\"cy\",\"name\":\"Walisisk\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"gl\":[{\"code\":\"az\",\"name\":\"acerbaixano\"},{\"code\":\"de\",\"name\":\"alemn\"},{\"code\":\"am\",\"name\":\"amrico\"},{\"code\":\"ar\",\"name\":\"rabe\"},{\"code\":\"bg\",\"name\":\"blgaro\"},{\"code\":\"ca\",\"name\":\"cataln\"},{\"code\":\"cs\",\"name\":\"checo\"},{\"code\":\"zh-cn\",\"name\":\"chins (simplificado)\"},{\"code\":\"zh-tw\",\"name\":\"chins (tradicional)\"},{\"code\":\"ko\",\"name\":\"coreano\"},{\"code\":\"hr\",\"name\":\"croata\"},{\"code\":\"da\",\"name\":\"dinamarqus\"},{\"code\":\"sk\",\"name\":\"eslovaco\"},{\"code\":\"sl\",\"name\":\"esloveno\"},{\"code\":\"es\",\"name\":\"espaol\"},{\"code\":\"et\",\"name\":\"estoniano\"},{\"code\":\"eu\",\"name\":\"uscaro\"},{\"code\":\"fi\",\"name\":\"fins\"},{\"code\":\"fr\",\"name\":\"francs\"},{\"code\":\"gd\",\"name\":\"galico escocs\"},{\"code\":\"gl\",\"name\":\"galego\"},{\"code\":\"cy\",\"name\":\"gals\"},{\"code\":\"el\",\"name\":\"grego\"},{\"code\":\"he\",\"name\":\"hebreo\"},{\"code\":\"hu\",\"name\":\"hngaro\"},{\"code\":\"id\",\"name\":\"indonesio\"},{\"code\":\"en\",\"name\":\"ingls\"},{\"code\":\"ga\",\"name\":\"irlands\"},{\"code\":\"is\",\"name\":\"islands\"},{\"code\":\"it\",\"name\":\"italiano\"},{\"code\":\"lv\",\"name\":\"letn\"},{\"code\":\"lt\",\"name\":\"lituano\"},{\"code\":\"mi\",\"name\":\"maor\"},{\"code\":\"nl\",\"name\":\"neerlands\"},{\"code\":\"nb\",\"name\":\"noruegus\"},{\"code\":\"fa\",\"name\":\"persa\"},{\"code\":\"pl\",\"name\":\"polaco\"},{\"code\":\"pt\",\"name\":\"portugus\"},{\"code\":\"ro\",\"name\":\"romans\"},{\"code\":\"ru\",\"name\":\"ruso\"},{\"code\":\"sr\",\"name\":\"serbio\"},{\"code\":\"sv\",\"name\":\"sueco\"},{\"code\":\"th\",\"name\":\"tailands\"},{\"code\":\"tr\",\"name\":\"turco\"},{\"code\":\"uk\",\"name\":\"ucrano\"},{\"code\":\"vi\",\"name\":\"vietnamita\"},{\"code\":\"ja\",\"name\":\"xapons\"},{\"code\":\"zu\",\"name\":\"zul\"}],\"sl\":[{\"code\":\"am\",\"name\":\"amharina\"},{\"code\":\"en\",\"name\":\"angleina\"},{\"code\":\"ar\",\"name\":\"arabina\"},{\"code\":\"az\",\"name\":\"azerbajdanina\"},{\"code\":\"eu\",\"name\":\"baskovina\"},{\"code\":\"bg\",\"name\":\"bolgarina\"},{\"code\":\"cs\",\"name\":\"eina\"},{\"code\":\"da\",\"name\":\"danina\"},{\"code\":\"et\",\"name\":\"estonina\"},{\"code\":\"fi\",\"name\":\"finina\"},{\"code\":\"fr\",\"name\":\"francoina\"},{\"code\":\"gl\",\"name\":\"galicijina\"},{\"code\":\"el\",\"name\":\"grina\"},{\"code\":\"he\",\"name\":\"hebrejina\"},{\"code\":\"hr\",\"name\":\"hrvaina\"},{\"code\":\"id\",\"name\":\"indonezijina\"},{\"code\":\"ga\",\"name\":\"irina\"},{\"code\":\"is\",\"name\":\"islandina\"},{\"code\":\"it\",\"name\":\"italijanina\"},{\"code\":\"ja\",\"name\":\"japonina\"},{\"code\":\"ca\",\"name\":\"katalonina\"},{\"code\":\"zh-cn\",\"name\":\"kitajina (poenostavljena)\"},{\"code\":\"zh-tw\",\"name\":\"kitajina (tradicionalna)\"},{\"code\":\"ko\",\"name\":\"korejina\"},{\"code\":\"lv\",\"name\":\"latvijina\"},{\"code\":\"lt\",\"name\":\"litovina\"},{\"code\":\"hu\",\"name\":\"madarina\"},{\"code\":\"mi\",\"name\":\"maorina\"},{\"code\":\"de\",\"name\":\"nemina\"},{\"code\":\"nl\",\"name\":\"nizozemina\"},{\"code\":\"nb\",\"name\":\"norveina\"},{\"code\":\"fa\",\"name\":\"perzijina\"},{\"code\":\"pl\",\"name\":\"poljina\"},{\"code\":\"pt\",\"name\":\"portugalina\"},{\"code\":\"ro\",\"name\":\"romunina\"},{\"code\":\"ru\",\"name\":\"ruina\"},{\"code\":\"sk\",\"name\":\"slovaina\"},{\"code\":\"sl\",\"name\":\"slovenina\"},{\"code\":\"sr\",\"name\":\"srbina\"},{\"code\":\"gd\",\"name\":\"kotska gelina\"},{\"code\":\"es\",\"name\":\"panina\"},{\"code\":\"sv\",\"name\":\"vedina\"},{\"code\":\"th\",\"name\":\"tajina\"},{\"code\":\"tr\",\"name\":\"turina\"},{\"code\":\"uk\",\"name\":\"ukrajinina\"},{\"code\":\"cy\",\"name\":\"valianina\"},{\"code\":\"vi\",\"name\":\"vietnamina\"},{\"code\":\"zu\",\"name\":\"zulujina\"}],\"fr\":[{\"code\":\"de\",\"name\":\"Allemand\"},{\"code\":\"am\",\"name\":\"Amharique\"},{\"code\":\"en\",\"name\":\"Anglais\"},{\"code\":\"ar\",\"name\":\"Arabe\"},{\"code\":\"az\",\"name\":\"Azri\"},{\"code\":\"eu\",\"name\":\"Basque\"},{\"code\":\"bg\",\"name\":\"Bulgare\"},{\"code\":\"ca\",\"name\":\"Catalan\"},{\"code\":\"zh-cn\",\"name\":\"Chinois (simplifi)\"},{\"code\":\"zh-tw\",\"name\":\"Chinois (traditionnel)\"},{\"code\":\"ko\",\"name\":\"Coren\"},{\"code\":\"hr\",\"name\":\"Croate\"},{\"code\":\"da\",\"name\":\"Danois\"},{\"code\":\"es\",\"name\":\"Espagnol\"},{\"code\":\"et\",\"name\":\"Estonien\"},{\"code\":\"fi\",\"name\":\"Finnois\"},{\"code\":\"fr\",\"name\":\"Franais\"},{\"code\":\"gd\",\"name\":\"Galique (cosse)\"},{\"code\":\"gl\",\"name\":\"Galicien\"},{\"code\":\"cy\",\"name\":\"Gallois\"},{\"code\":\"el\",\"name\":\"Grec\"},{\"code\":\"he\",\"name\":\"Hbreu\"},{\"code\":\"hu\",\"name\":\"Hongrois\"},{\"code\":\"id\",\"name\":\"Indonsien\"},{\"code\":\"ga\",\"name\":\"Irlandais\"},{\"code\":\"is\",\"name\":\"Islandais\"},{\"code\":\"it\",\"name\":\"Italien\"},{\"code\":\"ja\",\"name\":\"Japonais\"},{\"code\":\"lv\",\"name\":\"Letton\"},{\"code\":\"lt\",\"name\":\"Lituanien\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nl\",\"name\":\"Nerlandais\"},{\"code\":\"nb\",\"name\":\"Norvgien\"},{\"code\":\"fa\",\"name\":\"Persan\"},{\"code\":\"pl\",\"name\":\"Polonais\"},{\"code\":\"pt\",\"name\":\"Portugais\"},{\"code\":\"ro\",\"name\":\"Roumain\"},{\"code\":\"ru\",\"name\":\"Russe\"},{\"code\":\"sr\",\"name\":\"Serbe\"},{\"code\":\"sk\",\"name\":\"Slovaque\"},{\"code\":\"sl\",\"name\":\"Slovne\"},{\"code\":\"sv\",\"name\":\"Sudois\"},{\"code\":\"cs\",\"name\":\"Tchque\"},{\"code\":\"th\",\"name\":\"Tha\"},{\"code\":\"tr\",\"name\":\"Turc\"},{\"code\":\"uk\",\"name\":\"Ukrainien\"},{\"code\":\"vi\",\"name\":\"Vietnamien\"},{\"code\":\"zu\",\"name\":\"Zoulou\"}],\"hu\":[{\"code\":\"am\",\"name\":\"amhara\"},{\"code\":\"en\",\"name\":\"angol\"},{\"code\":\"ar\",\"name\":\"arab\"},{\"code\":\"az\",\"name\":\"azeri\"},{\"code\":\"eu\",\"name\":\"baszk\"},{\"code\":\"bg\",\"name\":\"bolgr\"},{\"code\":\"cs\",\"name\":\"cseh\"},{\"code\":\"da\",\"name\":\"dn\"},{\"code\":\"et\",\"name\":\"szt\"},{\"code\":\"fi\",\"name\":\"finn\"},{\"code\":\"fr\",\"name\":\"francia\"},{\"code\":\"gl\",\"name\":\"galciai\"},{\"code\":\"el\",\"name\":\"grg\"},{\"code\":\"he\",\"name\":\"hber\"},{\"code\":\"nl\",\"name\":\"holland\"},{\"code\":\"hr\",\"name\":\"horvt\"},{\"code\":\"id\",\"name\":\"indonz\"},{\"code\":\"ga\",\"name\":\"r\"},{\"code\":\"is\",\"name\":\"izlandi\"},{\"code\":\"ja\",\"name\":\"japn\"},{\"code\":\"ca\",\"name\":\"kataln\"},{\"code\":\"zh-cn\",\"name\":\"knai (egyszerstett)\"},{\"code\":\"zh-tw\",\"name\":\"knai (hagyomnyos)\"},{\"code\":\"ko\",\"name\":\"koreai\"},{\"code\":\"pl\",\"name\":\"lengyel\"},{\"code\":\"lv\",\"name\":\"lett\"},{\"code\":\"lt\",\"name\":\"litvn\"},{\"code\":\"hu\",\"name\":\"magyar\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"de\",\"name\":\"nmet\"},{\"code\":\"nb\",\"name\":\"norvg\"},{\"code\":\"it\",\"name\":\"olasz\"},{\"code\":\"ru\",\"name\":\"orosz\"},{\"code\":\"fa\",\"name\":\"perzsa\"},{\"code\":\"pt\",\"name\":\"portugl\"},{\"code\":\"ro\",\"name\":\"romn\"},{\"code\":\"gd\",\"name\":\"skt-gael\"},{\"code\":\"es\",\"name\":\"spanyol\"},{\"code\":\"sv\",\"name\":\"svd\"},{\"code\":\"sr\",\"name\":\"szerb\"},{\"code\":\"sk\",\"name\":\"szlovk\"},{\"code\":\"sl\",\"name\":\"szlovn\"},{\"code\":\"th\",\"name\":\"thai\"},{\"code\":\"tr\",\"name\":\"trk\"},{\"code\":\"uk\",\"name\":\"ukrn\"},{\"code\":\"vi\",\"name\":\"vietnami\"},{\"code\":\"cy\",\"name\":\"walesi\"},{\"code\":\"zu\",\"name\":\"zulu\"}],\"uk\":[{\"code\":\"az\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"zh-tw\",\"name\":\" ()\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" ()\"},{\"code\":\"ja\",\"name\":\"\"}],\"zh-tw\":[{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"zh-tw\",\"name\":\"()\"},{\"code\":\"zh-cn\",\"name\":\"()\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"ja\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"az\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\"\"}],\"pt\":[{\"code\":\"am\",\"name\":\"Amharic\"},{\"code\":\"ar\",\"name\":\"Arabic\"},{\"code\":\"az\",\"name\":\"Azerbaijani\"},{\"code\":\"eu\",\"name\":\"Basque\"},{\"code\":\"bg\",\"name\":\"Bulgarian\"},{\"code\":\"ca\",\"name\":\"Catalan\"},{\"code\":\"zh-cn\",\"name\":\"Chinese (Simplified)\"},{\"code\":\"zh-tw\",\"name\":\"Chinese (Traditional)\"},{\"code\":\"hr\",\"name\":\"Croatian\"},{\"code\":\"cs\",\"name\":\"Czech\"},{\"code\":\"da\",\"name\":\"Danish\"},{\"code\":\"nl\",\"name\":\"Dutch\"},{\"code\":\"en\",\"name\":\"English\"},{\"code\":\"et\",\"name\":\"Estonian\"},{\"code\":\"fi\",\"name\":\"Finnish\"},{\"code\":\"fr\",\"name\":\"French\"},{\"code\":\"gl\",\"name\":\"Galician\"},{\"code\":\"de\",\"name\":\"German\"},{\"code\":\"el\",\"name\":\"Greek\"},{\"code\":\"he\",\"name\":\"Hebrew\"},{\"code\":\"hu\",\"name\":\"Hungarian\"},{\"code\":\"is\",\"name\":\"Icelandic\"},{\"code\":\"id\",\"name\":\"Indonesian\"},{\"code\":\"ga\",\"name\":\"Irish\"},{\"code\":\"it\",\"name\":\"Italian\"},{\"code\":\"ja\",\"name\":\"Japanese\"},{\"code\":\"ko\",\"name\":\"Korean\"},{\"code\":\"lv\",\"name\":\"Latvian\"},{\"code\":\"lt\",\"name\":\"Lithuanian\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nb\",\"name\":\"Norwegian\"},{\"code\":\"fa\",\"name\":\"Persian\"},{\"code\":\"pl\",\"name\":\"Polish\"},{\"code\":\"pt\",\"name\":\"Portuguese\"},{\"code\":\"ro\",\"name\":\"Romanian\"},{\"code\":\"ru\",\"name\":\"Russian\"},{\"code\":\"gd\",\"name\":\"Scots Gaelic\"},{\"code\":\"sr\",\"name\":\"Serbian\"},{\"code\":\"sk\",\"name\":\"Slovak\"},{\"code\":\"sl\",\"name\":\"Slovenian\"},{\"code\":\"es\",\"name\":\"Spanish\"},{\"code\":\"sv\",\"name\":\"Swedish\"},{\"code\":\"th\",\"name\":\"Thai\"},{\"code\":\"tr\",\"name\":\"Turkish\"},{\"code\":\"uk\",\"name\":\"Ukrainian\"},{\"code\":\"vi\",\"name\":\"Vietnamese\"},{\"code\":\"cy\",\"name\":\"Welsh\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"pt-br\":[{\"code\":\"de\",\"name\":\"Alemo\"},{\"code\":\"am\",\"name\":\"Amrico\"},{\"code\":\"ar\",\"name\":\"rabe\"},{\"code\":\"az\",\"name\":\"Azerbaijano\"},{\"code\":\"eu\",\"name\":\"Basco\"},{\"code\":\"bg\",\"name\":\"Blgaro\"},{\"code\":\"ca\",\"name\":\"Catalo\"},{\"code\":\"zh-cn\",\"name\":\"Chins (simplificado)\"},{\"code\":\"zh-tw\",\"name\":\"Chins (tradicional)\"},{\"code\":\"ko\",\"name\":\"Coreano\"},{\"code\":\"hr\",\"name\":\"Croata\"},{\"code\":\"da\",\"name\":\"Dinamarqus\"},{\"code\":\"sk\",\"name\":\"Eslovaco\"},{\"code\":\"sl\",\"name\":\"Esloveno\"},{\"code\":\"es\",\"name\":\"Espanhol\"},{\"code\":\"et\",\"name\":\"Estoniano\"},{\"code\":\"fi\",\"name\":\"Finlands\"},{\"code\":\"fr\",\"name\":\"Francs\"},{\"code\":\"gd\",\"name\":\"Galico escocs\"},{\"code\":\"gl\",\"name\":\"Galego\"},{\"code\":\"cy\",\"name\":\"Gals\"},{\"code\":\"el\",\"name\":\"Grego\"},{\"code\":\"he\",\"name\":\"Hebraico\"},{\"code\":\"nl\",\"name\":\"Holands\"},{\"code\":\"hu\",\"name\":\"Hngaro\"},{\"code\":\"id\",\"name\":\"Indonsio\"},{\"code\":\"en\",\"name\":\"Ingls\"},{\"code\":\"ga\",\"name\":\"Irlands\"},{\"code\":\"is\",\"name\":\"Islands\"},{\"code\":\"it\",\"name\":\"Italiano\"},{\"code\":\"ja\",\"name\":\"Japons\"},{\"code\":\"lv\",\"name\":\"Leto\"},{\"code\":\"lt\",\"name\":\"Lituano\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nb\",\"name\":\"Noruegus\"},{\"code\":\"fa\",\"name\":\"Persa\"},{\"code\":\"pl\",\"name\":\"Polons\"},{\"code\":\"pt\",\"name\":\"Portugus\"},{\"code\":\"ro\",\"name\":\"Romeno\"},{\"code\":\"ru\",\"name\":\"Russo\"},{\"code\":\"sr\",\"name\":\"Srvio\"},{\"code\":\"sv\",\"name\":\"Sueco\"},{\"code\":\"th\",\"name\":\"Tailands\"},{\"code\":\"cs\",\"name\":\"Tcheco\"},{\"code\":\"tr\",\"name\":\"Turco\"},{\"code\":\"uk\",\"name\":\"Ucraniano\"},{\"code\":\"vi\",\"name\":\"Vietnamita\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"tr\":[{\"code\":\"de\",\"name\":\"Almanca\"},{\"code\":\"ar\",\"name\":\"Arapa\"},{\"code\":\"az\",\"name\":\"Azerice\"},{\"code\":\"eu\",\"name\":\"Baska\"},{\"code\":\"bg\",\"name\":\"Bulgarca\"},{\"code\":\"cs\",\"name\":\"eke\"},{\"code\":\"zh-cn\",\"name\":\"ince (Basitletirilmi)\"},{\"code\":\"zh-tw\",\"name\":\"ince (Geleneksel)\"},{\"code\":\"da\",\"name\":\"Danca\"},{\"code\":\"id\",\"name\":\"Endonezya Dili\"},{\"code\":\"et\",\"name\":\"Estonyaca\"},{\"code\":\"fa\",\"name\":\"Farsa\"},{\"code\":\"nl\",\"name\":\"Felemenke\"},{\"code\":\"fi\",\"name\":\"Fince\"},{\"code\":\"fr\",\"name\":\"Franszca\"},{\"code\":\"cy\",\"name\":\"Galce\"},{\"code\":\"gl\",\"name\":\"Galiyaca\"},{\"code\":\"am\",\"name\":\"Habee\"},{\"code\":\"hr\",\"name\":\"Hrvata\"},{\"code\":\"he\",\"name\":\"branice\"},{\"code\":\"en\",\"name\":\"ngilizce\"},{\"code\":\"ga\",\"name\":\"rlandaca\"},{\"code\":\"es\",\"name\":\"spanyolca\"},{\"code\":\"sv\",\"name\":\"svee\"},{\"code\":\"it\",\"name\":\"talyanca\"},{\"code\":\"is\",\"name\":\"zlandaca\"},{\"code\":\"ja\",\"name\":\"Japonca\"},{\"code\":\"ca\",\"name\":\"Katalanca\"},{\"code\":\"ko\",\"name\":\"Korece\"},{\"code\":\"gd\",\"name\":\"Kuzey sko Dili\"},{\"code\":\"pl\",\"name\":\"Lehe\"},{\"code\":\"lv\",\"name\":\"Letonca\"},{\"code\":\"lt\",\"name\":\"Litvanca\"},{\"code\":\"hu\",\"name\":\"Macarca\"},{\"code\":\"mi\",\"name\":\"Maori Dili\"},{\"code\":\"nb\",\"name\":\"Norvee\"},{\"code\":\"pt\",\"name\":\"Portekizce\"},{\"code\":\"ro\",\"name\":\"Romence\"},{\"code\":\"ru\",\"name\":\"Rusa\"},{\"code\":\"sr\",\"name\":\"Srpa\"},{\"code\":\"sk\",\"name\":\"Slovaka\"},{\"code\":\"sl\",\"name\":\"Slovence\"},{\"code\":\"th\",\"name\":\"Tay Dili\"},{\"code\":\"tr\",\"name\":\"Trke\"},{\"code\":\"uk\",\"name\":\"Ukraynaca\"},{\"code\":\"vi\",\"name\":\"Vietnamca\"},{\"code\":\"el\",\"name\":\"Yunanca\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"ga\":[{\"code\":\"am\",\"name\":\"Amrais\"},{\"code\":\"ar\",\"name\":\"Araibis\"},{\"code\":\"az\",\"name\":\"Asarbaiseinis\"},{\"code\":\"eu\",\"name\":\"Bascais\"},{\"code\":\"en\",\"name\":\"Barla\"},{\"code\":\"cy\",\"name\":\"Breatnais\"},{\"code\":\"bg\",\"name\":\"Bulgiris\"},{\"code\":\"ca\",\"name\":\"Catalinis\"},{\"code\":\"ko\",\"name\":\"Ciris\"},{\"code\":\"hr\",\"name\":\"Critis\"},{\"code\":\"da\",\"name\":\"Danmhairgis\"},{\"code\":\"he\",\"name\":\"Eabhrais\"},{\"code\":\"et\",\"name\":\"Eastinis\"},{\"code\":\"fi\",\"name\":\"Fionlainnis\"},{\"code\":\"fr\",\"name\":\"Fraincis\"},{\"code\":\"ga\",\"name\":\"Gaeilge\"},{\"code\":\"gd\",\"name\":\"Gaeilge na hAlban\"},{\"code\":\"gl\",\"name\":\"Gailsis\"},{\"code\":\"de\",\"name\":\"Gearminis\"},{\"code\":\"el\",\"name\":\"Grigis\"},{\"code\":\"id\",\"name\":\"Indinisis\"},{\"code\":\"it\",\"name\":\"Iodilis\"},{\"code\":\"nb\",\"name\":\"Ioruais\"},{\"code\":\"is\",\"name\":\"oslainnis\"},{\"code\":\"lv\",\"name\":\"Laitvis\"},{\"code\":\"lt\",\"name\":\"Liotuinis\"},{\"code\":\"mi\",\"name\":\"Maorais\"},{\"code\":\"nl\",\"name\":\"Ollainnis\"},{\"code\":\"fa\",\"name\":\"Peirsis\"},{\"code\":\"pl\",\"name\":\"Polainnis\"},{\"code\":\"pt\",\"name\":\"Portaingilis\"},{\"code\":\"ro\",\"name\":\"Rminis\"},{\"code\":\"ru\",\"name\":\"Risis\"},{\"code\":\"ja\",\"name\":\"Seapinis\"},{\"code\":\"cs\",\"name\":\"Seicis\"},{\"code\":\"sr\",\"name\":\"Seirbis\"},{\"code\":\"zh-cn\",\"name\":\"Snis (Simplithe)\"},{\"code\":\"zh-tw\",\"name\":\"Snis (Traidisinta)\"},{\"code\":\"sl\",\"name\":\"Slivinis\"},{\"code\":\"sk\",\"name\":\"Slvaicis\"},{\"code\":\"es\",\"name\":\"Spinnis\"},{\"code\":\"sv\",\"name\":\"Sualainnis\"},{\"code\":\"zu\",\"name\":\"Slis\"},{\"code\":\"th\",\"name\":\"Talainnis\"},{\"code\":\"tr\",\"name\":\"Tuircis\"},{\"code\":\"uk\",\"name\":\"crinis\"},{\"code\":\"hu\",\"name\":\"Ungiris\"},{\"code\":\"vi\",\"name\":\"Vtneaimis\"}],\"th\":[{\"code\":\"el\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\"\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"zh-tw\",\"name\":\" ()\"},{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"ja\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"az\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"}],\"ja\":[{\"code\":\"is\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"az\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" \"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"zh-cn\",\"name\":\"()\"},{\"code\":\"zh-tw\",\"name\":\"()\"},{\"code\":\"ja\",\"name\":\"\"}],\"ja-hira\":[{\"code\":\"is\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"az\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" \"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"zh-cn\",\"name\":\"()\"},{\"code\":\"zh-tw\",\"name\":\"()\"},{\"code\":\"ja\",\"name\":\"\"}],\"nl\":[{\"code\":\"am\",\"name\":\"Amharisch\"},{\"code\":\"ar\",\"name\":\"Arabisch\"},{\"code\":\"az\",\"name\":\"Azerbeidzjaans\"},{\"code\":\"eu\",\"name\":\"Baskisch\"},{\"code\":\"bg\",\"name\":\"Bulgaars\"},{\"code\":\"ca\",\"name\":\"Catalaans\"},{\"code\":\"zh-tw\",\"name\":\"Chinees (traditioneel)\"},{\"code\":\"zh-cn\",\"name\":\"Chinees (vereenvoudigd)\"},{\"code\":\"da\",\"name\":\"Deens\"},{\"code\":\"de\",\"name\":\"Duits\"},{\"code\":\"en\",\"name\":\"Engels\"},{\"code\":\"et\",\"name\":\"Ests\"},{\"code\":\"fi\",\"name\":\"Fins\"},{\"code\":\"fr\",\"name\":\"Frans\"},{\"code\":\"gl\",\"name\":\"Galicisch\"},{\"code\":\"el\",\"name\":\"Grieks\"},{\"code\":\"he\",\"name\":\"Hebreeuws\"},{\"code\":\"hu\",\"name\":\"Hongaars\"},{\"code\":\"ga\",\"name\":\"Iers\"},{\"code\":\"is\",\"name\":\"IJslands\"},{\"code\":\"id\",\"name\":\"Indonesisch\"},{\"code\":\"it\",\"name\":\"Italiaans\"},{\"code\":\"ja\",\"name\":\"Japans\"},{\"code\":\"ko\",\"name\":\"Koreaans\"},{\"code\":\"hr\",\"name\":\"Kroatisch\"},{\"code\":\"lv\",\"name\":\"Lets\"},{\"code\":\"lt\",\"name\":\"Litouws\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nl\",\"name\":\"Nederlands\"},{\"code\":\"nb\",\"name\":\"Noors\"},{\"code\":\"uk\",\"name\":\"Oekraens\"},{\"code\":\"fa\",\"name\":\"Perzisch\"},{\"code\":\"pl\",\"name\":\"Pools\"},{\"code\":\"pt\",\"name\":\"Portugees\"},{\"code\":\"ro\",\"name\":\"Roemeens\"},{\"code\":\"ru\",\"name\":\"Russisch\"},{\"code\":\"gd\",\"name\":\"Schots Keltisch\"},{\"code\":\"sr\",\"name\":\"Servisch\"},{\"code\":\"sk\",\"name\":\"Slovaaks\"},{\"code\":\"sl\",\"name\":\"Sloveens\"},{\"code\":\"es\",\"name\":\"Spaans\"},{\"code\":\"th\",\"name\":\"Thai\"},{\"code\":\"cs\",\"name\":\"Tsjechisch\"},{\"code\":\"tr\",\"name\":\"Turks\"},{\"code\":\"vi\",\"name\":\"Vietnamees\"},{\"code\":\"cy\",\"name\":\"Wels\"},{\"code\":\"zu\",\"name\":\"Zoeloe\"},{\"code\":\"sv\",\"name\":\"Zweeds\"}],\"gd\":[{\"code\":\"am\",\"name\":\"Amtharais\"},{\"code\":\"ar\",\"name\":\"Arabais\"},{\"code\":\"az\",\"name\":\"Asarbaidenais\"},{\"code\":\"eu\",\"name\":\"Basgais\"},{\"code\":\"en\",\"name\":\"Beurla\"},{\"code\":\"vi\",\"name\":\"Bhiet-Namais\"},{\"code\":\"bg\",\"name\":\"Bulgarais\"},{\"code\":\"th\",\"name\":\"Cnan nan Tidh\"},{\"code\":\"ca\",\"name\":\"Catalanais\"},{\"code\":\"ko\",\"name\":\"Coiranais\"},{\"code\":\"hr\",\"name\":\"Crthaisis\"},{\"code\":\"cy\",\"name\":\"Cuimris\"},{\"code\":\"da\",\"name\":\"Danmhairgis\"},{\"code\":\"nl\",\"name\":\"Duitsis\"},{\"code\":\"he\",\"name\":\"Eabhra\"},{\"code\":\"it\",\"name\":\"Eadailtis\"},{\"code\":\"et\",\"name\":\"Eastoinis\"},{\"code\":\"fi\",\"name\":\"Fionnlannais\"},{\"code\":\"fr\",\"name\":\"Fraingis\"},{\"code\":\"ga\",\"name\":\"Gaeilge\"},{\"code\":\"gd\",\"name\":\"Gidhlig\"},{\"code\":\"gl\",\"name\":\"Gailsis\"},{\"code\":\"de\",\"name\":\"Gearmailtis\"},{\"code\":\"el\",\"name\":\"Grigis\"},{\"code\":\"id\",\"name\":\"Innd-Innsis\"},{\"code\":\"is\",\"name\":\"Innis-Tlis\"},{\"code\":\"lv\",\"name\":\"Laitbheis\"},{\"code\":\"lt\",\"name\":\"Liotuainis\"},{\"code\":\"mi\",\"name\":\"Mori\"},{\"code\":\"nb\",\"name\":\"Nirribhis\"},{\"code\":\"fa\",\"name\":\"Peirsis\"},{\"code\":\"pl\",\"name\":\"Plainnis\"},{\"code\":\"pt\",\"name\":\"Portagailis\"},{\"code\":\"ro\",\"name\":\"Rominis\"},{\"code\":\"ru\",\"name\":\"Ruisis\"},{\"code\":\"cs\",\"name\":\"Seacais\"},{\"code\":\"ja\",\"name\":\"Seapanais\"},{\"code\":\"sr\",\"name\":\"Sirbis\"},{\"code\":\"zh-tw\",\"name\":\"Sonais (seann-nsach)\"},{\"code\":\"zh-cn\",\"name\":\"Sonais (smplichte)\"},{\"code\":\"sk\",\"name\":\"Slbhacais\"},{\"code\":\"sl\",\"name\":\"Slbhainis\"},{\"code\":\"es\",\"name\":\"Spinntis\"},{\"code\":\"sv\",\"name\":\"Suainis\"},{\"code\":\"tr\",\"name\":\"Turcais\"},{\"code\":\"uk\",\"name\":\"Ucrinis\"},{\"code\":\"hu\",\"name\":\"Ungairis\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"nb\":[{\"code\":\"am\",\"name\":\"amharisk\"},{\"code\":\"ar\",\"name\":\"arabisk\"},{\"code\":\"az\",\"name\":\"aserbajdsjansk\"},{\"code\":\"eu\",\"name\":\"baskisk\"},{\"code\":\"bg\",\"name\":\"bulgarsk\"},{\"code\":\"da\",\"name\":\"dansk\"},{\"code\":\"en\",\"name\":\"engelsk\"},{\"code\":\"et\",\"name\":\"estisk\"},{\"code\":\"fa\",\"name\":\"farsi\"},{\"code\":\"fi\",\"name\":\"finsk\"},{\"code\":\"fr\",\"name\":\"fransk\"},{\"code\":\"gl\",\"name\":\"galisisk\"},{\"code\":\"el\",\"name\":\"gresk\"},{\"code\":\"he\",\"name\":\"hebraisk\"},{\"code\":\"id\",\"name\":\"indonesisk\"},{\"code\":\"ga\",\"name\":\"irsk\"},{\"code\":\"is\",\"name\":\"islandsk\"},{\"code\":\"it\",\"name\":\"italiensk\"},{\"code\":\"ja\",\"name\":\"japansk\"},{\"code\":\"ca\",\"name\":\"katalansk\"},{\"code\":\"zh-cn\",\"name\":\"kinesisk (forenklet)\"},{\"code\":\"zh-tw\",\"name\":\"kinesisk (tradisjonell)\"},{\"code\":\"ko\",\"name\":\"koreansk\"},{\"code\":\"hr\",\"name\":\"kroatisk\"},{\"code\":\"lv\",\"name\":\"latvisk\"},{\"code\":\"lt\",\"name\":\"litauisk\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"nl\",\"name\":\"nederlandsk\"},{\"code\":\"nb\",\"name\":\"norsk\"},{\"code\":\"pl\",\"name\":\"polsk\"},{\"code\":\"pt\",\"name\":\"portugisisk\"},{\"code\":\"ro\",\"name\":\"rumensk\"},{\"code\":\"ru\",\"name\":\"russisk\"},{\"code\":\"sr\",\"name\":\"serbisk\"},{\"code\":\"gd\",\"name\":\"skotsk glisk\"},{\"code\":\"sk\",\"name\":\"slovakisk\"},{\"code\":\"sl\",\"name\":\"slovensk\"},{\"code\":\"es\",\"name\":\"spansk\"},{\"code\":\"sv\",\"name\":\"svensk\"},{\"code\":\"th\",\"name\":\"thai\"},{\"code\":\"cs\",\"name\":\"tsjekkisk\"},{\"code\":\"tr\",\"name\":\"tyrkisk\"},{\"code\":\"de\",\"name\":\"tysk\"},{\"code\":\"uk\",\"name\":\"ukrainsk\"},{\"code\":\"hu\",\"name\":\"ungarsk\"},{\"code\":\"vi\",\"name\":\"vietnamesisk\"},{\"code\":\"cy\",\"name\":\"walisisk\"},{\"code\":\"zu\",\"name\":\"zulu\"}],\"de\":[{\"code\":\"am\",\"name\":\"Amharisch\"},{\"code\":\"ar\",\"name\":\"Arabisch\"},{\"code\":\"az\",\"name\":\"Aserbaidschanisch\"},{\"code\":\"eu\",\"name\":\"Baskisch\"},{\"code\":\"bg\",\"name\":\"Bulgarisch\"},{\"code\":\"zh-tw\",\"name\":\"Chinesisch (traditionell)\"},{\"code\":\"zh-cn\",\"name\":\"Chinesisch (vereinfacht)\"},{\"code\":\"da\",\"name\":\"Dnisch\"},{\"code\":\"de\",\"name\":\"Deutsch\"},{\"code\":\"en\",\"name\":\"Englisch\"},{\"code\":\"et\",\"name\":\"Estnisch\"},{\"code\":\"fi\",\"name\":\"Finnisch\"},{\"code\":\"fr\",\"name\":\"Franzsisch\"},{\"code\":\"gl\",\"name\":\"Galizisch\"},{\"code\":\"el\",\"name\":\"Griechisch\"},{\"code\":\"he\",\"name\":\"Hebrisch\"},{\"code\":\"id\",\"name\":\"Indonesisch\"},{\"code\":\"ga\",\"name\":\"Irisch\"},{\"code\":\"is\",\"name\":\"Islndisch\"},{\"code\":\"it\",\"name\":\"Italienisch\"},{\"code\":\"ja\",\"name\":\"Japanisch\"},{\"code\":\"ca\",\"name\":\"Katalanisch\"},{\"code\":\"ko\",\"name\":\"Koreanisch\"},{\"code\":\"hr\",\"name\":\"Kroatisch\"},{\"code\":\"lv\",\"name\":\"Lettisch\"},{\"code\":\"lt\",\"name\":\"Litauisch\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nl\",\"name\":\"Niederlndisch\"},{\"code\":\"nb\",\"name\":\"Norwegisch\"},{\"code\":\"fa\",\"name\":\"Persisch\"},{\"code\":\"pl\",\"name\":\"Polnisch\"},{\"code\":\"pt\",\"name\":\"Portugiesisch\"},{\"code\":\"ro\",\"name\":\"Rumnisch\"},{\"code\":\"ru\",\"name\":\"Russisch\"},{\"code\":\"gd\",\"name\":\"Schottisch-Glisch\"},{\"code\":\"sv\",\"name\":\"Schwedisch\"},{\"code\":\"sr\",\"name\":\"Serbisch\"},{\"code\":\"sk\",\"name\":\"Slowakisch\"},{\"code\":\"sl\",\"name\":\"Slowenisch\"},{\"code\":\"es\",\"name\":\"Spanisch\"},{\"code\":\"th\",\"name\":\"Thailndisch\"},{\"code\":\"cs\",\"name\":\"Tschechisch\"},{\"code\":\"tr\",\"name\":\"Trkisch\"},{\"code\":\"uk\",\"name\":\"Ukrainisch\"},{\"code\":\"hu\",\"name\":\"Ungarisch\"},{\"code\":\"vi\",\"name\":\"Vietnamesisch\"},{\"code\":\"cy\",\"name\":\"Walisisch\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"he\":[{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"az\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"ja\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"zh-tw\",\"name\":\" ()\"},{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" \"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"cs\",\"name\":\"'\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"}],\"sk\":[{\"code\":\"am\",\"name\":\"amharina\"},{\"code\":\"en\",\"name\":\"anglitina\"},{\"code\":\"ar\",\"name\":\"arabina\"},{\"code\":\"az\",\"name\":\"azerbajdanina\"},{\"code\":\"eu\",\"name\":\"baskitina\"},{\"code\":\"bg\",\"name\":\"bulharina\"},{\"code\":\"cs\",\"name\":\"etina\"},{\"code\":\"zh-tw\",\"name\":\"ntina (tradin)\"},{\"code\":\"zh-cn\",\"name\":\"ntina (zjednoduen)\"},{\"code\":\"da\",\"name\":\"dnina\"},{\"code\":\"et\",\"name\":\"estnina\"},{\"code\":\"fi\",\"name\":\"fnina\"},{\"code\":\"fr\",\"name\":\"francztina\"},{\"code\":\"gl\",\"name\":\"galcijina\"},{\"code\":\"el\",\"name\":\"grtina\"},{\"code\":\"he\",\"name\":\"hebrejina\"},{\"code\":\"nl\",\"name\":\"holandina\"},{\"code\":\"hr\",\"name\":\"chorvtina\"},{\"code\":\"id\",\"name\":\"indonztina\"},{\"code\":\"ga\",\"name\":\"rina\"},{\"code\":\"is\",\"name\":\"islandina\"},{\"code\":\"ja\",\"name\":\"japonina\"},{\"code\":\"ca\",\"name\":\"katalnina\"},{\"code\":\"ko\",\"name\":\"krejina\"},{\"code\":\"lt\",\"name\":\"litovina\"},{\"code\":\"lv\",\"name\":\"lotytina\"},{\"code\":\"hu\",\"name\":\"maarina\"},{\"code\":\"mi\",\"name\":\"maorijina\"},{\"code\":\"de\",\"name\":\"nemina\"},{\"code\":\"nb\",\"name\":\"nrina\"},{\"code\":\"fa\",\"name\":\"perztina\"},{\"code\":\"pl\",\"name\":\"potina\"},{\"code\":\"pt\",\"name\":\"portugalina\"},{\"code\":\"ro\",\"name\":\"rumunina\"},{\"code\":\"ru\",\"name\":\"rutina\"},{\"code\":\"sk\",\"name\":\"slovenina\"},{\"code\":\"sl\",\"name\":\"slovinina\"},{\"code\":\"sr\",\"name\":\"srbina\"},{\"code\":\"gd\",\"name\":\"ktska gaelina\"},{\"code\":\"es\",\"name\":\"panielina\"},{\"code\":\"sv\",\"name\":\"vdina\"},{\"code\":\"it\",\"name\":\"talianina\"},{\"code\":\"th\",\"name\":\"thajina\"},{\"code\":\"tr\",\"name\":\"turetina\"},{\"code\":\"uk\",\"name\":\"ukrajinina\"},{\"code\":\"vi\",\"name\":\"vietnamina\"},{\"code\":\"cy\",\"name\":\"waletina\"},{\"code\":\"zu\",\"name\":\"zulutina\"}],\"zu\":[{\"code\":\"am\",\"name\":\"isi-Amharic\"},{\"code\":\"ar\",\"name\":\"isi-Arabic\"},{\"code\":\"az\",\"name\":\"Isi-Azerbaijani\"},{\"code\":\"eu\",\"name\":\"isi-Basque\"},{\"code\":\"bg\",\"name\":\"isi-Bulgarian\"},{\"code\":\"ca\",\"name\":\"isi-Catalan\"},{\"code\":\"zh-cn\",\"name\":\"isi-Chinese (Simplified)\"},{\"code\":\"zh-tw\",\"name\":\"isi-Chinese (Traditional)\"},{\"code\":\"hr\",\"name\":\"isi-Croatian\"},{\"code\":\"cs\",\"name\":\"isi-Czech\"},{\"code\":\"da\",\"name\":\"isi-Danish\"},{\"code\":\"nl\",\"name\":\"isi-Dutch\"},{\"code\":\"en\",\"name\":\"isi-English\"},{\"code\":\"et\",\"name\":\"isi-Estonian\"},{\"code\":\"fi\",\"name\":\"isi-Finnish\"},{\"code\":\"fr\",\"name\":\"isi-French\"},{\"code\":\"gl\",\"name\":\"isi-Galician\"},{\"code\":\"de\",\"name\":\"isi-German\"},{\"code\":\"el\",\"name\":\"isi-Greek\"},{\"code\":\"hu\",\"name\":\"isi-Hangarian\"},{\"code\":\"he\",\"name\":\"isi-Hebrew\"},{\"code\":\"is\",\"name\":\"isi-Icelandic\"},{\"code\":\"id\",\"name\":\"isi-Indonesian\"},{\"code\":\"ga\",\"name\":\"isi-Irish\"},{\"code\":\"it\",\"name\":\"isi-Italian\"},{\"code\":\"ja\",\"name\":\"isi-Japanese\"},{\"code\":\"ko\",\"name\":\"isi-Korean\"},{\"code\":\"lv\",\"name\":\"isi-Latvian\"},{\"code\":\"lt\",\"name\":\"isi-Lithuanian\"},{\"code\":\"mi\",\"name\":\"isi-Maori\"},{\"code\":\"nb\",\"name\":\"isi-Norwegian\"},{\"code\":\"fa\",\"name\":\"isi-Persian\"},{\"code\":\"pl\",\"name\":\"isi-Polish\"},{\"code\":\"pt\",\"name\":\"isi-Portuguese\"},{\"code\":\"ro\",\"name\":\"isi-Romanian\"},{\"code\":\"ru\",\"name\":\"isi-Russian\"},{\"code\":\"gd\",\"name\":\"isi-Scots Gaelic\"},{\"code\":\"sr\",\"name\":\"isi-Serbian\"},{\"code\":\"sk\",\"name\":\"isi-Slovak\"},{\"code\":\"sl\",\"name\":\"isi-Slovenian\"},{\"code\":\"es\",\"name\":\"isi-Spanish\"},{\"code\":\"sv\",\"name\":\"isi-Swedish\"},{\"code\":\"th\",\"name\":\"isi-Thai\"},{\"code\":\"tr\",\"name\":\"isi-Turkish\"},{\"code\":\"uk\",\"name\":\"isi-Ukrainian\"},{\"code\":\"vi\",\"name\":\"isi-Vietnamese\"},{\"code\":\"cy\",\"name\":\"isi-Welsh\"},{\"code\":\"zu\",\"name\":\"isiZulu\"}],\"ru\":[{\"code\":\"az\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"zh-tw\",\"name\":\" ()\"},{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" ()\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"ja\",\"name\":\"\"}],\"pl\":[{\"code\":\"am\",\"name\":\"amharski\"},{\"code\":\"en\",\"name\":\"angielski\"},{\"code\":\"ar\",\"name\":\"arabski\"},{\"code\":\"az\",\"name\":\"azerski\"},{\"code\":\"eu\",\"name\":\"baskijski\"},{\"code\":\"bg\",\"name\":\"bugarski\"},{\"code\":\"zh-tw\",\"name\":\"chiski (tradycyjny)\"},{\"code\":\"zh-cn\",\"name\":\"chiski (uproszczony)\"},{\"code\":\"hr\",\"name\":\"chorwacki\"},{\"code\":\"cs\",\"name\":\"czeski\"},{\"code\":\"da\",\"name\":\"duski\"},{\"code\":\"et\",\"name\":\"estoski\"},{\"code\":\"fi\",\"name\":\"fiski\"},{\"code\":\"fr\",\"name\":\"francuski\"},{\"code\":\"gl\",\"name\":\"galicyjski\"},{\"code\":\"el\",\"name\":\"grecki\"},{\"code\":\"he\",\"name\":\"hebrajski\"},{\"code\":\"es\",\"name\":\"hiszpaski\"},{\"code\":\"id\",\"name\":\"indonezyjski\"},{\"code\":\"ga\",\"name\":\"irlandzki\"},{\"code\":\"is\",\"name\":\"islandzki\"},{\"code\":\"ja\",\"name\":\"japoski\"},{\"code\":\"ca\",\"name\":\"kataloski\"},{\"code\":\"ko\",\"name\":\"koreaski\"},{\"code\":\"lt\",\"name\":\"litewski\"},{\"code\":\"lv\",\"name\":\"otewski\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"nl\",\"name\":\"niderlandzki\"},{\"code\":\"de\",\"name\":\"niemiecki\"},{\"code\":\"nb\",\"name\":\"norweski\"},{\"code\":\"fa\",\"name\":\"perski\"},{\"code\":\"pl\",\"name\":\"polski\"},{\"code\":\"pt\",\"name\":\"portugalski\"},{\"code\":\"ru\",\"name\":\"rosyjski\"},{\"code\":\"ro\",\"name\":\"rumuski\"},{\"code\":\"sr\",\"name\":\"serbski\"},{\"code\":\"sk\",\"name\":\"sowacki\"},{\"code\":\"sl\",\"name\":\"soweski\"},{\"code\":\"gd\",\"name\":\"szkocki gaelicki\"},{\"code\":\"sv\",\"name\":\"szwedzki\"},{\"code\":\"th\",\"name\":\"tajski\"},{\"code\":\"tr\",\"name\":\"turecki\"},{\"code\":\"uk\",\"name\":\"ukraiski\"},{\"code\":\"cy\",\"name\":\"walijski\"},{\"code\":\"hu\",\"name\":\"wgierski\"},{\"code\":\"vi\",\"name\":\"wietnamski\"},{\"code\":\"it\",\"name\":\"woski\"},{\"code\":\"zu\",\"name\":\"zulu\"}],\"am\":[{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"zh-cn\",\"name\":\"   ()\"},{\"code\":\"zh-tw\",\"name\":\"  ()\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"az\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" \"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"ja\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"}],\"az\":[{\"code\":\"de\",\"name\":\"Alman\"},{\"code\":\"am\",\"name\":\"Amarikc\"},{\"code\":\"az\",\"name\":\"Azrbaycan dili\"},{\"code\":\"eu\",\"name\":\"Bask\"},{\"code\":\"bg\",\"name\":\"Bolqar\"},{\"code\":\"cs\",\"name\":\"ex\"},{\"code\":\"zh-tw\",\"name\":\"in (n'nvi)\"},{\"code\":\"zh-cn\",\"name\":\"in (Sadldirilmi)\"},{\"code\":\"da\",\"name\":\"Danimarka\"},{\"code\":\"et\",\"name\":\"Eston\"},{\"code\":\"ar\",\"name\":\"rb\"},{\"code\":\"fa\",\"name\":\"Fars Dili\"},{\"code\":\"fi\",\"name\":\"Fin\"},{\"code\":\"fr\",\"name\":\"Fransz\"},{\"code\":\"nl\",\"name\":\"Holland\"},{\"code\":\"hr\",\"name\":\"Xorvat\"},{\"code\":\"es\",\"name\":\"Ispan\"},{\"code\":\"id\",\"name\":\"ndoneziya\"},{\"code\":\"en\",\"name\":\"ngilis\"},{\"code\":\"ga\",\"name\":\"rland\"},{\"code\":\"is\",\"name\":\"sland\"},{\"code\":\"sv\",\"name\":\"sve\"},{\"code\":\"it\",\"name\":\"talyan\"},{\"code\":\"he\",\"name\":\"vrit\"},{\"code\":\"ca\",\"name\":\"Katalan\"},{\"code\":\"ko\",\"name\":\"Koreya\"},{\"code\":\"gl\",\"name\":\"Qalisian\"},{\"code\":\"lv\",\"name\":\"Lat\"},{\"code\":\"lt\",\"name\":\"Litva\"},{\"code\":\"hu\",\"name\":\"Macar\"},{\"code\":\"mi\",\"name\":\"Maoric\"},{\"code\":\"nb\",\"name\":\"Norve\"},{\"code\":\"pl\",\"name\":\"Polyak\"},{\"code\":\"pt\",\"name\":\"Portuqal\"},{\"code\":\"ro\",\"name\":\"Rumn\"},{\"code\":\"ru\",\"name\":\"Rus\"},{\"code\":\"sr\",\"name\":\"Serb\"},{\"code\":\"sk\",\"name\":\"Slovak\"},{\"code\":\"sl\",\"name\":\"Sloven\"},{\"code\":\"gd\",\"name\":\"otland (Kelt)\"},{\"code\":\"th\",\"name\":\"Tayca\"},{\"code\":\"tr\",\"name\":\"Trk\"},{\"code\":\"cy\",\"name\":\"Uels\"},{\"code\":\"uk\",\"name\":\"Ukrayna\"},{\"code\":\"vi\",\"name\":\"Vyetnam\"},{\"code\":\"ja\",\"name\":\"Yapon\"},{\"code\":\"el\",\"name\":\"Yunan\"},{\"code\":\"zu\",\"name\":\"Zulu dili\"}],\"hr\":[{\"code\":\"am\",\"name\":\"amharik\"},{\"code\":\"ar\",\"name\":\"arapski\"},{\"code\":\"az\",\"name\":\"azerbajdanski\"},{\"code\":\"eu\",\"name\":\"baskijski\"},{\"code\":\"bg\",\"name\":\"bugarski\"},{\"code\":\"cs\",\"name\":\"eki\"},{\"code\":\"da\",\"name\":\"danski\"},{\"code\":\"en\",\"name\":\"engleski\"},{\"code\":\"et\",\"name\":\"estonski\"},{\"code\":\"fi\",\"name\":\"finski\"},{\"code\":\"fr\",\"name\":\"francuski\"},{\"code\":\"gl\",\"name\":\"galski\"},{\"code\":\"el\",\"name\":\"grki\"},{\"code\":\"he\",\"name\":\"hebrejski\"},{\"code\":\"hr\",\"name\":\"hrvatski\"},{\"code\":\"id\",\"name\":\"indonezijski\"},{\"code\":\"ga\",\"name\":\"irski\"},{\"code\":\"is\",\"name\":\"islandski\"},{\"code\":\"ja\",\"name\":\"japanski\"},{\"code\":\"ca\",\"name\":\"katalonski\"},{\"code\":\"zh-cn\",\"name\":\"kineski (pojednost.)\"},{\"code\":\"zh-tw\",\"name\":\"kineski (tradicionalni)\"},{\"code\":\"ko\",\"name\":\"korejski\"},{\"code\":\"lv\",\"name\":\"latvijski/letonski\"},{\"code\":\"lt\",\"name\":\"litvanski\"},{\"code\":\"hu\",\"name\":\"maarski\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"nl\",\"name\":\"nizozemski\"},{\"code\":\"nb\",\"name\":\"norveki\"},{\"code\":\"de\",\"name\":\"njemaki\"},{\"code\":\"fa\",\"name\":\"perzijski\"},{\"code\":\"pl\",\"name\":\"poljski\"},{\"code\":\"pt\",\"name\":\"portugalski\"},{\"code\":\"ro\",\"name\":\"rumunjski\"},{\"code\":\"ru\",\"name\":\"ruski\"},{\"code\":\"sk\",\"name\":\"slovaki\"},{\"code\":\"sl\",\"name\":\"slovenski\"},{\"code\":\"sr\",\"name\":\"srpski\"},{\"code\":\"gd\",\"name\":\"kotski keltski\"},{\"code\":\"es\",\"name\":\"panjolski\"},{\"code\":\"sv\",\"name\":\"vedski\"},{\"code\":\"th\",\"name\":\"tajlandski\"},{\"code\":\"it\",\"name\":\"talijanski\"},{\"code\":\"tr\",\"name\":\"turski\"},{\"code\":\"uk\",\"name\":\"ukrajinski\"},{\"code\":\"cy\",\"name\":\"velki\"},{\"code\":\"vi\",\"name\":\"vijetnamski\"},{\"code\":\"zu\",\"name\":\"zulu\"}],\"fa\":[{\"code\":\"az\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\" \"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"zh-tw\",\"name\":\" ()\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"ja\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" \"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"}],\"mi\":[{\"code\":\"az\",\"name\":\"Ahepaitani\"},{\"code\":\"ga\",\"name\":\"Airihi\"},{\"code\":\"am\",\"name\":\"Amariki\"},{\"code\":\"ar\",\"name\":\"Arapi\"},{\"code\":\"et\",\"name\":\"Etnia\"},{\"code\":\"zh-tw\",\"name\":\"Haina (Onamata)\"},{\"code\":\"zh-cn\",\"name\":\"Hainamana (Kua whakammtia)\"},{\"code\":\"hu\",\"name\":\"Hanekeria\"},{\"code\":\"ja\",\"name\":\"Hapanihi\"},{\"code\":\"sr\",\"name\":\"Herepia\"},{\"code\":\"fi\",\"name\":\"Hinerangi\"},{\"code\":\"he\",\"name\":\"Hiperu\"},{\"code\":\"sk\",\"name\":\"Horowkia\"},{\"code\":\"sl\",\"name\":\"Horowinia\"},{\"code\":\"sv\",\"name\":\"Huitene\"},{\"code\":\"zu\",\"name\":\"Huru\"},{\"code\":\"en\",\"name\":\"Ingarihi\"},{\"code\":\"id\",\"name\":\"Initonhia\"},{\"code\":\"it\",\"name\":\"Itriana\"},{\"code\":\"gl\",\"name\":\"Karihia\"},{\"code\":\"ca\",\"name\":\"Katarna\"},{\"code\":\"el\",\"name\":\"Kiriki\"},{\"code\":\"ko\",\"name\":\"Kreana\"},{\"code\":\"hr\",\"name\":\"Korotiana\"},{\"code\":\"tr\",\"name\":\"Korukoru\"},{\"code\":\"mi\",\"name\":\"Mori\"},{\"code\":\"nb\",\"name\":\"Nwei\"},{\"code\":\"eu\",\"name\":\"Pkihi\"},{\"code\":\"es\",\"name\":\"Pniora\"},{\"code\":\"fa\",\"name\":\"Perhia\"},{\"code\":\"pl\",\"name\":\"Prana\"},{\"code\":\"pt\",\"name\":\"Potukhi\"},{\"code\":\"bg\",\"name\":\"Purukriana\"},{\"code\":\"lv\",\"name\":\"Rwhiana\"},{\"code\":\"lt\",\"name\":\"Ritunia\"},{\"code\":\"ro\",\"name\":\"Romnia\"},{\"code\":\"ru\",\"name\":\"Rhia\"},{\"code\":\"th\",\"name\":\"Tai\"},{\"code\":\"nl\",\"name\":\"Tati\"},{\"code\":\"da\",\"name\":\"Tenemka\"},{\"code\":\"de\",\"name\":\"Tiamana\"},{\"code\":\"cs\",\"name\":\"Tieke\"},{\"code\":\"is\",\"name\":\"Tiorangi\"},{\"code\":\"gd\",\"name\":\"Tuauri Kotarangi\"},{\"code\":\"uk\",\"name\":\"kareiana\"},{\"code\":\"cy\",\"name\":\"Wra\"},{\"code\":\"vi\",\"name\":\"Whitinmu\"},{\"code\":\"fr\",\"name\":\"Ww\"}],\"el\":[{\"code\":\"en\",\"name\":\"\"},{\"code\":\"az\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" \"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"ja\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"zh-tw\",\"name\":\" ()\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"}],\"is\":[{\"code\":\"am\",\"name\":\"amharsku\"},{\"code\":\"ar\",\"name\":\"arabska\"},{\"code\":\"az\",\"name\":\"aserska\"},{\"code\":\"eu\",\"name\":\"baskneska\"},{\"code\":\"bg\",\"name\":\"blgarska\"},{\"code\":\"da\",\"name\":\"danska\"},{\"code\":\"et\",\"name\":\"eistneska\"},{\"code\":\"en\",\"name\":\"enska\"},{\"code\":\"fi\",\"name\":\"finnska\"},{\"code\":\"fr\",\"name\":\"franska\"},{\"code\":\"gl\",\"name\":\"galisska\"},{\"code\":\"el\",\"name\":\"grska\"},{\"code\":\"he\",\"name\":\"hebreska\"},{\"code\":\"nl\",\"name\":\"hollenska\"},{\"code\":\"id\",\"name\":\"indnesska\"},{\"code\":\"ga\",\"name\":\"rska\"},{\"code\":\"is\",\"name\":\"slenska\"},{\"code\":\"it\",\"name\":\"talska\"},{\"code\":\"ja\",\"name\":\"japanska\"},{\"code\":\"ca\",\"name\":\"katalnska\"},{\"code\":\"zh-cn\",\"name\":\"knverska (einfldu)\"},{\"code\":\"zh-tw\",\"name\":\"knverska (hefbundin)\"},{\"code\":\"ko\",\"name\":\"kreska\"},{\"code\":\"hr\",\"name\":\"kratska\"},{\"code\":\"lv\",\"name\":\"lettneska\"},{\"code\":\"lt\",\"name\":\"lithska\"},{\"code\":\"mi\",\"name\":\"maorska\"},{\"code\":\"nb\",\"name\":\"norska\"},{\"code\":\"fa\",\"name\":\"persneska\"},{\"code\":\"pt\",\"name\":\"portgalska\"},{\"code\":\"pl\",\"name\":\"plska\"},{\"code\":\"ro\",\"name\":\"rmenska\"},{\"code\":\"ru\",\"name\":\"rssneska\"},{\"code\":\"sr\",\"name\":\"serbneska\"},{\"code\":\"gd\",\"name\":\"skosk-gelska\"},{\"code\":\"sk\",\"name\":\"slvakska\"},{\"code\":\"sl\",\"name\":\"slvenska\"},{\"code\":\"es\",\"name\":\"spnska\"},{\"code\":\"zu\",\"name\":\"sl\"},{\"code\":\"sv\",\"name\":\"snska\"},{\"code\":\"th\",\"name\":\"talenska\"},{\"code\":\"cs\",\"name\":\"tkkneska\"},{\"code\":\"tr\",\"name\":\"tyrkneska\"},{\"code\":\"hu\",\"name\":\"ungverska\"},{\"code\":\"uk\",\"name\":\"kranska\"},{\"code\":\"cy\",\"name\":\"velska\"},{\"code\":\"vi\",\"name\":\"vetnamska\"},{\"code\":\"de\",\"name\":\"ska\"}],\"fi\":[{\"code\":\"am\",\"name\":\"amhara\"},{\"code\":\"ar\",\"name\":\"arabia\"},{\"code\":\"az\",\"name\":\"azeri\"},{\"code\":\"eu\",\"name\":\"baski\"},{\"code\":\"bg\",\"name\":\"bulgaria\"},{\"code\":\"en\",\"name\":\"englanti\"},{\"code\":\"es\",\"name\":\"espanja\"},{\"code\":\"gl\",\"name\":\"galicia\"},{\"code\":\"he\",\"name\":\"heprea\"},{\"code\":\"nl\",\"name\":\"hollanti\"},{\"code\":\"ga\",\"name\":\"iiri\"},{\"code\":\"id\",\"name\":\"indonesia\"},{\"code\":\"is\",\"name\":\"islanti\"},{\"code\":\"it\",\"name\":\"italia\"},{\"code\":\"ja\",\"name\":\"japani\"},{\"code\":\"ca\",\"name\":\"katalaani\"},{\"code\":\"zh-tw\",\"name\":\"kiina (perinteinen)\"},{\"code\":\"zh-cn\",\"name\":\"kiina (yksinkert.)\"},{\"code\":\"ko\",\"name\":\"korea\"},{\"code\":\"el\",\"name\":\"kreikka\"},{\"code\":\"hr\",\"name\":\"kroatia\"},{\"code\":\"cy\",\"name\":\"kymri\"},{\"code\":\"lv\",\"name\":\"latvia\"},{\"code\":\"lt\",\"name\":\"liettua\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"nb\",\"name\":\"norja\"},{\"code\":\"fa\",\"name\":\"persia\"},{\"code\":\"pt\",\"name\":\"portugali\"},{\"code\":\"pl\",\"name\":\"puola\"},{\"code\":\"fr\",\"name\":\"ranska\"},{\"code\":\"ro\",\"name\":\"romania\"},{\"code\":\"sv\",\"name\":\"ruotsi\"},{\"code\":\"de\",\"name\":\"saksa\"},{\"code\":\"sr\",\"name\":\"serbia\"},{\"code\":\"gd\",\"name\":\"skottigaeli\"},{\"code\":\"sk\",\"name\":\"slovakia\"},{\"code\":\"sl\",\"name\":\"slovenia\"},{\"code\":\"fi\",\"name\":\"suomi\"},{\"code\":\"da\",\"name\":\"tanska\"},{\"code\":\"th\",\"name\":\"thai\"},{\"code\":\"cs\",\"name\":\"tsekki\"},{\"code\":\"tr\",\"name\":\"turkki\"},{\"code\":\"uk\",\"name\":\"ukraina\"},{\"code\":\"hu\",\"name\":\"unkari\"},{\"code\":\"ru\",\"name\":\"venj\"},{\"code\":\"vi\",\"name\":\"vietnam\"},{\"code\":\"et\",\"name\":\"viro\"},{\"code\":\"zu\",\"name\":\"zulu\"}],\"eu\":[{\"code\":\"de\",\"name\":\"alemana\"},{\"code\":\"am\",\"name\":\"amharera\"},{\"code\":\"ar\",\"name\":\"arabiera\"},{\"code\":\"az\",\"name\":\"azerbaijanera\"},{\"code\":\"bg\",\"name\":\"bulgariera\"},{\"code\":\"da\",\"name\":\"daniera\"},{\"code\":\"ro\",\"name\":\"errumaniera\"},{\"code\":\"ru\",\"name\":\"errusiera\"},{\"code\":\"gd\",\"name\":\"Eskoziako gaelera\"},{\"code\":\"sk\",\"name\":\"eslovakiera\"},{\"code\":\"sl\",\"name\":\"esloveniera\"},{\"code\":\"et\",\"name\":\"estoniera\"},{\"code\":\"eu\",\"name\":\"euskara\"},{\"code\":\"fr\",\"name\":\"frantsesa\"},{\"code\":\"cy\",\"name\":\"gaelera\"},{\"code\":\"gl\",\"name\":\"galiziera\"},{\"code\":\"es\",\"name\":\"gaztelania\"},{\"code\":\"el\",\"name\":\"greziera\"},{\"code\":\"he\",\"name\":\"hebreera\"},{\"code\":\"hu\",\"name\":\"hungariera\"},{\"code\":\"id\",\"name\":\"indonesiera\"},{\"code\":\"en\",\"name\":\"ingelesa\"},{\"code\":\"ga\",\"name\":\"irlandera\"},{\"code\":\"is\",\"name\":\"islandiera\"},{\"code\":\"it\",\"name\":\"italiera\"},{\"code\":\"ja\",\"name\":\"japoniera\"},{\"code\":\"ca\",\"name\":\"katalana\"},{\"code\":\"ko\",\"name\":\"koreera\"},{\"code\":\"hr\",\"name\":\"kroaziera\"},{\"code\":\"lv\",\"name\":\"letoniera\"},{\"code\":\"lt\",\"name\":\"lituaniera\"},{\"code\":\"mi\",\"name\":\"maoriera\"},{\"code\":\"nl\",\"name\":\"nederlandera\"},{\"code\":\"nb\",\"name\":\"norvegiera\"},{\"code\":\"fa\",\"name\":\"persiera\"},{\"code\":\"pl\",\"name\":\"poloniera\"},{\"code\":\"pt\",\"name\":\"portugesa\"},{\"code\":\"sr\",\"name\":\"serbiera\"},{\"code\":\"sv\",\"name\":\"suediera\"},{\"code\":\"fi\",\"name\":\"suomiera\"},{\"code\":\"th\",\"name\":\"thaiera\"},{\"code\":\"tr\",\"name\":\"turkiera\"},{\"code\":\"cs\",\"name\":\"txekiera\"},{\"code\":\"zh-cn\",\"name\":\"txinera (soildua)\"},{\"code\":\"zh-tw\",\"name\":\"txinera (tradizionala)\"},{\"code\":\"uk\",\"name\":\"ukrainera\"},{\"code\":\"vi\",\"name\":\"vietnamera\"},{\"code\":\"zu\",\"name\":\"zuluera\"}],\"ca\":[{\"code\":\"de\",\"name\":\"alemany\"},{\"code\":\"am\",\"name\":\"amhric\"},{\"code\":\"en\",\"name\":\"angls\"},{\"code\":\"ar\",\"name\":\"rab\"},{\"code\":\"az\",\"name\":\"zeri\"},{\"code\":\"eu\",\"name\":\"basc\"},{\"code\":\"bg\",\"name\":\"blgar\"},{\"code\":\"es\",\"name\":\"castell\"},{\"code\":\"ca\",\"name\":\"catal\"},{\"code\":\"ko\",\"name\":\"core\"},{\"code\":\"hr\",\"name\":\"croat\"},{\"code\":\"da\",\"name\":\"dans\"},{\"code\":\"sk\",\"name\":\"eslovac\"},{\"code\":\"sl\",\"name\":\"eslov\"},{\"code\":\"et\",\"name\":\"estoni\"},{\"code\":\"fi\",\"name\":\"fins\"},{\"code\":\"fr\",\"name\":\"francs\"},{\"code\":\"gd\",\"name\":\"galic escocs\"},{\"code\":\"gl\",\"name\":\"gallec\"},{\"code\":\"cy\",\"name\":\"galls\"},{\"code\":\"el\",\"name\":\"grec\"},{\"code\":\"he\",\"name\":\"hebreu\"},{\"code\":\"hu\",\"name\":\"hongars\"},{\"code\":\"id\",\"name\":\"indonesi\"},{\"code\":\"ga\",\"name\":\"irlands\"},{\"code\":\"is\",\"name\":\"islands\"},{\"code\":\"it\",\"name\":\"itali\"},{\"code\":\"ja\",\"name\":\"japons\"},{\"code\":\"lv\",\"name\":\"let\"},{\"code\":\"lt\",\"name\":\"litu\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"nl\",\"name\":\"neerlands\"},{\"code\":\"nb\",\"name\":\"noruec\"},{\"code\":\"fa\",\"name\":\"persa\"},{\"code\":\"pl\",\"name\":\"polons\"},{\"code\":\"pt\",\"name\":\"portugus\"},{\"code\":\"ro\",\"name\":\"romans\"},{\"code\":\"ru\",\"name\":\"rus\"},{\"code\":\"sr\",\"name\":\"serbi\"},{\"code\":\"sv\",\"name\":\"suec\"},{\"code\":\"th\",\"name\":\"tai\"},{\"code\":\"tr\",\"name\":\"turc\"},{\"code\":\"cs\",\"name\":\"txec\"},{\"code\":\"uk\",\"name\":\"ucrans\"},{\"code\":\"vi\",\"name\":\"vietnamita\"},{\"code\":\"zh-cn\",\"name\":\"xins (simplificat)\"},{\"code\":\"zh-tw\",\"name\":\"xins (tradicional)\"},{\"code\":\"zu\",\"name\":\"zul\"}],\"lv\":[{\"code\":\"am\",\"name\":\"amharu\"},{\"code\":\"en\",\"name\":\"angu\"},{\"code\":\"ar\",\"name\":\"arbu\"},{\"code\":\"az\",\"name\":\"azerbaidu\"},{\"code\":\"eu\",\"name\":\"basku\"},{\"code\":\"bg\",\"name\":\"bulgru\"},{\"code\":\"cs\",\"name\":\"ehu\"},{\"code\":\"da\",\"name\":\"du\"},{\"code\":\"he\",\"name\":\"ebreju (ivrits)\"},{\"code\":\"fr\",\"name\":\"franu\"},{\"code\":\"gl\",\"name\":\"galisieu\"},{\"code\":\"el\",\"name\":\"grieu\"},{\"code\":\"nl\",\"name\":\"holandieu\"},{\"code\":\"hr\",\"name\":\"horvtu\"},{\"code\":\"et\",\"name\":\"igauu\"},{\"code\":\"id\",\"name\":\"indonzieu\"},{\"code\":\"ga\",\"name\":\"ru\"},{\"code\":\"is\",\"name\":\"slandieu\"},{\"code\":\"it\",\"name\":\"itu\"},{\"code\":\"ja\",\"name\":\"japu\"},{\"code\":\"ca\",\"name\":\"katalu\"},{\"code\":\"ko\",\"name\":\"korejieu\"},{\"code\":\"ru\",\"name\":\"krievu\"},{\"code\":\"zh-tw\",\"name\":\"nieu (tradicionl)\"},{\"code\":\"zh-cn\",\"name\":\"nieu (vienkrot)\"},{\"code\":\"lv\",\"name\":\"latvieu\"},{\"code\":\"lt\",\"name\":\"lietuvieu\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"nb\",\"name\":\"norvu\"},{\"code\":\"fa\",\"name\":\"persieu\"},{\"code\":\"pl\",\"name\":\"pou\"},{\"code\":\"pt\",\"name\":\"portugu\"},{\"code\":\"ro\",\"name\":\"rumu\"},{\"code\":\"sr\",\"name\":\"serbu\"},{\"code\":\"gd\",\"name\":\"skotu glu\"},{\"code\":\"sk\",\"name\":\"slovku\"},{\"code\":\"sl\",\"name\":\"slovu\"},{\"code\":\"fi\",\"name\":\"somu\"},{\"code\":\"es\",\"name\":\"spu\"},{\"code\":\"th\",\"name\":\"taju\"},{\"code\":\"tr\",\"name\":\"turku\"},{\"code\":\"uk\",\"name\":\"ukraiu\"},{\"code\":\"hu\",\"name\":\"ungru\"},{\"code\":\"de\",\"name\":\"vcu\"},{\"code\":\"cy\",\"name\":\"velsieu\"},{\"code\":\"vi\",\"name\":\"vjetnamieu\"},{\"code\":\"zu\",\"name\":\"zulu\"},{\"code\":\"sv\",\"name\":\"zviedru\"}],\"id\":[{\"code\":\"am\",\"name\":\"Amhara\"},{\"code\":\"ar\",\"name\":\"Arab\"},{\"code\":\"az\",\"name\":\"Azerbaijan\"},{\"code\":\"eu\",\"name\":\"Basque\"},{\"code\":\"nl\",\"name\":\"Belanda\"},{\"code\":\"bg\",\"name\":\"Bulgaria\"},{\"code\":\"cs\",\"name\":\"Cek\"},{\"code\":\"zh-cn\",\"name\":\"China (Aks. Sederhana)\"},{\"code\":\"zh-tw\",\"name\":\"China (Aks. Tradisional)\"},{\"code\":\"da\",\"name\":\"Denmark\"},{\"code\":\"et\",\"name\":\"Estonia\"},{\"code\":\"fa\",\"name\":\"Farsi\"},{\"code\":\"fi\",\"name\":\"Finlandia\"},{\"code\":\"ga\",\"name\":\"Gaelig\"},{\"code\":\"gd\",\"name\":\"Gaelik Skotlandia\"},{\"code\":\"gl\",\"name\":\"Galisia\"},{\"code\":\"he\",\"name\":\"Ibrani\"},{\"code\":\"id\",\"name\":\"Indonesia\"},{\"code\":\"en\",\"name\":\"Inggris\"},{\"code\":\"is\",\"name\":\"Islan\"},{\"code\":\"it\",\"name\":\"Italia\"},{\"code\":\"ja\",\"name\":\"Jepang\"},{\"code\":\"de\",\"name\":\"Jerman\"},{\"code\":\"ca\",\"name\":\"Katala\"},{\"code\":\"ko\",\"name\":\"Korea\"},{\"code\":\"hr\",\"name\":\"Kroat\"},{\"code\":\"lv\",\"name\":\"Latvia\"},{\"code\":\"lt\",\"name\":\"Lituania\"},{\"code\":\"hu\",\"name\":\"Magyar\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nb\",\"name\":\"Norsk\"},{\"code\":\"pl\",\"name\":\"Polandia\"},{\"code\":\"pt\",\"name\":\"Portugis\"},{\"code\":\"fr\",\"name\":\"Prancis\"},{\"code\":\"ro\",\"name\":\"Rumania\"},{\"code\":\"ru\",\"name\":\"Rusia\"},{\"code\":\"sr\",\"name\":\"Serb\"},{\"code\":\"sk\",\"name\":\"Slovakia\"},{\"code\":\"sl\",\"name\":\"Slovenia\"},{\"code\":\"es\",\"name\":\"Spanyol\"},{\"code\":\"sv\",\"name\":\"Swensk\"},{\"code\":\"th\",\"name\":\"Thai\"},{\"code\":\"tr\",\"name\":\"Turki\"},{\"code\":\"uk\",\"name\":\"Ukraina\"},{\"code\":\"vi\",\"name\":\"Vietnam\"},{\"code\":\"cy\",\"name\":\"Wales\"},{\"code\":\"el\",\"name\":\"Yunani\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"es\":[{\"code\":\"de\",\"name\":\"alemn\"},{\"code\":\"am\",\"name\":\"amhrico\"},{\"code\":\"ar\",\"name\":\"rabe\"},{\"code\":\"az\",\"name\":\"azer\"},{\"code\":\"bg\",\"name\":\"blgaro\"},{\"code\":\"ca\",\"name\":\"cataln\"},{\"code\":\"cs\",\"name\":\"checo\"},{\"code\":\"zh-cn\",\"name\":\"chino (simplificado)\"},{\"code\":\"zh-tw\",\"name\":\"chino (tradicional)\"},{\"code\":\"ko\",\"name\":\"coreano\"},{\"code\":\"hr\",\"name\":\"croata\"},{\"code\":\"da\",\"name\":\"dans\"},{\"code\":\"sk\",\"name\":\"eslovaco\"},{\"code\":\"sl\",\"name\":\"esloveno\"},{\"code\":\"es\",\"name\":\"espaol\"},{\"code\":\"et\",\"name\":\"estonio\"},{\"code\":\"eu\",\"name\":\"euskera\"},{\"code\":\"fi\",\"name\":\"finlands\"},{\"code\":\"fr\",\"name\":\"francs\"},{\"code\":\"gd\",\"name\":\"galico escocs\"},{\"code\":\"cy\",\"name\":\"gals\"},{\"code\":\"gl\",\"name\":\"gallego\"},{\"code\":\"el\",\"name\":\"griego\"},{\"code\":\"he\",\"name\":\"hebreo\"},{\"code\":\"hu\",\"name\":\"hngaro\"},{\"code\":\"id\",\"name\":\"indonesio\"},{\"code\":\"en\",\"name\":\"ingls\"},{\"code\":\"ga\",\"name\":\"irlands\"},{\"code\":\"is\",\"name\":\"islands\"},{\"code\":\"it\",\"name\":\"italiano\"},{\"code\":\"ja\",\"name\":\"japons\"},{\"code\":\"lv\",\"name\":\"letn\"},{\"code\":\"lt\",\"name\":\"lituano\"},{\"code\":\"mi\",\"name\":\"maor\"},{\"code\":\"nl\",\"name\":\"neerlands\"},{\"code\":\"nb\",\"name\":\"noruego\"},{\"code\":\"fa\",\"name\":\"persa\"},{\"code\":\"pl\",\"name\":\"polaco\"},{\"code\":\"pt\",\"name\":\"portugus\"},{\"code\":\"ro\",\"name\":\"rumano\"},{\"code\":\"ru\",\"name\":\"ruso\"},{\"code\":\"sr\",\"name\":\"serbio\"},{\"code\":\"sv\",\"name\":\"sueco\"},{\"code\":\"th\",\"name\":\"tailands\"},{\"code\":\"tr\",\"name\":\"turco\"},{\"code\":\"uk\",\"name\":\"ucraniano\"},{\"code\":\"vi\",\"name\":\"vietnamita\"},{\"code\":\"zu\",\"name\":\"zul\"}],\"es-419\":[{\"code\":\"de\",\"name\":\"alemn\"},{\"code\":\"am\",\"name\":\"amhrico\"},{\"code\":\"ar\",\"name\":\"rabe\"},{\"code\":\"az\",\"name\":\"azer\"},{\"code\":\"bg\",\"name\":\"blgaro\"},{\"code\":\"ca\",\"name\":\"cataln\"},{\"code\":\"cs\",\"name\":\"checo\"},{\"code\":\"zh-cn\",\"name\":\"chino (simplificado)\"},{\"code\":\"zh-tw\",\"name\":\"chino (tradicional)\"},{\"code\":\"ko\",\"name\":\"coreano\"},{\"code\":\"hr\",\"name\":\"croata\"},{\"code\":\"da\",\"name\":\"dans\"},{\"code\":\"sk\",\"name\":\"eslovaco\"},{\"code\":\"sl\",\"name\":\"esloveno\"},{\"code\":\"es\",\"name\":\"espaol\"},{\"code\":\"et\",\"name\":\"estonio\"},{\"code\":\"eu\",\"name\":\"euskera\"},{\"code\":\"fi\",\"name\":\"finlands\"},{\"code\":\"fr\",\"name\":\"francs\"},{\"code\":\"gd\",\"name\":\"galico escocs\"},{\"code\":\"cy\",\"name\":\"gals\"},{\"code\":\"gl\",\"name\":\"gallego\"},{\"code\":\"el\",\"name\":\"griego\"},{\"code\":\"he\",\"name\":\"hebreo\"},{\"code\":\"hu\",\"name\":\"hngaro\"},{\"code\":\"id\",\"name\":\"indonesio\"},{\"code\":\"en\",\"name\":\"ingls\"},{\"code\":\"ga\",\"name\":\"irlands\"},{\"code\":\"is\",\"name\":\"islands\"},{\"code\":\"it\",\"name\":\"italiano\"},{\"code\":\"ja\",\"name\":\"japons\"},{\"code\":\"lv\",\"name\":\"letn\"},{\"code\":\"lt\",\"name\":\"lituano\"},{\"code\":\"mi\",\"name\":\"maor\"},{\"code\":\"nl\",\"name\":\"neerlands\"},{\"code\":\"nb\",\"name\":\"noruego\"},{\"code\":\"fa\",\"name\":\"persa\"},{\"code\":\"pl\",\"name\":\"polaco\"},{\"code\":\"pt\",\"name\":\"portugus\"},{\"code\":\"ro\",\"name\":\"rumano\"},{\"code\":\"ru\",\"name\":\"ruso\"},{\"code\":\"sr\",\"name\":\"serbio\"},{\"code\":\"sv\",\"name\":\"sueco\"},{\"code\":\"th\",\"name\":\"tailands\"},{\"code\":\"tr\",\"name\":\"turco\"},{\"code\":\"uk\",\"name\":\"ucraniano\"},{\"code\":\"vi\",\"name\":\"vietnamita\"},{\"code\":\"zu\",\"name\":\"zul\"}],\"et\":[{\"code\":\"am\",\"name\":\"amhaari\"},{\"code\":\"ar\",\"name\":\"araabia\"},{\"code\":\"az\",\"name\":\"aserbaidaani\"},{\"code\":\"eu\",\"name\":\"baski\"},{\"code\":\"bg\",\"name\":\"bulgaaria\"},{\"code\":\"et\",\"name\":\"eesti\"},{\"code\":\"gl\",\"name\":\"galeegi\"},{\"code\":\"he\",\"name\":\"heebrea\"},{\"code\":\"es\",\"name\":\"hispaania\"},{\"code\":\"nl\",\"name\":\"hollandi\"},{\"code\":\"hr\",\"name\":\"horvaadi\"},{\"code\":\"ga\",\"name\":\"iiri\"},{\"code\":\"id\",\"name\":\"indoneesia\"},{\"code\":\"en\",\"name\":\"inglise\"},{\"code\":\"is\",\"name\":\"islandi\"},{\"code\":\"it\",\"name\":\"itaalia\"},{\"code\":\"ja\",\"name\":\"jaapani\"},{\"code\":\"ca\",\"name\":\"katalaani\"},{\"code\":\"ko\",\"name\":\"korea\"},{\"code\":\"el\",\"name\":\"kreeka\"},{\"code\":\"lt\",\"name\":\"leedu\"},{\"code\":\"zh-cn\",\"name\":\"lihtsustatud hiina\"},{\"code\":\"lv\",\"name\":\"lti\"},{\"code\":\"mi\",\"name\":\"maoori\"},{\"code\":\"nb\",\"name\":\"norra\"},{\"code\":\"pl\",\"name\":\"poola\"},{\"code\":\"pt\",\"name\":\"portugali\"},{\"code\":\"fr\",\"name\":\"prantsuse\"},{\"code\":\"fa\",\"name\":\"prsia\"},{\"code\":\"sv\",\"name\":\"rootsi\"},{\"code\":\"ro\",\"name\":\"rumeenia\"},{\"code\":\"de\",\"name\":\"saksa\"},{\"code\":\"sr\",\"name\":\"serbia\"},{\"code\":\"sk\",\"name\":\"slovaki\"},{\"code\":\"sl\",\"name\":\"sloveeni\"},{\"code\":\"fi\",\"name\":\"soome\"},{\"code\":\"zu\",\"name\":\"suulu\"},{\"code\":\"gd\",\"name\":\"oti\"},{\"code\":\"da\",\"name\":\"taani\"},{\"code\":\"th\",\"name\":\"tai\"},{\"code\":\"zh-tw\",\"name\":\"traditsiooniline hiina\"},{\"code\":\"cs\",\"name\":\"tehhi\"},{\"code\":\"tr\",\"name\":\"trgi\"},{\"code\":\"cy\",\"name\":\"uelsi\"},{\"code\":\"uk\",\"name\":\"ukraina\"},{\"code\":\"hu\",\"name\":\"ungari\"},{\"code\":\"ru\",\"name\":\"vene\"},{\"code\":\"vi\",\"name\":\"vietnami\"}],\"cy\":[{\"code\":\"de\",\"name\":\"Almaeneg\"},{\"code\":\"am\",\"name\":\"Amharic\"},{\"code\":\"ar\",\"name\":\"Arabeg\"},{\"code\":\"az\",\"name\":\"Aserbaijaneg\"},{\"code\":\"eu\",\"name\":\"Basgeg\"},{\"code\":\"bg\",\"name\":\"Bwlgaraidd\"},{\"code\":\"ca\",\"name\":\"Catalaneg\"},{\"code\":\"hr\",\"name\":\"Croateg\"},{\"code\":\"cy\",\"name\":\"Cymraeg\"},{\"code\":\"da\",\"name\":\"Daneg\"},{\"code\":\"it\",\"name\":\"Eidaleg\"},{\"code\":\"et\",\"name\":\"Estoneg\"},{\"code\":\"vi\",\"name\":\"Fietnameg\"},{\"code\":\"fi\",\"name\":\"Ffineg\"},{\"code\":\"nl\",\"name\":\"Fflemeg\"},{\"code\":\"fr\",\"name\":\"Ffrangeg\"},{\"code\":\"gd\",\"name\":\"Gaeleg yr Alban\"},{\"code\":\"gl\",\"name\":\"Galisaidd\"},{\"code\":\"el\",\"name\":\"Groeg\"},{\"code\":\"ga\",\"name\":\"Gwyddeleg\"},{\"code\":\"he\",\"name\":\"Hebraeg\"},{\"code\":\"hu\",\"name\":\"Hwngareg\"},{\"code\":\"ko\",\"name\":\"Iaith Corea\"},{\"code\":\"id\",\"name\":\"Indonesieg\"},{\"code\":\"is\",\"name\":\"Islandeg\"},{\"code\":\"uk\",\"name\":\"Iwcraineg\"},{\"code\":\"ja\",\"name\":\"Japaneg\"},{\"code\":\"lv\",\"name\":\"Latfieg\"},{\"code\":\"lt\",\"name\":\"Lithwaneg\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nb\",\"name\":\"Norwyeg\"},{\"code\":\"fa\",\"name\":\"Perseg\"},{\"code\":\"pt\",\"name\":\"Portiwgaleg\"},{\"code\":\"pl\",\"name\":\"Pwyleg\"},{\"code\":\"ro\",\"name\":\"Rwmaneg\"},{\"code\":\"ru\",\"name\":\"Rwsieg\"},{\"code\":\"en\",\"name\":\"Saesneg\"},{\"code\":\"es\",\"name\":\"Sbaeneg\"},{\"code\":\"sr\",\"name\":\"Serbeg\"},{\"code\":\"sk\",\"name\":\"Slofac\"},{\"code\":\"sl\",\"name\":\"Slofenia\"},{\"code\":\"sv\",\"name\":\"Swedeg\"},{\"code\":\"zu\",\"name\":\"Swlw\"},{\"code\":\"th\",\"name\":\"Tai\"},{\"code\":\"cs\",\"name\":\"Tsieceg\"},{\"code\":\"zh-tw\",\"name\":\"Tsieineeg (Traddodiadol)\"},{\"code\":\"zh-cn\",\"name\":\"Tsieineeg (Wedi symleiddio)\"},{\"code\":\"tr\",\"name\":\"Twrceg\"}],\"zh-cn\":[{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"az\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"ja\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"zh-tw\",\"name\":\"()\"},{\"code\":\"zh-cn\",\"name\":\"()\"}],\"bg\":[{\"code\":\"az\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"zh-tw\",\"name\":\" ()\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" \"},{\"code\":\"ja\",\"name\":\"\"}],\"ar\":[{\"code\":\"is\",\"name\":\"\"},{\"code\":\"az\",\"name\":\"\"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" \"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"zh-tw\",\"name\":\" ()\"},{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"ja\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"}],\"en\":[{\"code\":\"am\",\"name\":\"Amharic\"},{\"code\":\"ar\",\"name\":\"Arabic\"},{\"code\":\"az\",\"name\":\"Azerbaijani\"},{\"code\":\"eu\",\"name\":\"Basque\"},{\"code\":\"bg\",\"name\":\"Bulgarian\"},{\"code\":\"ca\",\"name\":\"Catalan\"},{\"code\":\"zh-cn\",\"name\":\"Chinese (Simplified)\"},{\"code\":\"zh-tw\",\"name\":\"Chinese (Traditional)\"},{\"code\":\"hr\",\"name\":\"Croatian\"},{\"code\":\"cs\",\"name\":\"Czech\"},{\"code\":\"da\",\"name\":\"Danish\"},{\"code\":\"nl\",\"name\":\"Dutch\"},{\"code\":\"en\",\"name\":\"English\"},{\"code\":\"et\",\"name\":\"Estonian\"},{\"code\":\"fi\",\"name\":\"Finnish\"},{\"code\":\"fr\",\"name\":\"French\"},{\"code\":\"gl\",\"name\":\"Galician\"},{\"code\":\"de\",\"name\":\"German\"},{\"code\":\"el\",\"name\":\"Greek\"},{\"code\":\"he\",\"name\":\"Hebrew\"},{\"code\":\"hu\",\"name\":\"Hungarian\"},{\"code\":\"is\",\"name\":\"Icelandic\"},{\"code\":\"id\",\"name\":\"Indonesian\"},{\"code\":\"ga\",\"name\":\"Irish\"},{\"code\":\"it\",\"name\":\"Italian\"},{\"code\":\"ja\",\"name\":\"Japanese\"},{\"code\":\"ko\",\"name\":\"Korean\"},{\"code\":\"lv\",\"name\":\"Latvian\"},{\"code\":\"lt\",\"name\":\"Lithuanian\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nb\",\"name\":\"Norwegian\"},{\"code\":\"fa\",\"name\":\"Persian\"},{\"code\":\"pl\",\"name\":\"Polish\"},{\"code\":\"pt\",\"name\":\"Portuguese\"},{\"code\":\"ro\",\"name\":\"Romanian\"},{\"code\":\"ru\",\"name\":\"Russian\"},{\"code\":\"gd\",\"name\":\"Scots Gaelic\"},{\"code\":\"sr\",\"name\":\"Serbian\"},{\"code\":\"sk\",\"name\":\"Slovak\"},{\"code\":\"sl\",\"name\":\"Slovenian\"},{\"code\":\"es\",\"name\":\"Spanish\"},{\"code\":\"sv\",\"name\":\"Swedish\"},{\"code\":\"th\",\"name\":\"Thai\"},{\"code\":\"tr\",\"name\":\"Turkish\"},{\"code\":\"uk\",\"name\":\"Ukrainian\"},{\"code\":\"vi\",\"name\":\"Vietnamese\"},{\"code\":\"cy\",\"name\":\"Welsh\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"sr\":[{\"code\":\"az\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"ja\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"zh-tw\",\"name\":\" ()\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" \"},{\"code\":\"es\",\"name\":\"\"}],\"sv\":[{\"code\":\"am\",\"name\":\"amhariska\"},{\"code\":\"ar\",\"name\":\"arabiska\"},{\"code\":\"az\",\"name\":\"azerbajdzjanska\"},{\"code\":\"eu\",\"name\":\"baskiska\"},{\"code\":\"bg\",\"name\":\"bulgariska\"},{\"code\":\"da\",\"name\":\"danska\"},{\"code\":\"en\",\"name\":\"engelska\"},{\"code\":\"et\",\"name\":\"estniska\"},{\"code\":\"fi\",\"name\":\"finska\"},{\"code\":\"fr\",\"name\":\"franska\"},{\"code\":\"gd\",\"name\":\"gaeliska\"},{\"code\":\"gl\",\"name\":\"galiciska\"},{\"code\":\"el\",\"name\":\"grekiska\"},{\"code\":\"he\",\"name\":\"hebreiska\"},{\"code\":\"id\",\"name\":\"indonesiska\"},{\"code\":\"ga\",\"name\":\"irlndska\"},{\"code\":\"is\",\"name\":\"islndska\"},{\"code\":\"it\",\"name\":\"italienska\"},{\"code\":\"ja\",\"name\":\"japanska\"},{\"code\":\"ca\",\"name\":\"katalanska\"},{\"code\":\"zh-cn\",\"name\":\"kinesiska (frenklad)\"},{\"code\":\"zh-tw\",\"name\":\"kinesiska (traditionell)\"},{\"code\":\"ko\",\"name\":\"koreanska\"},{\"code\":\"hr\",\"name\":\"kroatiska\"},{\"code\":\"lv\",\"name\":\"lettiska\"},{\"code\":\"lt\",\"name\":\"litauiska\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"nl\",\"name\":\"nederlndska\"},{\"code\":\"nb\",\"name\":\"norska\"},{\"code\":\"fa\",\"name\":\"persiska\"},{\"code\":\"pl\",\"name\":\"polska\"},{\"code\":\"pt\",\"name\":\"portugisiska\"},{\"code\":\"ro\",\"name\":\"rumnska\"},{\"code\":\"ru\",\"name\":\"ryska\"},{\"code\":\"sr\",\"name\":\"serbiska\"},{\"code\":\"sk\",\"name\":\"slovakiska\"},{\"code\":\"sl\",\"name\":\"slovenska\"},{\"code\":\"es\",\"name\":\"spanska\"},{\"code\":\"sv\",\"name\":\"svenska\"},{\"code\":\"th\",\"name\":\"thailndska\"},{\"code\":\"cs\",\"name\":\"tjeckiska\"},{\"code\":\"tr\",\"name\":\"turkiska\"},{\"code\":\"de\",\"name\":\"tyska\"},{\"code\":\"uk\",\"name\":\"ukrainska\"},{\"code\":\"hu\",\"name\":\"ungerska\"},{\"code\":\"vi\",\"name\":\"vietnamesiska\"},{\"code\":\"cy\",\"name\":\"walesiska\"},{\"code\":\"zu\",\"name\":\"zulu\"}],\"ro\":[{\"code\":\"am\",\"name\":\"Amharic\"},{\"code\":\"ar\",\"name\":\"Arab\"},{\"code\":\"az\",\"name\":\"Azerbaidjan\"},{\"code\":\"eu\",\"name\":\"Basc\"},{\"code\":\"bg\",\"name\":\"Bulgar\"},{\"code\":\"ca\",\"name\":\"Catalan\"},{\"code\":\"cs\",\"name\":\"Ceh\"},{\"code\":\"zh-cn\",\"name\":\"Chinez (Simplificat)\"},{\"code\":\"zh-tw\",\"name\":\"Chinez (Tradiional)\"},{\"code\":\"ko\",\"name\":\"Coreean\"},{\"code\":\"hr\",\"name\":\"Croat\"},{\"code\":\"da\",\"name\":\"Danez\"},{\"code\":\"he\",\"name\":\"Ebraic\"},{\"code\":\"en\",\"name\":\"Englez\"},{\"code\":\"et\",\"name\":\"Eston\"},{\"code\":\"fi\",\"name\":\"Finlandez\"},{\"code\":\"fr\",\"name\":\"Francez\"},{\"code\":\"cy\",\"name\":\"Galez\"},{\"code\":\"gd\",\"name\":\"Galica scoian\"},{\"code\":\"gl\",\"name\":\"Galician\"},{\"code\":\"de\",\"name\":\"German\"},{\"code\":\"el\",\"name\":\"Greac\"},{\"code\":\"id\",\"name\":\"Indonezian\"},{\"code\":\"ga\",\"name\":\"Irlandez\"},{\"code\":\"is\",\"name\":\"Islandez\"},{\"code\":\"it\",\"name\":\"Italian\"},{\"code\":\"ja\",\"name\":\"Japonez\"},{\"code\":\"lv\",\"name\":\"Leton\"},{\"code\":\"lt\",\"name\":\"Lituanian\"},{\"code\":\"hu\",\"name\":\"Maghiar\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nl\",\"name\":\"Neerlandez\"},{\"code\":\"nb\",\"name\":\"Norvegian\"},{\"code\":\"fa\",\"name\":\"Persan\"},{\"code\":\"pl\",\"name\":\"Polonez\"},{\"code\":\"pt\",\"name\":\"Portughez\"},{\"code\":\"ro\",\"name\":\"Romn\"},{\"code\":\"ru\",\"name\":\"Rus\"},{\"code\":\"sr\",\"name\":\"Srb\"},{\"code\":\"sk\",\"name\":\"Slovac\"},{\"code\":\"sl\",\"name\":\"Sloven\"},{\"code\":\"es\",\"name\":\"Spaniol\"},{\"code\":\"sv\",\"name\":\"Suedez\"},{\"code\":\"th\",\"name\":\"Thailandez\"},{\"code\":\"tr\",\"name\":\"Turc\"},{\"code\":\"uk\",\"name\":\"Ucrainean\"},{\"code\":\"vi\",\"name\":\"Vietnamez\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"lt\":[{\"code\":\"ga\",\"name\":\"airi\"},{\"code\":\"am\",\"name\":\"amhar\"},{\"code\":\"en\",\"name\":\"angl\"},{\"code\":\"ar\",\"name\":\"arab\"},{\"code\":\"az\",\"name\":\"Azerbaidaniei\"},{\"code\":\"eu\",\"name\":\"bask\"},{\"code\":\"bg\",\"name\":\"bulgar\"},{\"code\":\"cs\",\"name\":\"ek\"},{\"code\":\"da\",\"name\":\"dan\"},{\"code\":\"et\",\"name\":\"est\"},{\"code\":\"gl\",\"name\":\"galis\"},{\"code\":\"el\",\"name\":\"graik\"},{\"code\":\"he\",\"name\":\"hebraj\"},{\"code\":\"id\",\"name\":\"indoneziei\"},{\"code\":\"is\",\"name\":\"island\"},{\"code\":\"es\",\"name\":\"ispan\"},{\"code\":\"it\",\"name\":\"ital\"},{\"code\":\"ja\",\"name\":\"japon\"},{\"code\":\"ca\",\"name\":\"kataloniei\"},{\"code\":\"zh-cn\",\"name\":\"kin (supaprastinta)\"},{\"code\":\"zh-tw\",\"name\":\"kin (tradicin)\"},{\"code\":\"ko\",\"name\":\"korjiei\"},{\"code\":\"hr\",\"name\":\"kroat\"},{\"code\":\"lv\",\"name\":\"latvi\"},{\"code\":\"pl\",\"name\":\"lenk\"},{\"code\":\"lt\",\"name\":\"lietuvi\"},{\"code\":\"mi\",\"name\":\"maori\"},{\"code\":\"nb\",\"name\":\"norveg\"},{\"code\":\"nl\",\"name\":\"oland\"},{\"code\":\"fa\",\"name\":\"pers\"},{\"code\":\"pt\",\"name\":\"portugal\"},{\"code\":\"fr\",\"name\":\"prancz\"},{\"code\":\"ro\",\"name\":\"rumun\"},{\"code\":\"ru\",\"name\":\"rus\"},{\"code\":\"sr\",\"name\":\"serb\"},{\"code\":\"sk\",\"name\":\"slovak\"},{\"code\":\"sl\",\"name\":\"slovn\"},{\"code\":\"fi\",\"name\":\"suomi\"},{\"code\":\"gd\",\"name\":\"kot (gl)\"},{\"code\":\"sv\",\"name\":\"ved\"},{\"code\":\"th\",\"name\":\"taj\"},{\"code\":\"tr\",\"name\":\"turk\"},{\"code\":\"uk\",\"name\":\"ukrainiei\"},{\"code\":\"cy\",\"name\":\"val\"},{\"code\":\"hu\",\"name\":\"vengr\"},{\"code\":\"vi\",\"name\":\"vietnamiei\"},{\"code\":\"de\",\"name\":\"vokiei\"},{\"code\":\"zu\",\"name\":\"zulus\"}],\"ko\":[{\"code\":\"gl\",\"name\":\"\"},{\"code\":\"el\",\"name\":\"\"},{\"code\":\"nl\",\"name\":\"\"},{\"code\":\"nb\",\"name\":\"\"},{\"code\":\"da\",\"name\":\"\"},{\"code\":\"de\",\"name\":\"\"},{\"code\":\"lv\",\"name\":\"\"},{\"code\":\"ru\",\"name\":\"\"},{\"code\":\"ro\",\"name\":\"\"},{\"code\":\"lt\",\"name\":\"\"},{\"code\":\"mi\",\"name\":\"\"},{\"code\":\"eu\",\"name\":\"\"},{\"code\":\"vi\",\"name\":\"\"},{\"code\":\"bg\",\"name\":\"\"},{\"code\":\"sr\",\"name\":\"\"},{\"code\":\"sv\",\"name\":\"\"},{\"code\":\"gd\",\"name\":\" \"},{\"code\":\"es\",\"name\":\"\"},{\"code\":\"sk\",\"name\":\"\"},{\"code\":\"sl\",\"name\":\"\"},{\"code\":\"ar\",\"name\":\"\"},{\"code\":\"is\",\"name\":\"\"},{\"code\":\"ga\",\"name\":\"\"},{\"code\":\"az\",\"name\":\"\"},{\"code\":\"am\",\"name\":\"\"},{\"code\":\"et\",\"name\":\"\"},{\"code\":\"en\",\"name\":\"\"},{\"code\":\"uk\",\"name\":\"\"},{\"code\":\"cy\",\"name\":\"\"},{\"code\":\"it\",\"name\":\"\"},{\"code\":\"id\",\"name\":\"\"},{\"code\":\"ja\",\"name\":\"\"},{\"code\":\"zu\",\"name\":\"\"},{\"code\":\"zh-cn\",\"name\":\"()\"},{\"code\":\"zh-tw\",\"name\":\"()\"},{\"code\":\"cs\",\"name\":\"\"},{\"code\":\"ca\",\"name\":\"\"},{\"code\":\"hr\",\"name\":\"\"},{\"code\":\"th\",\"name\":\"\"},{\"code\":\"tr\",\"name\":\"\"},{\"code\":\"fa\",\"name\":\"\"},{\"code\":\"pt\",\"name\":\"\"},{\"code\":\"pl\",\"name\":\"\"},{\"code\":\"fr\",\"name\":\"\"},{\"code\":\"fi\",\"name\":\"\"},{\"code\":\"ko\",\"name\":\"\"},{\"code\":\"hu\",\"name\":\"\"},{\"code\":\"he\",\"name\":\"\"}],\"it\":[{\"code\":\"am\",\"name\":\"Amarico\"},{\"code\":\"ar\",\"name\":\"Arabo\"},{\"code\":\"az\",\"name\":\"Azero\"},{\"code\":\"eu\",\"name\":\"Basco\"},{\"code\":\"bg\",\"name\":\"Bulgaro\"},{\"code\":\"ca\",\"name\":\"Catalano\"},{\"code\":\"cs\",\"name\":\"Ceco\"},{\"code\":\"zh-cn\",\"name\":\"Cinese (semplificato)\"},{\"code\":\"zh-tw\",\"name\":\"Cinese (tradizionale)\"},{\"code\":\"ko\",\"name\":\"Coreano\"},{\"code\":\"hr\",\"name\":\"Croato\"},{\"code\":\"da\",\"name\":\"Danese\"},{\"code\":\"he\",\"name\":\"Ebraico\"},{\"code\":\"et\",\"name\":\"Estone\"},{\"code\":\"fi\",\"name\":\"Finlandese\"},{\"code\":\"fr\",\"name\":\"Francese\"},{\"code\":\"gd\",\"name\":\"Gaelico scozzese\"},{\"code\":\"gl\",\"name\":\"Galiziano\"},{\"code\":\"cy\",\"name\":\"Gallese\"},{\"code\":\"ja\",\"name\":\"Giapponese\"},{\"code\":\"el\",\"name\":\"Greco\"},{\"code\":\"id\",\"name\":\"Indonesiano\"},{\"code\":\"en\",\"name\":\"Inglese\"},{\"code\":\"ga\",\"name\":\"Irlandese\"},{\"code\":\"is\",\"name\":\"Islandese\"},{\"code\":\"it\",\"name\":\"Italiano\"},{\"code\":\"lv\",\"name\":\"Lettone\"},{\"code\":\"lt\",\"name\":\"Lituano\"},{\"code\":\"mi\",\"name\":\"Maori\"},{\"code\":\"nb\",\"name\":\"Norvegese\"},{\"code\":\"nl\",\"name\":\"Olandese\"},{\"code\":\"fa\",\"name\":\"Persiano\"},{\"code\":\"pl\",\"name\":\"Polacco\"},{\"code\":\"pt\",\"name\":\"Portoghese\"},{\"code\":\"ro\",\"name\":\"Rumeno\"},{\"code\":\"ru\",\"name\":\"Russo\"},{\"code\":\"sr\",\"name\":\"Serbo\"},{\"code\":\"sk\",\"name\":\"Slovacco\"},{\"code\":\"sl\",\"name\":\"Sloveno\"},{\"code\":\"es\",\"name\":\"Spagnolo\"},{\"code\":\"sv\",\"name\":\"Svedese\"},{\"code\":\"th\",\"name\":\"Tailandese\"},{\"code\":\"de\",\"name\":\"Tedesco\"},{\"code\":\"tr\",\"name\":\"Turco\"},{\"code\":\"uk\",\"name\":\"Ucraino\"},{\"code\":\"hu\",\"name\":\"Ungherese\"},{\"code\":\"vi\",\"name\":\"Vietnamita\"},{\"code\":\"zu\",\"name\":\"Zulu\"}],\"vi\":[{\"code\":\"ar\",\"name\":\"Ting  Rp\"},{\"code\":\"am\",\"name\":\"Ting Amharic\"},{\"code\":\"en\",\"name\":\"Ting Anh\"},{\"code\":\"az\",\"name\":\"Ting Azerbaijan\"},{\"code\":\"pl\",\"name\":\"Ting Ba Lan\"},{\"code\":\"fa\",\"name\":\"Ting Ba T\"},{\"code\":\"eu\",\"name\":\"Ting Basque\"},{\"code\":\"pt\",\"name\":\"Ting B o Nha\"},{\"code\":\"bg\",\"name\":\"Ting Bulgaria\"},{\"code\":\"ca\",\"name\":\"Ting Catalan\"},{\"code\":\"hr\",\"name\":\"Ting Croatia\"},{\"code\":\"he\",\"name\":\"Ting Do Thi\"},{\"code\":\"da\",\"name\":\"Ting an Mch\"},{\"code\":\"de\",\"name\":\"Ting c\"},{\"code\":\"et\",\"name\":\"Ting Estonia\"},{\"code\":\"gd\",\"name\":\"Ting Gael Scotland\"},{\"code\":\"gl\",\"name\":\"Ting Galicia\"},{\"code\":\"nl\",\"name\":\"Ting H Lan\"},{\"code\":\"ko\",\"name\":\"Ting Hn\"},{\"code\":\"hu\",\"name\":\"Ting Hungary\"},{\"code\":\"el\",\"name\":\"Ting Hy Lp\"},{\"code\":\"is\",\"name\":\"Ting Iceland\"},{\"code\":\"id\",\"name\":\"Ting Indonesia\"},{\"code\":\"ga\",\"name\":\"Ting Ireland\"},{\"code\":\"lv\",\"name\":\"Ting Latvia\"},{\"code\":\"lt\",\"name\":\"Ting Litva\"},{\"code\":\"mi\",\"name\":\"Ting Maori\"},{\"code\":\"nb\",\"name\":\"Ting Na Uy\"},{\"code\":\"ru\",\"name\":\"Ting Nga\"},{\"code\":\"ja\",\"name\":\"Ting Nht\"},{\"code\":\"fr\",\"name\":\"Ting Php\"},{\"code\":\"fi\",\"name\":\"Ting Phn Lan\"},{\"code\":\"ro\",\"name\":\"Ting Rumani\"},{\"code\":\"cs\",\"name\":\"Ting Sc\"},{\"code\":\"sr\",\"name\":\"Ting Serbia\"},{\"code\":\"sk\",\"name\":\"Ting Slovak\"},{\"code\":\"sl\",\"name\":\"Ting Slovenia\"},{\"code\":\"es\",\"name\":\"Ting Ty Ban Nha\"},{\"code\":\"th\",\"name\":\"Ting Thi\"},{\"code\":\"tr\",\"name\":\"Ting Th Nh K\"},{\"code\":\"sv\",\"name\":\"Ting Thy in\"},{\"code\":\"zh-cn\",\"name\":\"Ting Trung (Gian Th)\"},{\"code\":\"zh-tw\",\"name\":\"Ting Trung (Phn th)\"},{\"code\":\"uk\",\"name\":\"Ting Ukraina\"},{\"code\":\"vi\",\"name\":\"Ting Vit\"},{\"code\":\"cy\",\"name\":\"Ting X Wales\"},{\"code\":\"it\",\"name\":\"Ting \"},{\"code\":\"zu\",\"name\":\"Ting Zulu\"}]},\"nameMap\":{\"albntina\":\"sq\",\"amhartina\":\"am\",\"anglitina\":\"en\",\"arabtina\":\"ar\",\"armntina\":\"hy\",\"zerbjdntina\":\"az\",\"barmtina\":\"my\",\"baskitina\":\"eu\",\"blorutina\":\"be\",\"bulhartina\":\"bg\",\"etina\":\"cs\",\"ntina (tradin)\":\"zh-tw\",\"ntina (zjednoduen)\":\"zh-cn\",\"dntina\":\"da\",\"esperanto\":\"eo\",\"estontina\":\"et\",\"fintina\":\"fi\",\"francouztina\":\"fr\",\"galicijtina\":\"gl\",\"haitsk kreoltina\":\"ht\",\"hebrejtina\":\"he\",\"hindtina\":\"hi\",\"holandtina\":\"nl\",\"chorvattina\":\"hr\",\"indontina\":\"id\",\"irtina\":\"ga\",\"islandtina\":\"is\",\"italtina\":\"it\",\"japontina\":\"ja\",\"kannadtina\":\"kn\",\"katalntina\":\"ca\",\"korejtina\":\"ko\",\"kurdtina\":\"ku\",\"latina\":\"la\",\"litevtina\":\"lt\",\"lotytina\":\"lv\",\"maartina\":\"hu\",\"makedontina\":\"mk\",\"malajlamtina\":\"ml\",\"malajtina\":\"ms\",\"malttina\":\"mt\",\"maortina\":\"mi\",\"marttina\":\"mr\",\"mongoltina\":\"mn\",\"nmina\":\"de\",\"nortina\":\"nb\",\"pertina\":\"fa\",\"poltina\":\"pl\",\"portugaltina\":\"pt\",\"rumuntina\":\"ro\",\"rutina\":\"ru\",\"etina\":\"el\",\"skotsk gaeltina\":\"gd\",\"sloventina\":\"sk\",\"slovintina\":\"sl\",\"srbtina\":\"sr\",\"panltina\":\"es\",\"vdtina\":\"sv\",\"telutina\":\"te\",\"thajtina\":\"th\",\"turetina\":\"tr\",\"ukrajintina\":\"uk\",\"uzbetina\":\"uz\",\"veltina\":\"cy\",\"vietnamtina\":\"vi\",\"zulu\":\"zu\",\"albansk\":\"sq\",\"amharisk\":\"am\",\"arabisk\":\"ar\",\"armensk\":\"hy\",\"aserbajdsjansk\":\"az\",\"baskisk\":\"eu\",\"bulgarsk\":\"bg\",\"burmesisk\":\"my\",\"dansk\":\"da\",\"engelsk\":\"en\",\"estisk\":\"et\",\"finsk\":\"fi\",\"fransk\":\"fr\",\"galicisk\":\"gl\",\"grsk\":\"el\",\"haitisk kreolsk\":\"ht\",\"hebraisk\":\"he\",\"hindi\":\"hi\",\"hollandsk\":\"nl\",\"hviderussisk\":\"be\",\"indonesisk\":\"id\",\"irsk\":\"ga\",\"islandsk\":\"is\",\"italiensk\":\"it\",\"japansk\":\"ja\",\"kannada\":\"kn\",\"katalansk\":\"ca\",\"kinesisk (forenklet)\":\"zh-cn\",\"kinesisk (traditionelt)\":\"zh-tw\",\"koreansk\":\"ko\",\"kroatisk\":\"hr\",\"kurdisk\":\"ku\",\"latin\":\"la\",\"lettisk\":\"lv\",\"litauisk\":\"lt\",\"makedonsk\":\"mk\",\"malajisk\":\"ms\",\"malayalam\":\"ml\",\"maltesisk\":\"mt\",\"maori\":\"mi\",\"marathi\":\"mr\",\"mongolsk\":\"mn\",\"norsk\":\"nb\",\"persisk\":\"fa\",\"polsk\":\"pl\",\"portugisisk\":\"pt\",\"rumnsk\":\"ro\",\"russisk\":\"ru\",\"serbisk\":\"sr\",\"skotsk glisk\":\"gd\",\"slovakisk\":\"sk\",\"slovensk\":\"sl\",\"spansk\":\"es\",\"svensk\":\"sv\",\"telugu\":\"te\",\"thailandsk\":\"th\",\"tjekkisk\":\"cs\",\"tyrkisk\":\"tr\",\"tysk\":\"de\",\"ukrainsk\":\"uk\",\"ungarsk\":\"hu\",\"usbekisk\":\"uz\",\"vietnamesisk\":\"vi\",\"walisisk\":\"cy\",\"acerbaixano\":\"az\",\"albans\":\"sq\",\"alemn\":\"de\",\"amrico\":\"am\",\"rabe\":\"ar\",\"armenio\":\"hy\",\"bielorruso\":\"be\",\"birmano\":\"my\",\"blgaro\":\"bg\",\"canars\":\"kn\",\"cataln\":\"ca\",\"checo\":\"cs\",\"chins (simplificado)\":\"zh-cn\",\"chins (tradicional)\":\"zh-tw\",\"coreano\":\"ko\",\"crioulo haitiano\":\"ht\",\"croata\":\"hr\",\"curdo\":\"ku\",\"dinamarqus\":\"da\",\"eslovaco\":\"sk\",\"esloveno\":\"sl\",\"espaol\":\"es\",\"estoniano\":\"et\",\"uscaro\":\"eu\",\"fins\":\"fi\",\"francs\":\"fr\",\"galico escocs\":\"gd\",\"galego\":\"gl\",\"gals\":\"cy\",\"grego\":\"el\",\"hebreo\":\"he\",\"hngaro\":\"hu\",\"indonesio\":\"id\",\"ingls\":\"en\",\"irlands\":\"ga\",\"islands\":\"is\",\"italiano\":\"it\",\"latn\":\"la\",\"letn\":\"lv\",\"lituano\":\"lt\",\"macedonio\":\"mk\",\"malabar\":\"ml\",\"malaio\":\"ms\",\"malts\":\"mt\",\"maor\":\"mi\",\"mongol\":\"mn\",\"neerlands\":\"nl\",\"noruegus\":\"nb\",\"persa\":\"fa\",\"polaco\":\"pl\",\"portugus\":\"pt\",\"romans\":\"ro\",\"ruso\":\"ru\",\"serbio\":\"sr\",\"sueco\":\"sv\",\"tailands\":\"th\",\"telug\":\"te\",\"turco\":\"tr\",\"ucrano\":\"uk\",\"usbeco\":\"uz\",\"vietnamita\":\"vi\",\"xapons\":\"ja\",\"zul\":\"zu\",\"albanina\":\"sq\",\"amharina\":\"am\",\"angleina\":\"en\",\"arabina\":\"ar\",\"armenina\":\"hy\",\"azerbajdanina\":\"az\",\"baskovina\":\"eu\",\"beloruina\":\"be\",\"bolgarina\":\"bg\",\"burmanina\":\"my\",\"eina\":\"cs\",\"danina\":\"da\",\"estonina\":\"et\",\"finina\":\"fi\",\"francoina\":\"fr\",\"galicijina\":\"gl\",\"grina\":\"el\",\"haitijska kreolina\":\"ht\",\"hebrejina\":\"he\",\"hindijina\":\"hi\",\"hrvaina\":\"hr\",\"indonezijina\":\"id\",\"irina\":\"ga\",\"islandina\":\"is\",\"italijanina\":\"it\",\"japonina\":\"ja\",\"kanareina\":\"kn\",\"katalonina\":\"ca\",\"kitajina (poenostavljena)\":\"zh-cn\",\"kitajina (tradicionalna)\":\"zh-tw\",\"korejina\":\"ko\",\"kurdina\":\"ku\",\"latinina\":\"la\",\"latvijina\":\"lv\",\"litovina\":\"lt\",\"madarina\":\"hu\",\"makedonina\":\"mk\",\"malajalina\":\"ml\",\"malajina\":\"ms\",\"malteina\":\"mt\",\"maorina\":\"mi\",\"maratina\":\"mr\",\"mongolina\":\"mn\",\"nemina\":\"de\",\"nizozemina\":\"nl\",\"norveina\":\"nb\",\"perzijina\":\"fa\",\"poljina\":\"pl\",\"portugalina\":\"pt\",\"romunina\":\"ro\",\"ruina\":\"ru\",\"slovaina\":\"sk\",\"slovenina\":\"sl\",\"srbina\":\"sr\",\"kotska gelina\":\"gd\",\"panina\":\"es\",\"vedina\":\"sv\",\"tajina\":\"th\",\"teluina\":\"te\",\"turina\":\"tr\",\"ukrajinina\":\"uk\",\"uzbeina\":\"uz\",\"valianina\":\"cy\",\"vietnamina\":\"vi\",\"zulujina\":\"zu\",\"albanais\":\"sq\",\"allemand\":\"de\",\"amharique\":\"am\",\"anglais\":\"en\",\"arabe\":\"ar\",\"armnien\":\"hy\",\"azri\":\"az\",\"basque\":\"eu\",\"bilorusse\":\"be\",\"birman\":\"my\",\"bulgare\":\"bg\",\"catalan\":\"ca\",\"chinois (simplifi)\":\"zh-cn\",\"chinois (traditionnel)\":\"zh-tw\",\"coren\":\"ko\",\"crole hatien\":\"ht\",\"croate\":\"hr\",\"danois\":\"da\",\"espagnol\":\"es\",\"espranto\":\"eo\",\"estonien\":\"et\",\"finnois\":\"fi\",\"franais\":\"fr\",\"galique (cosse)\":\"gd\",\"galicien\":\"gl\",\"gallois\":\"cy\",\"grec\":\"el\",\"hbreu\":\"he\",\"hongrois\":\"hu\",\"indonsien\":\"id\",\"irlandais\":\"ga\",\"islandais\":\"is\",\"italien\":\"it\",\"japonais\":\"ja\",\"kurde\":\"ku\",\"letton\":\"lv\",\"lituanien\":\"lt\",\"macdonien\":\"mk\",\"malaisien\":\"ms\",\"maltais\":\"mt\",\"nerlandais\":\"nl\",\"norvgien\":\"nb\",\"ouzbek\":\"uz\",\"persan\":\"fa\",\"polonais\":\"pl\",\"portugais\":\"pt\",\"roumain\":\"ro\",\"russe\":\"ru\",\"serbe\":\"sr\",\"slovaque\":\"sk\",\"slovne\":\"sl\",\"sudois\":\"sv\",\"tchque\":\"cs\",\"tha\":\"th\",\"turc\":\"tr\",\"ukrainien\":\"uk\",\"vietnamien\":\"vi\",\"zoulou\":\"zu\",\"albn\":\"sq\",\"amhara\":\"am\",\"angol\":\"en\",\"arab\":\"ar\",\"azeri\":\"az\",\"baszk\":\"eu\",\"belorusz\":\"be\",\"bolgr\":\"bg\",\"burmai\":\"my\",\"cseh\":\"cs\",\"dn\":\"da\",\"eszperant\":\"eo\",\"szt\":\"et\",\"finn\":\"fi\",\"francia\":\"fr\",\"galciai\":\"gl\",\"grg\":\"el\",\"haiti kreol\":\"ht\",\"hber\":\"he\",\"holland\":\"nl\",\"horvt\":\"hr\",\"indonz\":\"id\",\"r\":\"ga\",\"izlandi\":\"is\",\"japn\":\"ja\",\"kataln\":\"ca\",\"knai (egyszerstett)\":\"zh-cn\",\"knai (hagyomnyos)\":\"zh-tw\",\"koreai\":\"ko\",\"kurd\":\"ku\",\"lengyel\":\"pl\",\"lett\":\"lv\",\"litvn\":\"lt\",\"macedn\":\"mk\",\"magyar\":\"hu\",\"malj\":\"ms\",\"malajlam\":\"ml\",\"mltai\":\"mt\",\"marthi\":\"mr\",\"nmet\":\"de\",\"norvg\":\"nb\",\"olasz\":\"it\",\"orosz\":\"ru\",\"rmny\":\"hy\",\"perzsa\":\"fa\",\"portugl\":\"pt\",\"romn\":\"ro\",\"skt-gael\":\"gd\",\"spanyol\":\"es\",\"svd\":\"sv\",\"szerb\":\"sr\",\"szlovk\":\"sk\",\"szlovn\":\"sl\",\"thai\":\"th\",\"trk\":\"tr\",\"ukrn\":\"uk\",\"zbg\":\"uz\",\"vietnami\":\"vi\",\"walesi\":\"cy\",\"\":\"az\",\"\":\"sq\",\"\":\"am\",\"\":\"en\",\"\":\"ar\",\"\":\"eu\",\"\":\"be\",\"\":\"my\",\"\":\"bg\",\"\":\"vi\",\"\":\"cy\",\"\":\"hy\",\" \":\"ht\",\"\":\"hi\",\"\":\"el\",\"\":\"gl\",\"\":\"da\",\"\":\"eo\",\"\":\"et\",\"\":\"zu\",\"\":\"he\",\"\":\"id\",\"\":\"ga\",\"\":\"is\",\"\":\"es\",\"\":\"it\",\"\":\"kn\",\"\":\"ca\",\" ()\":\"zh-cn\",\" ()\":\"zh-tw\",\"\":\"ko\",\"\":\"ku\",\"\":\"la\",\"\":\"lv\",\"\":\"lt\",\"\":\"mk\",\"\":\"ms\",\"\":\"ml\",\"\":\"mt\",\"\":\"mi\",\"\":\"mr\",\"\":\"mn\",\"\":\"nl\",\"\":\"de\",\"\":\"nb\",\"\":\"fa\",\"\":\"pl\",\"\":\"pt\",\"\":\"ru\",\"\":\"ro\",\"\":\"sr\",\"\":\"sk\",\"\":\"sl\",\"\":\"th\",\"\":\"te\",\"\":\"tr\",\"\":\"hu\",\"\":\"uz\",\"\":\"uk\",\"\":\"fi\",\"\":\"fr\",\"\":\"hr\",\"\":\"cs\",\"\":\"sv\",\" ()\":\"gd\",\"\":\"ja\",\"\":\"tr\",\"()\":\"zh-tw\",\"()\":\"zh-cn\",\"\":\"da\",\"\":\"eu\",\"\":\"ja\",\"\":\"mi\",\"\":\"eo\",\"\":\"gl\",\"\":\"ca\",\"\":\"kn\",\"\":\"be\",\"\":\"lt\",\"\":\"is\",\"\":\"hu\",\"\":\"id\",\"\":\"hi\",\"\":\"es\",\"\":\"hr\",\"\":\"he\",\"\":\"el\",\"\":\"hy\",\"\":\"az\",\"\":\"la\",\"\":\"lv\",\"\":\"fr\",\"\":\"fa\",\"\":\"pl\",\"\":\"fi\",\"\":\"am\",\"\":\"ar\",\"\":\"sq\",\"\":\"ru\",\"\":\"bg\",\"\":\"zu\",\"\":\"cy\",\"\":\"en\",\"\":\"ku\",\"\":\"nb\",\"\":\"th\",\"\":\"te\",\"\":\"ht\",\"\":\"uk\",\"\":\"uz\",\"\":\"mt\",\"\":\"ms\",\"\":\"mk\",\"\":\"mr\",\"\":\"ml\",\"\":\"cs\",\"\":\"nl\",\"\":\"sk\",\"\":\"sl\",\"\":\"vi\",\"\":\"sr\",\"\":\"et\",\"\":\"ga\",\"\":\"sv\",\"\":\"it\",\"\":\"pt\",\"\":\"mn\",\"\":\"de\",\"\":\"my\",\"\":\"ko\",\"\":\"ro\",\"\":\"gd\",\"\":\"az\",\"\":\"am\",\"\":\"ar\",\"\":\"hy\",\"\":\"sq\",\"\":\"is\",\"\":\"ga\",\"\":\"en\",\"\":\"id\",\"\":\"it\",\"\":\"uz\",\"\":\"et\",\"\":\"eo\",\"\":\"kn\",\" ()\":\"ku\",\"\":\"ca\",\"\":\"ko\",\"\":\"hr\",\"\":\"gl\",\"\":\"el\",\" ()\":\"zh-tw\",\" ()\":\"zh-cn\",\"\":\"ja\",\"\":\"de\",\"\":\"zu\",\"\":\"cs\",\"\":\"nl\",\"\":\"da\",\"\":\"tr\",\"\":\"te\",\"\":\"th\",\"\":\"nb\",\"\":\"pt\",\"\":\"pl\",\"\":\"fa\",\"\":\"fi\",\"\":\"fr\",\"\":\"bg\",\"\":\"eu\",\"\":\"be\",\"\":\"mn\",\"\":\"mr\",\"\":\"ms\",\"\":\"ml\",\"\":\"mi\",\"\":\"mt\",\"\":\"mk\",\" ()\":\"my\",\"\":\"uk\",\"\":\"ru\",\"\":\"ro\",\"\":\"lv\",\"\":\"lt\",\"\":\"la\",\"\":\"cy\",\"\":\"vi\",\"\":\"sr\",\" \":\"gd\",\"\":\"es\",\"\":\"sk\",\"\":\"sl\",\"\":\"sv\",\"\":\"hu\",\"\":\"hi\",\"\":\"he\",\" \":\"ht\",\"albanian\":\"sq\",\"amharic\":\"am\",\"arabic\":\"ar\",\"armenian\":\"hy\",\"azerbaijani\":\"az\",\"belarusian\":\"be\",\"bulgarian\":\"bg\",\"chinese (simplified)\":\"zh-cn\",\"chinese (traditional)\":\"zh-tw\",\"croatian\":\"hr\",\"czech\":\"cs\",\"danish\":\"da\",\"dutch\":\"nl\",\"english\":\"en\",\"estonian\":\"et\",\"finnish\":\"fi\",\"french\":\"fr\",\"galician\":\"gl\",\"german\":\"de\",\"greek\":\"el\",\"haitian creole\":\"ht\",\"hebrew\":\"he\",\"hungarian\":\"hu\",\"icelandic\":\"is\",\"indonesian\":\"id\",\"irish\":\"ga\",\"italian\":\"it\",\"japanese\":\"ja\",\"korean\":\"ko\",\"kurdish (kurmanji)\":\"ku\",\"latvian\":\"lv\",\"lithuanian\":\"lt\",\"macedonian\":\"mk\",\"malay\":\"ms\",\"maltese\":\"mt\",\"mongolian\":\"mn\",\"myanmar (burmese)\":\"my\",\"norwegian\":\"nb\",\"persian\":\"fa\",\"polish\":\"pl\",\"portuguese\":\"pt\",\"romanian\":\"ro\",\"russian\":\"ru\",\"scots gaelic\":\"gd\",\"serbian\":\"sr\",\"slovak\":\"sk\",\"slovenian\":\"sl\",\"spanish\":\"es\",\"swedish\":\"sv\",\"turkish\":\"tr\",\"ukrainian\":\"uk\",\"uzbek\":\"uz\",\"vietnamese\":\"vi\",\"welsh\":\"cy\",\"albans\":\"sq\",\"alemo\":\"de\",\"armnio\":\"hy\",\"azerbaijano\":\"az\",\"basco\":\"eu\",\"bielo-russo\":\"be\",\"birmans\":\"my\",\"canars\":\"kn\",\"catalo\":\"ca\",\"chins (simplificado)\":\"zh-cn\",\"chins (tradicional)\":\"zh-tw\",\"dinamarqus\":\"da\",\"espanhol\":\"es\",\"finlands\":\"fi\",\"francs\":\"fr\",\"galico escocs\":\"gd\",\"gals\":\"cy\",\"hebraico\":\"he\",\"holands\":\"nl\",\"indonsio\":\"id\",\"ingls\":\"en\",\"irlands\":\"ga\",\"islands\":\"is\",\"japons\":\"ja\",\"latim\":\"la\",\"leto\":\"lv\",\"macednio\":\"mk\",\"malaiala\":\"ml\",\"malts\":\"mt\",\"marata\":\"mr\",\"noruegus\":\"nb\",\"polons\":\"pl\",\"portugus\":\"pt\",\"romeno\":\"ro\",\"russo\":\"ru\",\"srvio\":\"sr\",\"tailands\":\"th\",\"tcheco\":\"cs\",\"telugo\":\"te\",\"ucraniano\":\"uk\",\"uzbeque\":\"uz\",\"almanca\":\"de\",\"arapa\":\"ar\",\"arnavuta\":\"sq\",\"azerice\":\"az\",\"baska\":\"eu\",\"belarusa\":\"be\",\"bulgarca\":\"bg\",\"burmaca\":\"my\",\"eke\":\"cs\",\"ince (basitletirilmi)\":\"zh-cn\",\"ince (geleneksel)\":\"zh-tw\",\"danca\":\"da\",\"endonezya dili\":\"id\",\"ermenice\":\"hy\",\"esperantoca\":\"eo\",\"estonyaca\":\"et\",\"farsa\":\"fa\",\"felemenke\":\"nl\",\"fince\":\"fi\",\"franszca\":\"fr\",\"galce\":\"cy\",\"galiyaca\":\"gl\",\"habee\":\"am\",\"haiti creole dili\":\"ht\",\"hrvata\":\"hr\",\"hinte\":\"hi\",\"ibranice\":\"he\",\"ingilizce\":\"en\",\"irlandaca\":\"ga\",\"ispanyolca\":\"es\",\"isvee\":\"sv\",\"italyanca\":\"it\",\"izlandaca\":\"is\",\"japonca\":\"ja\",\"katalanca\":\"ca\",\"korece\":\"ko\",\"kuzey isko dili\":\"gd\",\"krte\":\"ku\",\"latince\":\"la\",\"lehe\":\"pl\",\"letonca\":\"lv\",\"litvanca\":\"lt\",\"macarca\":\"hu\",\"makedonca\":\"mk\",\"malezya dili\":\"ms\",\"malta dili\":\"mt\",\"maori dili\":\"mi\",\"moolca\":\"mn\",\"norvee\":\"nb\",\"zbeke\":\"uz\",\"portekizce\":\"pt\",\"romence\":\"ro\",\"rusa\":\"ru\",\"srpa\":\"sr\",\"slovaka\":\"sk\",\"slovence\":\"sl\",\"tay dili\":\"th\",\"telugu dili\":\"te\",\"trke\":\"tr\",\"ukraynaca\":\"uk\",\"vietnamca\":\"vi\",\"yunanca\":\"el\",\"airminis\":\"hy\",\"albinis\":\"sq\",\"amrais\":\"am\",\"araibis\":\"ar\",\"asarbaiseinis\":\"az\",\"bascais\":\"eu\",\"bealarisis\":\"be\",\"barla\":\"en\",\"breatnais\":\"cy\",\"bulgiris\":\"bg\",\"cannadais\":\"kn\",\"catalinis\":\"ca\",\"coirdis (curmainsis)\":\"ku\",\"ciris\":\"ko\",\"cril ht\":\"ht\",\"critis\":\"hr\",\"danmhairgis\":\"da\",\"eabhrais\":\"he\",\"eastinis\":\"et\",\"fionlainnis\":\"fi\",\"fraincis\":\"fr\",\"gaeilge\":\"ga\",\"gaeilge na halban\":\"gd\",\"gailsis\":\"gl\",\"gearminis\":\"de\",\"grigis\":\"el\",\"hiondis\":\"hi\",\"indinisis\":\"id\",\"iodilis\":\"it\",\"ioruais\":\"nb\",\"oslainnis\":\"is\",\"laidin\":\"la\",\"laitvis\":\"lv\",\"liotuinis\":\"lt\",\"macadinis\":\"mk\",\"maenmar (burmais)\":\"my\",\"mailalaimis\":\"ml\",\"malaeis\":\"ms\",\"mltais\":\"mt\",\"maorais\":\"mi\",\"maraitis\":\"mr\",\"mongilis\":\"mn\",\"ollainnis\":\"nl\",\"peirsis\":\"fa\",\"polainnis\":\"pl\",\"portaingilis\":\"pt\",\"rminis\":\"ro\",\"risis\":\"ru\",\"seapinis\":\"ja\",\"seicis\":\"cs\",\"seirbis\":\"sr\",\"snis (simplithe)\":\"zh-cn\",\"snis (traidisinta)\":\"zh-tw\",\"slivinis\":\"sl\",\"slvaicis\":\"sk\",\"spinnis\":\"es\",\"sualainnis\":\"sv\",\"slis\":\"zu\",\"talainnis\":\"th\",\"teileagis\":\"te\",\"tuircis\":\"tr\",\"crinis\":\"uk\",\"isbiceastinis\":\"uz\",\"ungiris\":\"hu\",\"vtneaimis\":\"vi\",\"\":\"el\",\"\":\"kn\",\"\":\"gl\",\"\":\"gd\",\"\":\"ko\",\"\":\"ca\",\"\":\"ku\",\"\":\"hr\",\" ()\":\"zh-tw\",\" ()\":\"zh-cn\",\"\":\"cs\",\"\":\"zu\",\"\":\"sr\",\"\":\"ja\",\"\":\"nl\",\"\":\"da\",\"\":\"tr\",\"\":\"te\",\"\":\"th\",\"\":\"nb\",\"\":\"bg\",\"\":\"eu\",\"\":\"be\",\"\":\"fa\",\"\":\"pt\",\"\":\"pl\",\"\":\"fr\",\"\":\"fi\",\"\":\"mn\",\"\":\"mt\",\"\":\"mk\",\"\":\"mr\",\"\":\"ml\",\"\":\"ms\",\"\":\"mi\",\" ()\":\"my\",\"\":\"uk\",\"\":\"de\",\"\":\"ru\",\"\":\"ro\",\"\":\"la\",\"\":\"lv\",\"\":\"lt\",\"\":\"cy\",\"\":\"vi\",\"\":\"es\",\"\":\"sk\",\"\":\"sl\",\"\":\"sv\",\"\":\"en\",\"\":\"am\",\"\":\"sq\",\"\":\"az\",\"\":\"hy\",\"\":\"ar\",\"\":\"it\",\"\":\"id\",\"\":\"uz\",\"\":\"et\",\"\":\"eo\",\"\":\"is\",\"\":\"ga\",\"\":\"hu\",\"\":\"hi\",\"\":\"he\",\"\":\"ht\",\"\":\"is\",\"\":\"ga\",\"\":\"az\",\"\":\"am\",\"\":\"ar\",\"\":\"sq\",\"\":\"hy\",\"\":\"it\",\"\":\"id\",\"\":\"cy\",\"\":\"uk\",\"\":\"uz\",\"\":\"et\",\"\":\"eo\",\"\":\"nl\",\"\":\"ca\",\"\":\"gl\",\"\":\"kn\",\"\":\"el\",\"\":\"ku\",\"\":\"hr\",\"\":\"sv\",\"\":\"zu\",\" \":\"gd\",\"\":\"es\",\"\":\"sk\",\"\":\"sl\",\"\":\"sr\",\"\":\"th\",\"\":\"cs\",\"\":\"te\",\"\":\"da\",\"\":\"de\",\"\":\"tr\",\"\":\"nb\",\"\":\"ht\",\"\":\"eu\",\"\":\"hu\",\"\":\"hi\",\"\":\"fi\",\"\":\"fr\",\"\":\"bg\",\"\":\"vi\",\"\":\"he\",\"\":\"be\",\"\":\"fa\",\"\":\"pl\",\"\":\"pt\",\"\":\"mi\",\"\":\"mk\",\"\":\"mr\",\"\":\"ml\",\"\":\"mt\",\"\":\"ms\",\"\":\"my\",\"\":\"mn\",\"\":\"la\",\"\":\"lv\",\"\":\"lt\",\"\":\"ro\",\"\":\"ru\",\"\":\"en\",\"\":\"ko\",\"()\":\"zh-cn\",\"()\":\"zh-tw\",\"\":\"ja\",\"albanees\":\"sq\",\"amharisch\":\"am\",\"arabisch\":\"ar\",\"armeens\":\"hy\",\"azerbeidzjaans\":\"az\",\"baskisch\":\"eu\",\"birmaans\":\"my\",\"bulgaars\":\"bg\",\"catalaans\":\"ca\",\"chinees (traditioneel)\":\"zh-tw\",\"chinees (vereenvoudigd)\":\"zh-cn\",\"deens\":\"da\",\"duits\":\"de\",\"engels\":\"en\",\"ests\":\"et\",\"fins\":\"fi\",\"frans\":\"fr\",\"galicisch\":\"gl\",\"grieks\":\"el\",\"hatiaans creools\":\"ht\",\"hebreeuws\":\"he\",\"hongaars\":\"hu\",\"iers\":\"ga\",\"ijslands\":\"is\",\"indonesisch\":\"id\",\"italiaans\":\"it\",\"japans\":\"ja\",\"koerdisch\":\"ku\",\"koreaans\":\"ko\",\"kroatisch\":\"hr\",\"latijn\":\"la\",\"lets\":\"lv\",\"litouws\":\"lt\",\"macedonisch\":\"mk\",\"maleis\":\"ms\",\"maltees\":\"mt\",\"mongools\":\"mn\",\"nederlands\":\"nl\",\"noors\":\"nb\",\"oekraens\":\"uk\",\"oezbeeks\":\"uz\",\"perzisch\":\"fa\",\"pools\":\"pl\",\"portugees\":\"pt\",\"roemeens\":\"ro\",\"russisch\":\"ru\",\"schots keltisch\":\"gd\",\"servisch\":\"sr\",\"slovaaks\":\"sk\",\"sloveens\":\"sl\",\"spaans\":\"es\",\"tsjechisch\":\"cs\",\"turks\":\"tr\",\"vietnamees\":\"vi\",\"wels\":\"cy\",\"wit-russisch\":\"be\",\"zoeloe\":\"zu\",\"zweeds\":\"sv\",\"airmeinis\":\"hy\",\"albinis\":\"sq\",\"amtharais\":\"am\",\"arabais\":\"ar\",\"asarbaidenais\":\"az\",\"basgais\":\"eu\",\"bealaruisis\":\"be\",\"beurla\":\"en\",\"bhiet-namais\":\"vi\",\"bulgarais\":\"bg\",\"cnan nan tidh\":\"th\",\"catalanais\":\"ca\",\"coiranais\":\"ko\",\"crtheol haidhti\":\"ht\",\"crthaisis\":\"hr\",\"cuimris\":\"cy\",\"crdais (kurmanji)\":\"ku\",\"duitsis\":\"nl\",\"eabhra\":\"he\",\"eadailtis\":\"it\",\"eastoinis\":\"et\",\"fionnlannais\":\"fi\",\"fraingis\":\"fr\",\"gidhlig\":\"gd\",\"gailsis\":\"gl\",\"gearmailtis\":\"de\",\"grigis\":\"el\",\"hindis\":\"hi\",\"innd-innsis\":\"id\",\"innis-tlis\":\"is\",\"laideann\":\"la\",\"laitbheis\":\"lv\",\"liotuainis\":\"lt\",\"malaidhis\":\"ms\",\"mori\":\"mi\",\"masadonais\":\"mk\",\"minmar (burmais)\":\"my\",\"mongolais\":\"mn\",\"nirribhis\":\"nb\",\"plainnis\":\"pl\",\"portagailis\":\"pt\",\"rominis\":\"ro\",\"ruisis\":\"ru\",\"seacais\":\"cs\",\"seapanais\":\"ja\",\"sirbis\":\"sr\",\"sonais (seann-nsach)\":\"zh-tw\",\"sonais (smplichte)\":\"zh-cn\",\"slbhacais\":\"sk\",\"slbhainis\":\"sl\",\"spinntis\":\"es\",\"suainis\":\"sv\",\"turcais\":\"tr\",\"ucrinis\":\"uk\",\"ungairis\":\"hu\",\"usbagais\":\"uz\",\"farsi\":\"fa\",\"galisisk\":\"gl\",\"gresk\":\"el\",\"hviterussisk\":\"be\",\"kinesisk (tradisjonell)\":\"zh-tw\",\"kreol (haiti)\":\"ht\",\"latvisk\":\"lv\",\"malayisk\":\"ms\",\"nederlandsk\":\"nl\",\"rumensk\":\"ro\",\"tsjekkisk\":\"cs\",\"albanisch\":\"sq\",\"armenisch\":\"hy\",\"aserbaidschanisch\":\"az\",\"birmanisch\":\"my\",\"bulgarisch\":\"bg\",\"chinesisch (traditionell)\":\"zh-tw\",\"chinesisch (vereinfacht)\":\"zh-cn\",\"dnisch\":\"da\",\"deutsch\":\"de\",\"englisch\":\"en\",\"estnisch\":\"et\",\"finnisch\":\"fi\",\"franzsisch\":\"fr\",\"galizisch\":\"gl\",\"griechisch\":\"el\",\"haitianisch\":\"ht\",\"hebrisch\":\"he\",\"irisch\":\"ga\",\"islndisch\":\"is\",\"italienisch\":\"it\",\"japanisch\":\"ja\",\"katalanisch\":\"ca\",\"koreanisch\":\"ko\",\"kurdisch (kurmandschi)\":\"ku\",\"lateinisch\":\"la\",\"lettisch\":\"lv\",\"litauisch\":\"lt\",\"malaysisch\":\"ms\",\"maltesisch\":\"mt\",\"mazedonisch\":\"mk\",\"mongolisch\":\"mn\",\"niederlndisch\":\"nl\",\"norwegisch\":\"nb\",\"persisch\":\"fa\",\"polnisch\":\"pl\",\"portugiesisch\":\"pt\",\"rumnisch\":\"ro\",\"schottisch-glisch\":\"gd\",\"schwedisch\":\"sv\",\"serbisch\":\"sr\",\"slowakisch\":\"sk\",\"slowenisch\":\"sl\",\"spanisch\":\"es\",\"thailndisch\":\"th\",\"tschechisch\":\"cs\",\"trkisch\":\"tr\",\"ukrainisch\":\"uk\",\"ungarisch\":\"hu\",\"usbekisch\":\"uz\",\"vietnamesisch\":\"vi\",\"walisisch\":\"cy\",\"weirussisch\":\"be\",\"\":\"kn\",\" ()\":\"ku\",\"\":\"ko\",\"\":\"ca\",\"\":\"hr\",\"\":\"cs\",\"\":\"el\",\"\":\"gl\",\"\":\"ja\",\"\":\"de\",\" \":\"gd\",\"\":\"es\",\"\":\"sl\",\"\":\"sk\",\"\":\"sr\",\"\":\"sv\",\"\":\"zu\",\" ()\":\"zh-tw\",\" ()\":\"zh-cn\",\"\":\"tr\",\"\":\"te\",\"\":\"th\",\"\":\"nl\",\"\":\"da\",\"\":\"nb\",\"\":\"fa\",\"\":\"pt\",\"\":\"pl\",\"\":\"fr\",\"\":\"fi\",\"\":\"vi\",\"\":\"eu\",\"\":\"bg\",\"\":\"be\",\"\":\"ml\",\"\":\"ms\",\"\":\"mr\",\"\":\"mi\",\"\":\"mt\",\"\":\"mk\",\" ()\":\"my\",\"\":\"mn\",\"\":\"uk\",\"\":\"ru\",\"\":\"ro\",\"\":\"la\",\"\":\"lt\",\"\":\"lv\",\"\":\"cy\",\"\":\"he\",\" \":\"ht\",\"\":\"hi\",\"\":\"hu\",\"\":\"az\",\"\":\"hy\",\"\":\"ar\",\"\":\"it\",\"\":\"uz\",\"\":\"et\",\"\":\"eo\",\"\":\"is\",\"\":\"en\",\"\":\"id\",\"\":\"ga\",\"\":\"am\",\"\":\"sq\",\"\":\"uz\",\"\":\"uk\",\"\":\"az\",\"\":\"it\",\"\":\"id\",\"\":\"is\",\"\":\"ga\",\"\":\"sq\",\"\":\"am\",\"\":\"en\",\"\":\"et\",\"\":\"eo\",\"\":\"hy\",\"\":\"eu\",\"\":\"bg\",\"\":\"my\",\"\":\"be\",\"\":\"gl\",\"\":\"de\",\"\":\"da\",\"\":\"nl\",\"\":\"hu\",\"\":\"hi\",\"\":\"cy\",\"\":\"vi\",\"\":\"zu\",\"\":\"tr\",\"\":\"te\",\"\":\"el\",\"\":\"ja\",\"\":\"ku\",\"\":\"lv\",\"\":\"la\",\"\":\"lt\",\"\":\"mi\",\"\":\"ml\",\"\":\"ms\",\"\":\"mr\",\"\":\"mn\",\"\":\"mt\",\"\":\"mk\",\"\":\"nb\",\" ()\":\"zh-tw\",\" ()\":\"zh-cn\",\"\":\"sl\",\"\":\"sk\",\"\":\"es\",\" \":\"gd\",\"\":\"sr\",\"\":\"he\",\"\":\"ar\",\"\":\"pl\",\"\":\"pt\",\"\":\"fi\",\"\":\"fa\",\"'\":\"cs\",\"\":\"fr\",\"\":\"kn\",\"\":\"ko\",\"\":\"ca\",\"\":\"hr\",\" \":\"ht\",\"\":\"ro\",\"\":\"ru\",\"\":\"sv\",\"\":\"th\",\"\":\"az\",\"\":\"sq\",\"\":\"am\",\"\":\"en\",\"\":\"ar\",\"\":\"eu\",\"\":\"be\",\"\":\"bg\",\"\":\"my\",\"\":\"cy\",\"\":\"vi\",\"\":\"gl\",\"\":\"de\",\"\":\"el\",\"\":\"da\",\"\":\"hy\",\"\":\"et\",\"\":\"id\",\"\":\"ga\",\"\":\"is\",\"\":\"it\",\"\":\"ja\",\"\":\"kn\",\"\":\"ca\",\" ()\":\"zh-cn\",\" ()\":\"zh-tw\",\"\":\"ko\",\"\":\"ku\",\"\":\"lv\",\"\":\"la\",\"\":\"lt\",\"\":\"mk\",\"\":\"ml\",\"\":\"ms\",\"\":\"mt\",\"\":\"mi\",\"\":\"mr\",\"\":\"mn\",\"\":\"nb\",\"\":\"fa\",\"\":\"pl\",\"\":\"pt\",\"\":\"ro\",\"\":\"ru\",\"\":\"sk\",\"\":\"sl\",\"\":\"sr\",\"\":\"th\",\"\":\"te\",\"\":\"tr\",\"\":\"uz\",\"\":\"uk\",\"\":\"hu\",\"\":\"fi\",\"\":\"fr\",\" \":\"ht\",\"\":\"he\",\"\":\"hi\",\"\":\"nl\",\"\":\"hr\",\"\":\"cs\",\"\":\"sv\",\" \":\"gd\",\"\":\"es\",\"\":\"az\",\"\":\"am\",\"\":\"ar\",\"\":\"hy\",\"\":\"sq\",\"\":\"en\",\"\":\"id\",\"\":\"it\",\"\":\"uz\",\"\":\"et\",\"\":\"eo\",\"\":\"ga\",\"\":\"is\",\"\":\"kn\",\"\":\"ku\",\"\":\"ko\",\"\":\"ca\",\"\":\"hr\",\"\":\"gl\",\"\":\"el\",\" ()\":\"zh-cn\",\" ()\":\"zh-tw\",\"\":\"ja\",\"\":\"de\",\"\":\"zu\",\"\":\"cs\",\"\":\"tr\",\"\":\"nl\",\"\":\"da\",\"\":\"te\",\"\":\"th\",\"\":\"nb\",\"\":\"pt\",\"\":\"pl\",\"\":\"fa\",\"\":\"fi\",\"\":\"fr\",\"\":\"my\",\"\":\"bg\",\"\":\"eu\",\"\":\"be\",\"\":\"mn\",\"\":\"mr\",\"\":\"ms\",\"\":\"ml\",\"\":\"mt\",\"\":\"mi\",\"\":\"mk\",\"\":\"uk\",\"\":\"ru\",\"\":\"ro\",\"\":\"lt\",\"\":\"la\",\"\":\"lv\",\"\":\"vi\",\"\":\"cy\",\"\":\"sr\",\" \":\"gd\",\"\":\"es\",\"\":\"sk\",\"\":\"sl\",\"\":\"sv\",\"\":\"hu\",\" \":\"ht\",\"\":\"hi\",\"\":\"he\",\"\":\"am\",\"\":\"hy\",\"\":\"sq\",\"\":\"az\",\"\":\"ar\",\"\":\"id\",\"\":\"en\",\"\":\"it\",\"\":\"uk\",\"\":\"uz\",\"\":\"eo\",\"\":\"et\",\"\":\"is\",\"\":\"ga\",\"\":\"kn\",\"\":\"ca\",\"\":\"ku\",\"\":\"ko\",\"\":\"hr\",\"\":\"gl\",\"\":\"el\",\"\":\"cs\",\" ()\":\"zh-tw\",\" ()\":\"zh-cn\",\"\":\"de\",\"\":\"ja\",\"\":\"tr\",\"\":\"nl\",\"\":\"da\",\"\":\"th\",\"\":\"te\",\"\":\"nb\",\"\":\"fa\",\"\":\"pt\",\"\":\"pl\",\"\":\"fi\",\"\":\"fr\",\"\":\"my\",\"\":\"bg\",\"\":\"eu\",\"\":\"be\",\"\":\"mn\",\"\":\"ml\",\"\":\"ms\",\"\":\"mr\",\"\":\"mk\",\"\":\"mt\",\"\":\"mi\",\"\":\"la\",\"\":\"lv\",\"\":\"lt\",\"\":\"vi\",\"\":\"cy\",\"\":\"zu\",\"\":\"sr\",\" \":\"gd\",\"\":\"es\",\"\":\"sk\",\"\":\"sl\",\"\":\"sv\",\"\":\"hu\",\"\":\"hi\",\"\":\"he\",\" \":\"ht\",\"\":\"ru\",\"\":\"ro\",\"albnina\":\"sq\",\"amharina\":\"am\",\"arabina\":\"ar\",\"armnina\":\"hy\",\"azerbajdanina\":\"az\",\"barmina\":\"my\",\"bielorutina\":\"be\",\"bulharina\":\"bg\",\"ntina (tradin)\":\"zh-tw\",\"dnina\":\"da\",\"estnina\":\"et\",\"fnina\":\"fi\",\"francztina\":\"fr\",\"galcijina\":\"gl\",\"grtina\":\"el\",\"haitsk kreolina\":\"ht\",\"hebrejina\":\"he\",\"hindina\":\"hi\",\"holandina\":\"nl\",\"chorvtina\":\"hr\",\"indonztina\":\"id\",\"rina\":\"ga\",\"islandina\":\"is\",\"japonina\":\"ja\",\"kannadina\":\"kn\",\"katalnina\":\"ca\",\"krejina\":\"ko\",\"kurdina\":\"ku\",\"latinina\":\"la\",\"litovina\":\"lt\",\"macednina\":\"mk\",\"maarina\":\"hu\",\"malajmina\":\"ml\",\"malajina\":\"ms\",\"maltina\":\"mt\",\"maorijina\":\"mi\",\"maratina\":\"mr\",\"mongolina\":\"mn\",\"nemina\":\"de\",\"nrina\":\"nb\",\"perztina\":\"fa\",\"potina\":\"pl\",\"portugalina\":\"pt\",\"rumunina\":\"ro\",\"slovenina\":\"sk\",\"slovinina\":\"sl\",\"srbina\":\"sr\",\"ktska gaelina\":\"gd\",\"panielina\":\"es\",\"vdina\":\"sv\",\"talianina\":\"it\",\"telugina\":\"te\",\"thajina\":\"th\",\"ukrajinina\":\"uk\",\"vietnamina\":\"vi\",\"waletina\":\"cy\",\"zulutina\":\"zu\",\"isi-albania\":\"sq\",\"isi-amharic\":\"am\",\"isi-arabic\":\"ar\",\"isi-armenian\":\"hy\",\"isi-azerbaijani\":\"az\",\"isi-basque\":\"eu\",\"isi-belarusian\":\"be\",\"isi-bulgarian\":\"bg\",\"isi-burmese\":\"my\",\"isi-catalan\":\"ca\",\"isi-chinese (simplified)\":\"zh-cn\",\"isi-chinese (traditional)\":\"zh-tw\",\"isi-croatian\":\"hr\",\"isi-czech\":\"cs\",\"isi-danish\":\"da\",\"isi-dutch\":\"nl\",\"isi-english\":\"en\",\"isi-esperanto\":\"eo\",\"isi-estonian\":\"et\",\"isi-finnish\":\"fi\",\"isi-french\":\"fr\",\"isi-galician\":\"gl\",\"isi-german\":\"de\",\"isi-greek\":\"el\",\"isi-haitian creole\":\"ht\",\"isi-hangarian\":\"hu\",\"isi-hebrew\":\"he\",\"isi-hindi\":\"hi\",\"isi-icelandic\":\"is\",\"isi-indonesian\":\"id\",\"isi-irish\":\"ga\",\"isi-italian\":\"it\",\"isi-japanese\":\"ja\",\"isi-kannada\":\"kn\",\"isi-korean\":\"ko\",\"isi-kurdish\":\"ku\",\"isi-latin\":\"la\",\"isi-latvian\":\"lv\",\"isi-lithuanian\":\"lt\",\"isi-macedonian\":\"mk\",\"isi-malay\":\"ms\",\"isi-malayalam\":\"ml\",\"isi-maltese\":\"mt\",\"isi-maori\":\"mi\",\"isi-marathi\":\"mr\",\"isi-mongolian\":\"mn\",\"isi-norwegian\":\"nb\",\"isi-persian\":\"fa\",\"isi-polish\":\"pl\",\"isi-portuguese\":\"pt\",\"isi-romanian\":\"ro\",\"isi-russian\":\"ru\",\"isi-scots gaelic\":\"gd\",\"isi-serbian\":\"sr\",\"isi-slovak\":\"sk\",\"isi-slovenian\":\"sl\",\"isi-spanish\":\"es\",\"isi-swedish\":\"sv\",\"isi-telugu\":\"te\",\"isi-thai\":\"th\",\"isi-turkish\":\"tr\",\"isi-ukrainian\":\"uk\",\"isi-uzbek\":\"uz\",\"isi-vietnamese\":\"vi\",\"isi-welsh\":\"cy\",\"isizulu\":\"zu\",\"albania\":\"sq\",\"armenia\":\"hy\",\"azerbaijan\":\"az\",\"belanda\":\"nl\",\"belarus\":\"be\",\"bulgaria\":\"bg\",\"cina (mudah)\":\"zh-cn\",\"cina (tradisional)\":\"zh-tw\",\"croatia\":\"hr\",\"denmark\":\"da\",\"estonia\":\"et\",\"finland\":\"fi\",\"gaelic scotland\":\"gd\",\"galicia\":\"gl\",\"hungary\":\"hu\",\"ibrani\":\"he\",\"iceland\":\"is\",\"indonesia\":\"id\",\"inggeris\":\"en\",\"ireland\":\"ga\",\"itali\":\"it\",\"jepun\":\"ja\",\"jerman\":\"de\",\"korea\":\"ko\",\"kreol haiti\":\"ht\",\"kurdistan\":\"ku\",\"latvia\":\"lv\",\"lithuania\":\"lt\",\"macedonia\":\"mk\",\"malta\":\"mt\",\"melayu\":\"ms\",\"mongolia\":\"mn\",\"myanmar\":\"my\",\"norway\":\"nb\",\"parsi\":\"fa\",\"perancis\":\"fr\",\"poland\":\"pl\",\"portugis\":\"pt\",\"romania\":\"ro\",\"rusia\":\"ru\",\"sepanyol\":\"es\",\"serbia\":\"sr\",\"slovenia\":\"sl\",\"sweden\":\"sv\",\"turki\":\"tr\",\"ukraine\":\"uk\",\"vietnam\":\"vi\",\"wales\":\"cy\",\"\":\"az\",\"\":\"sq\",\"\":\"am\",\"\":\"en\",\"\":\"ar\",\"\":\"hy\",\"\":\"eu\",\"\":\"be\",\"\":\"my\",\"\":\"bg\",\"\":\"cy\",\"\":\"hu\",\"\":\"vi\",\"\":\"gl\",\"\":\"el\",\"\":\"da\",\"\":\"he\",\"\":\"id\",\"\":\"ga\",\"\":\"is\",\"\":\"es\",\"\":\"it\",\"\":\"ca\",\" ()\":\"zh-tw\",\" ()\":\"zh-cn\",\"\":\"ko\",\" ()\":\"ht\",\"\":\"ku\",\"\":\"la\",\"\":\"lv\",\"\":\"lt\",\"\":\"mk\",\"\":\"ms\",\"\":\"mt\",\"\":\"mi\",\"\":\"mn\",\"\":\"de\",\"\":\"nl\",\"\":\"nb\",\"\":\"fa\",\"\":\"pl\",\"\":\"pt\",\"\":\"ro\",\"\":\"ru\",\"\":\"sr\",\"\":\"sk\",\"\":\"sl\",\"\":\"th\",\"\":\"tr\",\"\":\"uz\",\"\":\"uk\",\"\":\"fi\",\"\":\"fr\",\"\":\"hi\",\"\":\"hr\",\"\":\"cs\",\"\":\"sv\",\" ()\":\"gd\",\"\":\"eo\",\"\":\"et\",\"\":\"ja\",\"albaski\":\"sq\",\"amharski\":\"am\",\"angielski\":\"en\",\"arabski\":\"ar\",\"azerski\":\"az\",\"baskijski\":\"eu\",\"biaoruski\":\"be\",\"birmaski\":\"my\",\"bugarski\":\"bg\",\"chiski (tradycyjny)\":\"zh-tw\",\"chiski (uproszczony)\":\"zh-cn\",\"chorwacki\":\"hr\",\"czeski\":\"cs\",\"duski\":\"da\",\"estoski\":\"et\",\"fiski\":\"fi\",\"francuski\":\"fr\",\"galicyjski\":\"gl\",\"grecki\":\"el\",\"hebrajski\":\"he\",\"hiszpaski\":\"es\",\"indonezyjski\":\"id\",\"irlandzki\":\"ga\",\"islandzki\":\"is\",\"japoski\":\"ja\",\"kataloski\":\"ca\",\"koreaski\":\"ko\",\"kreolski (haiti)\":\"ht\",\"kurdyjski\":\"ku\",\"litewski\":\"lt\",\"aciski\":\"la\",\"otewski\":\"lv\",\"macedoski\":\"mk\",\"malajalam\":\"ml\",\"malajski\":\"ms\",\"maltaski\":\"mt\",\"mongolski\":\"mn\",\"niderlandzki\":\"nl\",\"niemiecki\":\"de\",\"norweski\":\"nb\",\"ormiaski\":\"hy\",\"perski\":\"fa\",\"polski\":\"pl\",\"portugalski\":\"pt\",\"rosyjski\":\"ru\",\"rumuski\":\"ro\",\"serbski\":\"sr\",\"sowacki\":\"sk\",\"soweski\":\"sl\",\"szkocki gaelicki\":\"gd\",\"szwedzki\":\"sv\",\"tajski\":\"th\",\"turecki\":\"tr\",\"ukraiski\":\"uk\",\"uzbecki\":\"uz\",\"walijski\":\"cy\",\"wgierski\":\"hu\",\"wietnamski\":\"vi\",\"woski\":\"it\",\"\":\"az\",\"\":\"sq\",\"\":\"am\",\"\":\"en\",\"\":\"ar\",\"\":\"hy\",\"\":\"bg\",\"\":\"eu\",\"\":\"be\",\"'\":\"vi\",\"\":\"cy\",\"\":\"hu\",\" \":\"ht\",\"\":\"nl\",\"\":\"gl\",\"\":\"el\",\"\":\"da\",\"\":\"id\",\"\":\"ga\",\"\":\"is\",\"\":\"es\",\"\":\"it\",\"\":\"he\",\"\":\"ko\",\"\":\"ca\",\" ()\":\"zh-cn\",\" ()\":\"zh-tw\",\" ()\":\"ku\",\"\":\"lv\",\"\":\"la\",\"\":\"lt\",\"' ()\":\"my\",\"\":\"mi\",\"\":\"mk\",\"\":\"ms\",\"\":\"mt\",\"\":\"mn\",\"\":\"nb\",\"\":\"de\",\"\":\"pt\",\"\":\"fa\",\"\":\"pl\",\"\":\"ro\",\"\":\"ru\",\"\":\"sr\",\"\":\"sk\",\"\":\"sl\",\"\":\"th\",\"\":\"tr\",\"\":\"te\",\"\":\"uz\",\"\":\"uk\",\"\":\"fi\",\"\":\"fr\",\"\":\"hr\",\"\":\"hi\",\"\":\"cs\",\" \":\"gd\",\"\":\"sv\",\"\":\"eo\",\"\":\"et\",\"\":\"ja\",\"amarikisht\":\"am\",\"anglisht\":\"en\",\"arabisht\":\"ar\",\"armenisht\":\"hy\",\"azerisht\":\"az\",\"baskisht\":\"eu\",\"birmanisht\":\"my\",\"bjellorusisht\":\"be\",\"bullgarisht\":\"bg\",\"ekisht\":\"cs\",\"danisht\":\"da\",\"estonisht\":\"et\",\"finlandisht\":\"fi\",\"frngjisht\":\"fr\",\"galicianisht\":\"gl\",\"galishte skoceze\":\"gd\",\"greqisht\":\"el\",\"gjermanisht\":\"de\",\"hebraisht\":\"he\",\"hindisht\":\"hi\",\"holandisht\":\"nl\",\"hungarisht\":\"hu\",\"indonezisht\":\"id\",\"irlandisht\":\"ga\",\"islandisht\":\"is\",\"italisht\":\"it\",\"japonisht\":\"ja\",\"kanada\":\"kn\",\"katalonisht\":\"ca\",\"kinezisht (e thjeshtuar)\":\"zh-cn\",\"kinezisht (tradicionale)\":\"zh-tw\",\"koreanisht\":\"ko\",\"kreolishte haitiane\":\"ht\",\"kroatisht\":\"hr\",\"latinisht\":\"la\",\"letonisht\":\"lv\",\"lituanisht\":\"lt\",\"malajalamisht\":\"ml\",\"malajzisht\":\"ms\",\"malteze\":\"mt\",\"maorisht\":\"mi\",\"maqedonisht\":\"mk\",\"maratisht\":\"mr\",\"mongolisht\":\"mn\",\"norvegjisht\":\"nb\",\"persisht\":\"fa\",\"polonisht\":\"pl\",\"portugalisht\":\"pt\",\"rumanisht\":\"ro\",\"rusisht\":\"ru\",\"serbisht\":\"sr\",\"sllovakisht\":\"sk\",\"sllovenisht\":\"sl\",\"spanjisht\":\"es\",\"suedisht\":\"sv\",\"shqip\":\"sq\",\"tajlandisht\":\"th\",\"telugisht\":\"te\",\"turqisht\":\"tr\",\"uellsisht\":\"cy\",\"ukrainisht\":\"uk\",\"uzbekisht\":\"uz\",\"vietnamisht\":\"vi\",\"\":\"hu\",\"\":\"hi\",\"\":\"lt\",\"\":\"la\",\"\":\"lv\",\"\":\"ml\",\"\":\"ms\",\"\":\"mt\",\"\":\"mr\",\"\":\"mi\",\"\":\"mk\",\"\":\"mn\",\"\":\"ru\",\"\":\"ro\",\"\":\"sr\",\"\":\"sk\",\"\":\"sl\",\"\":\"sv\",\"\":\"es\",\"\":\"my\",\"\":\"bg\",\"\":\"eu\",\"\":\"be\",\"\":\"vi\",\"\":\"tr\",\"\":\"th\",\"\":\"te\",\"   ()\":\"zh-cn\",\"  ()\":\"zh-tw\",\"\":\"cs\",\"\":\"nb\",\"\":\"sq\",\"\":\"am\",\"\":\"hy\",\"\":\"az\",\"\":\"ga\",\"\":\"is\",\"\":\"uz\",\"\":\"et\",\"\":\"eo\",\"\":\"id\",\"\":\"en\",\"\":\"ku\",\"\":\"ca\",\"\":\"kn\",\"\":\"hr\",\"\":\"ko\",\"\":\"cy\",\"\":\"ar\",\"\":\"he\",\"\":\"zu\",\" \":\"ht\",\" \":\"gd\",\"\":\"uk\",\"\":\"nl\",\"\":\"da\",\"\":\"de\",\"\":\"ja\",\"\":\"gl\",\"\":\"el\",\"\":\"it\",\"\":\"fr\",\"\":\"fi\",\"\":\"fa\",\"\":\"pl\",\"\":\"pt\",\"alban\":\"sq\",\"alman\":\"de\",\"amarikc\":\"am\",\"azrbaycan dili\":\"az\",\"bask\":\"eu\",\"belarusca\":\"be\",\"bolqar\":\"bg\",\"ex\":\"cs\",\"in (n'nvi)\":\"zh-tw\",\"in (sadldirilmi)\":\"zh-cn\",\"danimarka\":\"da\",\"ermni\":\"hy\",\"eston\":\"et\",\"rb\":\"ar\",\"fars dili\":\"fa\",\"fin\":\"fi\",\"fransz\":\"fr\",\"haiti kreol dili\":\"ht\",\"hind\":\"hi\",\"xorvat\":\"hr\",\"ispan\":\"es\",\"indoneziya\":\"id\",\"ingilis\":\"en\",\"irland\":\"ga\",\"island\":\"is\",\"isve\":\"sv\",\"italyan\":\"it\",\"ivrit\":\"he\",\"katalan\":\"ca\",\"koreya\":\"ko\",\"krd dili (kurmanci)\":\"ku\",\"qalisian\":\"gl\",\"latn\":\"la\",\"lat\":\"lv\",\"litva\":\"lt\",\"macar\":\"hu\",\"makedoniya\":\"mk\",\"maoric\":\"mi\",\"monqolca\":\"mn\",\"myanma (birma) dili\":\"my\",\"norve\":\"nb\",\"zbk\":\"uz\",\"polyak\":\"pl\",\"portuqal\":\"pt\",\"rumn\":\"ro\",\"rus\":\"ru\",\"serb\":\"sr\",\"sloven\":\"sl\",\"otland (kelt)\":\"gd\",\"tayca\":\"th\",\"teluqu\":\"te\",\"trk\":\"tr\",\"uels\":\"cy\",\"ukrayna\":\"uk\",\"vyetnam\":\"vi\",\"yapon\":\"ja\",\"yunan\":\"el\",\"zulu dili\":\"zu\",\"albani\":\"sq\",\"amari\":\"am\",\"armen\":\"hy\",\"aerbajani\":\"az\",\"belarussu\":\"be\",\"bulgaru\":\"bg\",\"ek\":\"cs\",\"ini (semplifikat)\":\"zh-cn\",\"ini (tradizzjonali)\":\"zh-tw\",\"creole haiti\":\"ht\",\"dani\":\"da\",\"ebrajk\":\"he\",\"estonjan\":\"et\",\"finlandi\":\"fi\",\"frani\":\"fr\",\"appuni\":\"ja\",\"ermani\":\"de\",\"gaelic tal-iskoii\":\"gd\",\"galizjan\":\"gl\",\"grieg\":\"el\",\"garbi\":\"ar\",\"indi\":\"hi\",\"indonejan\":\"id\",\"ingli\":\"en\",\"irlandi\":\"ga\",\"islandi\":\"is\",\"kroat\":\"hr\",\"kurd (kurmanji)\":\"ku\",\"latvjan\":\"lv\",\"litwen\":\"lt\",\"maedonjan\":\"mk\",\"malasjan\":\"ms\",\"malti\":\"mt\",\"marati\":\"mr\",\"mjanmar (burma)\":\"my\",\"mongoljan\":\"mn\",\"norvei\":\"nb\",\"olandi\":\"nl\",\"persjan\":\"fa\",\"pollakk\":\"pl\",\"portugi\":\"pt\",\"rumen\":\"ro\",\"russu\":\"ru\",\"slovakk\":\"sk\",\"spanjol\":\"es\",\"svedi\":\"sv\",\"tajlandi\":\"th\",\"taljan\":\"it\",\"tork\":\"tr\",\"ukren\":\"uk\",\"ungeri\":\"hu\",\"ubek\":\"uz\",\"vjetnami\":\"vi\",\"ulu\":\"zu\",\"albanski\":\"sq\",\"amharik\":\"am\",\"arapski\":\"ar\",\"armenijski\":\"hy\",\"azerbajdanski\":\"az\",\"bjeloruski\":\"be\",\"bugarski\":\"bg\",\"burmanski\":\"my\",\"eki\":\"cs\",\"danski\":\"da\",\"engleski\":\"en\",\"estonski\":\"et\",\"finski\":\"fi\",\"galski\":\"gl\",\"grki\":\"el\",\"haiansko-kreolski\":\"ht\",\"hebrejski\":\"he\",\"hindu\":\"hi\",\"hrvatski\":\"hr\",\"indonezijski\":\"id\",\"irski\":\"ga\",\"islandski\":\"is\",\"japanski\":\"ja\",\"katalonski\":\"ca\",\"kineski (pojednost.)\":\"zh-cn\",\"kineski (tradicionalni)\":\"zh-tw\",\"korejski\":\"ko\",\"kurdski\":\"ku\",\"latinski\":\"la\",\"latvijski/letonski\":\"lv\",\"litvanski\":\"lt\",\"maarski\":\"hu\",\"makedonski\":\"mk\",\"malezijski\":\"ms\",\"malteki\":\"mt\",\"nizozemski\":\"nl\",\"norveki\":\"nb\",\"njemaki\":\"de\",\"perzijski\":\"fa\",\"poljski\":\"pl\",\"rumunjski\":\"ro\",\"ruski\":\"ru\",\"slovaki\":\"sk\",\"slovenski\":\"sl\",\"srpski\":\"sr\",\"kotski keltski\":\"gd\",\"panjolski\":\"es\",\"vedski\":\"sv\",\"tajlandski\":\"th\",\"talijanski\":\"it\",\"turski\":\"tr\",\"ukrajinski\":\"uk\",\"uzbekistanski\":\"uz\",\"velki\":\"cy\",\"vijetnamski\":\"vi\",\"\":\"az\",\"\":\"sq\",\"\":\"de\",\"\":\"hy\",\"\":\"uz\",\"\":\"es\",\"\":\"eo\",\"\":\"et\",\"\":\"sk\",\"\":\"sl\",\"\":\"uk\",\"\":\"am\",\"\":\"id\",\"\":\"en\",\"\":\"it\",\"\":\"ga\",\"\":\"is\",\"\":\"eu\",\"\":\"my\",\"\":\"be\",\"\":\"bg\",\"\":\"pt\",\"\":\"th\",\" \":\"tr\",\"\":\"te\",\"\":\"cs\",\" ()\":\"zh-cn\",\" ()\":\"zh-tw\",\"\":\"da\",\"\":\"ru\",\"\":\"ro\",\"\":\"zu\",\"\":\"ja\",\"\":\"sv\",\"\":\"sr\",\"\":\"he\",\"\":\"ar\",\"\":\"fa\",\"\":\"fr\",\"\":\"fi\",\"\":\"ca\",\"\":\"kn\",\" \":\"ht\",\"\":\"ku\",\"\":\"hr\",\"\":\"ko\",\"\":\"gl\",\" \":\"gd\",\"\":\"la\",\"\":\"lv\",\"\":\"pl\",\"\":\"lt\",\"\":\"mi\",\"\":\"ml\",\"\":\"ms\",\"\":\"mt\",\"\":\"hu\",\"\":\"mr\",\"\":\"mn\",\"\":\"mk\",\"\":\"nb\",\"\":\"cy\",\"\":\"vi\",\"\":\"nl\",\"\":\"hi\",\"\":\"el\",\"ahepaitani\":\"az\",\"airihi\":\"ga\",\"amariki\":\"am\",\"amniana\":\"hy\",\"arapeinia\":\"sq\",\"arapi\":\"ar\",\"epernato\":\"eo\",\"etnia\":\"et\",\"haina (onamata)\":\"zh-tw\",\"hainamana (kua whakammtia)\":\"zh-cn\",\"hanekeria\":\"hu\",\"hapanihi\":\"ja\",\"herepia\":\"sr\",\"hinerangi\":\"fi\",\"hni\":\"hi\",\"hiperu\":\"he\",\"horowkia\":\"sk\",\"horowinia\":\"sl\",\"huitene\":\"sv\",\"huru\":\"zu\",\"ingarihi\":\"en\",\"initonhia\":\"id\",\"itriana\":\"it\",\"kanata\":\"kn\",\"karihia\":\"gl\",\"katarna\":\"ca\",\"kereore haiti\":\"ht\",\"kiriki\":\"el\",\"kreana\":\"ko\",\"korotiana\":\"hr\",\"korukoru\":\"tr\",\"krihi\":\"ku\",\"makernia\":\"mk\",\"mratihi\":\"mt\",\"marei\":\"ms\",\"mareiarama\":\"ml\",\"mongriana\":\"mn\",\"nwei\":\"nb\",\"pkihi\":\"eu\",\"pniora\":\"es\",\"pma (purumhi)\":\"my\",\"peraruhia\":\"be\",\"perhia\":\"fa\",\"prana\":\"pl\",\"potukhi\":\"pt\",\"purukriana\":\"bg\",\"rtini\":\"la\",\"rwhiana\":\"lv\",\"ritunia\":\"lt\",\"romnia\":\"ro\",\"rhia\":\"ru\",\"tai\":\"th\",\"tati\":\"nl\",\"tenemka\":\"da\",\"teruku\":\"te\",\"tiamana\":\"de\",\"tieke\":\"cs\",\"tiorangi\":\"is\",\"tuauri kotarangi\":\"gd\",\"uhipeke\":\"uz\",\"kareiana\":\"uk\",\"wra\":\"cy\",\"whitinmu\":\"vi\",\"ww\":\"fr\",\"\":\"en\",\"\":\"az\",\"\":\"sq\",\"\":\"am\",\"\":\"ar\",\"\":\"hy\",\"\":\"eu\",\"\":\"vi\",\"\":\"my\",\"\":\"bg\",\" \":\"gd\",\"\":\"gl\",\"\":\"fr\",\"\":\"de\",\"\":\"da\",\"\":\"he\",\"\":\"el\",\"\":\"et\",\"\":\"eo\",\"\":\"zu\",\"\":\"ja\",\"\":\"id\",\"\":\"ga\",\"\":\"is\",\"\":\"es\",\"\":\"it\",\"\":\"kn\",\"\":\"ca\",\" ()\":\"zh-cn\",\" ()\":\"zh-tw\",\"\":\"ko\",\"\":\"ku\",\" \":\"ht\",\"\":\"hr\",\"\":\"la\",\"\":\"lv\",\"\":\"be\",\"\":\"lt\",\"\":\"ml\",\"\":\"ms\",\"\":\"mt\",\"\":\"mi\",\"\":\"mr\",\"\":\"mn\",\"\":\"nb\",\"\":\"nl\",\"\":\"cy\",\"\":\"hu\",\"\":\"uz\",\"\":\"uk\",\"\":\"fa\",\"\":\"pl\",\"\":\"pt\",\"\":\"ro\",\"\":\"ru\",\"\":\"sr\",\"\":\"mk\",\"\":\"sk\",\"\":\"sl\",\"\":\"sv\",\"\":\"th\",\"\":\"te\",\"\":\"tr\",\"\":\"cs\",\"\":\"fi\",\"\":\"hi\",\"amxar\":\"am\",\"arman\":\"hy\",\"bolgar\":\"bg\",\"dat\":\"da\",\"fors\":\"fa\",\"fransuz\":\"fr\",\"gaiti-kreol\":\"ht\",\"galisiy\":\"gl\",\"golland\":\"nl\",\"grek\":\"el\",\"ibroniy\":\"he\",\"indonez\":\"id\",\"ingliz\":\"en\",\"irland\":\"ga\",\"island\":\"is\",\"italyan\":\"it\",\"koreys\":\"ko\",\"kurd (kurmonji)\":\"ku\",\"latish\":\"lv\",\"lotin\":\"la\",\"makedon\":\"mk\",\"maltiy\":\"mt\",\"maratxi\":\"mr\",\"mogul\":\"mn\",\"nemis\":\"de\",\"norveg\":\"nb\",\"ozarbayjon\":\"az\",\"portugal\":\"pt\",\"rumin\":\"ro\",\"tay\":\"th\",\"turk\":\"tr\",\"ukrain\":\"uk\",\"valliy\":\"cy\",\"venger\":\"hu\",\"xitoy (ananaviy)\":\"zh-tw\",\"xitoy (soddalashgan)\":\"zh-cn\",\"ozbek\":\"uz\",\"shotland-gel\":\"gd\",\"shved\":\"sv\",\"chex\":\"cs\",\"albanska\":\"sq\",\"amharsku\":\"am\",\"arabska\":\"ar\",\"armenska\":\"hy\",\"aserska\":\"az\",\"baskneska\":\"eu\",\"blgarska\":\"bg\",\"brmska\":\"my\",\"danska\":\"da\",\"eistneska\":\"et\",\"enska\":\"en\",\"esperant\":\"eo\",\"finnska\":\"fi\",\"franska\":\"fr\",\"galisska\":\"gl\",\"grska\":\"el\",\"hatskt krelaml\":\"ht\",\"hebreska\":\"he\",\"hind\":\"hi\",\"hollenska\":\"nl\",\"hvtrssneska\":\"be\",\"indnesska\":\"id\",\"rska\":\"ga\",\"slenska\":\"is\",\"talska\":\"it\",\"japanska\":\"ja\",\"katalnska\":\"ca\",\"knverska (einfldu)\":\"zh-cn\",\"knverska (hefbundin)\":\"zh-tw\",\"kreska\":\"ko\",\"kratska\":\"hr\",\"krdska\":\"ku\",\"latna\":\"la\",\"lettneska\":\"lv\",\"lithska\":\"lt\",\"makednska\":\"mk\",\"malajska\":\"ms\",\"maltneska\":\"mt\",\"maorska\":\"mi\",\"marat\":\"mr\",\"monglska\":\"mn\",\"norska\":\"nb\",\"persneska\":\"fa\",\"portgalska\":\"pt\",\"plska\":\"pl\",\"rmenska\":\"ro\",\"rssneska\":\"ru\",\"serbneska\":\"sr\",\"skosk-gelska\":\"gd\",\"slvakska\":\"sk\",\"slvenska\":\"sl\",\"spnska\":\"es\",\"sl\":\"zu\",\"snska\":\"sv\",\"talenska\":\"th\",\"tkkneska\":\"cs\",\"tyrkneska\":\"tr\",\"ungverska\":\"hu\",\"kranska\":\"uk\",\"sbekska\":\"uz\",\"velska\":\"cy\",\"vetnamska\":\"vi\",\"ska\":\"de\",\"\":\"az\",\"\":\"sq\",\"\":\"am\",\"\":\"en\",\"\":\"ar\",\"\":\"eu\",\"\":\"be\",\"\":\"my\",\"\":\"bg\",\"\":\"gl\",\"\":\"de\",\"\":\"da\",\"\":\"he\",\"\":\"zu\",\"\":\"eo\",\"\":\"et\",\"\":\"th\",\"\":\"tr\",\"\":\"id\",\"\":\"ga\",\"\":\"is\",\"\":\"es\",\"\":\"it\",\"\":\"la\",\"\":\"lv\",\"\":\"pl\",\"\":\"lt\",\"\":\"hr\",\"\":\"kn\",\"\":\"ca\",\" \":\"gd\",\"\":\"ko\",\" ()\":\"ht\",\"\":\"hy\",\"\":\"hi\",\"\":\"nl\",\"\":\"el\",\"\":\"hu\",\"\":\"ja\",\"\":\"ml\",\"\":\"ms\",\"\":\"mt\",\"\":\"mk\",\"\":\"mi\",\"\":\"mr\",\"\":\"mn\",\"\":\"nb\",\"\":\"sv\",\"\":\"uz\",\"\":\"uk\",\"\":\"cs\",\" ()\":\"zh-tw\",\" ()\":\"zh-cn\",\"\":\"fa\",\"\":\"pt\",\"\":\"ro\",\"\":\"ru\",\"\":\"sr\",\"\":\"sk\",\"\":\"sl\",\"\":\"cy\",\"\":\"vi\",\"\":\"te\",\" ()\":\"ku\",\"\":\"fi\",\"\":\"fr\",\"arabia\":\"ar\",\"baski\":\"eu\",\"burma\":\"my\",\"englanti\":\"en\",\"espanja\":\"es\",\"haitinkreoli\":\"ht\",\"heprea\":\"he\",\"hollanti\":\"nl\",\"iiri\":\"ga\",\"islanti\":\"is\",\"italia\":\"it\",\"japani\":\"ja\",\"katalaani\":\"ca\",\"kiina (perinteinen)\":\"zh-tw\",\"kiina (yksinkert.)\":\"zh-cn\",\"kreikka\":\"el\",\"kroatia\":\"hr\",\"kurdi\":\"ku\",\"kymri\":\"cy\",\"liettua\":\"lt\",\"makedonia\":\"mk\",\"malaiji\":\"ms\",\"norja\":\"nb\",\"persia\":\"fa\",\"portugali\":\"pt\",\"puola\":\"pl\",\"ranska\":\"fr\",\"ruotsi\":\"sv\",\"saksa\":\"de\",\"skottigaeli\":\"gd\",\"slovakia\":\"sk\",\"suomi\":\"fi\",\"tanska\":\"da\",\"tsekki\":\"cs\",\"turkki\":\"tr\",\"ukraina\":\"uk\",\"unkari\":\"hu\",\"uzbekki\":\"uz\",\"valkovenj\":\"be\",\"venj\":\"ru\",\"viro\":\"et\",\"albaniera\":\"sq\",\"alemana\":\"de\",\"amharera\":\"am\",\"arabiera\":\"ar\",\"armeniera\":\"hy\",\"azerbaijanera\":\"az\",\"bielorrusiera\":\"be\",\"birmaniera\":\"my\",\"bulgariera\":\"bg\",\"daniera\":\"da\",\"errumaniera\":\"ro\",\"errusiera\":\"ru\",\"eskoziako gaelera\":\"gd\",\"eslovakiera\":\"sk\",\"esloveniera\":\"sl\",\"esperantoa\":\"eo\",\"estoniera\":\"et\",\"euskara\":\"eu\",\"frantsesa\":\"fr\",\"gaelera\":\"cy\",\"galiziera\":\"gl\",\"gaztelania\":\"es\",\"greziera\":\"el\",\"hebreera\":\"he\",\"hindia\":\"hi\",\"hungariera\":\"hu\",\"indonesiera\":\"id\",\"ingelesa\":\"en\",\"irlandera\":\"ga\",\"islandiera\":\"is\",\"italiera\":\"it\",\"japoniera\":\"ja\",\"katalana\":\"ca\",\"koreera\":\"ko\",\"kreolera (haiti)\":\"ht\",\"kroaziera\":\"hr\",\"kurduera\":\"ku\",\"letoniera\":\"lv\",\"lituaniera\":\"lt\",\"malabarera\":\"ml\",\"malaysiera\":\"ms\",\"maltera\":\"mt\",\"maoriera\":\"mi\",\"marathera\":\"mr\",\"mazedoniera\":\"mk\",\"mongoliera\":\"mn\",\"nederlandera\":\"nl\",\"norvegiera\":\"nb\",\"persiera\":\"fa\",\"poloniera\":\"pl\",\"portugesa\":\"pt\",\"serbiera\":\"sr\",\"suediera\":\"sv\",\"suomiera\":\"fi\",\"telugua\":\"te\",\"thaiera\":\"th\",\"turkiera\":\"tr\",\"txekiera\":\"cs\",\"txinera (soildua)\":\"zh-cn\",\"txinera (tradizionala)\":\"zh-tw\",\"ukrainera\":\"uk\",\"uzbekera\":\"uz\",\"vietnamera\":\"vi\",\"zuluera\":\"zu\",\"albans\":\"sq\",\"alemany\":\"de\",\"amhric\":\"am\",\"angls\":\"en\",\"rab\":\"ar\",\"armeni\":\"hy\",\"zeri\":\"az\",\"basc\":\"eu\",\"bielors\":\"be\",\"birm\":\"my\",\"blgar\":\"bg\",\"castell\":\"es\",\"catal\":\"ca\",\"core\":\"ko\",\"crioll d'hait\":\"ht\",\"croat\":\"hr\",\"dans\":\"da\",\"eslovac\":\"sk\",\"eslov\":\"sl\",\"estoni\":\"et\",\"fins\":\"fi\",\"francs\":\"fr\",\"galic escocs\":\"gd\",\"gallec\":\"gl\",\"galls\":\"cy\",\"hebreu\":\"he\",\"hongars\":\"hu\",\"indonesi\":\"id\",\"irlands\":\"ga\",\"islands\":\"is\",\"itali\":\"it\",\"japons\":\"ja\",\"let\":\"lv\",\"litu\":\"lt\",\"llat\":\"la\",\"macednic\":\"mk\",\"malai\":\"ms\",\"malailam\":\"ml\",\"malts\":\"mt\",\"neerlands\":\"nl\",\"noruec\":\"nb\",\"polons\":\"pl\",\"portugus\":\"pt\",\"romans\":\"ro\",\"serbi\":\"sr\",\"suec\":\"sv\",\"txec\":\"cs\",\"ucrans\":\"uk\",\"xins (simplificat)\":\"zh-cn\",\"xins (tradicional)\":\"zh-tw\",\"albu\":\"sq\",\"amharu\":\"am\",\"angu\":\"en\",\"arbu\":\"ar\",\"armu\":\"hy\",\"azerbaidu\":\"az\",\"baltkrievu\":\"be\",\"basku\":\"eu\",\"birmieu\":\"my\",\"bulgru\":\"bg\",\"ehu\":\"cs\",\"du\":\"da\",\"ebreju (ivrits)\":\"he\",\"franu\":\"fr\",\"galisieu\":\"gl\",\"grieu\":\"el\",\"holandieu\":\"nl\",\"horvtu\":\"hr\",\"igauu\":\"et\",\"indonzieu\":\"id\",\"ru\":\"ga\",\"slandieu\":\"is\",\"itu\":\"it\",\"japu\":\"ja\",\"katalu\":\"ca\",\"korejieu\":\"ko\",\"kreolu (haiti)\":\"ht\",\"krievu\":\"ru\",\"kurdu\":\"ku\",\"nieu (tradicionl)\":\"zh-tw\",\"nieu (vienkrot)\":\"zh-cn\",\"latu\":\"la\",\"latvieu\":\"lv\",\"lietuvieu\":\"lt\",\"maedonieu\":\"mk\",\"malajalamieu\":\"ml\",\"malajieu\":\"ms\",\"maltieu\":\"mt\",\"maratu\":\"mr\",\"mongou\":\"mn\",\"norvu\":\"nb\",\"persieu\":\"fa\",\"pou\":\"pl\",\"portugu\":\"pt\",\"rumu\":\"ro\",\"serbu\":\"sr\",\"skotu glu\":\"gd\",\"slovku\":\"sk\",\"slovu\":\"sl\",\"somu\":\"fi\",\"spu\":\"es\",\"taju\":\"th\",\"turku\":\"tr\",\"ukraiu\":\"uk\",\"ungru\":\"hu\",\"uzbeku\":\"uz\",\"vcu\":\"de\",\"velsieu\":\"cy\",\"vjetnamieu\":\"vi\",\"zviedru\":\"sv\",\"belarussia\":\"be\",\"cek\":\"cs\",\"china (aks. sederhana)\":\"zh-cn\",\"china (aks. tradisional)\":\"zh-tw\",\"finlandia\":\"fi\",\"gaelig\":\"ga\",\"gaelik skotlandia\":\"gd\",\"galisia\":\"gl\",\"inggris\":\"en\",\"islan\":\"is\",\"jepang\":\"ja\",\"katala\":\"ca\",\"lituania\":\"lt\",\"polandia\":\"pl\",\"prancis\":\"fr\",\"rumania\":\"ro\",\"swensk\":\"sv\",\"yunani\":\"el\",\"\":\"az\",\"\":\"hy\",\"\":\"sq\",\"\":\"en\",\"\":\"am\",\"\":\"ar\",\"\":\"id\",\"\":\"it\",\"\":\"uz\",\"\":\"eo\",\"\":\"et\",\"\":\"ga\",\" \":\"is\",\"\":\"kn\",\"\":\"ku\",\"\":\"ko\",\"\":\"ca\",\"\":\"hr\",\"\":\"gl\",\"\":\"el\",\"\":\"cs\",\" ()\":\"zh-cn\",\" ()\":\"zh-tw\",\"\":\"ja\",\"\":\"de\",\"\":\"zu\",\"\":\"tr\",\"\":\"nl\",\"\":\"da\",\"\":\"te\",\"\":\"th\",\"\":\"nb\",\"\":\"fa\",\"\":\"pt\",\"\":\"pl\",\"\":\"fi\",\"\":\"fr\",\"\":\"my\",\"\":\"bg\",\"\":\"eu\",\"\":\"be\",\"\":\"mn\",\"\":\"mi\",\"\":\"mr\",\"\":\"ml\",\"\":\"ms\",\"\":\"mt\",\"\":\"mk\",\"\":\"uk\",\"\":\"ru\",\"\":\"ro\",\"\":\"la\",\"\":\"lv\",\"\":\"lt\",\"\":\"vi\",\"\":\"cy\",\"\":\"sr\",\" \":\"gd\",\"\":\"es\",\"\":\"sk\",\"\":\"sl\",\"\":\"sv\",\"\":\"hu\",\"\":\"hi\",\"\":\"he\",\" \":\"ht\",\"amhrico\":\"am\",\"azer\":\"az\",\"chino (simplificado)\":\"zh-cn\",\"chino (tradicional)\":\"zh-tw\",\"criollo haitiano\":\"ht\",\"dans\":\"da\",\"estonio\":\"et\",\"euskera\":\"eu\",\"finlands\":\"fi\",\"gallego\":\"gl\",\"griego\":\"el\",\"japons\":\"ja\",\"kurdo\":\"ku\",\"malayo\":\"ms\",\"noruego\":\"nb\",\"rumano\":\"ro\",\"uzbeco\":\"uz\",\"albaania\":\"sq\",\"amhaari\":\"am\",\"araabia\":\"ar\",\"armeenia\":\"hy\",\"aserbaidaani\":\"az\",\"birma\":\"my\",\"bulgaaria\":\"bg\",\"eesti\":\"et\",\"galeegi\":\"gl\",\"haitikreooli\":\"ht\",\"heebrea\":\"he\",\"hispaania\":\"es\",\"hollandi\":\"nl\",\"horvaadi\":\"hr\",\"indoneesia\":\"id\",\"inglise\":\"en\",\"islandi\":\"is\",\"itaalia\":\"it\",\"jaapani\":\"ja\",\"kreeka\":\"el\",\"ladina\":\"la\",\"leedu\":\"lt\",\"lihtsustatud hiina\":\"zh-cn\",\"lti\":\"lv\",\"makedoonia\":\"mk\",\"malajalaami\":\"ml\",\"maoori\":\"mi\",\"mongoli\":\"mn\",\"norra\":\"nb\",\"poola\":\"pl\",\"prantsuse\":\"fr\",\"prsia\":\"fa\",\"rootsi\":\"sv\",\"rumeenia\":\"ro\",\"slovaki\":\"sk\",\"sloveeni\":\"sl\",\"soome\":\"fi\",\"suulu\":\"zu\",\"oti\":\"gd\",\"taani\":\"da\",\"traditsiooniline hiina\":\"zh-tw\",\"tehhi\":\"cs\",\"trgi\":\"tr\",\"uelsi\":\"cy\",\"ungari\":\"hu\",\"usbeki\":\"uz\",\"valgevene\":\"be\",\"vene\":\"ru\",\"albanyen\":\"sq\",\"amenyen\":\"hy\",\"angl\":\"en\",\"azbajani\":\"az\",\"belarisyen\":\"be\",\"bilgaryen\":\"bg\",\"chinwa (senp)\":\"zh-cn\",\"chinwa (tradisyonl)\":\"zh-tw\",\"danwa\":\"da\",\"ebre\":\"he\",\"endonezyen\":\"id\",\"endou\":\"hi\",\"estonyen\":\"et\",\"fenland\":\"fi\",\"franse\":\"fr\",\"gaelik ekos\":\"gd\",\"galisyen\":\"gl\",\"grk\":\"el\",\"ikrenyen\":\"uk\",\"iland\":\"ga\",\"island\":\"is\",\"italyen\":\"it\",\"izbk\":\"uz\",\"japon\":\"ja\",\"koreyen\":\"ko\",\"kreyl ayisyen\":\"ht\",\"kurde (kurmandji)\":\"ku\",\"kwoasyen\":\"hr\",\"laten\":\"la\",\"letonyen\":\"lv\",\"lityanyen\":\"lt\",\"mal\":\"ms\",\"malt\":\"mt\",\"masedonyen\":\"mk\",\"mongolyen\":\"mn\",\"myanma (burmese)\":\"my\",\"nvejyen\":\"nb\",\"oland, neyland\":\"nl\",\"onngaryen\":\"hu\",\"panyl\":\"es\",\"psyen\":\"fa\",\"polon\":\"pl\",\"ptig\":\"pt\",\"ris\":\"ru\",\"romanyen\":\"ro\",\"sb\":\"sr\",\"slovenyen\":\"sl\",\"syedwa\":\"sv\",\"tuk\":\"tr\",\"tyk\":\"cs\",\"vyetnamyen\":\"vi\",\"albaneg\":\"sq\",\"almaeneg\":\"de\",\"arabeg\":\"ar\",\"armeneg\":\"hy\",\"aserbaijaneg\":\"az\",\"basgeg\":\"eu\",\"belarwseg\":\"be\",\"bwlgaraidd\":\"bg\",\"catalaneg\":\"ca\",\"creol haiti\":\"ht\",\"croateg\":\"hr\",\"cymraeg\":\"cy\",\"cyrdeg (kurmandji)\":\"ku\",\"daneg\":\"da\",\"eidaleg\":\"it\",\"estoneg\":\"et\",\"fietnameg\":\"vi\",\"ffineg\":\"fi\",\"fflemeg\":\"nl\",\"ffrangeg\":\"fr\",\"gaeleg yr alban\":\"gd\",\"galisaidd\":\"gl\",\"groeg\":\"el\",\"gwyddeleg\":\"ga\",\"hebraeg\":\"he\",\"hwngareg\":\"hu\",\"iaith corea\":\"ko\",\"indonesieg\":\"id\",\"islandeg\":\"is\",\"iwcraineg\":\"uk\",\"japaneg\":\"ja\",\"latfieg\":\"lv\",\"lithwaneg\":\"lt\",\"lladin\":\"la\",\"macedoneg\":\"mk\",\"malteseg\":\"mt\",\"mongoleg\":\"mn\",\"myanmar (byrma)\":\"my\",\"norwyeg\":\"nb\",\"perseg\":\"fa\",\"portiwgaleg\":\"pt\",\"pwyleg\":\"pl\",\"rwmaneg\":\"ro\",\"rwsieg\":\"ru\",\"saesneg\":\"en\",\"sbaeneg\":\"es\",\"serbeg\":\"sr\",\"slofac\":\"sk\",\"slofenia\":\"sl\",\"swedeg\":\"sv\",\"swlw\":\"zu\",\"tsieceg\":\"cs\",\"tsieineeg (traddodiadol)\":\"zh-tw\",\"tsieineeg (wedi symleiddio)\":\"zh-cn\",\"twrceg\":\"tr\",\"usbec\":\"uz\",\"\":\"en\",\"\":\"az\",\"\":\"sq\",\"\":\"is\",\"\":\"hy\",\"\":\"it\",\"\":\"uz\",\"\":\"et\",\"\":\"eo\",\"\":\"am\",\"\":\"kn\",\" ()\":\"ku\",\"\":\"ca\",\"\":\"gl\",\" ()\":\"zh-tw\",\"\":\"cs\",\"\":\"ja\",\"\":\"zu\",\"\":\"da\",\"\":\"tr\",\"\":\"te\",\"\":\"pt\",\"\":\"fi\",\"\":\"fr\",\"\":\"my\",\"\":\"bg\",\"\":\"be\",\"\":\"eu\",\"\":\"ml\",\"\":\"mi\",\"\":\"mt\",\"\":\"mk\",\"\":\"uk\",\"\":\"ru\",\"\":\"ro\",\"\":\"lv\",\"\":\"la\",\"\":\"vi\",\"\":\"sr\",\"\":\"es\",\"\":\"sk\",\"\":\"sl\",\"\":\"hu\",\"\":\"he\",\" \":\"ht\",\"\":\"sq\",\"\":\"ar\",\"\":\"am\",\"\":\"az\",\"\":\"ga\",\"\":\"et\",\"\":\"eu\",\"\":\"be\",\"\":\"bg\",\"\":\"is\",\"\":\"pl\",\"\":\"fa\",\"\":\"da\",\"\":\"de\",\"\":\"ru\",\"\":\"fr\",\"\":\"fi\",\"\":\"ht\",\"\":\"ko\",\"\":\"nl\",\"\":\"gl\",\"\":\"ca\",\"\":\"cs\",\"\":\"kn\",\"\":\"hr\",\"\":\"ku\",\"\":\"la\",\"\":\"lv\",\"\":\"lt\",\"\":\"ro\",\"\":\"mt\",\"\":\"mr\",\"\":\"ml\",\"\":\"ms\",\"\":\"mk\",\"\":\"mi\",\"\":\"mn\",\"\":\"my\",\"\":\"zu\",\"\":\"nb\",\"\":\"pt\",\"\":\"ja\",\"\":\"sv\",\"\":\"sr\",\"\":\"eo\",\"\":\"sk\",\"\":\"sl\",\"\":\"gd\",\"\":\"te\",\"\":\"th\",\"\":\"tr\",\"\":\"cy\",\"\":\"uk\",\"\":\"uz\",\"\":\"es\",\"\":\"he\",\"\":\"el\",\"\":\"hu\",\"\":\"hy\",\"\":\"it\",\"\":\"hi\",\"\":\"id\",\"\":\"en\",\"\":\"vi\",\"()\":\"zh-tw\",\"()\":\"zh-cn\",\"\":\"az\",\"\":\"en\",\"\":\"ar\",\"\":\"hy\",\"\":\"eu\",\"\":\"be\",\"\":\"my\",\"\":\"bg\",\"\":\"gl\",\"\":\"el\",\"\":\"da\",\"\":\"id\",\"\":\"ga\",\"\":\"es\",\"\":\"it\",\" ()\":\"zh-cn\",\" ()\":\"zh-tw\",\"\":\"ko\",\"\":\"ku\",\"\":\"lv\",\"\":\"lt\",\"\":\"ms\",\"\":\"mt\",\"\":\"de\",\"\":\"nl\",\"\":\"nb\",\"\":\"fa\",\"\":\"ro\",\"\":\"sk\",\"\":\"sl\",\"\":\"sr\",\"\":\"th\",\"\":\"cy\",\"\":\"uz\",\"\":\"fi\",\"\":\"fr\",\" \":\"ht\",\"\":\"hr\",\" \":\"gd\",\"\":\"ja\",\"\":\"is\",\"\":\"az\",\"\":\"hy\",\"\":\"es\",\"\":\"eo\",\"\":\"et\",\" \":\"gd\",\"\":\"sq\",\"\":\"de\",\"\":\"am\",\"\":\"en\",\"\":\"id\",\"\":\"uz\",\"\":\"uk\",\"\":\"ga\",\"\":\"it\",\"\":\"eu\",\"\":\"pt\",\"\":\"bg\",\"\":\"my\",\"\":\"pl\",\"\":\"be\",\"\":\"th\",\"\":\"tr\",\"\":\"cs\",\"\":\"te\",\"\":\"gl\",\"\":\"da\",\"\":\"ru\",\"\":\"ro\",\"\":\"zu\",\"\":\"sk\",\"\":\"sl\",\"\":\"sv\",\"\":\"sr\",\" ()\":\"zh-tw\",\" ()\":\"zh-cn\",\"\":\"he\",\"\":\"ar\",\"\":\"fa\",\"\":\"fr\",\"\":\"fi\",\"\":\"vi\",\"\":\"ca\",\"\":\"kn\",\"\":\"ku\",\"\":\"hr\",\"\":\"ko\",\"\":\"lv\",\"\":\"la\",\"  \":\"ht\",\"\":\"lt\",\"\":\"ml\",\"\":\"mt\",\"\":\"mi\",\"\":\"mk\",\"\":\"ms\",\"\":\"mn\",\"\":\"mr\",\"\":\"nb\",\"\":\"hi\",\"\":\"hu\",\"\":\"nl\",\"\":\"cy\",\"\":\"ja\",\"\":\"el\",\"\":\"eu\",\"\":\"vi\",\"\":\"gl\",\"\":\"en\",\"\":\"id\",\"\":\"ja\",\"\":\"hy\",\" ()\":\"zh-cn\",\" ()\":\"zh-tw\",\" ()\":\"ht\",\"\":\"lv\",\"\":\"hu\",\"\":\"mr\",\"\":\"de\",\"\":\"fa\",\"\":\"pl\",\"\":\"ro\",\"\":\"sl\",\"\":\"th\",\"\":\"uk\",\"\":\"az\",\"\":\"sq\",\"\":\"am\",\"\":\"en\",\"\":\"ar\",\"\":\"hy\",\"\":\"eu\",\"\":\"be\",\"\":\"my\",\"\":\"bg\",\"\":\"vi\",\" \":\"ht\",\"\":\"gl\",\"\":\"gd\",\"\":\"de\",\"\":\"nl\",\"\":\"el\",\"\":\"da\",\"\":\"id\",\"\":\"ga\",\"\":\"is\",\"\":\"es\",\"\":\"it\",\"\":\"ca\",\"\":\"he\",\"\":\"ku\",\"\":\"lv\",\"\":\"la\",\"\":\"lt\",\"\":\"mk\",\"\":\"ms\",\"\":\"ml\",\"\":\"mt\",\"\":\"mn\",\"\":\"nb\",\"\":\"ru\",\"\":\"fa\",\"\":\"pl\",\"\":\"pt\",\"\":\"ro\",\"\":\"sr\",\"\":\"sk\",\"\":\"sl\",\"\":\"ko\",\"\":\"th\",\"\":\"tr\",\"\":\"te\",\"\":\"uz\",\"\":\"uk\",\"\":\"hu\",\"\":\"cy\",\"\":\"fi\",\"\":\"fr\",\"\":\"hr\",\" ()\":\"zh-cn\",\" ()\":\"zh-tw\",\"\":\"cs\",\"\":\"sv\",\"\":\"et\",\"\":\"ja\",\"amhariska\":\"am\",\"arabiska\":\"ar\",\"armeniska\":\"hy\",\"azerbajdzjanska\":\"az\",\"baskiska\":\"eu\",\"bulgariska\":\"bg\",\"burmesiska\":\"my\",\"engelska\":\"en\",\"estniska\":\"et\",\"finska\":\"fi\",\"gaeliska\":\"gd\",\"galiciska\":\"gl\",\"grekiska\":\"el\",\"haitiska\":\"ht\",\"hebreiska\":\"he\",\"indonesiska\":\"id\",\"irlndska\":\"ga\",\"islndska\":\"is\",\"italienska\":\"it\",\"kanaresiska\":\"kn\",\"katalanska\":\"ca\",\"kinesiska (frenklad)\":\"zh-cn\",\"kinesiska (traditionell)\":\"zh-tw\",\"koreanska\":\"ko\",\"kroatiska\":\"hr\",\"kurdiska\":\"ku\",\"lettiska\":\"lv\",\"litauiska\":\"lt\",\"makedonska\":\"mk\",\"malaysiska\":\"ms\",\"maltesiska\":\"mt\",\"mongoliska\":\"mn\",\"nederlndska\":\"nl\",\"persiska\":\"fa\",\"polska\":\"pl\",\"portugisiska\":\"pt\",\"rumnska\":\"ro\",\"ryska\":\"ru\",\"serbiska\":\"sr\",\"slovakiska\":\"sk\",\"slovenska\":\"sl\",\"spanska\":\"es\",\"svenska\":\"sv\",\"thailndska\":\"th\",\"tjeckiska\":\"cs\",\"turkiska\":\"tr\",\"tyska\":\"de\",\"ukrainska\":\"uk\",\"ungerska\":\"hu\",\"uzbekiska\":\"uz\",\"vietnamesiska\":\"vi\",\"vitryska\":\"be\",\"walesiska\":\"cy\",\"albanez\":\"sq\",\"amharic\":\"am\",\"arab\":\"ar\",\"armean\":\"hy\",\"azerbaidjan\":\"az\",\"basc\":\"eu\",\"bielorus\":\"be\",\"birman\":\"my\",\"bulgar\":\"bg\",\"catalan\":\"ca\",\"ceh\":\"cs\",\"chinez (simplificat)\":\"zh-cn\",\"chinez (tradiional)\":\"zh-tw\",\"coreean\":\"ko\",\"creol haitian\":\"ht\",\"croat\":\"hr\",\"danez\":\"da\",\"ebraic\":\"he\",\"englez\":\"en\",\"eston\":\"et\",\"finlandez\":\"fi\",\"francez\":\"fr\",\"galez\":\"cy\",\"galica scoian\":\"gd\",\"galician\":\"gl\",\"german\":\"de\",\"greac\":\"el\",\"indonezian\":\"id\",\"irlandez\":\"ga\",\"islandez\":\"is\",\"italian\":\"it\",\"japonez\":\"ja\",\"kurd\":\"ku\",\"latin\":\"la\",\"leton\":\"lv\",\"lituanian\":\"lt\",\"macedonean\":\"mk\",\"maghiar\":\"hu\",\"malaez\":\"ms\",\"maltez\":\"mt\",\"mongol\":\"mn\",\"neerlandez\":\"nl\",\"norvegian\":\"nb\",\"persan\":\"fa\",\"polonez\":\"pl\",\"portughez\":\"pt\",\"romn\":\"ro\",\"rus\":\"ru\",\"srb\":\"sr\",\"slovac\":\"sk\",\"sloven\":\"sl\",\"spaniol\":\"es\",\"suedez\":\"sv\",\"thailandez\":\"th\",\"turc\":\"tr\",\"ucrainean\":\"uk\",\"uzbec\":\"uz\",\"vietnamez\":\"vi\",\"airi\":\"ga\",\"alban\":\"sq\",\"amhar\":\"am\",\"angl\":\"en\",\"arab\":\"ar\",\"armn\":\"hy\",\"azerbaidaniei\":\"az\",\"baltarusi\":\"be\",\"bask\":\"eu\",\"birmiei\":\"my\",\"bulgar\":\"bg\",\"ek\":\"cs\",\"dan\":\"da\",\"est\":\"et\",\"galis\":\"gl\",\"graik\":\"el\",\"haiio kreol\":\"ht\",\"hebraj\":\"he\",\"indoneziei\":\"id\",\"island\":\"is\",\"ispan\":\"es\",\"ital\":\"it\",\"japon\":\"ja\",\"kanad\":\"kn\",\"kataloniei\":\"ca\",\"kin (supaprastinta)\":\"zh-cn\",\"kin (tradicin)\":\"zh-tw\",\"korjiei\":\"ko\",\"kroat\":\"hr\",\"kurd\":\"ku\",\"latvi\":\"lv\",\"lenk\":\"pl\",\"lietuvi\":\"lt\",\"lotyn\":\"la\",\"makedoniei\":\"mk\",\"malajali\":\"ml\",\"malajiei\":\"ms\",\"maltiei\":\"mt\",\"maori\":\"mi\",\"marat\":\"mr\",\"mongol\":\"mn\",\"norveg\":\"nb\",\"oland\":\"nl\",\"pers\":\"fa\",\"portugal\":\"pt\",\"prancz\":\"fr\",\"rumun\":\"ro\",\"rus\":\"ru\",\"serb\":\"sr\",\"slovak\":\"sk\",\"slovn\":\"sl\",\"suomi\":\"fi\",\"kot (gl)\":\"gd\",\"ved\":\"sv\",\"taj\":\"th\",\"telug\":\"te\",\"turk\":\"tr\",\"ukrainiei\":\"uk\",\"uzbek\":\"uz\",\"val\":\"cy\",\"vengr\":\"hu\",\"vietnamiei\":\"vi\",\"vokiei\":\"de\",\"zulus\":\"zu\",\"\":\"gl\",\"\":\"el\",\"\":\"nl\",\"\":\"nb\",\"\":\"da\",\"\":\"de\",\"\":\"lv\",\"\":\"la\",\"\":\"ru\",\"\":\"ro\",\"\":\"lt\",\"\":\"mr\",\"\":\"mi\",\"\":\"mk\",\"\":\"ml\",\"\":\"ms\",\"\":\"mt\",\"\":\"mn\",\" ()\":\"my\",\"\":\"eu\",\"\":\"vi\",\"\":\"be\",\"\":\"bg\",\"\":\"sr\",\"\":\"sv\",\" \":\"gd\",\"\":\"es\",\"\":\"sk\",\"\":\"sl\",\"\":\"ar\",\"\":\"hy\",\"\":\"is\",\" \":\"ht\",\"\":\"ga\",\"\":\"az\",\"\":\"sq\",\"\":\"am\",\"\":\"et\",\"\":\"eo\",\"\":\"en\",\"\":\"uz\",\"\":\"uk\",\"\":\"cy\",\"\":\"it\",\"\":\"id\",\"\":\"ja\",\"\":\"zu\",\"()\":\"zh-cn\",\"()\":\"zh-tw\",\"\":\"cs\",\"\":\"ca\",\"\":\"kn\",\"\":\"ku\",\"\":\"hr\",\"\":\"th\",\"\":\"tr\",\"\":\"te\",\"\":\"fa\",\"\":\"pt\",\"\":\"pl\",\"\":\"fr\",\"\":\"fi\",\"\":\"ko\",\"\":\"hu\",\"\":\"he\",\"\":\"hi\",\"albanese\":\"sq\",\"amarico\":\"am\",\"arabo\":\"ar\",\"armeno\":\"hy\",\"azero\":\"az\",\"bielorusso\":\"be\",\"bulgaro\":\"bg\",\"catalano\":\"ca\",\"ceco\":\"cs\",\"cinese (semplificato)\":\"zh-cn\",\"cinese (tradizionale)\":\"zh-tw\",\"creolo haitiano\":\"ht\",\"croato\":\"hr\",\"curdo (kurmanji)\":\"ku\",\"danese\":\"da\",\"ebraico\":\"he\",\"estone\":\"et\",\"finlandese\":\"fi\",\"francese\":\"fr\",\"gaelico scozzese\":\"gd\",\"galiziano\":\"gl\",\"gallese\":\"cy\",\"giapponese\":\"ja\",\"greco\":\"el\",\"indonesiano\":\"id\",\"inglese\":\"en\",\"irlandese\":\"ga\",\"islandese\":\"is\",\"latino\":\"la\",\"lettone\":\"lv\",\"macedone\":\"mk\",\"malese\":\"ms\",\"mongolo\":\"mn\",\"norvegese\":\"nb\",\"olandese\":\"nl\",\"persiano\":\"fa\",\"polacco\":\"pl\",\"portoghese\":\"pt\",\"rumeno\":\"ro\",\"serbo\":\"sr\",\"slovacco\":\"sk\",\"sloveno\":\"sl\",\"spagnolo\":\"es\",\"svedese\":\"sv\",\"tailandese\":\"th\",\"tedesco\":\"de\",\"ucraino\":\"uk\",\"ungherese\":\"hu\",\"quc t ng\":\"eo\",\"ting  rp\":\"ar\",\"ting albania\":\"sq\",\"ting amharic\":\"am\",\"ting anh\":\"en\",\"ting armenia\":\"hy\",\"ting azerbaijan\":\"az\",\"ting ba lan\":\"pl\",\"ting ba t\":\"fa\",\"ting basque\":\"eu\",\"ting belarus\":\"be\",\"ting b o nha\":\"pt\",\"ting bulgaria\":\"bg\",\"ting catalan\":\"ca\",\"ting creole  haiti\":\"ht\",\"ting croatia\":\"hr\",\"ting do thi\":\"he\",\"ting an mch\":\"da\",\"ting c\":\"de\",\"ting estonia\":\"et\",\"ting gael scotland\":\"gd\",\"ting galicia\":\"gl\",\"ting h lan\":\"nl\",\"ting hn\":\"ko\",\"ting hindi\":\"hi\",\"ting hungary\":\"hu\",\"ting hy lp\":\"el\",\"ting iceland\":\"is\",\"ting indonesia\":\"id\",\"ting ireland\":\"ga\",\"ting kannada\":\"kn\",\"ting kurd\":\"ku\",\"ting latinh\":\"la\",\"ting latvia\":\"lv\",\"ting litva\":\"lt\",\"ting m lai\":\"ms\",\"ting macedonia\":\"mk\",\"ting malayalam\":\"ml\",\"ting malta\":\"mt\",\"ting maori\":\"mi\",\"ting marathi\":\"mr\",\"ting mng c\":\"mn\",\"ting myanmar\":\"my\",\"ting na uy\":\"nb\",\"ting nga\":\"ru\",\"ting nht\":\"ja\",\"ting php\":\"fr\",\"ting phn lan\":\"fi\",\"ting rumani\":\"ro\",\"ting sc\":\"cs\",\"ting serbia\":\"sr\",\"ting slovak\":\"sk\",\"ting slovenia\":\"sl\",\"ting ty ban nha\":\"es\",\"ting telugu\":\"te\",\"ting thi\":\"th\",\"ting th nh k\":\"tr\",\"ting thy in\":\"sv\",\"ting trung (gian th)\":\"zh-cn\",\"ting trung (phn th)\":\"zh-tw\",\"ting ukraina\":\"uk\",\"ting uzbek\":\"uz\",\"ting vit\":\"vi\",\"ting x wales\":\"cy\",\"ting \":\"it\",\"ting zulu\":\"zu\",\"\":\"ja\"},\"scratchToGoogleMap\":{\"zh-cn\":\"zh\",\"nb\":\"no\",\"he\":\"iw\",\"es-419\":\"es\",\"pt-br\":\"pt\",\"ja-hira\":\"ja\"},\"previouslySupported\":[\"ab\",\"ms\",\"be\",\"eo\",\"hy\",\"hi\",\"kn\",\"ht\",\"ku\",\"la\",\"mk\",\"ml\",\"mt\",\"mr\",\"mn\",\"my\",\"nn\",\"sq\",\"te\",\"uz\"],\"spokenLanguages\":{\"en\":[{\"code\":\"zh-cn\",\"name\":\"Chinese (Mandarin)\"}],\"cy\":[{\"code\":\"zh-cn\",\"name\":\"Tsieineaidd (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portiwgaleg (Brasil)\"},{\"code\":\"es-419\",\"name\":\"Sbaeneg (America Ladin)\"}],\"zu\":[{\"code\":\"zh-cn\",\"name\":\"IsiShayina (isiMandarin)\"},{\"code\":\"hi\",\"name\":\"IsiHindi\"},{\"code\":\"pt-br\",\"name\":\"IsiPutukezi (saseBrazil)\"},{\"code\":\"es-419\",\"name\":\"ISpanishi (Latin American)\"}],\"ko\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\" \"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"az\":[{\"code\":\"zh-cn\",\"name\":\"in (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portuqal (Braziliya)\"},{\"code\":\"es-419\",\"name\":\"span (Latn Amerikas)\"}],\"he\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"mk\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"am\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"mr\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"cs\":[{\"code\":\"zh-cn\",\"name\":\"ntina (mandarinka)\"},{\"code\":\"hi\",\"name\":\"hindtina\"},{\"code\":\"pt-br\",\"name\":\"Portugaltina (brazilsk)\"},{\"code\":\"es-419\",\"name\":\"panltina (latinskoamerick)\"}],\"zh-cn\":[{\"code\":\"zh-cn\",\"name\":\"\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\"\"},{\"code\":\"es-419\",\"name\":\"\"}],\"la\":[{\"code\":\"zh-cn\",\"name\":\"Seres (Latin)\"},{\"code\":\"hi\",\"name\":\"Hibernica\"},{\"code\":\"pt-br\",\"name\":\"Portuguese (Spanish)\"},{\"code\":\"es-419\",\"name\":\"Hispanica (Latin American)\"}],\"nn\":[{\"code\":\"zh-cn\",\"name\":\"Kinesisk (mandarin)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugisisk (brasiliansk)\"},{\"code\":\"es-419\",\"name\":\"Spansk (latinamerikansk)\"}],\"my\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ()\"}],\"ga\":[{\"code\":\"zh-cn\",\"name\":\"Snis (Mandairnis)\"},{\"code\":\"hi\",\"name\":\"Hiondis\"},{\"code\":\"pt-br\",\"name\":\"Portaingilis (Brasale)\"},{\"code\":\"es-419\",\"name\":\"Spinnis (Meirice Laidineach)\"}],\"es\":[{\"code\":\"zh-cn\",\"name\":\"Chino (Mandarn)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugus (brasileo)\"},{\"code\":\"es-419\",\"name\":\"Espaol (latinoamericano)\"}],\"nl\":[{\"code\":\"zh-cn\",\"name\":\"Chinees (Mandarijn)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugees (Braziliaans)\"},{\"code\":\"es-419\",\"name\":\"Spaans (Latijns-Amerikaans)\"}],\"zh-tw\":[{\"code\":\"zh-cn\",\"name\":\"\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\"\"},{\"code\":\"es-419\",\"name\":\"\"}],\"pt-br\":[{\"code\":\"zh-cn\",\"name\":\"Mandarim (chins)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugus (brasileiro)\"},{\"code\":\"es-419\",\"name\":\"Espanhol (latino-americano)\"}],\"kn\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"uz\":[{\"code\":\"zh-cn\",\"name\":\"Xitoy (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindcha\"},{\"code\":\"pt-br\",\"name\":\"Portugal (Braziliya)\"},{\"code\":\"es-419\",\"name\":\"Ispan (Lotin Amerikasi)\"}],\"ja\":[{\"code\":\"zh-cn\",\"name\":\"\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\"\"},{\"code\":\"es-419\",\"name\":\"\"}],\"is\":[{\"code\":\"zh-cn\",\"name\":\"Knverska (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hind\"},{\"code\":\"pt-br\",\"name\":\"Portgalska (brasilska)\"},{\"code\":\"es-419\",\"name\":\"Spnska (rmnsku-amerska)\"}],\"sk\":[{\"code\":\"zh-cn\",\"name\":\"ntina (mandarnska)\"},{\"code\":\"hi\",\"name\":\"hindina\"},{\"code\":\"pt-br\",\"name\":\"Portugalina (brazlska)\"},{\"code\":\"es-419\",\"name\":\"panielina (latinskoamerick)\"}],\"ht\":[{\"code\":\"zh-cn\",\"name\":\"Chinwa (Mandaren)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Ptig (brezilyen)\"},{\"code\":\"es-419\",\"name\":\"Panyl (Amerik Latin)\"}],\"bg\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ()\"}],\"de\":[{\"code\":\"zh-cn\",\"name\":\"Chinesisch (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugiesisch (brasilianisch)\"},{\"code\":\"es-419\",\"name\":\"Spanisch (Lateinamerikanisch)\"}],\"gd\":[{\"code\":\"zh-cn\",\"name\":\"Sneach (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Indeach\"},{\"code\":\"pt-br\",\"name\":\"Portuguese (Brazilian)\"},{\"code\":\"es-419\",\"name\":\"Spinntis (Ameireagaidh Laidinn)\"}],\"et\":[{\"code\":\"zh-cn\",\"name\":\"Hiina (mandariini)\"},{\"code\":\"hi\",\"name\":\"Hindi keel\"},{\"code\":\"pt-br\",\"name\":\"Portugali (Brasiilia)\"},{\"code\":\"es-419\",\"name\":\"Hispaania keel (Ladina-Ameerika)\"}],\"fi\":[{\"code\":\"zh-cn\",\"name\":\"Kiina (mandariini)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugali (brasilia)\"},{\"code\":\"es-419\",\"name\":\"Espanja (Latinalainen Amerikka)\"}],\"ar\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"hu\":[{\"code\":\"zh-cn\",\"name\":\"Knai (mandarin)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugl (brazil)\"},{\"code\":\"es-419\",\"name\":\"Spanyol (latin-amerikai)\"}],\"mt\":[{\"code\":\"zh-cn\",\"name\":\"ini (Mandarin)\"},{\"code\":\"hi\",\"name\":\"indi\"},{\"code\":\"pt-br\",\"name\":\"Portugi (Brailjan)\"},{\"code\":\"es-419\",\"name\":\"Spanjol (Latin-Amerikan)\"}],\"ro\":[{\"code\":\"zh-cn\",\"name\":\"Chinez (mandarin)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portughez (brazilian)\"},{\"code\":\"es-419\",\"name\":\"Spaniol (latino-american)\"}],\"fa\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"hi\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"eo\":[{\"code\":\"zh-cn\",\"name\":\"ina (mandarena)\"},{\"code\":\"hi\",\"name\":\"Hinda\"},{\"code\":\"pt-br\",\"name\":\"Portugala (brazila)\"},{\"code\":\"es-419\",\"name\":\"Hispana (latina)\"}],\"lt\":[{\"code\":\"zh-cn\",\"name\":\"Kin (mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugal (Brazilijos)\"},{\"code\":\"es-419\",\"name\":\"Ispan (Lotyn Amerikos)\"}],\"it\":[{\"code\":\"zh-cn\",\"name\":\"Cinese (mandarino)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portoghese (brasiliano)\"},{\"code\":\"es-419\",\"name\":\"Spagnolo (latino-americano)\"}],\"el\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"mi\":[{\"code\":\"zh-cn\",\"name\":\"Hainamana (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Potukua (Brazil)\"},{\"code\":\"es-419\",\"name\":\"Pniora (Latin American)\"}],\"hr\":[{\"code\":\"zh-cn\",\"name\":\"Kineski (mandarinski)\"},{\"code\":\"hi\",\"name\":\"hindski\"},{\"code\":\"pt-br\",\"name\":\"Portugalski (brazilski)\"},{\"code\":\"es-419\",\"name\":\"panjolski (latinoameriki)\"}],\"ca\":[{\"code\":\"zh-cn\",\"name\":\"Xins (mandar)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugus (brasiler)\"},{\"code\":\"es-419\",\"name\":\"Espanyol (llatinoameric)\"}],\"th\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ()\"}],\"hy\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ()\"}],\"id\":[{\"code\":\"zh-cn\",\"name\":\"Mandarin (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugis (Brasil)\"},{\"code\":\"es-419\",\"name\":\"Spanyol (Amerika Latin)\"}],\"eu\":[{\"code\":\"zh-cn\",\"name\":\"Txinera (mandarina)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugesa (brasildarra)\"},{\"code\":\"es-419\",\"name\":\"Espainiera (latinoamerikarra)\"}],\"da\":[{\"code\":\"zh-cn\",\"name\":\"Kinesisk (mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugisisk (brasiliansk)\"},{\"code\":\"es-419\",\"name\":\"Spansk (latinamerikansk)\"}],\"ru\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ()\"}],\"sr\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ()\"}],\"gl\":[{\"code\":\"zh-cn\",\"name\":\"Chins (mandarn)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugus (brasileiro)\"},{\"code\":\"es-419\",\"name\":\"Espaol (latinoamericano)\"}],\"lv\":[{\"code\":\"zh-cn\",\"name\":\"nieu (mandarnu)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugu (Brazlijas)\"},{\"code\":\"es-419\",\"name\":\"Spu (latameriku)\"}],\"nb\":[{\"code\":\"zh-cn\",\"name\":\"Kinesisk (mandarin)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugisisk (brasiliansk)\"},{\"code\":\"es-419\",\"name\":\"Spansk (latinamerikansk)\"}],\"tr\":[{\"code\":\"zh-cn\",\"name\":\"in (mandalinas)\"},{\"code\":\"hi\",\"name\":\"Hinte\"},{\"code\":\"pt-br\",\"name\":\"Portekizce (Brezilya)\"},{\"code\":\"es-419\",\"name\":\"spanyolca (Latin Amerika)\"}],\"fr\":[{\"code\":\"zh-cn\",\"name\":\"Mandarin (chinois)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugais (brsilien)\"},{\"code\":\"es-419\",\"name\":\"Espagnol (latino-amricain)\"}],\"sv\":[{\"code\":\"zh-cn\",\"name\":\"Kinesiska (mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugisiska (brasilianska)\"},{\"code\":\"es-419\",\"name\":\"Spanska (latinamerikanska)\"}],\"sl\":[{\"code\":\"zh-cn\",\"name\":\"Kitajina (mandarina)\"},{\"code\":\"hi\",\"name\":\"Hindujina\"},{\"code\":\"pt-br\",\"name\":\"Portugalina (brazilska)\"},{\"code\":\"es-419\",\"name\":\"panina (latinskoamerika)\"}],\"ml\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"be\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ()\"}],\"pl\":[{\"code\":\"zh-cn\",\"name\":\"Chiski (mandaryski)\"},{\"code\":\"hi\",\"name\":\"hinduski\"},{\"code\":\"pt-br\",\"name\":\"Portugalski (brazylijski)\"},{\"code\":\"es-419\",\"name\":\"Hiszpaski (latynoamerykaski)\"}],\"pt\":[{\"code\":\"zh-cn\",\"name\":\"Mandarim (chins)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugus (brasileiro)\"},{\"code\":\"es-419\",\"name\":\"Espanhol (latino-americano)\"}],\"ku\":[{\"code\":\"zh-cn\",\"name\":\"Chinese (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hind\"},{\"code\":\"pt-br\",\"name\":\"Portekz (Brazilian)\"},{\"code\":\"es-419\",\"name\":\"Spanish (Amerkaya Latn)\"}],\"sq\":[{\"code\":\"zh-cn\",\"name\":\"Kinezisht (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugeze (Braziliane)\"},{\"code\":\"es-419\",\"name\":\"Spanjisht (Amerika Latine)\"}],\"ms\":[{\"code\":\"zh-cn\",\"name\":\"Cina (Mandarin)\"},{\"code\":\"hi\",\"name\":\"Hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugis (Brazil)\"},{\"code\":\"es-419\",\"name\":\"Sepanyol (Amerika Latin)\"}],\"vi\":[{\"code\":\"zh-cn\",\"name\":\"Ting trung quc\"},{\"code\":\"hi\",\"name\":\"Ting Hindi\"},{\"code\":\"pt-br\",\"name\":\"B o Nha (Brazil)\"},{\"code\":\"es-419\",\"name\":\"Ty Ban Nha (M Latinh)\"}],\"te\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ( )\"}],\"uk\":[{\"code\":\"zh-cn\",\"name\":\" ()\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\" ()\"},{\"code\":\"es-419\",\"name\":\" ()\"}],\"mn\":[{\"code\":\"zh-cn\",\"name\":\"  ()\"},{\"code\":\"hi\",\"name\":\" \"},{\"code\":\"pt-br\",\"name\":\"  ()\"},{\"code\":\"es-419\",\"name\":\"  ( )\"}],\"es-419\":[{\"code\":\"zh-cn\",\"name\":\"Chino (Mandarn)\"},{\"code\":\"hi\",\"name\":\"hindi\"},{\"code\":\"pt-br\",\"name\":\"Portugus (brasileo)\"},{\"code\":\"es-419\",\"name\":\"Espaol (latinoamericano)\"}],\"ja-hira\":[{\"code\":\"zh-cn\",\"name\":\"\"},{\"code\":\"hi\",\"name\":\"\"},{\"code\":\"pt-br\",\"name\":\"\"},{\"code\":\"es-419\",\"name\":\"\"}]}}");

/***/ }),

/***/ "./node_modules/transformation-matrix/build-es/applyToPoint.js":
/*!*********************************************************************!*\
  !*** ./node_modules/transformation-matrix/build-es/applyToPoint.js ***!
  \*********************************************************************/
/*! exports provided: applyToPoint, applyToPoints */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyToPoint", function() { return applyToPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyToPoints", function() { return applyToPoints; });
/**
 * Calculate a point transformed with an affine matrix
 * @param matrix Affine matrix
 * @param point Point
 * @returns {{x: number, y: number} | Array} Point
 */
function applyToPoint(matrix, point) {
  return Array.isArray(point) ? [matrix.a * point[0] + matrix.c * point[1] + matrix.e, matrix.b * point[0] + matrix.d * point[1] + matrix.f] : {
    x: matrix.a * point.x + matrix.c * point.y + matrix.e,
    y: matrix.b * point.x + matrix.d * point.y + matrix.f
  };
}

/**
 * Calculate an array of points transformed with an affine matrix
 * @param matrix Affine matrix
 * @param points Array of points
 * @returns {array} Array of points
 */
function applyToPoints(matrix, points) {
  return points.map(function (point) {
    return applyToPoint(matrix, point);
  });
}

/***/ }),

/***/ "./node_modules/transformation-matrix/build-es/fromObject.js":
/*!*******************************************************************!*\
  !*** ./node_modules/transformation-matrix/build-es/fromObject.js ***!
  \*******************************************************************/
/*! exports provided: fromObject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromObject", function() { return fromObject; });
/**
 * Extract an affine matrix from an object that contains a,b,c,d,e,f keys
 * Each value could be a float or a string that contains a float
 * @param object
 * @return {{a: *, b: *, c: *, e: *, d: *, f: *}}}
 */
function fromObject(object) {
  return {
    a: parseFloat(object.a),
    b: parseFloat(object.b),
    c: parseFloat(object.c),
    d: parseFloat(object.d),
    e: parseFloat(object.e),
    f: parseFloat(object.f)
  };
}

/***/ }),

/***/ "./node_modules/transformation-matrix/build-es/fromString.js":
/*!*******************************************************************!*\
  !*** ./node_modules/transformation-matrix/build-es/fromString.js ***!
  \*******************************************************************/
/*! exports provided: fromString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromString", function() { return fromString; });
/**
 * @ignore
 * @type {RegExp}
 */
var matrixRegex = /^matrix\(\s*([0-9_+-.e]+)\s*,\s*([0-9_+-.e]+)\s*,\s*([0-9_+-.e]+)\s*,\s*([0-9_+-.e]+)\s*,\s*([0-9_+-.e]+)\s*,\s*([0-9_+-.e]+)\s*\)$/i;

/**
 * Parse a string matrix formatted as matrix(a,b,c,d,e,f)
 * @param string String with a matrix
 * @returns {{a: number, b: number, c: number, e: number, d: number, f: number}} Affine matrix
 */
function fromString(string) {
  var parsed = string.match(matrixRegex);
  if (parsed === null || parsed.length < 7) throw new Error("'" + string + "' is not a matrix");
  return {
    a: parseFloat(parsed[1]),
    b: parseFloat(parsed[2]),
    c: parseFloat(parsed[3]),
    d: parseFloat(parsed[4]),
    e: parseFloat(parsed[5]),
    f: parseFloat(parsed[6])
  };
}

/***/ }),

/***/ "./node_modules/transformation-matrix/build-es/identity.js":
/*!*****************************************************************!*\
  !*** ./node_modules/transformation-matrix/build-es/identity.js ***!
  \*****************************************************************/
/*! exports provided: identity */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/**
 * Identity matrix
 * @returns {{a: number, b: number, c: number, e: number, d: number, f: number}} Affine matrix
 */
function identity() {
  return {
    a: 1,
    c: 0,
    e: 0,
    b: 0,
    d: 1,
    f: 0
  };
}

/***/ }),

/***/ "./node_modules/transformation-matrix/build-es/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/transformation-matrix/build-es/index.js ***!
  \**************************************************************/
/*! exports provided: applyToPoint, applyToPoints, fromObject, fromString, identity, inverse, isAffineMatrix, rotate, rotateDEG, scale, shear, skew, skewDEG, toCSS, toSVG, toString, transform, compose, translate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _applyToPoint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./applyToPoint */ "./node_modules/transformation-matrix/build-es/applyToPoint.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "applyToPoint", function() { return _applyToPoint__WEBPACK_IMPORTED_MODULE_0__["applyToPoint"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "applyToPoints", function() { return _applyToPoint__WEBPACK_IMPORTED_MODULE_0__["applyToPoints"]; });

/* harmony import */ var _fromObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fromObject */ "./node_modules/transformation-matrix/build-es/fromObject.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fromObject", function() { return _fromObject__WEBPACK_IMPORTED_MODULE_1__["fromObject"]; });

/* harmony import */ var _fromString__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fromString */ "./node_modules/transformation-matrix/build-es/fromString.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fromString", function() { return _fromString__WEBPACK_IMPORTED_MODULE_2__["fromString"]; });

/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./identity */ "./node_modules/transformation-matrix/build-es/identity.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return _identity__WEBPACK_IMPORTED_MODULE_3__["identity"]; });

/* harmony import */ var _inverse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./inverse */ "./node_modules/transformation-matrix/build-es/inverse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return _inverse__WEBPACK_IMPORTED_MODULE_4__["inverse"]; });

/* harmony import */ var _isAffineMatrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isAffineMatrix */ "./node_modules/transformation-matrix/build-es/isAffineMatrix.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isAffineMatrix", function() { return _isAffineMatrix__WEBPACK_IMPORTED_MODULE_5__["isAffineMatrix"]; });

/* harmony import */ var _rotate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rotate */ "./node_modules/transformation-matrix/build-es/rotate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return _rotate__WEBPACK_IMPORTED_MODULE_6__["rotate"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rotateDEG", function() { return _rotate__WEBPACK_IMPORTED_MODULE_6__["rotateDEG"]; });

/* harmony import */ var _scale__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./scale */ "./node_modules/transformation-matrix/build-es/scale.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return _scale__WEBPACK_IMPORTED_MODULE_7__["scale"]; });

/* harmony import */ var _shear__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./shear */ "./node_modules/transformation-matrix/build-es/shear.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shear", function() { return _shear__WEBPACK_IMPORTED_MODULE_8__["shear"]; });

/* harmony import */ var _skew__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./skew */ "./node_modules/transformation-matrix/build-es/skew.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "skew", function() { return _skew__WEBPACK_IMPORTED_MODULE_9__["skew"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "skewDEG", function() { return _skew__WEBPACK_IMPORTED_MODULE_9__["skewDEG"]; });

/* harmony import */ var _toString__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./toString */ "./node_modules/transformation-matrix/build-es/toString.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toCSS", function() { return _toString__WEBPACK_IMPORTED_MODULE_10__["toCSS"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toSVG", function() { return _toString__WEBPACK_IMPORTED_MODULE_10__["toSVG"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toString", function() { return _toString__WEBPACK_IMPORTED_MODULE_10__["toString"]; });

/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./transform */ "./node_modules/transformation-matrix/build-es/transform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "transform", function() { return _transform__WEBPACK_IMPORTED_MODULE_11__["transform"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return _transform__WEBPACK_IMPORTED_MODULE_11__["compose"]; });

/* harmony import */ var _translate__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./translate */ "./node_modules/transformation-matrix/build-es/translate.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return _translate__WEBPACK_IMPORTED_MODULE_12__["translate"]; });















/***/ }),

/***/ "./node_modules/transformation-matrix/build-es/inverse.js":
/*!****************************************************************!*\
  !*** ./node_modules/transformation-matrix/build-es/inverse.js ***!
  \****************************************************************/
/*! exports provided: inverse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/**
 * Calculate a matrix that is the inverse of the provided matrix
 * @param matrix Affine matrix
 * @returns {{a: number, b: number, c: number, e: number, d: number, f: number}} Affine matrix
 */
function inverse(matrix) {
  // http://www.wolframalpha.com/input/?i=Inverse+%5B%7B%7Ba,c,e%7D,%7Bb,d,f%7D,%7B0,0,1%7D%7D%5D

  var a = matrix.a,
      b = matrix.b,
      c = matrix.c,
      d = matrix.d,
      e = matrix.e,
      f = matrix.f;


  var denom = a * d - b * c;

  return {
    a: d / denom,
    b: b / -denom,
    c: c / -denom,
    d: a / denom,
    e: (d * e - c * f) / -denom,
    f: (b * e - a * f) / denom
  };
}

/***/ }),

/***/ "./node_modules/transformation-matrix/build-es/isAffineMatrix.js":
/*!***********************************************************************!*\
  !*** ./node_modules/transformation-matrix/build-es/isAffineMatrix.js ***!
  \***********************************************************************/
/*! exports provided: isAffineMatrix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAffineMatrix", function() { return isAffineMatrix; });
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isNumeric = function isNumeric(n) {
  return typeof n === 'number' && !isNaN(n) && isFinite(n);
};
var isObject = function isObject(obj) {
  return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
};

/**
 * Check if the object contain an affine matrix
 * @param object
 * @return {boolean}
 */
function isAffineMatrix(object) {
  return isObject(object) && object.hasOwnProperty('a') && isNumeric(object.a) && object.hasOwnProperty('b') && isNumeric(object.b) && object.hasOwnProperty('c') && isNumeric(object.c) && object.hasOwnProperty('d') && isNumeric(object.d) && object.hasOwnProperty('e') && isNumeric(object.e) && object.hasOwnProperty('f') && isNumeric(object.f);
}

/***/ }),

/***/ "./node_modules/transformation-matrix/build-es/rotate.js":
/*!***************************************************************!*\
  !*** ./node_modules/transformation-matrix/build-es/rotate.js ***!
  \***************************************************************/
/*! exports provided: rotate, rotateDEG */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateDEG", function() { return rotateDEG; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/transformation-matrix/build-es/utils.js");
/* harmony import */ var _translate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./translate */ "./node_modules/transformation-matrix/build-es/translate.js");
/* harmony import */ var _transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transform */ "./node_modules/transformation-matrix/build-es/transform.js");




var cos = Math.cos,
    sin = Math.sin,
    PI = Math.PI;
/**
 * Calculate a rotation matrix
 * @param angle Angle in radians
 * @param [cx] If (cx,cy) are supplied the rotate is about this point
 * @param [cy] If (cx,cy) are supplied the rotate is about this point
 * @returns {{a: number, b: number, c: number, e: number, d: number, f: number}} Affine matrix *
 */

function rotate(angle, cx, cy) {
  var cosAngle = cos(angle);
  var sinAngle = sin(angle);
  var rotationMatrix = {
    a: cosAngle,
    c: -sinAngle,
    e: 0,
    b: sinAngle,
    d: cosAngle,
    f: 0
  };
  if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__["isUndefined"])(cx) || Object(_utils__WEBPACK_IMPORTED_MODULE_0__["isUndefined"])(cy)) {
    return rotationMatrix;
  }

  return Object(_transform__WEBPACK_IMPORTED_MODULE_2__["transform"])([Object(_translate__WEBPACK_IMPORTED_MODULE_1__["translate"])(cx, cy), rotationMatrix, Object(_translate__WEBPACK_IMPORTED_MODULE_1__["translate"])(-cx, -cy)]);
}

/**
 * Calculate a rotation matrix with a DEG angle
 * @param angle Angle in degree
 * @param [cx] If (cx,cy) are supplied the rotate is about this point
 * @param [cy] If (cx,cy) are supplied the rotate is about this point
 * @returns {{a: number, b: number, c: number, e: number, d: number, f: number}} Affine matrix
 */
function rotateDEG(angle) {
  var cx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  var cy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

  return rotate(angle * PI / 180, cx, cy);
}

/***/ }),

/***/ "./node_modules/transformation-matrix/build-es/scale.js":
/*!**************************************************************!*\
  !*** ./node_modules/transformation-matrix/build-es/scale.js ***!
  \**************************************************************/
/*! exports provided: scale */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./node_modules/transformation-matrix/build-es/utils.js");


/**
 * Calculate a scaling matrix
 * @param sx Scaling on axis x
 * @param [sy = sx] Scaling on axis y (default sx)
 * @returns {{a: number, b: number, c: number, e: number, d: number, f: number}} Affine matrix
 */
function scale(sx) {
  var sy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

  if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__["isUndefined"])(sy)) sy = sx;
  return {
    a: sx,
    c: 0,
    e: 0,
    b: 0,
    d: sy,
    f: 0
  };
}

/***/ }),

/***/ "./node_modules/transformation-matrix/build-es/shear.js":
/*!**************************************************************!*\
  !*** ./node_modules/transformation-matrix/build-es/shear.js ***!
  \**************************************************************/
/*! exports provided: shear */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shear", function() { return shear; });
/**
 * Calculate a shear matrix
 * @param shx Shear on axis x
 * @param shy Shear on axis y
 * @returns {{a: number, b: number, c: number, e: number, d: number, f: number}} Affine matrix
 */
function shear(shx, shy) {
  return {
    a: 1,
    c: shx,
    e: 0,
    b: shy,
    d: 1,
    f: 0
  };
}

/***/ }),

/***/ "./node_modules/transformation-matrix/build-es/skew.js":
/*!*************************************************************!*\
  !*** ./node_modules/transformation-matrix/build-es/skew.js ***!
  \*************************************************************/
/*! exports provided: skew, skewDEG */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "skew", function() { return skew; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "skewDEG", function() { return skewDEG; });
// https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/skew
var tan = Math.tan;

/**
 * Calculate a skew matrix
 * @param ax Skew on axis x
 * @param ay Skew on axis y
 * @returns {{a: number, b: number, c: number, e: number, d: number, f: number}} Affine matrix
 */

function skew(ax, ay) {
  return {
    a: 1,
    c: tan(ax),
    e: 0,
    b: tan(ay),
    d: 1,
    f: 0
  };
}

/**
 * Calculate a skew matrix using DEG angles
 * @param ax Skew on axis x
 * @param ay Skew on axis y
 * @returns {{a: number, b: number, c: number, e: number, d: number, f: number}} Affine matrix
 */
function skewDEG(ax, ay) {
  return skew(ax * Math.PI / 180, ay * Math.PI / 180);
}

/***/ }),

/***/ "./node_modules/transformation-matrix/build-es/toString.js":
/*!*****************************************************************!*\
  !*** ./node_modules/transformation-matrix/build-es/toString.js ***!
  \*****************************************************************/
/*! exports provided: toCSS, toSVG, toString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toCSS", function() { return toCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toSVG", function() { return toSVG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toString", function() { return toString; });
/**
 * Serialize the matrix to a string that can be used with CSS or SVG
 * @param matrix Affine matrix
 * @returns {string} String that contains a matrix formatted as matrix(a,b,c,d,e,f)
 */
function toCSS(matrix) {
  return toString(matrix);
}

/**
 * Serialize the matrix to a string that can be used with CSS or SVG
 * @param matrix Affine matrix
 * @returns {string} String that contains a matrix formatted as matrix(a,b,c,d,e,f)
 */
function toSVG(matrix) {
  return toString(matrix);
}

/**
 * Serialize the matrix to a string that can be used with CSS or SVG
 * @param matrix Affine matrix
 * @returns {string} String that contains a matrix formatted as matrix(a,b,c,d,e,f)
 */
function toString(matrix) {
  return "matrix(" + matrix.a + "," + matrix.b + "," + matrix.c + "," + matrix.d + "," + matrix.e + "," + matrix.f + ")";
}

/***/ }),

/***/ "./node_modules/transformation-matrix/build-es/transform.js":
/*!******************************************************************!*\
  !*** ./node_modules/transformation-matrix/build-es/transform.js ***!
  \******************************************************************/
/*! exports provided: transform, compose */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transform", function() { return transform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return compose; });
function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

/**
 * Merge multiple matrices into one
 * @param matrices {...object} list of matrices
 * @returns {{a: number, b: number, c: number, e: number, d: number, f: number}} Affine matrix
 */
function transform() {
  for (var _len = arguments.length, matrices = Array(_len), _key = 0; _key < _len; _key++) {
    matrices[_key] = arguments[_key];
  }

  matrices = Array.isArray(matrices[0]) ? matrices[0] : matrices;

  var multiply = function multiply(m1, m2) {
    return {
      a: m1.a * m2.a + m1.c * m2.b,
      c: m1.a * m2.c + m1.c * m2.d,
      e: m1.a * m2.e + m1.c * m2.f + m1.e,
      b: m1.b * m2.a + m1.d * m2.b,
      d: m1.b * m2.c + m1.d * m2.d,
      f: m1.b * m2.e + m1.d * m2.f + m1.f
    };
  };

  switch (matrices.length) {
    case 0:
      throw new Error('no matrices provided');

    case 1:
      return matrices[0];

    case 2:
      return multiply(matrices[0], matrices[1]);

    default:
      var _matrices = matrices,
          _matrices2 = _toArray(_matrices),
          m1 = _matrices2[0],
          m2 = _matrices2[1],
          rest = _matrices2.slice(2);

      var m = multiply(m1, m2);
      return transform.apply(undefined, [m].concat(_toConsumableArray(rest)));
  }
}

/**
 * Merge multiple matrices into one (alias of `transform`)
 * @param matrices {...object} list of matrices
 * @returns {{a: number, b: number, c: number, e: number, d: number, f: number}} Affine matrix
 */
function compose() {
  return transform.apply(undefined, arguments);
}

/***/ }),

/***/ "./node_modules/transformation-matrix/build-es/translate.js":
/*!******************************************************************!*\
  !*** ./node_modules/transformation-matrix/build-es/translate.js ***!
  \******************************************************************/
/*! exports provided: translate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/**
 * Calculate a translate matrix
 * @param tx Translation on axis x
 * @param [ty = 0] Translation on axis y
 * @returns {{a: number, b: number, c: number, e: number, d: number, f: number}} Affine matrix
 */
function translate(tx) {
  var ty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  return {
    a: 1,
    c: 0,
    e: tx,
    b: 0,
    d: 1,
    f: ty
  };
}

/***/ }),

/***/ "./node_modules/transformation-matrix/build-es/utils.js":
/*!**************************************************************!*\
  !*** ./node_modules/transformation-matrix/build-es/utils.js ***!
  \**************************************************************/
/*! exports provided: isUndefined */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isUndefined", function() { return isUndefined; });
function isUndefined(val) {
  return typeof val === 'undefined';
}

/***/ }),

/***/ "./node_modules/worker-loader/dist/cjs.js?name=js/extension-worker/extension-worker.[hash].js!./src/extension-support/extension-worker.js":
/*!************************************************************************************************************************************************!*\
  !*** ./node_modules/worker-loader/dist/cjs.js?name=js/extension-worker/extension-worker.[hash].js!./src/extension-support/extension-worker.js ***!
  \************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
  return new Worker(__webpack_require__.p + "js/extension-worker/extension-worker.7aa03078e6bc64757805.js");
};

/***/ }),

/***/ "./src/blocks/scratch3_control.js":
/*!****************************************!*\
  !*** ./src/blocks/scratch3_control.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Cast = __webpack_require__(/*! ../util/cast */ "./src/util/cast.js");

class Scratch3ControlBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    /**
     * The "counter" block value. For compatibility with 2.0.
     * @type {number}
     */

    this._counter = 0;
    this.runtime.on('RUNTIME_DISPOSED', this.clearCounter.bind(this));
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      control_repeat: this.repeat,
      control_repeat_until: this.repeatUntil,
      control_while: this.repeatWhile,
      control_for_each: this.forEach,
      control_forever: this.forever,
      control_wait: this.wait,
      control_wait_until: this.waitUntil,
      control_if: this.if,
      control_if_else: this.ifElse,
      control_stop: this.stop,
      control_create_clone_of: this.createClone,
      control_delete_this_clone: this.deleteClone,
      control_get_counter: this.getCounter,
      control_incr_counter: this.incrCounter,
      control_clear_counter: this.clearCounter,
      control_all_at_once: this.allAtOnce
    };
  }

  getHats() {
    return {
      control_start_as_clone: {
        restartExistingThreads: false
      }
    };
  }

  repeat(args, util) {
    const times = Math.round(Cast.toNumber(args.TIMES)); // Initialize loop

    if (typeof util.stackFrame.loopCounter === 'undefined') {
      util.stackFrame.loopCounter = times;
    } // Only execute once per frame.
    // When the branch finishes, `repeat` will be executed again and
    // the second branch will be taken, yielding for the rest of the frame.
    // Decrease counter


    util.stackFrame.loopCounter--; // If we still have some left, start the branch.

    if (util.stackFrame.loopCounter >= 0) {
      util.startBranch(1, true);
    }
  }

  repeatUntil(args, util) {
    const condition = Cast.toBoolean(args.CONDITION); // If the condition is false (repeat UNTIL), start the branch.

    if (!condition) {
      util.startBranch(1, true);
    }
  }

  repeatWhile(args, util) {
    const condition = Cast.toBoolean(args.CONDITION); // If the condition is true (repeat WHILE), start the branch.

    if (condition) {
      util.startBranch(1, true);
    }
  }

  forEach(args, util) {
    const variable = util.target.lookupOrCreateVariable(args.VARIABLE.id, args.VARIABLE.name);

    if (typeof util.stackFrame.index === 'undefined') {
      util.stackFrame.index = 0;
    }

    if (util.stackFrame.index < Number(args.VALUE)) {
      util.stackFrame.index++;
      variable.value = util.stackFrame.index;
      util.startBranch(1, true);
    }
  }

  waitUntil(args, util) {
    const condition = Cast.toBoolean(args.CONDITION);

    if (!condition) {
      util.yield();
    }
  }

  forever(args, util) {
    util.startBranch(1, true);
  }

  wait(args, util) {
    if (util.stackTimerNeedsInit()) {
      const duration = Math.max(0, 1000 * Cast.toNumber(args.DURATION));
      util.startStackTimer(duration);
      this.runtime.requestRedraw();
      util.yield();
    } else if (!util.stackTimerFinished()) {
      util.yield();
    }
  }

  if(args, util) {
    const condition = Cast.toBoolean(args.CONDITION);

    if (condition) {
      util.startBranch(1, false);
    }
  }

  ifElse(args, util) {
    const condition = Cast.toBoolean(args.CONDITION);

    if (condition) {
      util.startBranch(1, false);
    } else {
      util.startBranch(2, false);
    }
  }

  stop(args, util) {
    const option = args.STOP_OPTION;

    if (option === 'all') {
      util.stopAll();
    } else if (option === 'other scripts in sprite' || option === 'other scripts in stage') {
      util.stopOtherTargetThreads();
    } else if (option === 'this script') {
      util.stopThisScript();
    }
  }

  createClone(args, util) {
    this._createClone(Cast.toString(args.CLONE_OPTION), util.target);
  }

  _createClone(cloneOption, target) {
    // used by compiler
    // Set clone target
    let cloneTarget;

    if (cloneOption === '_myself_') {
      cloneTarget = target;
    } else {
      cloneTarget = this.runtime.getSpriteTargetByName(cloneOption);
    } // If clone target is not found, return


    if (!cloneTarget) return; // Create clone

    const newClone = cloneTarget.makeClone();

    if (newClone) {
      this.runtime.addTarget(newClone); // Place behind the original target.

      newClone.goBehindOther(cloneTarget);
    }
  }

  deleteClone(args, util) {
    if (util.target.isOriginal) return;
    this.runtime.disposeTarget(util.target);
    this.runtime.stopForTarget(util.target);
  }

  getCounter() {
    return this._counter;
  }

  clearCounter() {
    this._counter = 0;
  }

  incrCounter() {
    this._counter++;
  }

  allAtOnce(args, util) {
    // Since the "all at once" block is implemented for compatiblity with
    // Scratch 2.0 projects, it behaves the same way it did in 2.0, which
    // is to simply run the contained script (like "if 1 = 1").
    // (In early versions of Scratch 2.0, it would work the same way as
    // "run without screen refresh" custom blocks do now, but this was
    // removed before the release of 2.0.)
    util.startBranch(1, false);
  }

}

module.exports = Scratch3ControlBlocks;

/***/ }),

/***/ "./src/blocks/scratch3_core_example.js":
/*!*********************************************!*\
  !*** ./src/blocks/scratch3_core_example.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const BlockType = __webpack_require__(/*! ../extension-support/block-type */ "./src/extension-support/block-type.js");

const ArgumentType = __webpack_require__(/*! ../extension-support/argument-type */ "./src/extension-support/argument-type.js");
/* eslint-disable-next-line max-len */


const blockIconURI = 'data:image/svg+xml,%3Csvg id="rotate-counter-clockwise" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%233d79cc;%7D.cls-2%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3Erotate-counter-clockwise%3C/title%3E%3Cpath class="cls-1" d="M22.68,12.2a1.6,1.6,0,0,1-1.27.63H13.72a1.59,1.59,0,0,1-1.16-2.58l1.12-1.41a4.82,4.82,0,0,0-3.14-.77,4.31,4.31,0,0,0-2,.8,4.25,4.25,0,0,0-1.34,1.73,5.06,5.06,0,0,0,.54,4.62A5.58,5.58,0,0,0,12,17.74h0a2.26,2.26,0,0,1-.16,4.52A10.25,10.25,0,0,1,3.74,18,10.14,10.14,0,0,1,2.25,8.78,9.7,9.7,0,0,1,5.08,4.64,9.92,9.92,0,0,1,9.66,2.5a10.66,10.66,0,0,1,7.72,1.68l1.08-1.35a1.57,1.57,0,0,1,1.24-.6,1.6,1.6,0,0,1,1.54,1.21l1.7,7.37A1.57,1.57,0,0,1,22.68,12.2Z"/%3E%3Cpath class="cls-2" d="M21.38,11.83H13.77a.59.59,0,0,1-.43-1l1.75-2.19a5.9,5.9,0,0,0-4.7-1.58,5.07,5.07,0,0,0-4.11,3.17A6,6,0,0,0,7,15.77a6.51,6.51,0,0,0,5,2.92,1.31,1.31,0,0,1-.08,2.62,9.3,9.3,0,0,1-7.35-3.82A9.16,9.16,0,0,1,3.17,9.12,8.51,8.51,0,0,1,5.71,5.4,8.76,8.76,0,0,1,9.82,3.48a9.71,9.71,0,0,1,7.75,2.07l1.67-2.1a.59.59,0,0,1,1,.21L22,11.08A.59.59,0,0,1,21.38,11.83Z"/%3E%3C/svg%3E';
/**
 * An example core block implemented using the extension spec.
 * This is not loaded as part of the core blocks in the VM but it is provided
 * and used as part of tests.
 */

class Scratch3CoreExample {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: 'coreExample',
      name: 'CoreEx',
      // This string does not need to be translated as this extension is only used as an example.
      blocks: [{
        func: 'MAKE_A_VARIABLE',
        blockType: BlockType.BUTTON,
        text: 'make a variable (CoreEx)'
      }, {
        opcode: 'exampleOpcode',
        blockType: BlockType.REPORTER,
        text: 'example block'
      }, {
        opcode: 'exampleWithInlineImage',
        blockType: BlockType.COMMAND,
        text: 'block with image [CLOCKWISE] inline',
        arguments: {
          CLOCKWISE: {
            type: ArgumentType.IMAGE,
            dataURI: blockIconURI
          }
        }
      }]
    };
  }
  /**
   * Example opcode just returns the name of the stage target.
   * @returns {string} The name of the first target in the project.
   */


  exampleOpcode() {
    const stage = this.runtime.getTargetForStage();
    return stage ? stage.getName() : 'no stage yet';
  }

  exampleWithInlineImage() {
    return;
  }

}

module.exports = Scratch3CoreExample;

/***/ }),

/***/ "./src/blocks/scratch3_data.js":
/*!*************************************!*\
  !*** ./src/blocks/scratch3_data.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Cast = __webpack_require__(/*! ../util/cast */ "./src/util/cast.js");

class Scratch3DataBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      data_variable: this.getVariable,
      data_setvariableto: this.setVariableTo,
      data_changevariableby: this.changeVariableBy,
      data_hidevariable: this.hideVariable,
      data_showvariable: this.showVariable,
      data_listcontents: this.getListContents,
      data_addtolist: this.addToList,
      data_deleteoflist: this.deleteOfList,
      data_deletealloflist: this.deleteAllOfList,
      data_insertatlist: this.insertAtList,
      data_replaceitemoflist: this.replaceItemOfList,
      data_itemoflist: this.getItemOfList,
      data_itemnumoflist: this.getItemNumOfList,
      data_lengthoflist: this.lengthOfList,
      data_listcontainsitem: this.listContainsItem,
      data_hidelist: this.hideList,
      data_showlist: this.showList
    };
  }

  getVariable(args, util) {
    const variable = util.target.lookupOrCreateVariable(args.VARIABLE.id, args.VARIABLE.name);
    return variable.value;
  }

  setVariableTo(args, util) {
    const variable = util.target.lookupOrCreateVariable(args.VARIABLE.id, args.VARIABLE.name);
    variable.value = args.VALUE;

    if (variable.isCloud) {
      util.ioQuery('cloud', 'requestUpdateVariable', [variable.name, args.VALUE]);
    }
  }

  changeVariableBy(args, util) {
    const variable = util.target.lookupOrCreateVariable(args.VARIABLE.id, args.VARIABLE.name);
    const castedValue = Cast.toNumber(variable.value);
    const dValue = Cast.toNumber(args.VALUE);
    const newValue = castedValue + dValue;
    variable.value = newValue;

    if (variable.isCloud) {
      util.ioQuery('cloud', 'requestUpdateVariable', [variable.name, newValue]);
    }
  }

  changeMonitorVisibility(id, visible) {
    // Send the monitor blocks an event like the flyout checkbox event.
    // This both updates the monitor state and changes the isMonitored block flag.
    this.runtime.monitorBlocks.changeBlock({
      id: id,
      // Monitor blocks for variables are the variable ID.
      element: 'checkbox',
      // Mimic checkbox event from flyout.
      value: visible
    }, this.runtime);
  }

  showVariable(args) {
    this.changeMonitorVisibility(args.VARIABLE.id, true);
  }

  hideVariable(args) {
    this.changeMonitorVisibility(args.VARIABLE.id, false);
  }

  showList(args) {
    this.changeMonitorVisibility(args.LIST.id, true);
  }

  hideList(args) {
    this.changeMonitorVisibility(args.LIST.id, false);
  }

  getListContents(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name); // If block is running for monitors, return copy of list as an array if changed.

    if (util.thread.updateMonitor) {
      // Return original list value if up-to-date, which doesn't trigger monitor update.
      if (list._monitorUpToDate) return list.value; // If value changed, reset the flag and return a copy to trigger monitor update.
      // Because monitors use Immutable data structures, only new objects trigger updates.

      list._monitorUpToDate = true;
      return list.value.slice();
    } // Determine if the list is all single letters.
    // If it is, report contents joined together with no separator.
    // If it's not, report contents joined together with a space.


    let allSingleLetters = true;

    for (let i = 0; i < list.value.length; i++) {
      const listItem = list.value[i];

      if (!(typeof listItem === 'string' && listItem.length === 1)) {
        allSingleLetters = false;
        break;
      }
    }

    if (allSingleLetters) {
      return list.value.join('');
    }

    return list.value.join(' ');
  }

  addToList(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    list.value.push(args.ITEM);
    list._monitorUpToDate = false;
  }

  deleteOfList(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    const index = Cast.toListIndex(args.INDEX, list.value.length, true);

    if (index === Cast.LIST_INVALID) {
      return;
    } else if (index === Cast.LIST_ALL) {
      list.value = [];
      return;
    }

    list.value.splice(index - 1, 1);
    list._monitorUpToDate = false;
  }

  deleteAllOfList(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    list.value = [];
    return;
  }

  insertAtList(args, util) {
    const item = args.ITEM;
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    const index = Cast.toListIndex(args.INDEX, list.value.length + 1, false);

    if (index === Cast.LIST_INVALID) {
      return;
    }

    list.value.splice(index - 1, 0, item);
    list._monitorUpToDate = false;
  }

  replaceItemOfList(args, util) {
    const item = args.ITEM;
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    const index = Cast.toListIndex(args.INDEX, list.value.length, false);

    if (index === Cast.LIST_INVALID) {
      return;
    }

    list.value[index - 1] = item;
    list._monitorUpToDate = false;
  }

  getItemOfList(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    const index = Cast.toListIndex(args.INDEX, list.value.length, false);

    if (index === Cast.LIST_INVALID) {
      return '';
    }

    return list.value[index - 1];
  }

  getItemNumOfList(args, util) {
    const item = args.ITEM;
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name); // Go through the list items one-by-one using Cast.compare. This is for
    // cases like checking if 123 is contained in a list [4, 7, '123'] --
    // Scratch considers 123 and '123' to be equal.

    for (let i = 0; i < list.value.length; i++) {
      if (Cast.compare(list.value[i], item) === 0) {
        return i + 1;
      }
    } // We don't bother using .indexOf() at all, because it would end up with
    // edge cases such as the index of '123' in [4, 7, 123, '123', 9].
    // If we use indexOf(), this block would return 4 instead of 3, because
    // indexOf() sees the first occurence of the string 123 as the fourth
    // item in the list. With Scratch, this would be confusing -- after all,
    // '123' and 123 look the same, so one would expect the block to say
    // that the first occurrence of '123' (or 123) to be the third item.
    // Default to 0 if there's no match. Since Scratch lists are 1-indexed,
    // we don't have to worry about this conflicting with the "this item is
    // the first value" number (in JS that is 0, but in Scratch it's 1).


    return 0;
  }

  lengthOfList(args, util) {
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);
    return list.value.length;
  }

  listContainsItem(args, util) {
    const item = args.ITEM;
    const list = util.target.lookupOrCreateList(args.LIST.id, args.LIST.name);

    if (list.value.indexOf(item) >= 0) {
      return true;
    } // Try using Scratch comparison operator on each item.
    // (Scratch considers the string '123' equal to the number 123).


    for (let i = 0; i < list.value.length; i++) {
      if (Cast.compare(list.value[i], item) === 0) {
        return true;
      }
    }

    return false;
  }

}

module.exports = Scratch3DataBlocks;

/***/ }),

/***/ "./src/blocks/scratch3_event.js":
/*!**************************************!*\
  !*** ./src/blocks/scratch3_event.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Cast = __webpack_require__(/*! ../util/cast */ "./src/util/cast.js");

class Scratch3EventBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    this.runtime.on('KEY_PRESSED', key => {
      this.runtime.startHats('event_whenkeypressed', {
        KEY_OPTION: key
      });
      this.runtime.startHats('event_whenkeypressed', {
        KEY_OPTION: 'any'
      });
    });
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      event_whenanything: this.whenAnything,
      event_whentouchingobject: this.touchingObject,
      event_broadcast: this.broadcast,
      event_broadcastandwait: this.broadcastAndWait,
      event_whengreaterthan: this.hatGreaterThanPredicate
    };
  }

  getHats() {
    return {
      event_whenflagclicked: {
        restartExistingThreads: true
      },
      event_whenkeypressed: {
        restartExistingThreads: false
      },
      event_whenanything: {
        restartExistingThreads: false
      },
      event_whenthisspriteclicked: {
        restartExistingThreads: true
      },
      event_whentouchingobject: {
        restartExistingThreads: false,
        edgeActivated: true
      },
      event_whenstageclicked: {
        restartExistingThreads: true
      },
      event_whenbackdropswitchesto: {
        restartExistingThreads: true
      },
      event_whengreaterthan: {
        restartExistingThreads: false,
        edgeActivated: true
      },
      event_whenbroadcastreceived: {
        restartExistingThreads: true
      }
    };
  }

  whenAnything(args, util) {
    return args.BOOL;
  }

  touchingObject(args, util) {
    return util.target.isTouchingObject(args.TOUCHINGOBJECTMENU);
  }

  hatGreaterThanPredicate(args, util) {
    const option = Cast.toString(args.WHENGREATERTHANMENU).toLowerCase();
    const value = Cast.toNumber(args.VALUE);

    switch (option) {
      case 'timer':
        return util.ioQuery('clock', 'projectTimer') > value;

      case 'loudness':
        return this.runtime.audioEngine && this.runtime.audioEngine.getLoudness() > value;
    }

    return false;
  }

  broadcast(args, util) {
    const broadcastVar = util.runtime.getTargetForStage().lookupBroadcastMsg(args.BROADCAST_OPTION.id, args.BROADCAST_OPTION.name);

    if (broadcastVar) {
      const broadcastOption = broadcastVar.name;
      util.startHats('event_whenbroadcastreceived', {
        BROADCAST_OPTION: broadcastOption
      });
    }
  }

  broadcastAndWait(args, util) {
    if (!util.stackFrame.broadcastVar) {
      util.stackFrame.broadcastVar = util.runtime.getTargetForStage().lookupBroadcastMsg(args.BROADCAST_OPTION.id, args.BROADCAST_OPTION.name);
    }

    if (util.stackFrame.broadcastVar) {
      const broadcastOption = util.stackFrame.broadcastVar.name; // Have we run before, starting threads?

      if (!util.stackFrame.startedThreads) {
        // No - start hats for this broadcast.
        util.stackFrame.startedThreads = util.startHats('event_whenbroadcastreceived', {
          BROADCAST_OPTION: broadcastOption
        });

        if (util.stackFrame.startedThreads.length === 0) {
          // Nothing was started.
          return;
        }
      } // We've run before; check if the wait is still going on.


      const instance = this; // Scratch 2 considers threads to be waiting if they are still in
      // runtime.threads. Threads that have run all their blocks, or are
      // marked done but still in runtime.threads are still considered to
      // be waiting.

      const waiting = util.stackFrame.startedThreads.some(thread => instance.runtime.threads.indexOf(thread) !== -1);

      if (waiting) {
        // If all threads are waiting for the next tick or later yield
        // for a tick as well. Otherwise yield until the next loop of
        // the threads.
        if (util.stackFrame.startedThreads.every(thread => instance.runtime.isWaitingThread(thread))) {
          util.yieldTick();
        } else {
          util.yield();
        }
      }
    }
  }

}

module.exports = Scratch3EventBlocks;

/***/ }),

/***/ "./src/blocks/scratch3_looks.js":
/*!**************************************!*\
  !*** ./src/blocks/scratch3_looks.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Cast = __webpack_require__(/*! ../util/cast */ "./src/util/cast.js");

const Clone = __webpack_require__(/*! ../util/clone */ "./src/util/clone.js");

const RenderedTarget = __webpack_require__(/*! ../sprites/rendered-target */ "./src/sprites/rendered-target.js");

const uid = __webpack_require__(/*! ../util/uid */ "./src/util/uid.js");

const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");

const getMonitorIdForBlockWithArgs = __webpack_require__(/*! ../util/get-monitor-id */ "./src/util/get-monitor-id.js");

const MathUtil = __webpack_require__(/*! ../util/math-util */ "./src/util/math-util.js");
/**
 * @typedef {object} BubbleState - the bubble state associated with a particular target.
 * @property {Boolean} onSpriteRight - tracks whether the bubble is right or left of the sprite.
 * @property {?int} drawableId - the ID of the associated bubble Drawable, null if none.
 * @property {string} text - the text of the bubble.
 * @property {string} type - the type of the bubble, "say" or "think"
 * @property {?string} usageId - ID indicating the most recent usage of the say/think bubble.
 *      Used for comparison when determining whether to clear a say/think bubble.
 */


class Scratch3LooksBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    this._onTargetChanged = this._onTargetChanged.bind(this);
    this._onResetBubbles = this._onResetBubbles.bind(this);
    this._onTargetWillExit = this._onTargetWillExit.bind(this);
    this._updateBubble = this._updateBubble.bind(this); // Reset all bubbles on start/stop

    this.runtime.on('PROJECT_STOP_ALL', this._onResetBubbles);
    this.runtime.on('targetWasRemoved', this._onTargetWillExit); // Enable other blocks to use bubbles like ask/answer

    this.runtime.on(Scratch3LooksBlocks.SAY_OR_THINK, this._updateBubble);
  }
  /**
   * The default bubble state, to be used when a target has no existing bubble state.
   * @type {BubbleState}
   */


  static get DEFAULT_BUBBLE_STATE() {
    return {
      drawableId: null,
      onSpriteRight: true,
      skinId: null,
      text: '',
      type: 'say',
      usageId: null
    };
  }
  /**
   * The key to load & store a target's bubble-related state.
   * @type {string}
   */


  static get STATE_KEY() {
    return 'Scratch.looks';
  }
  /**
   * Event name for a text bubble being created or updated.
   * @const {string}
   */


  static get SAY_OR_THINK() {
    // There are currently many places in the codebase which explicitly refer to this event by the string 'SAY',
    // so keep this as the string 'SAY' for now rather than changing it to 'SAY_OR_THINK' and breaking things.
    return 'SAY';
  }
  /**
   * Limit for say bubble string.
   * @const {string}
   */


  static get SAY_BUBBLE_LIMIT() {
    return 330;
  }
  /**
   * Limit for ghost effect
   * @const {object}
   */


  static get EFFECT_GHOST_LIMIT() {
    return {
      min: 0,
      max: 100
    };
  }
  /**
   * Limit for brightness effect
   * @const {object}
   */


  static get EFFECT_BRIGHTNESS_LIMIT() {
    return {
      min: -100,
      max: 100
    };
  }
  /**
   * @param {Target} target - collect bubble state for this target. Probably, but not necessarily, a RenderedTarget.
   * @returns {BubbleState} the mutable bubble state associated with that target. This will be created if necessary.
   * @private
   */


  _getBubbleState(target) {
    let bubbleState = target.getCustomState(Scratch3LooksBlocks.STATE_KEY);

    if (!bubbleState) {
      bubbleState = Clone.simple(Scratch3LooksBlocks.DEFAULT_BUBBLE_STATE);
      target.setCustomState(Scratch3LooksBlocks.STATE_KEY, bubbleState);
    }

    return bubbleState;
  }
  /**
   * Handle a target which has moved.
   * @param {RenderedTarget} target - the target which has moved.
   * @private
   */


  _onTargetChanged(target) {
    const bubbleState = this._getBubbleState(target);

    if (bubbleState.drawableId) {
      this._positionBubble(target);
    }
  }
  /**
   * Handle a target which is exiting.
   * @param {RenderedTarget} target - the target.
   * @private
   */


  _onTargetWillExit(target) {
    const bubbleState = this._getBubbleState(target);

    if (bubbleState.drawableId && bubbleState.skinId) {
      this.runtime.renderer.destroyDrawable(bubbleState.drawableId, StageLayering.SPRITE_LAYER);
      this.runtime.renderer.destroySkin(bubbleState.skinId);
      bubbleState.drawableId = null;
      bubbleState.skinId = null;
      this.runtime.requestRedraw();
    }

    target.onTargetVisualChange = null;
  }
  /**
   * Handle project start/stop by clearing all visible bubbles.
   * @private
   */


  _onResetBubbles() {
    for (let n = 0; n < this.runtime.targets.length; n++) {
      const bubbleState = this._getBubbleState(this.runtime.targets[n]);

      bubbleState.text = '';

      this._onTargetWillExit(this.runtime.targets[n]);
    }

    clearTimeout(this._bubbleTimeout);
  }
  /**
   * Position the bubble of a target. If it doesn't fit on the specified side, flip and rerender.
   * @param {!Target} target Target whose bubble needs positioning.
   * @private
   */


  _positionBubble(target) {
    if (!target.visible) return;

    const bubbleState = this._getBubbleState(target);

    const [bubbleWidth, bubbleHeight] = this.runtime.renderer.getCurrentSkinSize(bubbleState.drawableId);
    let targetBounds;

    try {
      targetBounds = target.getBoundsForBubble();
    } catch (error_) {
      // Bounds calculation could fail (e.g. on empty costumes), in that case
      // use the x/y position of the target.
      targetBounds = {
        left: target.x,
        right: target.x,
        top: target.y,
        bottom: target.y
      };
    }

    const stageSize = this.runtime.renderer.getNativeSize();
    const stageBounds = {
      left: -stageSize[0] / 2,
      right: stageSize[0] / 2,
      top: stageSize[1] / 2,
      bottom: -stageSize[1] / 2
    };

    if (bubbleState.onSpriteRight && bubbleWidth + targetBounds.right > stageBounds.right && targetBounds.left - bubbleWidth > stageBounds.left) {
      // Only flip if it would fit
      bubbleState.onSpriteRight = false;

      this._renderBubble(target);
    } else if (!bubbleState.onSpriteRight && targetBounds.left - bubbleWidth < stageBounds.left && bubbleWidth + targetBounds.right < stageBounds.right) {
      // Only flip if it would fit
      bubbleState.onSpriteRight = true;

      this._renderBubble(target);
    } else {
      this.runtime.renderer.updateDrawablePosition(bubbleState.drawableId, [bubbleState.onSpriteRight ? Math.max(stageBounds.left, // Bubble should not extend past left edge of stage
      Math.min(stageBounds.right - bubbleWidth, targetBounds.right)) : Math.min(stageBounds.right - bubbleWidth, // Bubble should not extend past right edge of stage
      Math.max(stageBounds.left, targetBounds.left - bubbleWidth)), // Bubble should not extend past the top of the stage
      Math.min(stageBounds.top, targetBounds.bottom + bubbleHeight)]);
      this.runtime.requestRedraw();
    }
  }
  /**
   * Create a visible bubble for a target. If a bubble exists for the target,
   * just set it to visible and update the type/text. Otherwise create a new
   * bubble and update the relevant custom state.
   * @param {!Target} target Target who needs a bubble.
   * @return {undefined} Early return if text is empty string.
   * @private
   */


  _renderBubble(target) {
    // used by compiler
    if (!this.runtime.renderer) return;

    const bubbleState = this._getBubbleState(target);

    const {
      type,
      text,
      onSpriteRight
    } = bubbleState; // Remove the bubble if target is not visible, or text is being set to blank.

    if (!target.visible || text === '') {
      this._onTargetWillExit(target);

      return;
    }

    if (bubbleState.skinId) {
      this.runtime.renderer.updateTextSkin(bubbleState.skinId, type, text, onSpriteRight, [0, 0]);
    } else {
      target.onTargetVisualChange = this._onTargetChanged;
      bubbleState.drawableId = this.runtime.renderer.createDrawable(StageLayering.SPRITE_LAYER);
      bubbleState.skinId = this.runtime.renderer.createTextSkin(type, text, bubbleState.onSpriteRight, [0, 0]);
      this.runtime.renderer.updateDrawableSkinId(bubbleState.drawableId, bubbleState.skinId);
    }

    this._positionBubble(target);
  }
  /**
   * Properly format text for a text bubble.
   * @param {string} text The text to be formatted
   * @return {string} The formatted text
   * @private
   */


  _formatBubbleText(text) {
    if (text === '') return text; // Non-integers should be rounded to 2 decimal places (no more, no less), unless they're small enough that
    // rounding would display them as 0.00. This matches 2.0's behavior:
    // https://github.com/LLK/scratch-flash/blob/2e4a402ceb205a042887f54b26eebe1c2e6da6c0/src/scratch/ScratchSprite.as#L579-L585

    if (typeof text === 'number' && Math.abs(text) >= 0.01 && text % 1 !== 0) {
      text = text.toFixed(2);
    } // Limit the length of the string.


    text = String(text).substr(0, Scratch3LooksBlocks.SAY_BUBBLE_LIMIT);
    return text;
  }
  /**
   * The entry point for say/think blocks. Clears existing bubble if the text is empty.
   * Set the bubble custom state and then call _renderBubble.
   * @param {!Target} target Target that say/think blocks are being called on.
   * @param {!string} type Either "say" or "think"
   * @param {!string} text The text for the bubble, empty string clears the bubble.
   * @private
   */


  _updateBubble(target, type, text) {
    const bubbleState = this._getBubbleState(target);

    bubbleState.type = type;
    bubbleState.text = this._formatBubbleText(text);
    bubbleState.usageId = uid();

    this._renderBubble(target);
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      looks_say: this.say,
      looks_sayforsecs: this.sayforsecs,
      looks_think: this.think,
      looks_thinkforsecs: this.thinkforsecs,
      looks_show: this.show,
      looks_hide: this.hide,
      looks_hideallsprites: () => {},
      // legacy no-op block
      looks_switchcostumeto: this.switchCostume,
      looks_switchbackdropto: this.switchBackdrop,
      looks_switchbackdroptoandwait: this.switchBackdropAndWait,
      looks_nextcostume: this.nextCostume,
      looks_nextbackdrop: this.nextBackdrop,
      looks_changeeffectby: this.changeEffect,
      looks_seteffectto: this.setEffect,
      looks_cleargraphiceffects: this.clearEffects,
      looks_changesizeby: this.changeSize,
      looks_setsizeto: this.setSize,
      looks_changestretchby: () => {},
      // legacy no-op blocks
      looks_setstretchto: () => {},
      looks_gotofrontback: this.goToFrontBack,
      looks_goforwardbackwardlayers: this.goForwardBackwardLayers,
      looks_size: this.getSize,
      looks_costumenumbername: this.getCostumeNumberName,
      looks_backdropnumbername: this.getBackdropNumberName
    };
  }

  getMonitored() {
    return {
      looks_size: {
        isSpriteSpecific: true,
        getId: targetId => "".concat(targetId, "_size")
      },
      looks_costumenumbername: {
        isSpriteSpecific: true,
        getId: (targetId, fields) => getMonitorIdForBlockWithArgs("".concat(targetId, "_costumenumbername"), fields)
      },
      looks_backdropnumbername: {
        getId: (_, fields) => getMonitorIdForBlockWithArgs('backdropnumbername', fields)
      }
    };
  }

  say(args, util) {
    // @TODO in 2.0 calling say/think resets the right/left bias of the bubble
    const message = args.MESSAGE;

    this._say(message, util.target);
  }

  _say(message, target) {
    // used by compiler
    this.runtime.emit(Scratch3LooksBlocks.SAY_OR_THINK, target, 'say', message);
  }

  sayforsecs(args, util) {
    this.say(args, util);
    const target = util.target;

    const usageId = this._getBubbleState(target).usageId;

    return new Promise(resolve => {
      this._bubbleTimeout = setTimeout(() => {
        this._bubbleTimeout = null; // Clear say bubble if it hasn't been changed and proceed.

        if (this._getBubbleState(target).usageId === usageId) {
          this._updateBubble(target, 'say', '');
        }

        resolve();
      }, 1000 * args.SECS);
    });
  }

  think(args, util) {
    this.runtime.emit(Scratch3LooksBlocks.SAY_OR_THINK, util.target, 'think', args.MESSAGE);
  }

  thinkforsecs(args, util) {
    this.think(args, util);
    const target = util.target;

    const usageId = this._getBubbleState(target).usageId;

    return new Promise(resolve => {
      this._bubbleTimeout = setTimeout(() => {
        this._bubbleTimeout = null; // Clear think bubble if it hasn't been changed and proceed.

        if (this._getBubbleState(target).usageId === usageId) {
          this._updateBubble(target, 'think', '');
        }

        resolve();
      }, 1000 * args.SECS);
    });
  }

  show(args, util) {
    util.target.setVisible(true);

    this._renderBubble(util.target);
  }

  hide(args, util) {
    util.target.setVisible(false);

    this._renderBubble(util.target);
  }
  /**
   * Utility function to set the costume of a target.
   * Matches the behavior of Scratch 2.0 for different types of arguments.
   * @param {!Target} target Target to set costume to.
   * @param {Any} requestedCostume Costume requested, e.g., 0, 'name', etc.
   * @param {boolean=} optZeroIndex Set to zero-index the requestedCostume.
   * @return {Array.<!Thread>} Any threads started by this switch.
   */


  _setCostume(target, requestedCostume, optZeroIndex) {
    // used by compiler
    if (typeof requestedCostume === 'number') {
      // Numbers should be treated as costume indices, always
      target.setCostume(optZeroIndex ? requestedCostume : requestedCostume - 1);
    } else {
      // Strings should be treated as costume names, where possible
      const costumeIndex = target.getCostumeIndexByName(requestedCostume.toString());

      if (costumeIndex !== -1) {
        target.setCostume(costumeIndex);
      } else if (requestedCostume === 'next costume') {
        target.setCostume(target.currentCostume + 1);
      } else if (requestedCostume === 'previous costume') {
        target.setCostume(target.currentCostume - 1); // Try to cast the string to a number (and treat it as a costume index)
        // Pure whitespace should not be treated as a number
        // Note: isNaN will cast the string to a number before checking if it's NaN
      } else if (!(isNaN(requestedCostume) || Cast.isWhiteSpace(requestedCostume))) {
        target.setCostume(optZeroIndex ? Number(requestedCostume) : Number(requestedCostume) - 1);
      }
    } // Per 2.0, 'switch costume' can't start threads even in the Stage.


    return [];
  }
  /**
   * Utility function to set the backdrop of a target.
   * Matches the behavior of Scratch 2.0 for different types of arguments.
   * @param {!Target} stage Target to set backdrop to.
   * @param {Any} requestedBackdrop Backdrop requested, e.g., 0, 'name', etc.
   * @param {boolean=} optZeroIndex Set to zero-index the requestedBackdrop.
   * @return {Array.<!Thread>} Any threads started by this switch.
   */


  _setBackdrop(stage, requestedBackdrop, optZeroIndex) {
    // used by compiler
    if (typeof requestedBackdrop === 'number') {
      // Numbers should be treated as backdrop indices, always
      stage.setCostume(optZeroIndex ? requestedBackdrop : requestedBackdrop - 1);
    } else {
      // Strings should be treated as backdrop names where possible
      const costumeIndex = stage.getCostumeIndexByName(requestedBackdrop.toString());

      if (costumeIndex !== -1) {
        stage.setCostume(costumeIndex);
      } else if (requestedBackdrop === 'next backdrop') {
        stage.setCostume(stage.currentCostume + 1);
      } else if (requestedBackdrop === 'previous backdrop') {
        stage.setCostume(stage.currentCostume - 1);
      } else if (requestedBackdrop === 'random backdrop') {
        const numCostumes = stage.getCostumes().length;

        if (numCostumes > 1) {
          // Don't pick the current backdrop, so that the block
          // will always have an observable effect.
          const lowerBound = 0;
          const upperBound = numCostumes - 1;
          const costumeToExclude = stage.currentCostume;
          const nextCostume = MathUtil.inclusiveRandIntWithout(lowerBound, upperBound, costumeToExclude);
          stage.setCostume(nextCostume);
        } // Try to cast the string to a number (and treat it as a costume index)
        // Pure whitespace should not be treated as a number
        // Note: isNaN will cast the string to a number before checking if it's NaN

      } else if (!(isNaN(requestedBackdrop) || Cast.isWhiteSpace(requestedBackdrop))) {
        stage.setCostume(optZeroIndex ? Number(requestedBackdrop) : Number(requestedBackdrop) - 1);
      }
    }

    const newName = stage.getCostumes()[stage.currentCostume].name;
    return this.runtime.startHats('event_whenbackdropswitchesto', {
      BACKDROP: newName
    });
  }

  switchCostume(args, util) {
    this._setCostume(util.target, args.COSTUME); // used by compiler

  }

  nextCostume(args, util) {
    this._setCostume(util.target, util.target.currentCostume + 1, true);
  }

  switchBackdrop(args) {
    this._setBackdrop(this.runtime.getTargetForStage(), args.BACKDROP);
  }

  switchBackdropAndWait(args, util) {
    // Have we run before, starting threads?
    if (!util.stackFrame.startedThreads) {
      // No - switch the backdrop.
      util.stackFrame.startedThreads = this._setBackdrop(this.runtime.getTargetForStage(), args.BACKDROP);

      if (util.stackFrame.startedThreads.length === 0) {
        // Nothing was started.
        return;
      }
    } // We've run before; check if the wait is still going on.


    const instance = this; // Scratch 2 considers threads to be waiting if they are still in
    // runtime.threads. Threads that have run all their blocks, or are
    // marked done but still in runtime.threads are still considered to
    // be waiting.

    const waiting = util.stackFrame.startedThreads.some(thread => instance.runtime.threads.indexOf(thread) !== -1);

    if (waiting) {
      // If all threads are waiting for the next tick or later yield
      // for a tick as well. Otherwise yield until the next loop of
      // the threads.
      if (util.stackFrame.startedThreads.every(thread => instance.runtime.isWaitingThread(thread))) {
        util.yieldTick();
      } else {
        util.yield();
      }
    }
  }

  nextBackdrop() {
    const stage = this.runtime.getTargetForStage();

    this._setBackdrop(stage, stage.currentCostume + 1, true);
  }

  clampEffect(effect, value) {
    // used by compiler
    let clampedValue = value;

    switch (effect) {
      case 'ghost':
        clampedValue = MathUtil.clamp(value, Scratch3LooksBlocks.EFFECT_GHOST_LIMIT.min, Scratch3LooksBlocks.EFFECT_GHOST_LIMIT.max);
        break;

      case 'brightness':
        clampedValue = MathUtil.clamp(value, Scratch3LooksBlocks.EFFECT_BRIGHTNESS_LIMIT.min, Scratch3LooksBlocks.EFFECT_BRIGHTNESS_LIMIT.max);
        break;
    }

    return clampedValue;
  }

  changeEffect(args, util) {
    const effect = Cast.toString(args.EFFECT).toLowerCase();
    const change = Cast.toNumber(args.CHANGE);
    if (!util.target.effects.hasOwnProperty(effect)) return;
    let newValue = change + util.target.effects[effect];
    newValue = this.clampEffect(effect, newValue);
    util.target.setEffect(effect, newValue);
  }

  setEffect(args, util) {
    const effect = Cast.toString(args.EFFECT).toLowerCase();
    let value = Cast.toNumber(args.VALUE);
    value = this.clampEffect(effect, value);
    util.target.setEffect(effect, value);
  }

  clearEffects(args, util) {
    util.target.clearEffects();
  }

  changeSize(args, util) {
    const change = Cast.toNumber(args.CHANGE);
    util.target.setSize(util.target.size + change);
  }

  setSize(args, util) {
    const size = Cast.toNumber(args.SIZE);
    util.target.setSize(size);
  }

  goToFrontBack(args, util) {
    if (!util.target.isStage) {
      if (args.FRONT_BACK === 'front') {
        util.target.goToFront();
      } else {
        util.target.goToBack();
      }
    }
  }

  goForwardBackwardLayers(args, util) {
    if (!util.target.isStage) {
      if (args.FORWARD_BACKWARD === 'forward') {
        util.target.goForwardLayers(Cast.toNumber(args.NUM));
      } else {
        util.target.goBackwardLayers(Cast.toNumber(args.NUM));
      }
    }
  }

  getSize(args, util) {
    return Math.round(util.target.size);
  }

  getBackdropNumberName(args) {
    const stage = this.runtime.getTargetForStage();

    if (args.NUMBER_NAME === 'number') {
      return stage.currentCostume + 1;
    } // Else return name


    return stage.getCostumes()[stage.currentCostume].name;
  }

  getCostumeNumberName(args, util) {
    if (args.NUMBER_NAME === 'number') {
      return util.target.currentCostume + 1;
    } // Else return name


    return util.target.getCostumes()[util.target.currentCostume].name;
  }

}

module.exports = Scratch3LooksBlocks;

/***/ }),

/***/ "./src/blocks/scratch3_motion.js":
/*!***************************************!*\
  !*** ./src/blocks/scratch3_motion.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Cast = __webpack_require__(/*! ../util/cast */ "./src/util/cast.js");

const MathUtil = __webpack_require__(/*! ../util/math-util */ "./src/util/math-util.js");

const Timer = __webpack_require__(/*! ../util/timer */ "./src/util/timer.js");

class Scratch3MotionBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      motion_movesteps: this.moveSteps,
      motion_gotoxy: this.goToXY,
      motion_goto: this.goTo,
      motion_turnright: this.turnRight,
      motion_turnleft: this.turnLeft,
      motion_pointindirection: this.pointInDirection,
      motion_pointtowards: this.pointTowards,
      motion_glidesecstoxy: this.glide,
      motion_glideto: this.glideTo,
      motion_ifonedgebounce: this.ifOnEdgeBounce,
      motion_setrotationstyle: this.setRotationStyle,
      motion_changexby: this.changeX,
      motion_setx: this.setX,
      motion_changeyby: this.changeY,
      motion_sety: this.setY,
      motion_xposition: this.getX,
      motion_yposition: this.getY,
      motion_direction: this.getDirection,
      // Legacy no-op blocks:
      motion_scroll_right: () => {},
      motion_scroll_up: () => {},
      motion_align_scene: () => {},
      motion_xscroll: () => {},
      motion_yscroll: () => {}
    };
  }

  getMonitored() {
    return {
      motion_xposition: {
        isSpriteSpecific: true,
        getId: targetId => "".concat(targetId, "_xposition")
      },
      motion_yposition: {
        isSpriteSpecific: true,
        getId: targetId => "".concat(targetId, "_yposition")
      },
      motion_direction: {
        isSpriteSpecific: true,
        getId: targetId => "".concat(targetId, "_direction")
      }
    };
  }

  moveSteps(args, util) {
    const steps = Cast.toNumber(args.STEPS);

    this._moveSteps(steps, util.target);
  }

  _moveSteps(steps, target) {
    // used by compiler
    const radians = MathUtil.degToRad(90 - target.direction);
    const dx = steps * Math.cos(radians);
    const dy = steps * Math.sin(radians);
    target.setXY(target.x + dx, target.y + dy);
  }

  goToXY(args, util) {
    const x = Cast.toNumber(args.X);
    const y = Cast.toNumber(args.Y);
    util.target.setXY(x, y);
  }

  getTargetXY(targetName, util) {
    let targetX = 0;
    let targetY = 0;

    if (targetName === '_mouse_') {
      targetX = util.ioQuery('mouse', 'getScratchX');
      targetY = util.ioQuery('mouse', 'getScratchY');
    } else if (targetName === '_random_') {
      const stageWidth = this.runtime.stageWidth;
      const stageHeight = this.runtime.stageHeight;
      targetX = Math.round(stageWidth * (Math.random() - 0.5));
      targetY = Math.round(stageHeight * (Math.random() - 0.5));
    } else {
      targetName = Cast.toString(targetName);
      const goToTarget = this.runtime.getSpriteTargetByName(targetName);
      if (!goToTarget) return;
      targetX = goToTarget.x;
      targetY = goToTarget.y;
    }

    return [targetX, targetY];
  }

  goTo(args, util) {
    const targetXY = this.getTargetXY(args.TO, util);

    if (targetXY) {
      util.target.setXY(targetXY[0], targetXY[1]);
    }
  }

  turnRight(args, util) {
    const degrees = Cast.toNumber(args.DEGREES);
    util.target.setDirection(util.target.direction + degrees);
  }

  turnLeft(args, util) {
    const degrees = Cast.toNumber(args.DEGREES);
    util.target.setDirection(util.target.direction - degrees);
  }

  pointInDirection(args, util) {
    const direction = Cast.toNumber(args.DIRECTION);
    util.target.setDirection(direction);
  }

  pointTowards(args, util) {
    let targetX = 0;
    let targetY = 0;

    if (args.TOWARDS === '_mouse_') {
      targetX = util.ioQuery('mouse', 'getScratchX');
      targetY = util.ioQuery('mouse', 'getScratchY');
    } else if (args.TOWARDS === '_random_') {
      util.target.setDirection(Math.round(Math.random() * 360) - 180);
      return;
    } else {
      args.TOWARDS = Cast.toString(args.TOWARDS);
      const pointTarget = this.runtime.getSpriteTargetByName(args.TOWARDS);
      if (!pointTarget) return;
      targetX = pointTarget.x;
      targetY = pointTarget.y;
    }

    const dx = targetX - util.target.x;
    const dy = targetY - util.target.y;
    const direction = 90 - MathUtil.radToDeg(Math.atan2(dy, dx));
    util.target.setDirection(direction);
  }

  glide(args, util) {
    if (util.stackFrame.timer) {
      const timeElapsed = util.stackFrame.timer.timeElapsed();

      if (timeElapsed < util.stackFrame.duration * 1000) {
        // In progress: move to intermediate position.
        const frac = timeElapsed / (util.stackFrame.duration * 1000);
        const dx = frac * (util.stackFrame.endX - util.stackFrame.startX);
        const dy = frac * (util.stackFrame.endY - util.stackFrame.startY);
        util.target.setXY(util.stackFrame.startX + dx, util.stackFrame.startY + dy);
        util.yield();
      } else {
        // Finished: move to final position.
        util.target.setXY(util.stackFrame.endX, util.stackFrame.endY);
      }
    } else {
      // First time: save data for future use.
      util.stackFrame.timer = new Timer();
      util.stackFrame.timer.start();
      util.stackFrame.duration = Cast.toNumber(args.SECS);
      util.stackFrame.startX = util.target.x;
      util.stackFrame.startY = util.target.y;
      util.stackFrame.endX = Cast.toNumber(args.X);
      util.stackFrame.endY = Cast.toNumber(args.Y);

      if (util.stackFrame.duration <= 0) {
        // Duration too short to glide.
        util.target.setXY(util.stackFrame.endX, util.stackFrame.endY);
        return;
      }

      util.yield();
    }
  }

  glideTo(args, util) {
    const targetXY = this.getTargetXY(args.TO, util);

    if (targetXY) {
      this.glide({
        SECS: args.SECS,
        X: targetXY[0],
        Y: targetXY[1]
      }, util);
    }
  }

  ifOnEdgeBounce(args, util) {
    this._ifOnEdgeBounce(util.target);
  }

  _ifOnEdgeBounce(target) {
    // used by compiler
    const bounds = target.getBounds();

    if (!bounds) {
      return;
    } // Measure distance to edges.
    // Values are positive when the sprite is far away,
    // and clamped to zero when the sprite is beyond.


    const stageWidth = this.runtime.stageWidth;
    const stageHeight = this.runtime.stageHeight;
    const distLeft = Math.max(0, stageWidth / 2 + bounds.left);
    const distTop = Math.max(0, stageHeight / 2 - bounds.top);
    const distRight = Math.max(0, stageWidth / 2 - bounds.right);
    const distBottom = Math.max(0, stageHeight / 2 + bounds.bottom); // Find the nearest edge.

    let nearestEdge = '';
    let minDist = Infinity;

    if (distLeft < minDist) {
      minDist = distLeft;
      nearestEdge = 'left';
    }

    if (distTop < minDist) {
      minDist = distTop;
      nearestEdge = 'top';
    }

    if (distRight < minDist) {
      minDist = distRight;
      nearestEdge = 'right';
    }

    if (distBottom < minDist) {
      minDist = distBottom;
      nearestEdge = 'bottom';
    }

    if (minDist > 0) {
      return; // Not touching any edge.
    } // Point away from the nearest edge.


    const radians = MathUtil.degToRad(90 - target.direction);
    let dx = Math.cos(radians);
    let dy = -Math.sin(radians);

    if (nearestEdge === 'left') {
      dx = Math.max(0.2, Math.abs(dx));
    } else if (nearestEdge === 'top') {
      dy = Math.max(0.2, Math.abs(dy));
    } else if (nearestEdge === 'right') {
      dx = 0 - Math.max(0.2, Math.abs(dx));
    } else if (nearestEdge === 'bottom') {
      dy = 0 - Math.max(0.2, Math.abs(dy));
    }

    const newDirection = MathUtil.radToDeg(Math.atan2(dy, dx)) + 90;
    target.setDirection(newDirection); // Keep within the stage.

    const fencedPosition = target.keepInFence(target.x, target.y);
    target.setXY(fencedPosition[0], fencedPosition[1]);
  }

  setRotationStyle(args, util) {
    util.target.setRotationStyle(args.STYLE);
  }

  changeX(args, util) {
    const dx = Cast.toNumber(args.DX);
    util.target.setXY(util.target.x + dx, util.target.y);
  }

  setX(args, util) {
    const x = Cast.toNumber(args.X);
    util.target.setXY(x, util.target.y);
  }

  changeY(args, util) {
    const dy = Cast.toNumber(args.DY);
    util.target.setXY(util.target.x, util.target.y + dy);
  }

  setY(args, util) {
    const y = Cast.toNumber(args.Y);
    util.target.setXY(util.target.x, y);
  }

  getX(args, util) {
    return this.limitPrecision(util.target.x);
  }

  getY(args, util) {
    return this.limitPrecision(util.target.y);
  }

  getDirection(args, util) {
    return util.target.direction;
  } // This corresponds to snapToInteger in Scratch 2


  limitPrecision(coordinate) {
    const rounded = Math.round(coordinate);
    const delta = coordinate - rounded;
    const limitedCoord = Math.abs(delta) < 1e-9 ? rounded : coordinate;
    return limitedCoord;
  }

}

module.exports = Scratch3MotionBlocks;

/***/ }),

/***/ "./src/blocks/scratch3_operators.js":
/*!******************************************!*\
  !*** ./src/blocks/scratch3_operators.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Cast = __webpack_require__(/*! ../util/cast.js */ "./src/util/cast.js");

const MathUtil = __webpack_require__(/*! ../util/math-util.js */ "./src/util/math-util.js");

class Scratch3OperatorsBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      operator_add: this.add,
      operator_subtract: this.subtract,
      operator_multiply: this.multiply,
      operator_divide: this.divide,
      operator_lt: this.lt,
      operator_equals: this.equals,
      operator_gt: this.gt,
      operator_and: this.and,
      operator_or: this.or,
      operator_not: this.not,
      operator_random: this.random,
      operator_join: this.join,
      operator_letter_of: this.letterOf,
      operator_length: this.length,
      operator_contains: this.contains,
      operator_mod: this.mod,
      operator_round: this.round,
      operator_mathop: this.mathop,
      operator_advlog: this.advlog
    };
  }

  add(args) {
    return Cast.toNumber(args.NUM1) + Cast.toNumber(args.NUM2);
  }

  subtract(args) {
    return Cast.toNumber(args.NUM1) - Cast.toNumber(args.NUM2);
  }

  multiply(args) {
    return Cast.toNumber(args.NUM1) * Cast.toNumber(args.NUM2);
  }

  divide(args) {
    return Cast.toNumber(args.NUM1) / Cast.toNumber(args.NUM2);
  }

  lt(args) {
    return Cast.compare(args.OPERAND1, args.OPERAND2) < 0;
  }

  equals(args) {
    return Cast.compare(args.OPERAND1, args.OPERAND2) === 0;
  }

  gt(args) {
    return Cast.compare(args.OPERAND1, args.OPERAND2) > 0;
  }

  and(args) {
    return Cast.toBoolean(args.OPERAND1) && Cast.toBoolean(args.OPERAND2);
  }

  or(args) {
    return Cast.toBoolean(args.OPERAND1) || Cast.toBoolean(args.OPERAND2);
  }

  not(args) {
    return !Cast.toBoolean(args.OPERAND);
  }

  random(args) {
    return this._random(args.FROM, args.TO);
  }

  _random(from, to) {
    // used by compiler
    const nFrom = Cast.toNumber(from);
    const nTo = Cast.toNumber(to);
    const low = nFrom <= nTo ? nFrom : nTo;
    const high = nFrom <= nTo ? nTo : nFrom;
    if (low === high) return low; // If both arguments are ints, truncate the result to an int.

    if (Cast.isInt(from) && Cast.isInt(to)) {
      return low + Math.floor(Math.random() * (high + 1 - low));
    }

    return Math.random() * (high - low) + low;
  }

  join(args) {
    return Cast.toString(args.STRING1) + Cast.toString(args.STRING2);
  }

  letterOf(args) {
    const index = Cast.toNumber(args.LETTER) - 1;
    const str = Cast.toString(args.STRING); // Out of bounds?

    if (index < 0 || index >= str.length) {
      return '';
    }

    return str.charAt(index);
  }

  length(args) {
    return Cast.toString(args.STRING).length;
  }

  contains(args) {
    const format = function format(string) {
      return Cast.toString(string).toLowerCase();
    };

    return format(args.STRING1).includes(format(args.STRING2));
  }

  mod(args) {
    const n = Cast.toNumber(args.NUM1);
    const modulus = Cast.toNumber(args.NUM2);
    let result = n % modulus; // Scratch mod uses floored division instead of truncated division.

    if (result / modulus < 0) result += modulus;
    return result;
  }

  round(args) {
    return Math.round(Cast.toNumber(args.NUM));
  }

  mathop(args) {
    const operator = Cast.toString(args.OPERATOR).toLowerCase();
    const n = Cast.toNumber(args.NUM);

    switch (operator) {
      case 'abs':
        return Math.abs(n);

      case 'floor':
        return Math.floor(n);

      case 'ceiling':
        return Math.ceil(n);

      case 'sqrt':
        return Math.sqrt(n);

      case 'sin':
        return Math.round(Math.sin(Math.PI * n / 180) * 1e10) / 1e10;

      case 'cos':
        return Math.round(Math.cos(Math.PI * n / 180) * 1e10) / 1e10;

      case 'tan':
        return MathUtil.tan(n);

      case 'asin':
        return Math.asin(n) * 180 / Math.PI;

      case 'acos':
        return Math.acos(n) * 180 / Math.PI;

      case 'atan':
        return Math.atan(n) * 180 / Math.PI;

      case 'ln':
        return Math.log(n);

      case 'log':
        return Math.log(n) / Math.LN10;

      case 'e ^':
        return Math.exp(n);

      case '10 ^':
        return Math.pow(10, n);
    }

    return 0;
  }

  advlog(args) {
    return Math.log(Cast.toNumber(args.NUM2)) / Math.log(Cast.toNumber(args.NUM1));
  }

}

module.exports = Scratch3OperatorsBlocks;

/***/ }),

/***/ "./src/blocks/scratch3_procedures.js":
/*!*******************************************!*\
  !*** ./src/blocks/scratch3_procedures.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

class Scratch3ProcedureBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      procedures_definition: this.definition,
      procedures_call: this.call,
      argument_reporter_string_number: this.argumentReporterStringNumber,
      argument_reporter_boolean: this.argumentReporterBoolean
    };
  }

  definition() {// No-op: execute the blocks.
  }

  call(args, util) {
    if (!util.stackFrame.executed) {
      const procedureCode = args.mutation.proccode;
      const paramNamesIdsAndDefaults = util.getProcedureParamNamesIdsAndDefaults(procedureCode); // If null, procedure could not be found, which can happen if custom
      // block is dragged between sprites without the definition.
      // Match Scratch 2.0 behavior and noop.

      if (paramNamesIdsAndDefaults === null) {
        return;
      }

      const [paramNames, paramIds, paramDefaults] = paramNamesIdsAndDefaults; // Initialize params for the current stackFrame to {}, even if the procedure does
      // not take any arguments. This is so that `getParam` down the line does not look
      // at earlier stack frames for the values of a given parameter (#1729)

      util.initParams();

      for (let i = 0; i < paramIds.length; i++) {
        if (args.hasOwnProperty(paramIds[i])) {
          util.pushParam(paramNames[i], args[paramIds[i]]);
        } else {
          util.pushParam(paramNames[i], paramDefaults[i]);
        }
      }

      util.stackFrame.executed = true;
      util.startProcedure(procedureCode);
    }
  }

  argumentReporterStringNumber(args, util) {
    const value = util.getParam(args.VALUE);

    if (value === null) {
      // tw: support legacy block
      if (String(args.VALUE).toLowerCase() === 'last key pressed') {
        return util.ioQuery('keyboard', 'getLastKeyPressed');
      } // When the parameter is not found in the most recent procedure
      // call, the default is always 0.


      return 0;
    }

    return value;
  }

  argumentReporterBoolean(args, util) {
    const value = util.getParam(args.VALUE);

    if (value === null) {
      // tw: implement is compiled? and is turbowarp?
      const lowercaseValue = String(args.VALUE).toLowerCase();

      if (util.target.runtime.compilerOptions.enabled && lowercaseValue === 'is compiled?') {
        return true;
      }

      if (lowercaseValue === 'is turbowarp?' || lowercaseValue === 'is penguinmod or turbowarp?') {
        return true;
      } // When the parameter is not found in the most recent procedure
      // call, the default is always 0.


      return 0;
    }

    return value;
  }

}

module.exports = Scratch3ProcedureBlocks;

/***/ }),

/***/ "./src/blocks/scratch3_sensing.js":
/*!****************************************!*\
  !*** ./src/blocks/scratch3_sensing.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Cast = __webpack_require__(/*! ../util/cast */ "./src/util/cast.js");

const Timer = __webpack_require__(/*! ../util/timer */ "./src/util/timer.js");

const getMonitorIdForBlockWithArgs = __webpack_require__(/*! ../util/get-monitor-id */ "./src/util/get-monitor-id.js");

class Scratch3SensingBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    /**
     * The "answer" block value.
     * @type {string}
     */

    this._answer = ''; // used by compiler

    /**
     * The timer utility.
     * @type {Timer}
     */

    this._timer = new Timer();
    /**
     * The stored microphone loudness measurement.
     * @type {number}
     */

    this._cachedLoudness = -1;
    /**
     * The time of the most recent microphone loudness measurement.
     * @type {number}
     */

    this._cachedLoudnessTimestamp = 0;
    /**
     * The list of queued questions and respective `resolve` callbacks.
     * @type {!Array}
     */

    this._questionList = [];
    this.runtime.on('ANSWER', this._onAnswer.bind(this));
    this.runtime.on('PROJECT_START', this._resetAnswer.bind(this));
    this.runtime.on('PROJECT_STOP_ALL', this._clearAllQuestions.bind(this));
    this.runtime.on('STOP_FOR_TARGET', this._clearTargetQuestions.bind(this));
    this.runtime.on('RUNTIME_DISPOSED', this._resetAnswer.bind(this));
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      sensing_touchingobject: this.touchingObject,
      sensing_touchingcolor: this.touchingColor,
      sensing_coloristouchingcolor: this.colorTouchingColor,
      sensing_distanceto: this.distanceTo,
      sensing_timer: this.getTimer,
      sensing_resettimer: this.resetTimer,
      sensing_of: this.getAttributeOf,
      sensing_mousex: this.getMouseX,
      sensing_mousey: this.getMouseY,
      sensing_setdragmode: this.setDragMode,
      sensing_mousedown: this.getMouseDown,
      sensing_keypressed: this.getKeyPressed,
      sensing_current: this.current,
      sensing_dayssince2000: this.daysSince2000,
      sensing_loudness: this.getLoudness,
      sensing_loud: this.isLoud,
      sensing_askandwait: this.askAndWait,
      sensing_answer: this.getAnswer,
      sensing_username: this.getUsername,
      sensing_userid: () => {} // legacy no-op block

    };
  }

  getMonitored() {
    return {
      sensing_answer: {
        getId: () => 'answer'
      },
      sensing_loudness: {
        getId: () => 'loudness'
      },
      sensing_timer: {
        getId: () => 'timer'
      },
      sensing_current: {
        // This is different from the default toolbox xml id in order to support
        // importing multiple monitors from the same opcode from sb2 files,
        // something that is not currently supported in scratch 3.
        getId: (_, fields) => getMonitorIdForBlockWithArgs('current', fields) // _${param}`

      }
    };
  }

  _onAnswer(answer) {
    this._answer = answer;

    const questionObj = this._questionList.shift();

    if (questionObj) {
      const [_question, resolve, target, wasVisible, wasStage] = questionObj; // If the target was visible when asked, hide the say bubble unless the target was the stage.

      if (wasVisible && !wasStage) {
        this.runtime.emit('SAY', target, 'say', '');
      }

      resolve();

      this._askNextQuestion();
    }
  }

  _resetAnswer() {
    this._answer = '';
  }

  _enqueueAsk(question, resolve, target, wasVisible, wasStage) {
    this._questionList.push([question, resolve, target, wasVisible, wasStage]);
  }

  _askNextQuestion() {
    if (this._questionList.length > 0) {
      const [question, _resolve, target, wasVisible, wasStage] = this._questionList[0]; // If the target is visible, emit a blank question and use the
      // say event to trigger a bubble unless the target was the stage.

      if (wasVisible && !wasStage) {
        this.runtime.emit('SAY', target, 'say', question);
        this.runtime.emit('QUESTION', '');
      } else {
        this.runtime.emit('QUESTION', question);
      }
    }
  }

  _clearAllQuestions() {
    this._questionList = [];
    this.runtime.emit('QUESTION', null);
  }

  _clearTargetQuestions(stopTarget) {
    const currentlyAsking = this._questionList.length > 0 && this._questionList[0][2] === stopTarget;
    this._questionList = this._questionList.filter(question => question[2] !== stopTarget);

    if (currentlyAsking) {
      this.runtime.emit('SAY', stopTarget, 'say', '');

      if (this._questionList.length > 0) {
        this._askNextQuestion();
      } else {
        this.runtime.emit('QUESTION', null);
      }
    }
  }

  askAndWait(args, util) {
    const _target = util.target;
    return new Promise(resolve => {
      const isQuestionAsked = this._questionList.length > 0;

      this._enqueueAsk(String(args.QUESTION), resolve, _target, _target.visible, _target.isStage);

      if (!isQuestionAsked) {
        this._askNextQuestion();
      }
    });
  }

  getAnswer() {
    return this._answer;
  }

  touchingObject(args, util) {
    return util.target.isTouchingObject(args.TOUCHINGOBJECTMENU);
  }

  touchingColor(args, util) {
    const color = Cast.toRgbColorList(args.COLOR);
    return util.target.isTouchingColor(color);
  }

  colorTouchingColor(args, util) {
    const maskColor = Cast.toRgbColorList(args.COLOR);
    const targetColor = Cast.toRgbColorList(args.COLOR2);
    return util.target.colorIsTouchingColor(targetColor, maskColor);
  }

  distanceTo(args, util) {
    if (util.target.isStage) return 10000;
    let targetX = 0;
    let targetY = 0;

    if (args.DISTANCETOMENU === '_mouse_') {
      targetX = util.ioQuery('mouse', 'getScratchX');
      targetY = util.ioQuery('mouse', 'getScratchY');
    } else {
      args.DISTANCETOMENU = Cast.toString(args.DISTANCETOMENU);
      const distTarget = this.runtime.getSpriteTargetByName(args.DISTANCETOMENU);
      if (!distTarget) return 10000;
      targetX = distTarget.x;
      targetY = distTarget.y;
    }

    const dx = util.target.x - targetX;
    const dy = util.target.y - targetY;
    return Math.sqrt(dx * dx + dy * dy);
  }

  setDragMode(args, util) {
    util.target.setDraggable(args.DRAG_MODE === 'draggable');
  }

  getTimer(args, util) {
    return util.ioQuery('clock', 'projectTimer');
  }

  resetTimer(args, util) {
    util.ioQuery('clock', 'resetProjectTimer');
  }

  getMouseX(args, util) {
    return util.ioQuery('mouse', 'getScratchX');
  }

  getMouseY(args, util) {
    return util.ioQuery('mouse', 'getScratchY');
  }

  getMouseDown(args, util) {
    return util.ioQuery('mouse', 'getIsDown');
  }

  current(args) {
    const menuOption = Cast.toString(args.CURRENTMENU).toLowerCase();
    const date = new Date();

    switch (menuOption) {
      case 'year':
        return date.getFullYear();

      case 'month':
        return date.getMonth() + 1;
      // getMonth is zero-based

      case 'date':
        return date.getDate();

      case 'dayofweek':
        return date.getDay() + 1;
      // getDay is zero-based, Sun=0

      case 'hour':
        return date.getHours();

      case 'minute':
        return date.getMinutes();

      case 'second':
        return date.getSeconds();
    }

    return 0;
  }

  getKeyPressed(args, util) {
    return util.ioQuery('keyboard', 'getKeyIsDown', [args.KEY_OPTION]);
  }

  daysSince2000() {
    const msPerDay = 24 * 60 * 60 * 1000;
    const start = new Date(2000, 0, 1); // Months are 0-indexed.

    const today = new Date();
    const dstAdjust = today.getTimezoneOffset() - start.getTimezoneOffset();
    let mSecsSinceStart = today.valueOf() - start.valueOf();
    mSecsSinceStart += (today.getTimezoneOffset() - dstAdjust) * 60 * 1000;
    return mSecsSinceStart / msPerDay;
  }

  getLoudness() {
    if (typeof this.runtime.audioEngine === 'undefined') return -1;
    if (this.runtime.currentStepTime === null) return -1; // Only measure loudness once per step

    const timeSinceLoudness = this._timer.time() - this._cachedLoudnessTimestamp;

    if (timeSinceLoudness < this.runtime.currentStepTime) {
      return this._cachedLoudness;
    }

    this._cachedLoudnessTimestamp = this._timer.time();
    this._cachedLoudness = this.runtime.audioEngine.getLoudness();
    return this._cachedLoudness;
  }

  isLoud() {
    return this.getLoudness() > 10;
  }

  getAttributeOf(args) {
    let attrTarget;

    if (args.OBJECT === '_stage_') {
      attrTarget = this.runtime.getTargetForStage();
    } else {
      args.OBJECT = Cast.toString(args.OBJECT);
      attrTarget = this.runtime.getSpriteTargetByName(args.OBJECT);
    } // attrTarget can be undefined if the target does not exist
    // (e.g. single sprite uploaded from larger project referencing
    // another sprite that wasn't uploaded)


    if (!attrTarget) return 0; // Generic attributes

    if (attrTarget.isStage) {
      switch (args.PROPERTY) {
        // Scratch 1.4 support
        case 'background #':
          return attrTarget.currentCostume + 1;

        case 'backdrop #':
          return attrTarget.currentCostume + 1;

        case 'backdrop name':
          return attrTarget.getCostumes()[attrTarget.currentCostume].name;

        case 'volume':
          return attrTarget.volume;
      }
    } else {
      switch (args.PROPERTY) {
        case 'x position':
          return attrTarget.x;

        case 'y position':
          return attrTarget.y;

        case 'direction':
          return attrTarget.direction;

        case 'costume #':
          return attrTarget.currentCostume + 1;

        case 'costume name':
          return attrTarget.getCostumes()[attrTarget.currentCostume].name;

        case 'size':
          return attrTarget.size;

        case 'volume':
          return attrTarget.volume;
      }
    } // Target variables.


    const varName = args.PROPERTY;
    const variable = attrTarget.lookupVariableByNameAndType(varName, '', true);

    if (variable) {
      return variable.value;
    } // Otherwise, 0


    return 0;
  }

  getUsername(args, util) {
    return util.ioQuery('userData', 'getUsername');
  }

}

module.exports = Scratch3SensingBlocks;

/***/ }),

/***/ "./src/blocks/scratch3_sound.js":
/*!**************************************!*\
  !*** ./src/blocks/scratch3_sound.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const MathUtil = __webpack_require__(/*! ../util/math-util */ "./src/util/math-util.js");

const Cast = __webpack_require__(/*! ../util/cast */ "./src/util/cast.js");

const Clone = __webpack_require__(/*! ../util/clone */ "./src/util/clone.js");
/**
 * Occluded boolean value to make its use more understandable.
 * @const {boolean}
 */


const STORE_WAITING = true;

class Scratch3SoundBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    this.waitingSounds = {}; // Clear sound effects on green flag and stop button events.

    this.stopAllSounds = this.stopAllSounds.bind(this);
    this._stopWaitingSoundsForTarget = this._stopWaitingSoundsForTarget.bind(this);
    this._clearEffectsForAllTargets = this._clearEffectsForAllTargets.bind(this);

    if (this.runtime) {
      this.runtime.on('PROJECT_STOP_ALL', this.stopAllSounds);
      this.runtime.on('PROJECT_STOP_ALL', this._clearEffectsForAllTargets);
      this.runtime.on('STOP_FOR_TARGET', this._stopWaitingSoundsForTarget);
      this.runtime.on('PROJECT_START', this._clearEffectsForAllTargets);
    }

    this._onTargetCreated = this._onTargetCreated.bind(this);

    if (this.runtime) {
      runtime.on('targetWasCreated', this._onTargetCreated);
    }
  }
  /**
   * The key to load & store a target's sound-related state.
   * @type {string}
   */


  static get STATE_KEY() {
    return 'Scratch.sound';
  }
  /**
   * The default sound-related state, to be used when a target has no existing sound state.
   * @type {SoundState}
   */


  static get DEFAULT_SOUND_STATE() {
    return {
      effects: {
        pitch: 0,
        pan: 0
      }
    };
  }
  /**
   * The minimum and maximum MIDI note numbers, for clamping the input to play note.
   * @type {{min: number, max: number}}
   */


  static get MIDI_NOTE_RANGE() {
    return {
      min: 36,
      max: 96
    }; // C2 to C7
  }
  /**
   * The minimum and maximum beat values, for clamping the duration of play note, play drum and rest.
   * 100 beats at the default tempo of 60bpm is 100 seconds.
   * @type {{min: number, max: number}}
   */


  static get BEAT_RANGE() {
    return {
      min: 0,
      max: 100
    };
  }
  /** The minimum and maximum tempo values, in bpm.
   * @type {{min: number, max: number}}
   */


  static get TEMPO_RANGE() {
    return {
      min: 20,
      max: 500
    };
  }
  /** The minimum and maximum values for each sound effect.
   * @type {{effect:{min: number, max: number}}}
   */


  static get EFFECT_RANGE() {
    return {
      pitch: {
        min: -360,
        max: 360
      },
      // -3 to 3 octaves
      pan: {
        min: -100,
        max: 100
      } // 100% left to 100% right

    };
  }
  /** The minimum and maximum values for sound effects when miscellaneous limits are removed. */


  static get LARGER_EFFECT_RANGE() {
    return {
      // scratch-audio throws if pitch is too big because some math results in Infinity
      pitch: {
        min: -1000,
        max: 1000
      },
      // No reason for these to go beyond 100
      pan: {
        min: -100,
        max: 100
      }
    };
  }
  /**
   * @param {Target} target - collect sound state for this target.
   * @returns {SoundState} the mutable sound state associated with that target. This will be created if necessary.
   * @private
   */


  _getSoundState(target) {
    let soundState = target.getCustomState(Scratch3SoundBlocks.STATE_KEY);

    if (!soundState) {
      soundState = Clone.simple(Scratch3SoundBlocks.DEFAULT_SOUND_STATE);
      target.setCustomState(Scratch3SoundBlocks.STATE_KEY, soundState);
      target.soundEffects = soundState.effects;
    }

    return soundState;
  }
  /**
   * When a Target is cloned, clone the sound state.
   * @param {Target} newTarget - the newly created target.
   * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
   * @listens Runtime#event:targetWasCreated
   * @private
   */


  _onTargetCreated(newTarget, sourceTarget) {
    if (sourceTarget) {
      const soundState = sourceTarget.getCustomState(Scratch3SoundBlocks.STATE_KEY);

      if (soundState && newTarget) {
        newTarget.setCustomState(Scratch3SoundBlocks.STATE_KEY, Clone.simple(soundState));

        this._syncEffectsForTarget(newTarget);
      }
    }
  }
  /**
   * Retrieve the block primitives implemented by this package.
   * @return {object.<string, Function>} Mapping of opcode to Function.
   */


  getPrimitives() {
    return {
      sound_play: this.playSound,
      sound_playuntildone: this.playSoundAndWait,
      sound_stopallsounds: this.stopAllSounds,
      sound_seteffectto: this.setEffect,
      sound_changeeffectby: this.changeEffect,
      sound_cleareffects: this.clearEffects,
      sound_sounds_menu: this.soundsMenu,
      sound_beats_menu: this.beatsMenu,
      sound_effects_menu: this.effectsMenu,
      sound_setvolumeto: this.setVolume,
      sound_changevolumeby: this.changeVolume,
      sound_volume: this.getVolume
    };
  }

  getMonitored() {
    return {
      sound_volume: {
        isSpriteSpecific: true,
        getId: targetId => "".concat(targetId, "_volume")
      }
    };
  }

  playSound(args, util) {
    // Don't return the promise, it's the only difference for AndWait
    this._playSound(args, util);
  }

  playSoundAndWait(args, util) {
    return this._playSound(args, util, STORE_WAITING);
  }

  _playSound(args, util, storeWaiting) {
    const index = this._getSoundIndex(args.SOUND_MENU, util);

    if (index >= 0) {
      const {
        target
      } = util;
      const {
        sprite
      } = target;
      const {
        soundId
      } = sprite.sounds[index];

      if (sprite.soundBank) {
        if (storeWaiting === STORE_WAITING) {
          this._addWaitingSound(target.id, soundId);
        } else {
          this._removeWaitingSound(target.id, soundId);
        }

        return sprite.soundBank.playSound(target, soundId);
      }
    }
  }

  _addWaitingSound(targetId, soundId) {
    if (!this.waitingSounds[targetId]) {
      this.waitingSounds[targetId] = new Set();
    }

    this.waitingSounds[targetId].add(soundId);
  }

  _removeWaitingSound(targetId, soundId) {
    if (!this.waitingSounds[targetId]) {
      return;
    }

    this.waitingSounds[targetId].delete(soundId);
  }

  _getSoundIndex(soundName, util) {
    // if the sprite has no sounds, return -1
    const len = util.target.sprite.sounds.length;

    if (len === 0) {
      return -1;
    } // look up by name first


    const index = this.getSoundIndexByName(soundName, util);

    if (index !== -1) {
      return index;
    } // then try using the sound name as a 1-indexed index


    const oneIndexedIndex = parseInt(soundName, 10);

    if (!isNaN(oneIndexedIndex)) {
      return MathUtil.wrapClamp(oneIndexedIndex - 1, 0, len - 1);
    } // could not be found as a name or converted to index, return -1


    return -1;
  }

  getSoundIndexByName(soundName, util) {
    const sounds = util.target.sprite.sounds;

    for (let i = 0; i < sounds.length; i++) {
      if (sounds[i].name === soundName) {
        return i;
      }
    } // if there is no sound by that name, return -1


    return -1;
  }

  stopAllSounds() {
    if (this.runtime.targets === null) return;
    const allTargets = this.runtime.targets;

    for (let i = 0; i < allTargets.length; i++) {
      this._stopAllSoundsForTarget(allTargets[i]);
    }
  }

  _stopAllSoundsForTarget(target) {
    if (target.sprite.soundBank) {
      target.sprite.soundBank.stopAllSounds(target);

      if (this.waitingSounds[target.id]) {
        this.waitingSounds[target.id].clear();
      }
    }
  }

  _stopWaitingSoundsForTarget(target) {
    if (target.sprite.soundBank) {
      if (this.waitingSounds[target.id]) {
        for (const soundId of this.waitingSounds[target.id].values()) {
          target.sprite.soundBank.stop(target, soundId);
        }

        this.waitingSounds[target.id].clear();
      }
    }
  }

  setEffect(args, util) {
    return this._updateEffect(args, util, false);
  }

  changeEffect(args, util) {
    return this._updateEffect(args, util, true);
  }

  _updateEffect(args, util, change) {
    const effect = Cast.toString(args.EFFECT).toLowerCase();
    const value = Cast.toNumber(args.VALUE);

    const soundState = this._getSoundState(util.target);

    if (!soundState.effects.hasOwnProperty(effect)) return;

    if (change) {
      soundState.effects[effect] += value;
    } else {
      soundState.effects[effect] = value;
    }

    const miscLimits = this.runtime.runtimeOptions.miscLimits;
    const {
      min,
      max
    } = miscLimits ? Scratch3SoundBlocks.EFFECT_RANGE[effect] : Scratch3SoundBlocks.LARGER_EFFECT_RANGE[effect];
    soundState.effects[effect] = MathUtil.clamp(soundState.effects[effect], min, max);

    this._syncEffectsForTarget(util.target);

    if (miscLimits) {
      // Yield until the next tick.
      return Promise.resolve();
    } // Requesting a redraw makes sure that "forever: change pitch by 1" still work but without
    // yielding unnecessarily in other cases


    this.runtime.requestRedraw();
  }

  _syncEffectsForTarget(target) {
    if (!target || !target.sprite.soundBank) return;
    target.soundEffects = this._getSoundState(target).effects;
    target.sprite.soundBank.setEffects(target);
  }

  clearEffects(args, util) {
    this._clearEffectsForTarget(util.target);
  }

  _clearEffectsForTarget(target) {
    const soundState = this._getSoundState(target);

    for (const effect in soundState.effects) {
      if (!soundState.effects.hasOwnProperty(effect)) continue;
      soundState.effects[effect] = 0;
    }

    this._syncEffectsForTarget(target);
  }

  _clearEffectsForAllTargets() {
    if (this.runtime.targets === null) return;
    const allTargets = this.runtime.targets;

    for (let i = 0; i < allTargets.length; i++) {
      this._clearEffectsForTarget(allTargets[i]);
    }
  }

  setVolume(args, util) {
    const volume = Cast.toNumber(args.VOLUME);
    return this._updateVolume(volume, util);
  }

  changeVolume(args, util) {
    const volume = Cast.toNumber(args.VOLUME) + util.target.volume;
    return this._updateVolume(volume, util);
  }

  _updateVolume(volume, util) {
    volume = MathUtil.clamp(volume, 0, 100);
    util.target.volume = volume;

    this._syncEffectsForTarget(util.target);

    if (this.runtime.runtimeOptions.miscLimits) {
      // Yield until the next tick.
      return Promise.resolve();
    }

    this.runtime.requestRedraw();
  }

  getVolume(args, util) {
    return util.target.volume;
  }

  soundsMenu(args) {
    return args.SOUND_MENU;
  }

  beatsMenu(args) {
    return args.BEATS;
  }

  effectsMenu(args) {
    return args.EFFECT;
  }

}

module.exports = Scratch3SoundBlocks;

/***/ }),

/***/ "./src/compiler/compat-block-utility.js":
/*!**********************************************!*\
  !*** ./src/compiler/compat-block-utility.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const BlockUtility = __webpack_require__(/*! ../engine/block-utility */ "./src/engine/block-utility.js");

class CompatibilityLayerBlockUtility extends BlockUtility {
  // Branching operations are not supported.
  startBranch() {
    throw new Error('startBranch is not supported by this BlockUtility');
  }

  startProcedure() {
    throw new Error('startProcedure is not supported by this BlockUtility');
  } // Parameters are not used by compiled scripts.


  initParams() {
    throw new Error('initParams is not supported by this BlockUtility');
  }

  pushParam() {
    throw new Error('pushParam is not supported by this BlockUtility');
  }

  getParam() {
    throw new Error('getParam is not supported by this BlockUtility');
  }

} // Export a single instance to be reused.


module.exports = new CompatibilityLayerBlockUtility();

/***/ }),

/***/ "./src/compiler/compat-blocks.js":
/*!***************************************!*\
  !*** ./src/compiler/compat-blocks.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @fileoverview List of blocks to be supported in the compiler compatibility layer.
 * This is only for native blocks. Extensions should not be listed here.
 */
// Please keep these lists alphabetical.
const stacked = ['control_clear_counter', 'control_incr_counter', 'looks_changestretchby', 'looks_hideallsprites', 'looks_say', 'looks_sayforsecs', 'looks_setstretchto', 'looks_switchbackdroptoandwait', 'looks_think', 'looks_thinkforsecs', 'motion_align_scene', 'motion_glidesecstoxy', 'motion_glideto', 'motion_goto', 'motion_pointtowards', 'motion_scroll_right', 'motion_scroll_up', 'sensing_askandwait', 'sensing_setdragmode', 'sound_changeeffectby', 'sound_changevolumeby', 'sound_cleareffects', 'sound_play', 'sound_playuntildone', 'sound_seteffectto', 'sound_setvolumeto', 'sound_stopallsounds'];
const inputs = ['control_get_counter', 'motion_xscroll', 'motion_yscroll', 'sensing_loud', 'sensing_loudness', 'sensing_userid', 'sound_volume'];
module.exports = {
  stacked,
  inputs
};

/***/ }),

/***/ "./src/compiler/compile.js":
/*!*********************************!*\
  !*** ./src/compiler/compile.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const IRGenerator = __webpack_require__(/*! ./irgen */ "./src/compiler/irgen.js");

const JSGenerator = __webpack_require__(/*! ./jsgen */ "./src/compiler/jsgen.js");

const compile = thread => {
  const irGenerator = new IRGenerator(thread);
  const ir = irGenerator.generate();
  const procedures = {};
  const target = thread.target;

  const compileScript = script => {
    if (script.cachedCompileResult) {
      return script.cachedCompileResult;
    }

    const compiler = new JSGenerator(script, ir, target);
    const result = compiler.compile();
    script.cachedCompileResult = result;
    return result;
  };

  const entry = compileScript(ir.entry);

  for (const procedureVariant of Object.keys(ir.procedures)) {
    const procedureData = ir.procedures[procedureVariant];
    const procedureTree = compileScript(procedureData);
    procedures[procedureVariant] = procedureTree;
  }

  return {
    startingFunction: entry,
    procedures
  };
};

module.exports = compile;

/***/ }),

/***/ "./src/compiler/environment.js":
/*!*************************************!*\
  !*** ./src/compiler/environment.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* eslint-disable no-eval */

/**
 * @returns {boolean} true if the nullish coalescing operator (x ?? y) is supported.
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator
 */
const supportsNullishCoalescing = () => {
  try {
    // eslint-disable-next-line no-unused-vars
    const fn = new Function('undefined ?? 3'); // if function construction succeeds, the browser understood the syntax.

    return true;
  } catch (e) {
    return false;
  }
};

module.exports = {
  supportsNullishCoalescing: supportsNullishCoalescing()
};

/***/ }),

/***/ "./src/compiler/intermediate.js":
/*!**************************************!*\
  !*** ./src/compiler/intermediate.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @fileoverview Common intermediates shared amongst parts of the compiler.
 */

/**
 * An IntermediateScript describes a single script.
 * Scripts do not necessarily have hats.
 */
class IntermediateScript {
  constructor() {
    /**
     * The ID of the top block of this script.
     * @type {string}
     */
    this.topBlockId = null;
    /**
     * List of nodes that make up this script.
     * @type {Array|null}
     */

    this.stack = null;
    /**
     * Whether this script is a procedure.
     * @type {boolean}
     */

    this.isProcedure = false;
    /**
     * This procedure's code, if any.
     * @type {string}
     */

    this.procedureCode = '';
    /**
     * List of names of arguments accepted by this function, if it is a procedure.
     * @type {string[]}
     */

    this.arguments = [];
    /**
     * Whether this script should be run in warp mode.
     * @type {boolean}
     */

    this.isWarp = false;
    /**
     * Whether this script can `yield`
     * If false, this script will be compiled as a regular JavaScript function (function)
     * If true, this script will be compiled as a generator function (function*)
     * @type {boolean}
     */

    this.yields = true;
    /**
     * Whether this script should use the "warp timer"
     * @type {boolean}
     */

    this.warpTimer = false;
    /**
     * List of procedure IDs that this script needs.
     * @readonly
     */

    this.dependedProcedures = [];
    /**
     * Cached result of compiling this script.
     * @type {Function|null}
     */

    this.cachedCompileResult = null;
  }

}
/**
 * An IntermediateRepresentation contains scripts.
 */


class IntermediateRepresentation {
  constructor() {
    /**
     * The entry point of this IR.
     * @type {IntermediateScript}
     */
    this.entry = null;
    /**
     * Maps procedure variants to their intermediate script.
     * @type {Object.<string, IntermediateScript>}
     */

    this.procedures = {};
  }

}

module.exports = {
  IntermediateScript,
  IntermediateRepresentation
};

/***/ }),

/***/ "./src/compiler/irgen.js":
/*!*******************************!*\
  !*** ./src/compiler/irgen.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Cast = __webpack_require__(/*! ../util/cast */ "./src/util/cast.js");

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");

const BlockType = __webpack_require__(/*! ../extension-support/block-type */ "./src/extension-support/block-type.js");

const Variable = __webpack_require__(/*! ../engine/variable */ "./src/engine/variable.js");

const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");

const {
  IntermediateScript,
  IntermediateRepresentation
} = __webpack_require__(/*! ./intermediate */ "./src/compiler/intermediate.js");

const compatBlocks = __webpack_require__(/*! ./compat-blocks */ "./src/compiler/compat-blocks.js");
/**
 * @fileoverview Generate intermediate representations from Scratch blocks.
 */


const SCALAR_TYPE = '';
const LIST_TYPE = 'list';
/**
 * @typedef {Object.<string, *>} Node
 * @property {string} kind
 */

/**
 * Create a variable codegen object.
 * @param {'target'|'stage'} scope The scope of this variable -- which object owns it.
 * @param {import('../engine/variable.js')} varObj The Scratch Variable
 * @returns {*} A variable codegen object.
 */

const createVariableData = (scope, varObj) => ({
  scope,
  id: varObj.id,
  name: varObj.name,
  isCloud: varObj.isCloud
});
/**
 * @param {string} code
 * @param {boolean} warp
 * @returns {string}
 */


const generateProcedureVariant = (code, warp) => {
  if (warp) {
    return "W".concat(code);
  }

  return "Z".concat(code);
};
/**
 * @param {string} variant Variant generated by generateProcedureVariant()
 * @returns {string} original procedure code
 */


const parseProcedureCode = variant => variant.substring(1);
/**
 * @param {string} variant Variant generated by generateProcedureVariant()
 * @returns {boolean} true if warp enabled
 */


const parseIsWarp = variant => variant.charAt(0) === 'W';

class ScriptTreeGenerator {
  constructor(thread) {
    /** @private */
    this.thread = thread;
    /** @private */

    this.target = thread.target;
    /** @private */

    this.blocks = thread.blockContainer;
    /** @private */

    this.runtime = this.target.runtime;
    /** @private */

    this.stage = this.runtime.getTargetForStage();
    /**
     * This script's intermediate representation.
     */

    this.script = new IntermediateScript();
    this.script.warpTimer = this.target.runtime.compilerOptions.warpTimer;
    /**
     * Cache of variable ID to variable data object.
     * @type {Object.<string, object>}
     * @private
     */

    this.variableCache = {};
    this.usesTimer = false;
  }

  setProcedureVariant(procedureVariant) {
    const procedureCode = parseProcedureCode(procedureVariant);
    this.script.procedureCode = procedureCode;
    this.script.isProcedure = true;
    this.script.yields = false;
    const paramNamesIdsAndDefaults = this.blocks.getProcedureParamNamesIdsAndDefaults(procedureCode);

    if (paramNamesIdsAndDefaults === null) {
      throw new Error("IR: cannot find procedure: ".concat(procedureVariant));
    }

    const [paramNames, _paramIds, _paramDefaults] = paramNamesIdsAndDefaults;
    this.script.arguments = paramNames;
  }

  enableWarp() {
    this.script.isWarp = true;
  }

  getBlockById(blockId) {
    // Flyout blocks are stored in a special container.
    return this.blocks.getBlock(blockId) || this.blocks.runtime.flyoutBlocks.getBlock(blockId);
  }

  getBlockInfo(fullOpcode) {
    const [category, opcode] = StringUtil.splitFirst(fullOpcode, '_');

    if (!category || !opcode) {
      return null;
    }

    const categoryInfo = this.runtime._blockInfo.find(ci => ci.id === category);

    if (!categoryInfo) {
      return null;
    }

    const blockInfo = categoryInfo.blocks.find(b => b.info.opcode === opcode);

    if (!blockInfo) {
      return null;
    }

    return blockInfo;
  }
  /**
   * Descend into a child input of a block. (eg. the input STRING of "length of ( )")
   * @param {*} parentBlock The parent Scratch block that contains the input.
   * @param {string} inputName The name of the input to descend into.
   * @private
   * @returns {Node} Compiled input node for this input.
   */


  descendInputOfBlock(parentBlock, inputName) {
    const input = parentBlock.inputs[inputName];

    if (!input) {
      log.warn("IR: ".concat(parentBlock.opcode, ": missing input ").concat(inputName), parentBlock);
      return {
        kind: 'constant',
        value: 0
      };
    }

    const inputId = input.block;
    const block = this.getBlockById(inputId);

    if (!block) {
      log.warn("IR: ".concat(parentBlock.opcode, ": could not find input ").concat(inputName, " with ID ").concat(inputId));
      return {
        kind: 'constant',
        value: 0
      };
    }

    return this.descendInput(block);
  }
  /**
   * Descend into an input. (eg. "length of ( )")
   * @param {*} block The parent Scratch block input.
   * @private
   * @returns {Node} Compiled input node for this input.
   */


  descendInput(block) {
    switch (block.opcode) {
      case 'colour_picker':
        {
          const color = block.fields.COLOUR.value;
          const hex = color.substr(1);

          if (/^[0-9a-f]{6,8}$/.test(hex)) {
            return {
              kind: 'constant',
              value: Number.parseInt(hex, 16)
            };
          }

          return {
            kind: 'constant',
            value: color
          };
        }

      case 'math_angle':
      case 'math_integer':
      case 'math_number':
      case 'math_positive_number':
      case 'math_whole_number':
        return {
          kind: 'constant',
          value: block.fields.NUM.value
        };

      case 'text':
        return {
          kind: 'constant',
          value: block.fields.TEXT.value
        };

      case 'argument_reporter_string_number':
        {
          const name = block.fields.VALUE.value; // lastIndexOf because multiple parameters with the same name will use the value of the last definition

          const index = this.script.arguments.lastIndexOf(name);

          if (index === -1) {
            // Legacy support
            if (name.toLowerCase() === 'last key pressed') {
              return {
                kind: 'tw.lastKeyPressed'
              };
            }
          }

          if (index === -1) {
            return {
              kind: 'constant',
              value: 0
            };
          }

          return {
            kind: 'args.stringNumber',
            index: index
          };
        }

      case 'argument_reporter_boolean':
        {
          // see argument_reporter_string_number above
          const name = block.fields.VALUE.value;
          const index = this.script.arguments.lastIndexOf(name);

          if (index === -1) {
            if (name.toLowerCase() === 'is compiled?' || name.toLowerCase() === 'is turbowarp?' || name.toLowerCase() === 'is penguinmod or turbowarp?') {
              return {
                kind: 'constant',
                value: true
              };
            }

            return {
              kind: 'constant',
              value: 0
            };
          }

          return {
            kind: 'args.boolean',
            index: index
          };
        }

      case 'data_variable':
        return {
          kind: 'var.get',
          variable: this.descendVariable(block, 'VARIABLE', SCALAR_TYPE)
        };

      case 'data_itemoflist':
        return {
          kind: 'list.get',
          list: this.descendVariable(block, 'LIST', LIST_TYPE),
          index: this.descendInputOfBlock(block, 'INDEX')
        };

      case 'data_lengthoflist':
        return {
          kind: 'list.length',
          list: this.descendVariable(block, 'LIST', LIST_TYPE)
        };

      case 'data_listcontainsitem':
        return {
          kind: 'list.contains',
          list: this.descendVariable(block, 'LIST', LIST_TYPE),
          item: this.descendInputOfBlock(block, 'ITEM')
        };

      case 'data_itemnumoflist':
        return {
          kind: 'list.indexOf',
          list: this.descendVariable(block, 'LIST', LIST_TYPE),
          item: this.descendInputOfBlock(block, 'ITEM')
        };

      case 'data_listcontents':
        return {
          kind: 'list.contents',
          list: this.descendVariable(block, 'LIST', LIST_TYPE)
        };

      case 'event_broadcast_menu':
        {
          const broadcastOption = block.fields.BROADCAST_OPTION;
          const broadcastVariable = this.target.lookupBroadcastMsg(broadcastOption.id, broadcastOption.value); // TODO: empty string probably isn't the correct fallback

          const broadcastName = broadcastVariable ? broadcastVariable.name : '';
          return {
            kind: 'constant',
            value: broadcastName
          };
        }

      case 'looks_backdropnumbername':
        if (block.fields.NUMBER_NAME.value === 'number') {
          return {
            kind: 'looks.backdropNumber'
          };
        }

        return {
          kind: 'looks.backdropName'
        };

      case 'looks_costumenumbername':
        if (block.fields.NUMBER_NAME.value === 'number') {
          return {
            kind: 'looks.costumeNumber'
          };
        }

        return {
          kind: 'looks.costumeName'
        };

      case 'looks_size':
        return {
          kind: 'looks.size'
        };

      case 'motion_direction':
        return {
          kind: 'motion.direction'
        };

      case 'motion_xposition':
        return {
          kind: 'motion.x'
        };

      case 'motion_yposition':
        return {
          kind: 'motion.y'
        };

      case 'operator_add':
        return {
          kind: 'op.add',
          left: this.descendInputOfBlock(block, 'NUM1'),
          right: this.descendInputOfBlock(block, 'NUM2')
        };

      case 'operator_and':
        return {
          kind: 'op.and',
          left: this.descendInputOfBlock(block, 'OPERAND1'),
          right: this.descendInputOfBlock(block, 'OPERAND2')
        };

      case 'operator_contains':
        return {
          kind: 'op.contains',
          string: this.descendInputOfBlock(block, 'STRING1'),
          contains: this.descendInputOfBlock(block, 'STRING2')
        };

      case 'operator_divide':
        return {
          kind: 'op.divide',
          left: this.descendInputOfBlock(block, 'NUM1'),
          right: this.descendInputOfBlock(block, 'NUM2')
        };

      case 'operator_equals':
        return {
          kind: 'op.equals',
          left: this.descendInputOfBlock(block, 'OPERAND1'),
          right: this.descendInputOfBlock(block, 'OPERAND2')
        };

      case 'operator_gt':
        return {
          kind: 'op.greater',
          left: this.descendInputOfBlock(block, 'OPERAND1'),
          right: this.descendInputOfBlock(block, 'OPERAND2')
        };

      case 'operator_join':
        return {
          kind: 'op.join',
          left: this.descendInputOfBlock(block, 'STRING1'),
          right: this.descendInputOfBlock(block, 'STRING2')
        };

      case 'operator_length':
        return {
          kind: 'op.length',
          string: this.descendInputOfBlock(block, 'STRING')
        };

      case 'operator_letter_of':
        return {
          kind: 'op.letterOf',
          letter: this.descendInputOfBlock(block, 'LETTER'),
          string: this.descendInputOfBlock(block, 'STRING')
        };

      case 'operator_lt':
        return {
          kind: 'op.less',
          left: this.descendInputOfBlock(block, 'OPERAND1'),
          right: this.descendInputOfBlock(block, 'OPERAND2')
        };

      case 'operator_mathop':
        {
          const value = this.descendInputOfBlock(block, 'NUM');
          const operator = block.fields.OPERATOR.value.toLowerCase();

          switch (operator) {
            case 'abs':
              return {
                kind: 'op.abs',
                value
              };

            case 'floor':
              return {
                kind: 'op.floor',
                value
              };

            case 'ceiling':
              return {
                kind: 'op.ceiling',
                value
              };

            case 'sqrt':
              return {
                kind: 'op.sqrt',
                value
              };

            case 'sin':
              return {
                kind: 'op.sin',
                value
              };

            case 'cos':
              return {
                kind: 'op.cos',
                value
              };

            case 'tan':
              return {
                kind: 'op.tan',
                value
              };

            case 'asin':
              return {
                kind: 'op.asin',
                value
              };

            case 'acos':
              return {
                kind: 'op.acos',
                value
              };

            case 'atan':
              return {
                kind: 'op.atan',
                value
              };

            case 'ln':
              return {
                kind: 'op.ln',
                value
              };

            case 'log':
              return {
                kind: 'op.log',
                value
              };

            case 'e ^':
              return {
                kind: 'op.e^',
                value
              };

            case '10 ^':
              return {
                kind: 'op.10^',
                value
              };

            default:
              return {
                kind: 'constant',
                value: 0
              };
          }
        }

      case 'operator_advlog':
        return {
          kind: 'op.advlog',
          left: this.descendInputOfBlock(block, 'NUM1'),
          right: this.descendInputOfBlock(block, 'NUM2')
        };

      case 'operator_mod':
        return {
          kind: 'op.mod',
          left: this.descendInputOfBlock(block, 'NUM1'),
          right: this.descendInputOfBlock(block, 'NUM2')
        };

      case 'operator_multiply':
        return {
          kind: 'op.multiply',
          left: this.descendInputOfBlock(block, 'NUM1'),
          right: this.descendInputOfBlock(block, 'NUM2')
        };

      case 'operator_not':
        return {
          kind: 'op.not',
          operand: this.descendInputOfBlock(block, 'OPERAND')
        };

      case 'operator_or':
        return {
          kind: 'op.or',
          left: this.descendInputOfBlock(block, 'OPERAND1'),
          right: this.descendInputOfBlock(block, 'OPERAND2')
        };

      case 'operator_random':
        {
          const from = this.descendInputOfBlock(block, 'FROM');
          const to = this.descendInputOfBlock(block, 'TO'); // If both values are known at compile time, we can do some optimizations.
          // TODO: move optimizations to jsgen?

          if (from.kind === 'constant' && to.kind === 'constant') {
            const sFrom = from.value;
            const sTo = to.value;
            const nFrom = Cast.toNumber(sFrom);
            const nTo = Cast.toNumber(sTo); // If both numbers are the same, random is unnecessary.
            // todo: this probably never happens so consider removing

            if (nFrom === nTo) {
              return {
                kind: 'constant',
                value: nFrom
              };
            } // If both are ints, hint this to the compiler


            if (Cast.isInt(sFrom) && Cast.isInt(sTo)) {
              return {
                kind: 'op.random',
                low: nFrom <= nTo ? from : to,
                high: nFrom <= nTo ? to : from,
                useInts: true,
                useFloats: false
              };
            } // Otherwise hint that these are floats


            return {
              kind: 'op.random',
              low: nFrom <= nTo ? from : to,
              high: nFrom <= nTo ? to : from,
              useInts: false,
              useFloats: true
            };
          } else if (from.kind === 'constant') {
            // If only one value is known at compile-time, we can still attempt some optimizations.
            if (!Cast.isInt(Cast.toNumber(from.value))) {
              return {
                kind: 'op.random',
                low: from,
                high: to,
                useInts: false,
                useFloats: true
              };
            }
          } else if (to.kind === 'constant') {
            if (!Cast.isInt(Cast.toNumber(to.value))) {
              return {
                kind: 'op.random',
                low: from,
                high: to,
                useInts: false,
                useFloats: true
              };
            }
          } // No optimizations possible


          return {
            kind: 'op.random',
            low: from,
            high: to,
            useInts: false,
            useFloats: false
          };
        }

      case 'operator_round':
        return {
          kind: 'op.round',
          value: this.descendInputOfBlock(block, 'NUM')
        };

      case 'operator_subtract':
        return {
          kind: 'op.subtract',
          left: this.descendInputOfBlock(block, 'NUM1'),
          right: this.descendInputOfBlock(block, 'NUM2')
        };

      case 'sensing_answer':
        return {
          kind: 'sensing.answer'
        };

      case 'sensing_coloristouchingcolor':
        return {
          kind: 'sensing.colorTouchingColor',
          target: this.descendInputOfBlock(block, 'COLOR2'),
          mask: this.descendInputOfBlock(block, 'COLOR')
        };

      case 'sensing_current':
        switch (block.fields.CURRENTMENU.value.toLowerCase()) {
          case 'year':
            return {
              kind: 'sensing.year'
            };

          case 'month':
            return {
              kind: 'sensing.month'
            };

          case 'date':
            return {
              kind: 'sensing.date'
            };

          case 'dayofweek':
            return {
              kind: 'sensing.dayofweek'
            };

          case 'hour':
            return {
              kind: 'sensing.hour'
            };

          case 'minute':
            return {
              kind: 'sensing.minute'
            };

          case 'second':
            return {
              kind: 'sensing.second'
            };
        }

        return {
          kind: 'constant',
          value: 0
        };

      case 'sensing_dayssince2000':
        return {
          kind: 'sensing.daysSince2000'
        };

      case 'sensing_distanceto':
        return {
          kind: 'sensing.distance',
          target: this.descendInputOfBlock(block, 'DISTANCETOMENU')
        };

      case 'sensing_keypressed':
        return {
          kind: 'keyboard.pressed',
          key: this.descendInputOfBlock(block, 'KEY_OPTION')
        };

      case 'sensing_mousedown':
        return {
          kind: 'mouse.down'
        };

      case 'sensing_mousex':
        return {
          kind: 'mouse.x'
        };

      case 'sensing_mousey':
        return {
          kind: 'mouse.y'
        };

      case 'sensing_of':
        return {
          kind: 'sensing.of',
          property: block.fields.PROPERTY.value,
          object: this.descendInputOfBlock(block, 'OBJECT')
        };

      case 'sensing_timer':
        this.usesTimer = true;
        return {
          kind: 'timer.get'
        };

      case 'sensing_touchingcolor':
        return {
          kind: 'sensing.touchingColor',
          color: this.descendInputOfBlock(block, 'COLOR')
        };

      case 'sensing_touchingobject':
        return {
          kind: 'sensing.touching',
          object: this.descendInputOfBlock(block, 'TOUCHINGOBJECTMENU')
        };

      case 'sensing_username':
        return {
          kind: 'sensing.username'
        };

      case 'sound_sounds_menu':
        // This menu is special compared to other menus -- it actually has an opcode function.
        return {
          kind: 'constant',
          value: block.fields.SOUND_MENU.value
        };

      case 'tw_getLastKeyPressed':
        return {
          kind: 'tw.lastKeyPressed'
        };

      default:
        {
          const opcodeFunction = this.runtime.getOpcodeFunction(block.opcode);

          if (opcodeFunction) {
            // It might be a non-compiled primitive from a standard category
            if (compatBlocks.inputs.includes(block.opcode)) {
              return this.descendCompatLayer(block);
            } // It might be an extension block.


            const blockInfo = this.getBlockInfo(block.opcode);

            if (blockInfo) {
              const type = blockInfo.info.blockType;

              if (type === BlockType.REPORTER || type === BlockType.BOOLEAN) {
                return this.descendCompatLayer(block);
              }
            }
          } // It might be a menu.


          const inputs = Object.keys(block.inputs);
          const fields = Object.keys(block.fields);

          if (inputs.length === 0 && fields.length === 1) {
            return {
              kind: 'constant',
              value: block.fields[fields[0]].value
            };
          }

          log.warn("IR: Unknown input: ".concat(block.opcode), block);
          throw new Error("IR: Unknown input: ".concat(block.opcode));
        }
    }
  }
  /**
   * Descend into a stacked block. (eg. "move ( ) steps")
   * @param {*} block The Scratch block to parse.
   * @private
   * @returns {Node} Compiled node for this block.
   */


  descendStackedBlock(block) {
    switch (block.opcode) {
      case 'control_all_at_once':
        // In Scratch 3, this block behaves like "if 1 = 1"
        return {
          kind: 'control.if',
          condition: {
            kind: 'constant',
            value: true
          },
          whenTrue: this.descendSubstack(block, 'SUBSTACK'),
          whenFalse: []
        };

      case 'control_create_clone_of':
        return {
          kind: 'control.createClone',
          target: this.descendInputOfBlock(block, 'CLONE_OPTION')
        };

      case 'control_delete_this_clone':
        this.script.yields = true;
        return {
          kind: 'control.deleteClone'
        };

      case 'control_forever':
        this.analyzeLoop();
        return {
          kind: 'control.while',
          condition: {
            kind: 'constant',
            value: true
          },
          do: this.descendSubstack(block, 'SUBSTACK')
        };

      case 'control_for_each':
        this.analyzeLoop();
        return {
          kind: 'control.for',
          variable: this.descendVariable(block, 'VARIABLE', SCALAR_TYPE),
          count: this.descendInputOfBlock(block, 'VALUE'),
          do: this.descendSubstack(block, 'SUBSTACK')
        };

      case 'control_if':
        return {
          kind: 'control.if',
          condition: this.descendInputOfBlock(block, 'CONDITION'),
          whenTrue: this.descendSubstack(block, 'SUBSTACK'),
          whenFalse: []
        };

      case 'control_if_else':
        return {
          kind: 'control.if',
          condition: this.descendInputOfBlock(block, 'CONDITION'),
          whenTrue: this.descendSubstack(block, 'SUBSTACK'),
          whenFalse: this.descendSubstack(block, 'SUBSTACK2')
        };

      case 'control_repeat':
        this.analyzeLoop();
        return {
          kind: 'control.repeat',
          times: this.descendInputOfBlock(block, 'TIMES'),
          do: this.descendSubstack(block, 'SUBSTACK')
        };

      case 'control_repeat_until':
        {
          this.analyzeLoop(); // Dirty hack: automatically enable warp timer for this block if it uses timer
          // This fixes project that do things like "repeat until timer > 0.5"

          this.usesTimer = false;
          const condition = this.descendInputOfBlock(block, 'CONDITION');
          const needsWarpTimer = this.usesTimer;

          if (needsWarpTimer) {
            this.script.yields = true;
          }

          return {
            kind: 'control.while',
            condition: {
              kind: 'op.not',
              operand: condition
            },
            do: this.descendSubstack(block, 'SUBSTACK'),
            warpTimer: needsWarpTimer
          };
        }

      case 'control_stop':
        {
          const level = block.fields.STOP_OPTION.value;

          if (level === 'all') {
            this.script.yields = true;
            return {
              kind: 'control.stopAll'
            };
          } else if (level === 'other scripts in sprite' || level === 'other scripts in stage') {
            return {
              kind: 'control.stopOthers'
            };
          } else if (level === 'this script') {
            return {
              kind: 'control.stopScript'
            };
          }

          return {
            kind: 'noop'
          };
        }

      case 'control_wait':
        this.script.yields = true;
        return {
          kind: 'control.wait',
          seconds: this.descendInputOfBlock(block, 'DURATION')
        };

      case 'control_wait_until':
        this.script.yields = true;
        return {
          kind: 'control.waitUntil',
          condition: this.descendInputOfBlock(block, 'CONDITION')
        };

      case 'control_while':
        this.analyzeLoop();
        return {
          kind: 'control.while',
          condition: this.descendInputOfBlock(block, 'CONDITION'),
          do: this.descendSubstack(block, 'SUBSTACK'),
          // We should consider analyzing this like we do for control_repeat_until
          warpTimer: false
        };

      case 'data_addtolist':
        return {
          kind: 'list.add',
          list: this.descendVariable(block, 'LIST', LIST_TYPE),
          item: this.descendInputOfBlock(block, 'ITEM')
        };

      case 'data_changevariableby':
        {
          const variable = this.descendVariable(block, 'VARIABLE', SCALAR_TYPE);
          return {
            kind: 'var.set',
            variable,
            value: {
              kind: 'op.add',
              left: {
                kind: 'var.get',
                variable
              },
              right: this.descendInputOfBlock(block, 'VALUE')
            }
          };
        }

      case 'data_deletealloflist':
        return {
          kind: 'list.deleteAll',
          list: this.descendVariable(block, 'LIST', LIST_TYPE)
        };

      case 'data_deleteoflist':
        {
          const index = this.descendInputOfBlock(block, 'INDEX');

          if (index.kind === 'constant' && index.value === 'all') {
            return {
              kind: 'list.deleteAll',
              list: this.descendVariable(block, 'LIST', LIST_TYPE)
            };
          }

          return {
            kind: 'list.delete',
            list: this.descendVariable(block, 'LIST', LIST_TYPE),
            index: index
          };
        }

      case 'data_hidelist':
        return {
          kind: 'list.hide',
          list: this.descendVariable(block, 'LIST', LIST_TYPE)
        };

      case 'data_hidevariable':
        return {
          kind: 'var.hide',
          variable: this.descendVariable(block, 'VARIABLE', SCALAR_TYPE)
        };

      case 'data_insertatlist':
        return {
          kind: 'list.insert',
          list: this.descendVariable(block, 'LIST', LIST_TYPE),
          index: this.descendInputOfBlock(block, 'INDEX'),
          item: this.descendInputOfBlock(block, 'ITEM')
        };

      case 'data_replaceitemoflist':
        return {
          kind: 'list.replace',
          list: this.descendVariable(block, 'LIST', LIST_TYPE),
          index: this.descendInputOfBlock(block, 'INDEX'),
          item: this.descendInputOfBlock(block, 'ITEM')
        };

      case 'data_setvariableto':
        return {
          kind: 'var.set',
          variable: this.descendVariable(block, 'VARIABLE', SCALAR_TYPE),
          value: this.descendInputOfBlock(block, 'VALUE')
        };

      case 'data_showlist':
        return {
          kind: 'list.show',
          list: this.descendVariable(block, 'LIST', LIST_TYPE)
        };

      case 'data_showvariable':
        return {
          kind: 'var.show',
          variable: this.descendVariable(block, 'VARIABLE', SCALAR_TYPE)
        };

      case 'event_broadcast':
        return {
          kind: 'event.broadcast',
          broadcast: this.descendInputOfBlock(block, 'BROADCAST_INPUT')
        };

      case 'event_broadcastandwait':
        this.script.yields = true;
        return {
          kind: 'event.broadcastAndWait',
          broadcast: this.descendInputOfBlock(block, 'BROADCAST_INPUT')
        };

      case 'looks_changeeffectby':
        return {
          kind: 'looks.changeEffect',
          effect: block.fields.EFFECT.value.toLowerCase(),
          value: this.descendInputOfBlock(block, 'CHANGE')
        };

      case 'looks_changesizeby':
        return {
          kind: 'looks.changeSize',
          size: this.descendInputOfBlock(block, 'CHANGE')
        };

      case 'looks_cleargraphiceffects':
        return {
          kind: 'looks.clearEffects'
        };

      case 'looks_goforwardbackwardlayers':
        if (block.fields.FORWARD_BACKWARD.value === 'forward') {
          return {
            kind: 'looks.forwardLayers',
            layers: this.descendInputOfBlock(block, 'NUM')
          };
        }

        return {
          kind: 'looks.backwardLayers',
          layers: this.descendInputOfBlock(block, 'NUM')
        };

      case 'looks_gotofrontback':
        if (block.fields.FRONT_BACK.value === 'front') {
          return {
            kind: 'looks.goToFront'
          };
        }

        return {
          kind: 'looks.goToBack'
        };

      case 'looks_hide':
        return {
          kind: 'looks.hide'
        };

      case 'looks_nextbackdrop':
        return {
          kind: 'looks.nextBackdrop'
        };

      case 'looks_nextcostume':
        return {
          kind: 'looks.nextCostume'
        };

      case 'looks_seteffectto':
        return {
          kind: 'looks.setEffect',
          effect: block.fields.EFFECT.value.toLowerCase(),
          value: this.descendInputOfBlock(block, 'VALUE')
        };

      case 'looks_setsizeto':
        return {
          kind: 'looks.setSize',
          size: this.descendInputOfBlock(block, 'SIZE')
        };

      case 'looks_show':
        return {
          kind: 'looks.show'
        };

      case 'looks_switchbackdropto':
        return {
          kind: 'looks.switchBackdrop',
          backdrop: this.descendInputOfBlock(block, 'BACKDROP')
        };

      case 'looks_switchcostumeto':
        return {
          kind: 'looks.switchCostume',
          costume: this.descendInputOfBlock(block, 'COSTUME')
        };

      case 'motion_changexby':
        return {
          kind: 'motion.changeX',
          dx: this.descendInputOfBlock(block, 'DX')
        };

      case 'motion_changeyby':
        return {
          kind: 'motion.changeY',
          dy: this.descendInputOfBlock(block, 'DY')
        };

      case 'motion_gotoxy':
        return {
          kind: 'motion.setXY',
          x: this.descendInputOfBlock(block, 'X'),
          y: this.descendInputOfBlock(block, 'Y')
        };

      case 'motion_ifonedgebounce':
        return {
          kind: 'motion.ifOnEdgeBounce'
        };

      case 'motion_movesteps':
        return {
          kind: 'motion.step',
          steps: this.descendInputOfBlock(block, 'STEPS')
        };

      case 'motion_pointindirection':
        return {
          kind: 'motion.setDirection',
          direction: this.descendInputOfBlock(block, 'DIRECTION')
        };

      case 'motion_setrotationstyle':
        return {
          kind: 'motion.setRotationStyle',
          style: block.fields.STYLE.value
        };

      case 'motion_setx':
        return {
          kind: 'motion.setX',
          x: this.descendInputOfBlock(block, 'X')
        };

      case 'motion_sety':
        return {
          kind: 'motion.setY',
          y: this.descendInputOfBlock(block, 'Y')
        };

      case 'motion_turnleft':
        return {
          kind: 'motion.setDirection',
          direction: {
            kind: 'op.subtract',
            left: {
              kind: 'motion.direction'
            },
            right: this.descendInputOfBlock(block, 'DEGREES')
          }
        };

      case 'motion_turnright':
        return {
          kind: 'motion.setDirection',
          direction: {
            kind: 'op.add',
            left: {
              kind: 'motion.direction'
            },
            right: this.descendInputOfBlock(block, 'DEGREES')
          }
        };

      case 'pen_clear':
        return {
          kind: 'pen.clear'
        };

      case 'pen_changePenColorParamBy':
        return {
          kind: 'pen.changeParam',
          param: this.descendInputOfBlock(block, 'COLOR_PARAM'),
          value: this.descendInputOfBlock(block, 'VALUE')
        };

      case 'pen_changePenHueBy':
        return {
          kind: 'pen.legacyChangeHue',
          hue: this.descendInputOfBlock(block, 'HUE')
        };

      case 'pen_changePenShadeBy':
        return {
          kind: 'pen.legacyChangeShade',
          shade: this.descendInputOfBlock(block, 'SHADE')
        };

      case 'pen_penDown':
        return {
          kind: 'pen.down'
        };

      case 'pen_penUp':
        return {
          kind: 'pen.up'
        };

      case 'pen_setPenColorParamTo':
        return {
          kind: 'pen.setParam',
          param: this.descendInputOfBlock(block, 'COLOR_PARAM'),
          value: this.descendInputOfBlock(block, 'VALUE')
        };

      case 'pen_setPenColorToColor':
        return {
          kind: 'pen.setColor',
          color: this.descendInputOfBlock(block, 'COLOR')
        };

      case 'pen_setPenHueToNumber':
        return {
          kind: 'pen.legacySetHue',
          hue: this.descendInputOfBlock(block, 'HUE')
        };

      case 'pen_setPenShadeToNumber':
        return {
          kind: 'pen.legacySetShade',
          shade: this.descendInputOfBlock(block, 'SHADE')
        };

      case 'pen_setPenSizeTo':
        return {
          kind: 'pen.setSize',
          size: this.descendInputOfBlock(block, 'SIZE')
        };

      case 'pen_changePenSizeBy':
        return {
          kind: 'pen.changeSize',
          size: this.descendInputOfBlock(block, 'SIZE')
        };

      case 'pen_stamp':
        return {
          kind: 'pen.stamp'
        };

      case 'procedures_call':
        {
          // setting of yields will be handled later in the analysis phase
          const procedureCode = block.mutation.proccode;

          if (procedureCode === 'tw:debugger;') {
            return {
              kind: 'tw.debugger'
            };
          }

          const paramNamesIdsAndDefaults = this.blocks.getProcedureParamNamesIdsAndDefaults(procedureCode);

          if (paramNamesIdsAndDefaults === null) {
            return {
              kind: 'noop'
            };
          }

          const [paramNames, paramIds, paramDefaults] = paramNamesIdsAndDefaults;
          const addonBlock = this.runtime.getAddonBlock(procedureCode);

          if (addonBlock) {
            this.script.yields = true;
            const args = {};

            for (let i = 0; i < paramIds.length; i++) {
              let value;

              if (block.inputs[paramIds[i]] && block.inputs[paramIds[i]].block) {
                value = this.descendInputOfBlock(block, paramIds[i]);
              } else {
                value = {
                  kind: 'constant',
                  value: paramDefaults[i]
                };
              }

              args[paramNames[i]] = value;
            }

            return {
              kind: 'addons.call',
              code: procedureCode,
              arguments: args,
              blockId: block.id
            };
          }

          const definitionId = this.blocks.getProcedureDefinition(procedureCode);
          const definitionBlock = this.blocks.getBlock(definitionId);

          if (!definitionBlock) {
            return {
              kind: 'noop'
            };
          }

          const innerDefinition = this.blocks.getBlock(definitionBlock.inputs.custom_block.block);
          let isWarp = this.script.isWarp;

          if (!isWarp) {
            if (innerDefinition && innerDefinition.mutation) {
              const warp = innerDefinition.mutation.warp;

              if (typeof warp === 'boolean') {
                isWarp = warp;
              } else if (typeof warp === 'string') {
                isWarp = JSON.parse(warp);
              }
            }
          }

          const variant = generateProcedureVariant(procedureCode, isWarp);

          if (!this.script.dependedProcedures.includes(variant)) {
            this.script.dependedProcedures.push(variant);
          } // Non-warp direct recursion yields.


          if (!this.script.isWarp) {
            if (procedureCode === this.script.procedureCode) {
              this.script.yields = true;
            }
          }

          const args = [];

          for (let i = 0; i < paramIds.length; i++) {
            let value;

            if (block.inputs[paramIds[i]] && block.inputs[paramIds[i]].block) {
              value = this.descendInputOfBlock(block, paramIds[i]);
            } else {
              value = {
                kind: 'constant',
                value: paramDefaults[i]
              };
            }

            args.push(value);
          }

          return {
            kind: 'procedures.call',
            code: procedureCode,
            variant,
            arguments: args
          };
        }

      case 'sensing_resettimer':
        return {
          kind: 'timer.reset'
        };

      default:
        {
          const opcodeFunction = this.runtime.getOpcodeFunction(block.opcode);

          if (opcodeFunction) {
            // It might be a non-compiled primitive from a standard category
            if (compatBlocks.stacked.includes(block.opcode)) {
              return this.descendCompatLayer(block);
            } // It might be an extension block.


            const blockInfo = this.getBlockInfo(block.opcode);

            if (blockInfo) {
              const type = blockInfo.info.blockType;

              if (type === BlockType.COMMAND) {
                return this.descendCompatLayer(block);
              }
            }
          } // When this thread was triggered by a stack click, attempt to compile as an input.
          // TODO: perhaps this should be moved to generate()?


          if (this.thread.stackClick) {
            try {
              const inputNode = this.descendInput(block);
              return {
                kind: 'visualReport',
                input: inputNode
              };
            } catch (e) {// Ignore
            }
          }

          log.warn("IR: Unknown stacked block: ".concat(block.opcode), block);
          throw new Error("IR: Unknown stacked block: ".concat(block.opcode));
        }
    }
  }
  /**
   * Descend into a stack of blocks (eg. the blocks contained within an "if" block)
   * @param {*} parentBlock The parent Scratch block that contains the stack to parse.
   * @param {*} substackName The name of the stack to descend into.
   * @private
   * @returns {Node[]} List of stacked block nodes.
   */


  descendSubstack(parentBlock, substackName) {
    const input = parentBlock.inputs[substackName];

    if (!input) {
      return [];
    }

    const stackId = input.block;
    return this.walkStack(stackId);
  }
  /**
   * Descend into and walk the siblings of a stack.
   * @param {string} startingBlockId The ID of the first block of a stack.
   * @private
   * @returns {Node[]} List of stacked block nodes.
   */


  walkStack(startingBlockId) {
    const result = [];
    let blockId = startingBlockId;

    while (blockId !== null) {
      const block = this.getBlockById(blockId);

      if (!block) {
        break;
      }

      const node = this.descendStackedBlock(block);
      result.push(node);
      blockId = block.next;
    }

    return result;
  }
  /**
   * Descend into a variable.
   * @param {*} block The block that has the variable.
   * @param {string} fieldName The name of the field that the variable is stored in.
   * @param {''|'list'} type Variable type, '' for scalar and 'list' for list.
   * @private
   * @returns {*} A parsed variable object.
   */


  descendVariable(block, fieldName, type) {
    const variable = block.fields[fieldName];
    const id = variable.id;

    if (this.variableCache.hasOwnProperty(id)) {
      return this.variableCache[id];
    }

    const data = this._descendVariable(id, variable.value, type);

    this.variableCache[id] = data;
    return data;
  }
  /**
   * @param {string} id The ID of the variable.
   * @param {string} name The name of the variable.
   * @param {''|'list'} type The variable type.
   * @private
   * @returns {*} A parsed variable object.
   */


  _descendVariable(id, name, type) {
    const target = this.target;
    const stage = this.stage; // Look for by ID in target...

    if (target.variables.hasOwnProperty(id)) {
      return createVariableData('target', target.variables[id]);
    } // Look for by ID in stage...


    if (!target.isStage) {
      if (stage && stage.variables.hasOwnProperty(id)) {
        return createVariableData('stage', stage.variables[id]);
      }
    } // Look for by name and type in target...


    for (const varId in target.variables) {
      if (target.variables.hasOwnProperty(varId)) {
        const currVar = target.variables[varId];

        if (currVar.name === name && currVar.type === type) {
          return createVariableData('target', currVar);
        }
      }
    } // Look for by name and type in stage...


    if (!target.isStage && stage) {
      for (const varId in stage.variables) {
        if (stage.variables.hasOwnProperty(varId)) {
          const currVar = stage.variables[varId];

          if (currVar.name === name && currVar.type === type) {
            return createVariableData('stage', currVar);
          }
        }
      }
    } // Create it locally...


    const newVariable = new Variable(id, name, type, false);
    target.variables[id] = newVariable;

    if (target.sprite) {
      // Create the variable in all instances of this sprite.
      // This is necessary because the script cache is shared between clones.
      // sprite.clones has all instances of this sprite including the original and all clones
      for (const clone of target.sprite.clones) {
        if (!clone.variables.hasOwnProperty(id)) {
          clone.variables[id] = new Variable(id, name, type, false);
        }
      }
    }

    return createVariableData('target', newVariable);
  }
  /**
   * Descend into a block that uses the compatibility layer.
   * @param {*} block The block to use the compatibility layer for.
   * @private
   * @returns {Node} The parsed node.
   */


  descendCompatLayer(block) {
    this.script.yields = true;
    const inputs = {};
    const fields = {};

    for (const name of Object.keys(block.inputs)) {
      inputs[name] = this.descendInputOfBlock(block, name);
    }

    for (const name of Object.keys(block.fields)) {
      fields[name] = block.fields[name].value;
    }

    return {
      kind: 'compat',
      opcode: block.opcode,
      inputs,
      fields
    };
  }

  analyzeLoop() {
    if (!this.script.isWarp || this.script.warpTimer) {
      this.script.yields = true;
    }
  }

  readTopBlockComment(commentId) {
    const comment = this.target.comments[commentId];

    if (!comment) {
      // can't find the comment
      // this is safe to ignore
      return;
    }

    const text = comment.text;

    for (const line of text.split('\n')) {
      if (!/^tw\b/.test(line)) {
        continue;
      }

      const flags = line.split(' ');

      for (const flag of flags) {
        switch (flag) {
          case 'nocompile':
            throw new Error('Script explicitly disables compilation');

          case 'stuck':
            this.script.warpTimer = true;
            break;
        }
      } // Only the first 'tw' line is parsed.


      break;
    }
  }
  /**
   * @param {string} topBlockId The ID of the top block of the script.
   * @returns {IntermediateScript}
   */


  generate(topBlockId) {
    this.blocks.populateProcedureCache();
    this.script.topBlockId = topBlockId;
    const topBlock = this.getBlockById(topBlockId);

    if (!topBlock) {
      if (this.script.isProcedure) {
        // Empty procedure
        return this.script;
      }

      throw new Error('Cannot find top block');
    }

    if (topBlock.comment) {
      this.readTopBlockComment(topBlock.comment);
    } // If the top block is a hat, advance to its child.


    let entryBlock;

    if (this.runtime.getIsHat(topBlock.opcode) || topBlock.opcode === 'procedures_definition') {
      if (this.runtime.getIsEdgeActivatedHat(topBlock.opcode)) {
        throw new Error("Not compiling an edge-activated hat: ".concat(topBlock.opcode));
      }

      entryBlock = topBlock.next;
    } else {
      entryBlock = topBlockId;
    }

    if (!entryBlock) {
      // This is an empty script.
      return this.script;
    }

    this.script.stack = this.walkStack(entryBlock);
    return this.script;
  }

}

class IRGenerator {
  constructor(thread) {
    this.thread = thread;
    this.blocks = thread.blockContainer;
    this.proceduresToCompile = new Map();
    this.compilingProcedures = new Map();
    /** @type {Object.<string, IntermediateScript>} */

    this.procedures = {};
    this.analyzedProcedures = [];
  }

  addProcedureDependencies(dependencies) {
    for (const procedureVariant of dependencies) {
      if (this.procedures.hasOwnProperty(procedureVariant)) {
        continue;
      }

      if (this.compilingProcedures.has(procedureVariant)) {
        continue;
      }

      if (this.proceduresToCompile.has(procedureVariant)) {
        continue;
      }

      const procedureCode = parseProcedureCode(procedureVariant);
      const definition = this.blocks.getProcedureDefinition(procedureCode);
      this.proceduresToCompile.set(procedureVariant, definition);
    }
  }
  /**
   * @param {ScriptTreeGenerator} generator The generator to run.
   * @param {string} topBlockId The ID of the top block in the stack.
   * @returns {IntermediateScript} Intermediate script.
   */


  generateScriptTree(generator, topBlockId) {
    const result = generator.generate(topBlockId);
    this.addProcedureDependencies(result.dependedProcedures);
    return result;
  }
  /**
   * Recursively analyze a script and its dependencies.
   * @param {IntermediateScript} script Intermediate script.
   */


  analyzeScript(script) {
    let madeChanges = false;

    for (const procedureCode of script.dependedProcedures) {
      const procedureData = this.procedures[procedureCode]; // Analyze newly found procedures.

      if (!this.analyzedProcedures.includes(procedureCode)) {
        this.analyzedProcedures.push(procedureCode);

        if (this.analyzeScript(procedureData)) {
          madeChanges = true;
        }

        this.analyzedProcedures.pop();
      } // If a procedure used by a script may yield, the script itself may yield.


      if (procedureData.yields && !script.yields) {
        script.yields = true;
        madeChanges = true;
      }
    }

    return madeChanges;
  }
  /**
   * @returns {IntermediateRepresentation} Intermediate representation.
   */


  generate() {
    const entry = this.generateScriptTree(new ScriptTreeGenerator(this.thread), this.thread.topBlock); // Compile any required procedures.
    // As procedures can depend on other procedures, this process may take several iterations.

    const procedureTreeCache = this.blocks._cache.compiledProcedures;

    while (this.proceduresToCompile.size > 0) {
      this.compilingProcedures = this.proceduresToCompile;
      this.proceduresToCompile = new Map();

      for (const [procedureVariant, definitionId] of this.compilingProcedures.entries()) {
        if (procedureTreeCache[procedureVariant]) {
          const result = procedureTreeCache[procedureVariant];
          this.procedures[procedureVariant] = result;
          this.addProcedureDependencies(result.dependedProcedures);
        } else {
          const isWarp = parseIsWarp(procedureVariant);
          const generator = new ScriptTreeGenerator(this.thread);
          generator.setProcedureVariant(procedureVariant);
          if (isWarp) generator.enableWarp();
          const compiledProcedure = this.generateScriptTree(generator, definitionId);
          this.procedures[procedureVariant] = compiledProcedure;
          procedureTreeCache[procedureVariant] = compiledProcedure;
        }
      }
    } // Analyze scripts until no changes are made.


    while (this.analyzeScript(entry));

    const ir = new IntermediateRepresentation();
    ir.entry = entry;
    ir.procedures = this.procedures;
    return ir;
  }

}

module.exports = IRGenerator;

/***/ }),

/***/ "./src/compiler/jsexecute.js":
/*!***********************************!*\
  !*** ./src/compiler/jsexecute.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview Runtime for scripts generated by jsgen
 */

/* eslint-disable no-unused-vars */

/* eslint-disable prefer-template */

/* eslint-disable valid-jsdoc */

/* eslint-disable max-len */
const globalState = {
  Timer: __webpack_require__(/*! ../util/timer */ "./src/util/timer.js"),
  Cast: __webpack_require__(/*! ../util/cast */ "./src/util/cast.js"),
  log: __webpack_require__(/*! ../util/log */ "./src/util/log.js"),
  compatibilityLayerBlockUtility: __webpack_require__(/*! ./compat-block-utility */ "./src/compiler/compat-block-utility.js"),
  thread: null
};
let baseRuntime = '';
const runtimeFunctions = {};
/**
 * Determine whether the current tick is likely stuck.
 * This implements similar functionality to the warp timer found in Scratch.
 * @returns {boolean} true if the current tick is likely stuck.
 */

baseRuntime += "let stuckCounter = 0;\nconst isStuck = () => {\n    // The real time is not checked on every call for performance.\n    stuckCounter++;\n    if (stuckCounter === 100) {\n        stuckCounter = 0;\n        return globalState.thread.target.runtime.sequencer.timer.timeElapsed() > 500;\n    }\n    return false;\n};";
/**
 * Start hats by opcode.
 * @param {string} requestedHat The opcode of the hat to start.
 * @param {*} optMatchFields Fields to match.
 * @returns {Array} A list of threads that were started.
 */

runtimeFunctions.startHats = "const startHats = (requestedHat, optMatchFields) => {\n    const thread = globalState.thread;\n    const threads = thread.target.runtime.startHats(requestedHat, optMatchFields);\n    return threads;\n}";
/**
 * Implements "thread waiting", where scripts are halted until all the scripts have finished executing.
 * @param {Array} threads The list of threads.
 */

runtimeFunctions.waitThreads = "const waitThreads = function*(threads) {\n    const thread = globalState.thread;\n    const runtime = thread.target.runtime;\n\n    while (true) {\n        // determine whether any threads are running\n        let anyRunning = false;\n        for (let i = 0; i < threads.length; i++) {\n            if (runtime.threads.indexOf(threads[i]) !== -1) {\n                anyRunning = true;\n                break;\n            }\n        }\n        if (!anyRunning) {\n            // all threads are finished, can resume\n            return;\n        }\n\n        let allWaiting = true;\n        for (let i = 0; i < threads.length; i++) {\n            if (!runtime.isWaitingThread(threads[i])) {\n                allWaiting = false;\n                break;\n            }\n        }\n        if (allWaiting) {\n            thread.status = 3; // STATUS_YIELD_TICK\n        }\n\n        yield;\n    }\n}";
/**
 * Wait until a Promise resolves or rejects before continuing.
 * @param {Promise} promise The promise to wait for.
 * @returns {*} the value that the promise resolves to, otherwise undefined if the promise rejects
 */

/**
 * Execute a scratch-vm primitive.
 * @param {*} inputs The inputs to pass to the block.
 * @param {function} blockFunction The primitive's function.
 * @param {boolean} useFlags Whether to set flags (hasResumedFromPromise)
 * @returns {*} the value returned by the block, if any.
 */

runtimeFunctions.executeInCompatibilityLayer = "let hasResumedFromPromise = false;\nconst waitPromise = function*(promise) {\n    const thread = globalState.thread;\n    let returnValue;\n\n    promise\n        .then(value => {\n            returnValue = value;\n            thread.status = 0; // STATUS_RUNNING\n        })\n        .catch(error => {\n            thread.status = 0; // STATUS_RUNNING\n            globalState.log.warn('Promise rejected in compiled script:', error);\n        });\n\n    // enter STATUS_PROMISE_WAIT and yield\n    // this will stop script execution until the promise handlers reset the thread status\n    thread.status = 1; // STATUS_PROMISE_WAIT\n    yield;\n\n    return returnValue;\n};\nconst executeInCompatibilityLayer = function*(inputs, blockFunction, isWarp, useFlags) {\n    const thread = globalState.thread;\n\n    // reset the stackframe\n    // we only ever use one stackframe at a time, so this shouldn't cause issues\n    thread.stackFrames[thread.stackFrames.length - 1].reuse(isWarp);\n\n    const executeBlock = () => {\n        const compatibilityLayerBlockUtility = globalState.compatibilityLayerBlockUtility;\n        compatibilityLayerBlockUtility.thread = thread;\n        compatibilityLayerBlockUtility.sequencer = thread.target.runtime.sequencer;\n        return blockFunction(inputs, compatibilityLayerBlockUtility);\n    };\n\n    const isPromise = value => (\n        // see engine/execute.js\n        value !== null &&\n        typeof value === 'object' &&\n        typeof value.then === 'function'\n    );\n\n    let returnValue = executeBlock();\n\n    if (isPromise(returnValue)) {\n        returnValue = yield* waitPromise(returnValue);\n        if (useFlags) {\n            hasResumedFromPromise = true;\n        }\n        return returnValue;\n    }\n\n    while (thread.status === 2 /* STATUS_YIELD */ || thread.status === 3 /* STATUS_YIELD_TICK */) {\n        // Yielded threads will run next iteration.\n        if (thread.status === 2 /* STATUS_YIELD */) {\n            thread.status = 0; // STATUS_RUNNING\n            // Yield back to the event loop when stuck or not in warp mode.\n            if (!isWarp || isStuck()) {\n                yield;\n            }\n        } else {\n            // status is STATUS_YIELD_TICK, always yield to the event loop\n            yield;\n        }\n\n        returnValue = executeBlock();\n\n        if (isPromise(returnValue)) {\n            returnValue = yield* waitPromise(returnValue);\n            if (useFlags) {\n                hasResumedFromPromise = true;\n            }\n            return returnValue;\n        }\n    }\n\n    // todo: do we have to do anything extra if status is STATUS_DONE?\n\n    return returnValue;\n}";
/**
 * Run an addon block.
 * @param {string} procedureCode The block's procedure code
 * @param {string} blockId The ID of the block being run
 * @param {object} args The arguments to pass to the block
 */

runtimeFunctions.callAddonBlock = "const callAddonBlock = function*(procedureCode, blockId, args) {\n    const thread = globalState.thread;\n    const addonBlock = thread.target.runtime.getAddonBlock(procedureCode);\n    if (addonBlock) {\n        const target = thread.target;\n        addonBlock.callback(args, {\n            // Shim enough of BlockUtility to make addons work\n            peekStack () {\n                return blockId;\n            },\n            target\n        });\n        if (thread.status === 1 /* STATUS_PROMISE_WAIT */) {\n            yield;\n        }\n    }\n}";
/**
 * End the current script.
 */

runtimeFunctions.retire = "const retire = () => {\n    const thread = globalState.thread;\n    thread.target.runtime.sequencer.retireThread(thread);\n}";
/**
 * Scratch cast to boolean.
 * Similar to Cast.toBoolean()
 * @param {*} value The value to cast
 * @returns {boolean} The value cast to a boolean
 */

runtimeFunctions.toBoolean = "const toBoolean = value => {\n    if (typeof value === 'boolean') {\n        return value;\n    }\n    if (typeof value === 'string') {\n        if (value === '' || value === '0' || value.toLowerCase() === 'false') {\n            return false;\n        }\n        return true;\n    }\n    return !!value;\n}";
/**
 * If a number is very close to a whole number, round to that whole number.
 * @param {number} value Value to round
 * @returns {number} Rounded number or original number
 */

runtimeFunctions.limitPrecision = "const limitPrecision = value => {\n    const rounded = Math.round(value);\n    const delta = value - rounded;\n    return (Math.abs(delta) < 1e-9) ? rounded : value;\n}";
/**
 * Check if a value is considered whitespace.
 * Similar to Cast.isWhiteSpace()
 * @param {*} val Value to check
 * @returns {boolean} true if the value is whitespace
 */

baseRuntime += "const isWhiteSpace = val => typeof val === 'string' && val.trim().length === 0;";
/**
 * Determine if two values are equal.
 * @param {*} v1 First value
 * @param {*} v2 Second value
 * @returns {boolean} true if v1 is equal to v2
 */

baseRuntime += "const compareEqualSlow = (v1, v2) => {\n    const n1 = +v1;\n    if (isNaN(n1) || (n1 === 0 && isWhiteSpace(v1))) return ('' + v1).toLowerCase() === ('' + v2).toLowerCase();\n    const n2 = +v2;\n    if (isNaN(n2) || (n2 === 0 && isWhiteSpace(v2))) return ('' + v1).toLowerCase() === ('' + v2).toLowerCase();\n    return n1 === n2;\n};\nconst compareEqual = (v1, v2) => (typeof v1 === 'number' && typeof v2 === 'number' && !isNaN(v1) && !isNaN(v2) || v1 === v2) ? v1 === v2 : compareEqualSlow(v1, v2);";
/**
 * Determine if one value is greater than another.
 * @param {*} v1 First value
 * @param {*} v2 Second value
 * @returns {boolean} true if v1 is greater than v2
 */

runtimeFunctions.compareGreaterThan = "const compareGreaterThanSlow = (v1, v2) => {\n    let n1 = +v1;\n    let n2 = +v2;\n    if (n1 === 0 && isWhiteSpace(v1)) {\n        n1 = NaN;\n    } else if (n2 === 0 && isWhiteSpace(v2)) {\n        n2 = NaN;\n    }\n    if (isNaN(n1) || isNaN(n2)) {\n        const s1 = ('' + v1).toLowerCase();\n        const s2 = ('' + v2).toLowerCase();\n        return s1 > s2;\n    }\n    return n1 > n2;\n};\nconst compareGreaterThan = (v1, v2) => typeof v1 === 'number' && typeof v2 === 'number' && !isNaN(v1) ? v1 > v2 : compareGreaterThanSlow(v1, v2)";
/**
 * Determine if one value is less than another.
 * @param {*} v1 First value
 * @param {*} v2 Second value
 * @returns {boolean} true if v1 is less than v2
 */

runtimeFunctions.compareLessThan = "const compareLessThanSlow = (v1, v2) => {\n    let n1 = +v1;\n    let n2 = +v2;\n    if (n1 === 0 && isWhiteSpace(v1)) {\n        n1 = NaN;\n    } else if (n2 === 0 && isWhiteSpace(v2)) {\n        n2 = NaN;\n    }\n    if (isNaN(n1) || isNaN(n2)) {\n        const s1 = ('' + v1).toLowerCase();\n        const s2 = ('' + v2).toLowerCase();\n        return s1 < s2;\n    }\n    return n1 < n2;\n};\nconst compareLessThan = (v1, v2) => typeof v1 === 'number' && typeof v2 === 'number' && !isNaN(v2) ? v1 < v2 : compareLessThanSlow(v1, v2)";
/**
 * Generate a random integer.
 * @param {number} low Lower bound
 * @param {number} high Upper bound
 * @returns {number} A random integer between low and high, inclusive.
 */

runtimeFunctions.randomInt = "const randomInt = (low, high) => low + Math.floor(Math.random() * ((high + 1) - low))";
/**
 * Generate a random float.
 * @param {number} low Lower bound
 * @param {number} high Upper bound
 * @returns {number} A random floating point number between low and high.
 */

runtimeFunctions.randomFloat = "const randomFloat = (low, high) => (Math.random() * (high - low)) + low";
/**
 * Create and start a timer.
 * @returns {Timer} A started timer
 */

runtimeFunctions.timer = "const timer = () => {\n    const t = new globalState.Timer({\n        now: () => globalState.thread.target.runtime.currentMSecs\n    });\n    t.start();\n    return t;\n}";
/**
 * Returns the amount of days since January 1st, 2000.
 * @returns {number} Days since 2000.
 */
// Date.UTC(2000, 0, 1) === 946684800000
// Hardcoding it is marginally faster

runtimeFunctions.daysSince2000 = "const daysSince2000 = () => (Date.now() - 946684800000) / (24 * 60 * 60 * 1000)";
/**
 * Determine distance to a sprite or point.
 * @param {string} menu The name of the sprite or location to find.
 * @returns {number} Distance to the point, or 10000 if it cannot be calculated.
 */

runtimeFunctions.distance = "const distance = menu => {\n    const thread = globalState.thread;\n    if (thread.target.isStage) return 10000;\n\n    let targetX = 0;\n    let targetY = 0;\n    if (menu === '_mouse_') {\n        targetX = thread.target.runtime.ioDevices.mouse.getScratchX();\n        targetY = thread.target.runtime.ioDevices.mouse.getScratchY();\n    } else {\n        const distTarget = thread.target.runtime.getSpriteTargetByName(menu);\n        if (!distTarget) return 10000;\n        targetX = distTarget.x;\n        targetY = distTarget.y;\n    }\n\n    const dx = thread.target.x - targetX;\n    const dy = thread.target.y - targetY;\n    return Math.sqrt((dx * dx) + (dy * dy));\n}";
/**
 * Convert a Scratch list index to a JavaScript list index.
 * "all" is not considered as a list index.
 * Similar to Cast.toListIndex()
 * @param {number} index Scratch list index.
 * @param {number} length Length of the list.
 * @returns {number} 0 based list index, or -1 if invalid.
 */

baseRuntime += "const listIndexSlow = (index, length) => {\n    if (index === 'last') {\n        return length - 1;\n    } else if (index === 'random' || index === 'any') {\n        if (length > 0) {\n            return (Math.random() * length) | 0;\n        }\n        return -1;\n    }\n    index = (+index || 0) | 0;\n    if (index < 1 || index > length) {\n        return -1;\n    }\n    return index - 1;\n};\nconst listIndex = (index, length) => {\n    if (typeof index !== 'number') {\n      return listIndexSlow(index, length);\n    }\n    index = index | 0;\n    return index < 1 || index > length ? -1 : index - 1;\n};";
/**
 * Get a value from a list.
 * @param {Array} list The list
 * @param {*} idx The 1-indexed index in the list.
 * @returns {*} The list item, otherwise empty string if it does not exist.
 */

runtimeFunctions.listGet = "const listGet = (list, idx) => {\n    const index = listIndex(idx, list.length);\n    if (index === -1) {\n        return '';\n    }\n    return list[index];\n}";
/**
 * Replace a value in a list.
 * @param {import('../engine/variable')} list The list
 * @param {*} idx List index, Scratch style.
 * @param {*} value The new value.
 */

runtimeFunctions.listReplace = "const listReplace = (list, idx, value) => {\n    const index = listIndex(idx, list.value.length);\n    if (index === -1) {\n        return;\n    }\n    list.value[index] = value;\n    list._monitorUpToDate = false;\n}";
/**
 * Insert a value in a list.
 * @param {import('../engine/variable')} list The list.
 * @param {*} idx The Scratch index in the list.
 * @param {*} value The value to insert.
 */

runtimeFunctions.listInsert = "const listInsert = (list, idx, value) => {\n    const index = listIndex(idx, list.value.length + 1);\n    if (index === -1) {\n        return;\n    }\n    list.value.splice(index, 0, value);\n    list._monitorUpToDate = false;\n}";
/**
 * Delete a value from a list.
 * @param {import('../engine/variable')} list The list.
 * @param {*} idx The Scratch index in the list.
 */

runtimeFunctions.listDelete = "const listDelete = (list, idx) => {\n    if (idx === 'all') {\n        list.value = [];\n        return;\n    }\n    const index = listIndex(idx, list.value.length);\n    if (index === -1) {\n        return;\n    }\n    list.value.splice(index, 1);\n    list._monitorUpToDate = false;\n}";
/**
 * Return whether a list contains a value.
 * @param {import('../engine/variable')} list The list.
 * @param {*} item The value to search for.
 * @returns {boolean} True if the list contains the item
 */

runtimeFunctions.listContains = "const listContains = (list, item) => {\n    // TODO: evaluate whether indexOf is worthwhile here\n    if (list.value.indexOf(item) !== -1) {\n        return true;\n    }\n    for (let i = 0; i < list.value.length; i++) {\n        if (compareEqual(list.value[i], item)) {\n            return true;\n        }\n    }\n    return false;\n}";
/**
 * Find the 1-indexed index of an item in a list.
 * @param {import('../engine/variable')} list The list.
 * @param {*} item The item to search for
 * @returns {number} The 1-indexed index of the item in the list, otherwise 0
 */

runtimeFunctions.listIndexOf = "const listIndexOf = (list, item) => {\n    for (let i = 0; i < list.value.length; i++) {\n        if (compareEqual(list.value[i], item)) {\n            return i + 1;\n        }\n    }\n    return 0;\n}";
/**
 * Get the stringified form of a list.
 * @param {import('../engine/variable')} list The list.
 * @returns {string} Stringified form of the list.
 */

runtimeFunctions.listContents = "const listContents = list => {\n    for (let i = 0; i < list.value.length; i++) {\n        const listItem = list.value[i];\n        // this is an intentional break from what scratch 3 does to address our automatic string -> number conversions\n        // it fixes more than it breaks\n        if ((listItem + '').length !== 1) {\n            return list.value.join(' ');\n        }\n    }\n    return list.value.join('');\n}";
/**
 * Convert a color to an RGB list
 * @param {*} color The color value to convert
 * @return {Array.<number>} [r,g,b], values between 0-255.
 */

runtimeFunctions.colorToList = "const colorToList = color => globalState.Cast.toRgbColorList(color)";
/**
 * Implements Scratch modulo (floored division instead of truncated division)
 * @param {number} n Number
 * @param {number} modulus Base
 * @returns {number} n % modulus (floored division)
 */

runtimeFunctions.mod = "const mod = (n, modulus) => {\n    let result = n % modulus;\n    if (result / modulus < 0) result += modulus;\n    return result;\n}";
/**
 * Implements Scratch tangent.
 * @param {number} angle Angle in degrees.
 * @returns {number} value of tangent or Infinity or -Infinity
 */

runtimeFunctions.tan = "const tan = (angle) => {\n    switch (angle % 360) {\n    case -270: case 90: return Infinity;\n    case -90: case 270: return -Infinity;\n    }\n    return Math.round(Math.tan((Math.PI * angle) / 180) * 1e10) / 1e10;\n}";
/**
 * Step a compiled thread.
 * @param {Thread} thread The thread to step.
 */

const execute = thread => {
  globalState.thread = thread;
  thread.generator.next();
};

const insertRuntime = source => {
  let result = baseRuntime;

  for (const functionName of Object.keys(runtimeFunctions)) {
    if (source.includes(functionName)) {
      result += "".concat(runtimeFunctions[functionName], ";");
    }
  }

  result += "return ".concat(source);
  return result;
};
/**
 * Evaluate arbitrary JS in the context of the runtime.
 * @param {string} source The string to evaluate.
 * @returns {*} The result of evaluating the string.
 */


const scopedEval = source => {
  const withRuntime = insertRuntime(source);

  try {
    return new Function('globalState', withRuntime)(globalState);
  } catch (e) {
    globalState.log.error('was unable to compile script', withRuntime);
    throw e;
  }
};

execute.scopedEval = scopedEval;
execute.runtimeFunctions = runtimeFunctions;
module.exports = execute;

/***/ }),

/***/ "./src/compiler/jsgen.js":
/*!*******************************!*\
  !*** ./src/compiler/jsgen.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");

const Cast = __webpack_require__(/*! ../util/cast */ "./src/util/cast.js");

const VariablePool = __webpack_require__(/*! ./variable-pool */ "./src/compiler/variable-pool.js");

const jsexecute = __webpack_require__(/*! ./jsexecute */ "./src/compiler/jsexecute.js");

const environment = __webpack_require__(/*! ./environment */ "./src/compiler/environment.js"); // Imported for JSDoc types, not to actually use
// eslint-disable-next-line no-unused-vars


const {
  IntermediateScript,
  IntermediateRepresentation
} = __webpack_require__(/*! ./intermediate */ "./src/compiler/intermediate.js");
/**
 * @fileoverview Convert intermediate representations to JavaScript functions.
 */

/* eslint-disable max-len */

/* eslint-disable prefer-template */


const sanitize = string => {
  if (typeof string !== 'string') {
    log.warn("sanitize got unexpected type: ".concat(typeof string));
    string = '' + string;
  }

  return JSON.stringify(string).slice(1, -1);
};

const TYPE_NUMBER = 1;
const TYPE_STRING = 2;
const TYPE_BOOLEAN = 3;
const TYPE_UNKNOWN = 4;
const TYPE_NUMBER_NAN = 5; // Pen-related constants

const PEN_EXT = 'runtime.ext_pen';
const PEN_STATE = "".concat(PEN_EXT, "._getPenState(target)");
/**
 * Variable pool used for factory function names.
 */

const factoryNameVariablePool = new VariablePool('factory');
/**
 * Variable pool used for generated functions (non-generator)
 */

const functionNameVariablePool = new VariablePool('fun');
/**
 * Variable pool used for generated generator functions.
 */

const generatorNameVariablePool = new VariablePool('gen');
/**
 * @typedef Input
 * @property {() => string} asNumber
 * @property {() => string} asNumberOrNaN
 * @property {() => string} asString
 * @property {() => string} asBoolean
 * @property {() => string} asUnknown
 * @property {() => string} asSafe
 * @property {() => boolean} isAlwaysNumber
 * @property {() => boolean} isAlwaysNumberOrNaN
 * @property {() => boolean} isNeverNumber
 */

/**
 * @implements {Input}
 */

class TypedInput {
  constructor(source, type) {
    // for debugging
    if (typeof type !== 'number') throw new Error('type is invalid');
    this.source = source;
    this.type = type;
  }

  asNumber() {
    if (this.type === TYPE_NUMBER) return this.source;
    if (this.type === TYPE_NUMBER_NAN) return "(".concat(this.source, " || 0)");
    return "(+".concat(this.source, " || 0)");
  }

  asNumberOrNaN() {
    if (this.type === TYPE_NUMBER || this.type === TYPE_NUMBER_NAN) return this.source;
    return "(+".concat(this.source, ")");
  }

  asString() {
    if (this.type === TYPE_STRING) return this.source;
    return "(\"\" + ".concat(this.source, ")");
  }

  asBoolean() {
    if (this.type === TYPE_BOOLEAN) return this.source;
    return "toBoolean(".concat(this.source, ")");
  }

  asUnknown() {
    return this.source;
  }

  asSafe() {
    return this.asUnknown();
  }

  isAlwaysNumber() {
    return this.type === TYPE_NUMBER;
  }

  isAlwaysNumberOrNaN() {
    return this.type === TYPE_NUMBER || this.type === TYPE_NUMBER_NAN;
  }

  isNeverNumber() {
    return false;
  }

}
/**
 * @implements {Input}
 */


class ConstantInput {
  constructor(constantValue, safe) {
    this.constantValue = constantValue;
    this.safe = safe;
  }

  asNumber() {
    // Compute at compilation time
    const numberValue = +this.constantValue;

    if (numberValue) {
      // It's important that we use the number's stringified value and not the constant value
      // Using the constant value allows numbers such as "010" to be interpreted as 8 (or SyntaxError in strict mode) instead of 10.
      return numberValue.toString();
    } // numberValue is one of 0, -0, or NaN


    if (Object.is(numberValue, -0)) {
      return '-0';
    }

    return '0';
  }

  asNumberOrNaN() {
    return this.asNumber();
  }

  asString() {
    return "\"".concat(sanitize('' + this.constantValue), "\"");
  }

  asBoolean() {
    // Compute at compilation time
    return Cast.toBoolean(this.constantValue).toString();
  }

  asUnknown() {
    // Attempt to convert strings to numbers if it is unlikely to break things
    if (typeof this.constantValue === 'number') {
      // todo: handle NaN?
      return this.constantValue;
    }

    const numberValue = +this.constantValue;

    if (numberValue.toString() === this.constantValue) {
      return this.constantValue;
    }

    return this.asString();
  }

  asSafe() {
    if (this.safe) {
      return this.asUnknown();
    }

    return this.asString();
  }

  isAlwaysNumber() {
    const value = +this.constantValue;

    if (Number.isNaN(value)) {
      return false;
    } // Empty strings evaluate to 0 but should not be considered a number.


    if (value === 0) {
      return this.constantValue.toString().trim() !== '';
    }

    return true;
  }

  isAlwaysNumberOrNaN() {
    return this.isAlwaysNumber();
  }

  isNeverNumber() {
    return Number.isNaN(+this.constantValue);
  }

}
/**
 * @implements {Input}
 */


class VariableInput {
  constructor(source) {
    this.source = source;
    this.type = TYPE_UNKNOWN;
    /**
     * The value this variable was most recently set to, if any.
     * @type {Input}
     * @private
     */

    this._value = null;
  }
  /**
   * @param {Input} input The input this variable was most recently set to.
   */


  setInput(input) {
    if (input instanceof VariableInput) {
      // When being set to another variable, extract the value it was set to.
      // Otherwise, you may end up with infinite recursion in analysis methods when a variable is set to itself.
      if (input._value) {
        input = input._value;
      } else {
        this.type = TYPE_UNKNOWN;
        this._value = null;
        return;
      }
    }

    this._value = input;

    if (input instanceof TypedInput) {
      this.type = input.type;
    } else {
      this.type = TYPE_UNKNOWN;
    }
  }

  asNumber() {
    if (this.type === TYPE_NUMBER) return this.source;
    if (this.type === TYPE_NUMBER_NAN) return "(".concat(this.source, " || 0)");
    return "(+".concat(this.source, " || 0)");
  }

  asNumberOrNaN() {
    if (this.type === TYPE_NUMBER || this.type === TYPE_NUMBER_NAN) return this.source;
    return "(+".concat(this.source, ")");
  }

  asString() {
    if (this.type === TYPE_STRING) return this.source;
    return "(\"\" + ".concat(this.source, ")");
  }

  asBoolean() {
    if (this.type === TYPE_BOOLEAN) return this.source;
    return "toBoolean(".concat(this.source, ")");
  }

  asUnknown() {
    return this.source;
  }

  asSafe() {
    return this.asUnknown();
  }

  isAlwaysNumber() {
    if (this._value) {
      return this._value.isAlwaysNumber();
    }

    return false;
  }

  isAlwaysNumberOrNaN() {
    if (this._value) {
      return this._value.isAlwaysNumberOrNaN();
    }

    return false;
  }

  isNeverNumber() {
    if (this._value) {
      return this._value.isNeverNumber();
    }

    return false;
  }

}

const getNamesOfCostumesAndSounds = runtime => {
  const result = new Set();

  for (const target of runtime.targets) {
    if (target.isOriginal) {
      const sprite = target.sprite;

      for (const costume of sprite.costumes) {
        result.add(costume.name);
      }

      for (const sound of sprite.sounds) {
        result.add(sound.name);
      }
    }
  }

  return result;
};

const isSafeConstantForEqualsOptimization = input => {
  const numberValue = +input.constantValue; // Do not optimize 0

  if (!numberValue) {
    return false;
  } // Do not optimize numbers when the original form does not match


  return numberValue.toString() === input.constantValue.toString();
};
/**
 * A frame contains some information about the current substack being compiled.
 */


class Frame {
  constructor(isLoop) {
    /**
     * Whether the current stack runs in a loop (while, for)
     * @type {boolean}
     * @readonly
     */
    this.isLoop = isLoop;
    /**
     * Whether the current block is the last block in the stack.
     * @type {boolean}
     */

    this.isLastBlock = false;
  }

}

class JSGenerator {
  /**
   * @param {IntermediateScript} script
   * @param {IntermediateRepresentation} ir
   * @param {Target} target
   */
  constructor(script, ir, target) {
    this.script = script;
    this.ir = ir;
    this.target = target;
    this.source = '';
    /**
     * @type {Object.<string, VariableInput>}
     */

    this.variableInputs = {};
    this.isWarp = script.isWarp;
    this.isProcedure = script.isProcedure;
    this.warpTimer = script.warpTimer;
    /**
     * Stack of frames, most recent is last item.
     * @type {Frame[]}
     */

    this.frames = [];
    /**
     * The current Frame.
     * @type {Frame}
     */

    this.currentFrame = null;
    this.namesOfCostumesAndSounds = getNamesOfCostumesAndSounds(target.runtime);
    this.localVariables = new VariablePool('a');
    this._setupVariablesPool = new VariablePool('b');
    this._setupVariables = {};
    this.descendedIntoModulo = false;
    this.debug = this.target.runtime.debug;
  }
  /**
   * Enter a new frame
   * @param {Frame} frame New frame.
   */


  pushFrame(frame) {
    this.frames.push(frame);
    this.currentFrame = frame;
  }
  /**
   * Exit the current frame
   */


  popFrame() {
    this.frames.pop();
    this.currentFrame = this.frames[this.frames.length - 1];
  }
  /**
   * @returns {boolean} true if the current block is the last command of a loop
   */


  isLastBlockInLoop() {
    for (let i = this.frames.length - 1; i >= 0; i--) {
      const frame = this.frames[i];

      if (!frame.isLastBlock) {
        return false;
      }

      if (frame.isLoop) {
        return true;
      }
    }

    return false;
  }
  /**
   * @param {object} node Input node to compile.
   * @returns {Input} Compiled input.
   */


  descendInput(node) {
    switch (node.kind) {
      case 'args.boolean':
        return new TypedInput("toBoolean(p".concat(node.index, ")"), TYPE_BOOLEAN);

      case 'args.stringNumber':
        return new TypedInput("p".concat(node.index), TYPE_UNKNOWN);

      case 'compat':
        // Compatibility layer inputs never use flags.
        return new TypedInput("(".concat(this.generateCompatibilityLayerCall(node, false), ")"), TYPE_UNKNOWN);

      case 'constant':
        return this.safeConstantInput(node.value);

      case 'keyboard.pressed':
        return new TypedInput("runtime.ioDevices.keyboard.getKeyIsDown(".concat(this.descendInput(node.key).asSafe(), ")"), TYPE_BOOLEAN);

      case 'list.contains':
        return new TypedInput("listContains(".concat(this.referenceVariable(node.list), ", ").concat(this.descendInput(node.item).asUnknown(), ")"), TYPE_BOOLEAN);

      case 'list.contents':
        return new TypedInput("listContents(".concat(this.referenceVariable(node.list), ")"), TYPE_STRING);

      case 'list.get':
        {
          const index = this.descendInput(node.index);

          if (environment.supportsNullishCoalescing) {
            if (index.isAlwaysNumberOrNaN()) {
              return new TypedInput("(".concat(this.referenceVariable(node.list), ".value[(").concat(index.asNumber(), " | 0) - 1] ?? \"\")"), TYPE_UNKNOWN);
            }

            if (index instanceof ConstantInput && index.constantValue === 'last') {
              return new TypedInput("(".concat(this.referenceVariable(node.list), ".value[").concat(this.referenceVariable(node.list), ".value.length - 1] ?? \"\")"), TYPE_UNKNOWN);
            }
          }

          return new TypedInput("listGet(".concat(this.referenceVariable(node.list), ".value, ").concat(index.asUnknown(), ")"), TYPE_UNKNOWN);
        }

      case 'list.indexOf':
        return new TypedInput("listIndexOf(".concat(this.referenceVariable(node.list), ", ").concat(this.descendInput(node.item).asUnknown(), ")"), TYPE_NUMBER);

      case 'list.length':
        return new TypedInput("".concat(this.referenceVariable(node.list), ".value.length"), TYPE_NUMBER);

      case 'looks.size':
        return new TypedInput('Math.round(target.size)', TYPE_NUMBER);

      case 'looks.backdropName':
        return new TypedInput('stage.getCostumes()[stage.currentCostume].name', TYPE_STRING);

      case 'looks.backdropNumber':
        return new TypedInput('(stage.currentCostume + 1)', TYPE_NUMBER);

      case 'looks.costumeName':
        return new TypedInput('target.getCostumes()[target.currentCostume].name', TYPE_STRING);

      case 'looks.costumeNumber':
        return new TypedInput('(target.currentCostume + 1)', TYPE_NUMBER);

      case 'motion.direction':
        return new TypedInput('target.direction', TYPE_NUMBER);

      case 'motion.x':
        return new TypedInput('limitPrecision(target.x)', TYPE_NUMBER);

      case 'motion.y':
        return new TypedInput('limitPrecision(target.y)', TYPE_NUMBER);

      case 'mouse.down':
        return new TypedInput('runtime.ioDevices.mouse.getIsDown()', TYPE_BOOLEAN);

      case 'mouse.x':
        return new TypedInput('runtime.ioDevices.mouse.getScratchX()', TYPE_NUMBER);

      case 'mouse.y':
        return new TypedInput('runtime.ioDevices.mouse.getScratchY()', TYPE_NUMBER);

      case 'op.abs':
        return new TypedInput("Math.abs(".concat(this.descendInput(node.value).asNumber(), ")"), TYPE_NUMBER);

      case 'op.acos':
        // Needs to be marked as NaN because Math.acos(1.0001) === NaN
        return new TypedInput("((Math.acos(".concat(this.descendInput(node.value).asNumber(), ") * 180) / Math.PI)"), TYPE_NUMBER_NAN);

      case 'op.add':
        // Needs to be marked as NaN because Infinity + -Infinity === NaN
        return new TypedInput("(".concat(this.descendInput(node.left).asNumber(), " + ").concat(this.descendInput(node.right).asNumber(), ")"), TYPE_NUMBER_NAN);

      case 'op.and':
        return new TypedInput("(".concat(this.descendInput(node.left).asBoolean(), " && ").concat(this.descendInput(node.right).asBoolean(), ")"), TYPE_BOOLEAN);

      case 'op.asin':
        // Needs to be marked as NaN because Math.asin(1.0001) === NaN
        return new TypedInput("((Math.asin(".concat(this.descendInput(node.value).asNumber(), ") * 180) / Math.PI)"), TYPE_NUMBER_NAN);

      case 'op.atan':
        return new TypedInput("((Math.atan(".concat(this.descendInput(node.value).asNumber(), ") * 180) / Math.PI)"), TYPE_NUMBER);

      case 'op.ceiling':
        return new TypedInput("Math.ceil(".concat(this.descendInput(node.value).asNumber(), ")"), TYPE_NUMBER);

      case 'op.contains':
        return new TypedInput("(".concat(this.descendInput(node.string).asString(), ".toLowerCase().indexOf(").concat(this.descendInput(node.contains).asString(), ".toLowerCase()) !== -1)"), TYPE_BOOLEAN);

      case 'op.cos':
        return new TypedInput("(Math.round(Math.cos((Math.PI * ".concat(this.descendInput(node.value).asNumber(), ") / 180) * 1e10) / 1e10)"), TYPE_NUMBER);

      case 'op.divide':
        // Needs to be marked as NaN because 0 / 0 === NaN
        return new TypedInput("(".concat(this.descendInput(node.left).asNumber(), " / ").concat(this.descendInput(node.right).asNumber(), ")"), TYPE_NUMBER_NAN);

      case 'op.equals':
        {
          const left = this.descendInput(node.left);
          const right = this.descendInput(node.right); // When both operands are known to never be numbers, only use string comparison to avoid all number parsing.

          if (left.isNeverNumber() || right.isNeverNumber()) {
            return new TypedInput("(".concat(left.asString(), ".toLowerCase() === ").concat(right.asString(), ".toLowerCase())"), TYPE_BOOLEAN);
          }

          const leftAlwaysNumber = left.isAlwaysNumber();
          const rightAlwaysNumber = right.isAlwaysNumber(); // When both operands are known to be numbers, we can use ===

          if (leftAlwaysNumber && rightAlwaysNumber) {
            return new TypedInput("(".concat(left.asNumber(), " === ").concat(right.asNumber(), ")"), TYPE_BOOLEAN);
          } // In certain conditions, we can use === when one of the operands is known to be a safe number.


          if (leftAlwaysNumber && left instanceof ConstantInput && isSafeConstantForEqualsOptimization(left)) {
            return new TypedInput("(".concat(left.asNumber(), " === ").concat(right.asNumber(), ")"), TYPE_BOOLEAN);
          }

          if (rightAlwaysNumber && right instanceof ConstantInput && isSafeConstantForEqualsOptimization(right)) {
            return new TypedInput("(".concat(left.asNumber(), " === ").concat(right.asNumber(), ")"), TYPE_BOOLEAN);
          } // No compile-time optimizations possible - use fallback method.


          return new TypedInput("compareEqual(".concat(left.asUnknown(), ", ").concat(right.asUnknown(), ")"), TYPE_BOOLEAN);
        }

      case 'op.e^':
        return new TypedInput("Math.exp(".concat(this.descendInput(node.value).asNumber(), ")"), TYPE_NUMBER);

      case 'op.floor':
        return new TypedInput("Math.floor(".concat(this.descendInput(node.value).asNumber(), ")"), TYPE_NUMBER);

      case 'op.greater':
        {
          const left = this.descendInput(node.left);
          const right = this.descendInput(node.right); // When the left operand is a number and the right operand is a number or NaN, we can use >

          if (left.isAlwaysNumber() && right.isAlwaysNumberOrNaN()) {
            return new TypedInput("(".concat(left.asNumber(), " > ").concat(right.asNumberOrNaN(), ")"), TYPE_BOOLEAN);
          } // When the left operand is a number or NaN and the right operand is a number, we can negate <=


          if (left.isAlwaysNumberOrNaN() && right.isAlwaysNumber()) {
            return new TypedInput("!(".concat(left.asNumberOrNaN(), " <= ").concat(right.asNumber(), ")"), TYPE_BOOLEAN);
          } // When either operand is known to never be a number, avoid all number parsing.


          if (left.isNeverNumber() || right.isNeverNumber()) {
            return new TypedInput("(".concat(left.asString(), ".toLowerCase() > ").concat(right.asString(), ".toLowerCase())"), TYPE_BOOLEAN);
          } // No compile-time optimizations possible - use fallback method.


          return new TypedInput("compareGreaterThan(".concat(left.asUnknown(), ", ").concat(right.asUnknown(), ")"), TYPE_BOOLEAN);
        }

      case 'op.join':
        return new TypedInput("(".concat(this.descendInput(node.left).asString(), " + ").concat(this.descendInput(node.right).asString(), ")"), TYPE_STRING);

      case 'op.length':
        return new TypedInput("".concat(this.descendInput(node.string).asString(), ".length"), TYPE_NUMBER);

      case 'op.less':
        {
          const left = this.descendInput(node.left);
          const right = this.descendInput(node.right); // When the left operand is a number or NaN and the right operand is a number, we can use <

          if (left.isAlwaysNumberOrNaN() && right.isAlwaysNumber()) {
            return new TypedInput("(".concat(left.asNumberOrNaN(), " < ").concat(right.asNumber(), ")"), TYPE_BOOLEAN);
          } // When the left operand is a number and the right operand is a number or NaN, we can negate >=


          if (left.isAlwaysNumber() && right.isAlwaysNumberOrNaN()) {
            return new TypedInput("!(".concat(left.asNumber(), " >= ").concat(right.asNumberOrNaN(), ")"), TYPE_BOOLEAN);
          } // When either operand is known to never be a number, avoid all number parsing.


          if (left.isNeverNumber() || right.isNeverNumber()) {
            return new TypedInput("(".concat(left.asString(), ".toLowerCase() < ").concat(right.asString(), ".toLowerCase())"), TYPE_BOOLEAN);
          } // No compile-time optimizations possible - use fallback method.


          return new TypedInput("compareLessThan(".concat(left.asUnknown(), ", ").concat(right.asUnknown(), ")"), TYPE_BOOLEAN);
        }

      case 'op.letterOf':
        return new TypedInput("((".concat(this.descendInput(node.string).asString(), ")[(").concat(this.descendInput(node.letter).asNumber(), " | 0) - 1] || \"\")"), TYPE_STRING);

      case 'op.ln':
        // Needs to be marked as NaN because Math.log(-1) == NaN
        return new TypedInput("Math.log(".concat(this.descendInput(node.value).asNumber(), ")"), TYPE_NUMBER_NAN);

      case 'op.log':
        // Needs to be marked as NaN because Math.log(-1) == NaN
        return new TypedInput("(Math.log(".concat(this.descendInput(node.value).asNumber(), ") / Math.LN10)"), TYPE_NUMBER_NAN);

      case 'op.advlog':
        // Needs to be marked as NaN because Math.log(-1) == NaN
        return new TypedInput("(Math.log(".concat(this.descendInput(node.right).asNumber(), ") / (Math.log(").concat(this.descendInput(node.left).asNumber(), "))"), TYPE_NUMBER_NAN);

      case 'op.mod':
        this.descendedIntoModulo = true; // Needs to be marked as NaN because mod(0, 0) (and others) == NaN

        return new TypedInput("mod(".concat(this.descendInput(node.left).asNumber(), ", ").concat(this.descendInput(node.right).asNumber(), ")"), TYPE_NUMBER_NAN);

      case 'op.multiply':
        // Needs to be marked as NaN because Infinity * 0 === NaN
        return new TypedInput("(".concat(this.descendInput(node.left).asNumber(), " * ").concat(this.descendInput(node.right).asNumber(), ")"), TYPE_NUMBER_NAN);

      case 'op.not':
        return new TypedInput("!".concat(this.descendInput(node.operand).asBoolean()), TYPE_BOOLEAN);

      case 'op.or':
        return new TypedInput("(".concat(this.descendInput(node.left).asBoolean(), " || ").concat(this.descendInput(node.right).asBoolean(), ")"), TYPE_BOOLEAN);

      case 'op.random':
        if (node.useInts) {
          return new TypedInput("randomInt(".concat(this.descendInput(node.low).asNumber(), ", ").concat(this.descendInput(node.high).asNumber(), ")"), TYPE_NUMBER);
        }

        if (node.useFloats) {
          return new TypedInput("randomFloat(".concat(this.descendInput(node.low).asNumber(), ", ").concat(this.descendInput(node.high).asNumber(), ")"), TYPE_NUMBER);
        }

        return new TypedInput("runtime.ext_scratch3_operators._random(".concat(this.descendInput(node.low).asUnknown(), ", ").concat(this.descendInput(node.high).asUnknown(), ")"), TYPE_NUMBER);

      case 'op.round':
        return new TypedInput("Math.round(".concat(this.descendInput(node.value).asNumber(), ")"), TYPE_NUMBER);

      case 'op.sin':
        return new TypedInput("(Math.round(Math.sin((Math.PI * ".concat(this.descendInput(node.value).asNumber(), ") / 180) * 1e10) / 1e10)"), TYPE_NUMBER);

      case 'op.sqrt':
        // Needs to be marked as NaN because Math.sqrt(-1) === NaN
        return new TypedInput("Math.sqrt(".concat(this.descendInput(node.value).asNumber(), ")"), TYPE_NUMBER_NAN);

      case 'op.subtract':
        // Needs to be marked as NaN because Infinity - Infinity === NaN
        return new TypedInput("(".concat(this.descendInput(node.left).asNumber(), " - ").concat(this.descendInput(node.right).asNumber(), ")"), TYPE_NUMBER_NAN);

      case 'op.tan':
        return new TypedInput("tan(".concat(this.descendInput(node.value).asNumber(), ")"), TYPE_NUMBER);

      case 'op.10^':
        return new TypedInput("(10 ** ".concat(this.descendInput(node.value).asNumber(), ")"), TYPE_NUMBER);

      case 'sensing.answer':
        return new TypedInput("runtime.ext_scratch3_sensing._answer", TYPE_STRING);

      case 'sensing.colorTouchingColor':
        return new TypedInput("target.colorIsTouchingColor(colorToList(".concat(this.descendInput(node.target).asUnknown(), "), colorToList(").concat(this.descendInput(node.mask).asUnknown(), "))"), TYPE_BOOLEAN);

      case 'sensing.date':
        return new TypedInput("(new Date().getDate())", TYPE_NUMBER);

      case 'sensing.dayofweek':
        return new TypedInput("(new Date().getDay() + 1)", TYPE_NUMBER);

      case 'sensing.daysSince2000':
        return new TypedInput('daysSince2000()', TYPE_NUMBER);

      case 'sensing.distance':
        // TODO: on stages, this can be computed at compile time
        return new TypedInput("distance(".concat(this.descendInput(node.target).asString(), ")"), TYPE_NUMBER);

      case 'sensing.hour':
        return new TypedInput("(new Date().getHours())", TYPE_NUMBER);

      case 'sensing.minute':
        return new TypedInput("(new Date().getMinutes())", TYPE_NUMBER);

      case 'sensing.month':
        return new TypedInput("(new Date().getMonth() + 1)", TYPE_NUMBER);

      case 'sensing.of':
        {
          const object = this.descendInput(node.object).asString();
          const property = node.property;

          if (node.object.kind === 'constant') {
            const isStage = node.object.value === '_stage_'; // Note that if target isn't a stage, we can't assume it exists

            const objectReference = isStage ? 'stage' : this.evaluateOnce("runtime.getSpriteTargetByName(".concat(object, ")"));

            if (property === 'volume') {
              return new TypedInput("(".concat(objectReference, " ? ").concat(objectReference, ".volume : 0)"), TYPE_NUMBER);
            }

            if (isStage) {
              switch (property) {
                case 'background #': // fallthrough for scratch 1.0 compatibility

                case 'backdrop #':
                  return new TypedInput("(".concat(objectReference, ".currentCostume + 1)"), TYPE_NUMBER);

                case 'backdrop name':
                  return new TypedInput("".concat(objectReference, ".getCostumes()[").concat(objectReference, ".currentCostume].name"), TYPE_STRING);
              }
            } else {
              switch (property) {
                case 'x position':
                  return new TypedInput("(".concat(objectReference, " ? ").concat(objectReference, ".x : 0)"), TYPE_NUMBER);

                case 'y position':
                  return new TypedInput("(".concat(objectReference, " ? ").concat(objectReference, ".y : 0)"), TYPE_NUMBER);

                case 'direction':
                  return new TypedInput("(".concat(objectReference, " ? ").concat(objectReference, ".direction : 0)"), TYPE_NUMBER);

                case 'costume #':
                  return new TypedInput("(".concat(objectReference, " ? ").concat(objectReference, ".currentCostume + 1 : 0)"), TYPE_NUMBER);

                case 'costume name':
                  return new TypedInput("(".concat(objectReference, " ? ").concat(objectReference, ".getCostumes()[").concat(objectReference, ".currentCostume].name : 0)"), TYPE_UNKNOWN);

                case 'size':
                  return new TypedInput("(".concat(objectReference, " ? ").concat(objectReference, ".size : 0)"), TYPE_NUMBER);
              }
            }

            const variableReference = this.evaluateOnce("".concat(objectReference, " && ").concat(objectReference, ".lookupVariableByNameAndType(\"").concat(sanitize(property), "\", \"\", true)"));
            return new TypedInput("(".concat(variableReference, " ? ").concat(variableReference, ".value : 0)"), TYPE_UNKNOWN);
          }

          return new TypedInput("runtime.ext_scratch3_sensing.getAttributeOf({OBJECT: ".concat(object, ", PROPERTY: \"").concat(sanitize(property), "\" })"), TYPE_UNKNOWN);
        }

      case 'sensing.second':
        return new TypedInput("(new Date().getSeconds())", TYPE_NUMBER);

      case 'sensing.touching':
        return new TypedInput("target.isTouchingObject(".concat(this.descendInput(node.object).asUnknown(), ")"), TYPE_BOOLEAN);

      case 'sensing.touchingColor':
        return new TypedInput("target.isTouchingColor(colorToList(".concat(this.descendInput(node.color).asUnknown(), "))"), TYPE_BOOLEAN);

      case 'sensing.username':
        return new TypedInput('runtime.ioDevices.userData.getUsername()', TYPE_STRING);

      case 'sensing.year':
        return new TypedInput("(new Date().getFullYear())", TYPE_NUMBER);

      case 'timer.get':
        return new TypedInput('runtime.ioDevices.clock.projectTimer()', TYPE_NUMBER);

      case 'tw.lastKeyPressed':
        return new TypedInput('runtime.ioDevices.keyboard.getLastKeyPressed()', TYPE_STRING);

      case 'var.get':
        return this.descendVariable(node.variable);

      default:
        log.warn("JS: Unknown input: ".concat(node.kind), node);
        throw new Error("JS: Unknown input: ".concat(node.kind));
    }
  }
  /**
   * @param {*} node Stacked node to compile.
   */


  descendStackedBlock(node) {
    switch (node.kind) {
      case 'addons.call':
        this.source += "yield* callAddonBlock(\"".concat(sanitize(node.code), "\",\"").concat(sanitize(node.blockId), "\",{");
        this.yielded();

        for (const argumentName of Object.keys(node.arguments)) {
          const argumentValue = node.arguments[argumentName];
          this.source += "\"".concat(sanitize(argumentName), "\":").concat(this.descendInput(argumentValue).asSafe(), ",");
        }

        this.source += '});\n';
        break;

      case 'compat':
        {
          // If the last command in a loop returns a promise, immediately continue to the next iteration.
          // If you don't do this, the loop effectively yields twice per iteration and will run at half-speed.
          const isLastInLoop = this.isLastBlockInLoop();
          this.source += "".concat(this.generateCompatibilityLayerCall(node, isLastInLoop), ";\n");

          if (isLastInLoop) {
            this.source += 'if (hasResumedFromPromise) {hasResumedFromPromise = false;continue;}\n';
          }

          break;
        }

      case 'control.createClone':
        this.source += "runtime.ext_scratch3_control._createClone(".concat(this.descendInput(node.target).asString(), ", target);\n");
        break;

      case 'control.deleteClone':
        this.source += 'if (!target.isOriginal) {\n';
        this.source += '  runtime.disposeTarget(target);\n';
        this.source += '  runtime.stopForTarget(target);\n';
        this.retire();
        this.source += '}\n';
        break;

      case 'control.for':
        {
          this.resetVariableInputs();
          const index = this.localVariables.next();
          this.source += "var ".concat(index, " = 0; ");
          this.source += "while (".concat(index, " < ").concat(this.descendInput(node.count).asNumber(), ") { ");
          this.source += "".concat(index, "++; ");
          this.source += "".concat(this.referenceVariable(node.variable), ".value = ").concat(index, ";\n");
          this.descendStack(node.do, new Frame(true));
          this.yieldLoop();
          this.source += '}\n';
          break;
        }

      case 'control.if':
        this.source += "if (".concat(this.descendInput(node.condition).asBoolean(), ") {\n");
        this.descendStack(node.whenTrue, new Frame(false)); // only add the else branch if it won't be empty
        // this makes scripts have a bit less useless noise in them

        if (node.whenFalse.length) {
          this.source += "} else {\n";
          this.descendStack(node.whenFalse, new Frame(false));
        }

        this.source += "}\n";
        break;

      case 'control.repeat':
        {
          const i = this.localVariables.next();
          this.source += "for (var ".concat(i, " = ").concat(this.descendInput(node.times).asNumber(), "; ").concat(i, " >= 0.5; ").concat(i, "--) {\n");
          this.descendStack(node.do, new Frame(true));
          this.yieldLoop();
          this.source += "}\n";
          break;
        }

      case 'control.stopAll':
        this.source += 'runtime.stopAll();\n';
        this.retire();
        break;

      case 'control.stopOthers':
        this.source += 'runtime.stopForTarget(target, thread);\n';
        break;

      case 'control.stopScript':
        if (this.isProcedure) {
          this.source += 'return;\n';
        } else {
          this.retire();
        }

        break;

      case 'control.wait':
        {
          const duration = this.localVariables.next();
          this.source += "thread.timer = timer();\n";
          this.source += "var ".concat(duration, " = Math.max(0, 1000 * ").concat(this.descendInput(node.seconds).asNumber(), ");\n");
          this.requestRedraw(); // always yield at least once, even on 0 second durations

          this.yieldNotWarp();
          this.source += "while (thread.timer.timeElapsed() < ".concat(duration, ") {\n");
          this.yieldStuckOrNotWarp();
          this.source += '}\n';
          this.source += 'thread.timer = null;\n';
          break;
        }

      case 'control.waitUntil':
        {
          this.resetVariableInputs();
          this.source += "while (!".concat(this.descendInput(node.condition).asBoolean(), ") {\n");
          this.yieldStuckOrNotWarp();
          this.source += "}\n";
          break;
        }

      case 'control.while':
        this.resetVariableInputs();
        this.source += "while (".concat(this.descendInput(node.condition).asBoolean(), ") {\n");
        this.descendStack(node.do, new Frame(true));

        if (node.warpTimer) {
          this.yieldStuckOrNotWarp();
        } else {
          this.yieldLoop();
        }

        this.source += "}\n";
        break;

      case 'event.broadcast':
        this.source += "startHats(\"event_whenbroadcastreceived\", { BROADCAST_OPTION: ".concat(this.descendInput(node.broadcast).asString(), " });\n");
        this.resetVariableInputs();
        break;

      case 'event.broadcastAndWait':
        this.source += "yield* waitThreads(startHats(\"event_whenbroadcastreceived\", { BROADCAST_OPTION: ".concat(this.descendInput(node.broadcast).asString(), " }));\n");
        this.yielded();
        break;

      case 'list.add':
        {
          const list = this.referenceVariable(node.list);
          this.source += "".concat(list, ".value.push(").concat(this.descendInput(node.item).asSafe(), ");\n");
          this.source += "".concat(list, "._monitorUpToDate = false;\n");
          break;
        }

      case 'list.delete':
        {
          const list = this.referenceVariable(node.list);
          const index = this.descendInput(node.index);

          if (index instanceof ConstantInput) {
            if (index.constantValue === 'last') {
              this.source += "".concat(list, ".value.pop();\n");
              this.source += "".concat(list, "._monitorUpToDate = false;\n");
              break;
            }

            if (+index.constantValue === 1) {
              this.source += "".concat(list, ".value.shift();\n");
              this.source += "".concat(list, "._monitorUpToDate = false;\n");
              break;
            } // do not need a special case for all as that is handled in IR generation (list.deleteAll)

          }

          this.source += "listDelete(".concat(list, ", ").concat(index.asUnknown(), ");\n");
          break;
        }

      case 'list.deleteAll':
        this.source += "".concat(this.referenceVariable(node.list), ".value = [];\n");
        break;

      case 'list.hide':
        this.source += "runtime.monitorBlocks.changeBlock({ id: \"".concat(sanitize(node.list.id), "\", element: \"checkbox\", value: false }, runtime);\n");
        break;

      case 'list.insert':
        {
          const list = this.referenceVariable(node.list);
          const index = this.descendInput(node.index);
          const item = this.descendInput(node.item);

          if (index instanceof ConstantInput && +index.constantValue === 1) {
            this.source += "".concat(list, ".value.unshift(").concat(item.asSafe(), ");\n");
            this.source += "".concat(list, "._monitorUpToDate = false;\n");
            break;
          }

          this.source += "listInsert(".concat(list, ", ").concat(index.asUnknown(), ", ").concat(item.asSafe(), ");\n");
          break;
        }

      case 'list.replace':
        this.source += "listReplace(".concat(this.referenceVariable(node.list), ", ").concat(this.descendInput(node.index).asUnknown(), ", ").concat(this.descendInput(node.item).asSafe(), ");\n");
        break;

      case 'list.show':
        this.source += "runtime.monitorBlocks.changeBlock({ id: \"".concat(sanitize(node.list.id), "\", element: \"checkbox\", value: true }, runtime);\n");
        break;

      case 'looks.backwardLayers':
        if (!this.target.isStage) {
          this.source += "target.goBackwardLayers(".concat(this.descendInput(node.layers).asNumber(), ");\n");
        }

        break;

      case 'looks.clearEffects':
        this.source += 'target.clearEffects();\n';
        break;

      case 'looks.changeEffect':
        if (this.target.effects.hasOwnProperty(node.effect)) {
          this.source += "target.setEffect(\"".concat(sanitize(node.effect), "\", runtime.ext_scratch3_looks.clampEffect(\"").concat(sanitize(node.effect), "\", ").concat(this.descendInput(node.value).asNumber(), " + target.effects[\"").concat(sanitize(node.effect), "\"]));\n");
        }

        break;

      case 'looks.changeSize':
        this.source += "target.setSize(target.size + ".concat(this.descendInput(node.size).asNumber(), ");\n");
        break;

      case 'looks.forwardLayers':
        if (!this.target.isStage) {
          this.source += "target.goForwardLayers(".concat(this.descendInput(node.layers).asNumber(), ");\n");
        }

        break;

      case 'looks.goToBack':
        if (!this.target.isStage) {
          this.source += 'target.goToBack();\n';
        }

        break;

      case 'looks.goToFront':
        if (!this.target.isStage) {
          this.source += 'target.goToFront();\n';
        }

        break;

      case 'looks.hide':
        this.source += 'target.setVisible(false);\n';
        this.source += 'runtime.ext_scratch3_looks._renderBubble(target);\n';
        break;

      case 'looks.nextBackdrop':
        this.source += 'runtime.ext_scratch3_looks._setBackdrop(stage, stage.currentCostume + 1, true);\n';
        break;

      case 'looks.nextCostume':
        this.source += 'target.setCostume(target.currentCostume + 1);\n';
        break;

      case 'looks.setEffect':
        if (this.target.effects.hasOwnProperty(node.effect)) {
          this.source += "target.setEffect(\"".concat(sanitize(node.effect), "\", runtime.ext_scratch3_looks.clampEffect(\"").concat(sanitize(node.effect), "\", ").concat(this.descendInput(node.value).asNumber(), "));\n");
        }

        break;

      case 'looks.setSize':
        this.source += "target.setSize(".concat(this.descendInput(node.size).asNumber(), ");\n");
        break;

      case 'looks.show':
        this.source += 'target.setVisible(true);\n';
        this.source += 'runtime.ext_scratch3_looks._renderBubble(target);\n';
        break;

      case 'looks.switchBackdrop':
        this.source += "runtime.ext_scratch3_looks._setBackdrop(stage, ".concat(this.descendInput(node.backdrop).asSafe(), ");\n");
        break;

      case 'looks.switchCostume':
        this.source += "runtime.ext_scratch3_looks._setCostume(target, ".concat(this.descendInput(node.costume).asSafe(), ");\n");
        break;

      case 'motion.changeX':
        this.source += "target.setXY(target.x + ".concat(this.descendInput(node.dx).asNumber(), ", target.y);\n");
        break;

      case 'motion.changeY':
        this.source += "target.setXY(target.x, target.y + ".concat(this.descendInput(node.dy).asNumber(), ");\n");
        break;

      case 'motion.ifOnEdgeBounce':
        this.source += "runtime.ext_scratch3_motion._ifOnEdgeBounce(target);\n";
        break;

      case 'motion.setDirection':
        this.source += "target.setDirection(".concat(this.descendInput(node.direction).asNumber(), ");\n");
        break;

      case 'motion.setRotationStyle':
        this.source += "target.setRotationStyle(\"".concat(sanitize(node.style), "\");\n");
        break;

      case 'motion.setX': // fallthrough

      case 'motion.setY': // fallthrough

      case 'motion.setXY':
        {
          this.descendedIntoModulo = false;
          const x = 'x' in node ? this.descendInput(node.x).asNumber() : 'target.x';
          const y = 'y' in node ? this.descendInput(node.y).asNumber() : 'target.y';
          this.source += "target.setXY(".concat(x, ", ").concat(y, ");\n");

          if (this.descendedIntoModulo) {
            this.source += "if (target.interpolationData) target.interpolationData = null;\n";
          }

          break;
        }

      case 'motion.step':
        this.source += "runtime.ext_scratch3_motion._moveSteps(".concat(this.descendInput(node.steps).asNumber(), ", target);\n");
        break;

      case 'noop':
        // todo: remove noop entirely
        break;

      case 'pen.clear':
        this.source += "".concat(PEN_EXT, ".clear();\n");
        break;

      case 'pen.down':
        this.source += "".concat(PEN_EXT, "._penDown(target);\n");
        break;

      case 'pen.changeParam':
        this.source += "".concat(PEN_EXT, "._setOrChangeColorParam(").concat(this.descendInput(node.param).asString(), ", ").concat(this.descendInput(node.value).asNumber(), ", ").concat(PEN_STATE, ", true);\n");
        break;

      case 'pen.changeSize':
        this.source += "".concat(PEN_EXT, "._changePenSizeBy(").concat(this.descendInput(node.size).asNumber(), ", target);\n");
        break;

      case 'pen.legacyChangeHue':
        this.source += "".concat(PEN_EXT, "._changePenHueBy(").concat(this.descendInput(node.hue).asNumber(), ", target);\n");
        break;

      case 'pen.legacyChangeShade':
        this.source += "".concat(PEN_EXT, "._changePenShadeBy(").concat(this.descendInput(node.shade).asNumber(), ", target);\n");
        break;

      case 'pen.legacySetHue':
        this.source += "".concat(PEN_EXT, "._setPenHueToNumber(").concat(this.descendInput(node.hue).asNumber(), ", target);\n");
        break;

      case 'pen.legacySetShade':
        this.source += "".concat(PEN_EXT, "._setPenShadeToNumber(").concat(this.descendInput(node.shade).asNumber(), ", target);\n");
        break;

      case 'pen.setColor':
        this.source += "".concat(PEN_EXT, "._setPenColorToColor(").concat(this.descendInput(node.color).asUnknown(), ", target);\n");
        break;

      case 'pen.setParam':
        this.source += "".concat(PEN_EXT, "._setOrChangeColorParam(").concat(this.descendInput(node.param).asString(), ", ").concat(this.descendInput(node.value).asNumber(), ", ").concat(PEN_STATE, ", false);\n");
        break;

      case 'pen.setSize':
        this.source += "".concat(PEN_EXT, "._setPenSizeTo(").concat(this.descendInput(node.size).asNumber(), ", target);\n");
        break;

      case 'pen.stamp':
        this.source += "".concat(PEN_EXT, "._stamp(target);\n");
        break;

      case 'pen.up':
        this.source += "".concat(PEN_EXT, "._penUp(target);\n");
        break;

      case 'procedures.call':
        {
          const procedureCode = node.code;
          const procedureVariant = node.variant; // Do not generate any code for empty procedures.

          const procedureData = this.ir.procedures[procedureVariant];

          if (procedureData.stack === null) {
            break;
          }

          if (!this.isWarp && procedureCode === this.script.procedureCode) {
            // Direct recursion yields.
            this.yieldNotWarp();
          }

          if (procedureData.yields) {
            this.source += 'yield* ';

            if (!this.script.yields) {
              throw new Error('Script uses yielding procedure but is not marked as yielding.');
            }
          }

          this.source += "thread.procedures[\"".concat(sanitize(procedureVariant), "\"]("); // Only include arguments if the procedure accepts any.

          if (procedureData.arguments.length) {
            const args = [];

            for (const input of node.arguments) {
              args.push(this.descendInput(input).asSafe());
            }

            this.source += args.join(',');
          }

          this.source += ");\n"; // Variable input types may have changes after a procedure call.

          this.resetVariableInputs();
          break;
        }

      case 'timer.reset':
        this.source += 'runtime.ioDevices.clock.resetProjectTimer();\n';
        break;

      case 'tw.debugger':
        this.source += 'debugger;\n';
        break;

      case 'var.hide':
        this.source += "runtime.monitorBlocks.changeBlock({ id: \"".concat(sanitize(node.variable.id), "\", element: \"checkbox\", value: false }, runtime);\n");
        break;

      case 'var.set':
        {
          const variable = this.descendVariable(node.variable);
          const value = this.descendInput(node.value);
          variable.setInput(value);
          this.source += "".concat(variable.source, " = ").concat(value.asSafe(), ";\n");

          if (node.variable.isCloud) {
            this.source += "runtime.ioDevices.cloud.requestUpdateVariable(\"".concat(sanitize(node.variable.name), "\", ").concat(variable.source, ");\n");
          }

          break;
        }

      case 'var.show':
        this.source += "runtime.monitorBlocks.changeBlock({ id: \"".concat(sanitize(node.variable.id), "\", element: \"checkbox\", value: true }, runtime);\n");
        break;

      case 'visualReport':
        {
          const value = this.localVariables.next();
          this.source += "const ".concat(value, " = ").concat(this.descendInput(node.input).asUnknown(), ";"); // blocks like legacy no-ops can return a literal `undefined`

          this.source += "if (".concat(value, " !== undefined) runtime.visualReport(\"").concat(sanitize(this.script.topBlockId), "\", ").concat(value, ");\n");
          break;
        }

      default:
        log.warn("JS: Unknown stacked block: ".concat(node.kind), node);
        throw new Error("JS: Unknown stacked block: ".concat(node.kind));
    }
  }

  resetVariableInputs() {
    this.variableInputs = {};
  }

  descendStack(nodes, frame) {
    // Entering a stack -- all bets are off.
    // TODO: allow if/else to inherit values
    this.resetVariableInputs();
    this.pushFrame(frame);

    for (let i = 0; i < nodes.length; i++) {
      frame.isLastBlock = i === nodes.length - 1;
      this.descendStackedBlock(nodes[i]);
    } // Leaving a stack -- any assumptions made in the current stack do not apply outside of it
    // TODO: in if/else this might create an extra unused object


    this.resetVariableInputs();
    this.popFrame();
  }

  descendVariable(variable) {
    if (this.variableInputs.hasOwnProperty(variable.id)) {
      return this.variableInputs[variable.id];
    }

    const input = new VariableInput("".concat(this.referenceVariable(variable), ".value"));
    this.variableInputs[variable.id] = input;
    return input;
  }

  referenceVariable(variable) {
    if (variable.scope === 'target') {
      return this.evaluateOnce("target.variables[\"".concat(sanitize(variable.id), "\"]"));
    }

    return this.evaluateOnce("stage.variables[\"".concat(sanitize(variable.id), "\"]"));
  }

  evaluateOnce(source) {
    if (this._setupVariables.hasOwnProperty(source)) {
      return this._setupVariables[source];
    }

    const variable = this._setupVariablesPool.next();

    this._setupVariables[source] = variable;
    return variable;
  }

  retire() {
    // After running retire() (sets thread status and cleans up some unused data), we need to return to the event loop.
    // When in a procedure, return will only send us back to the previous procedure, so instead we yield back to the sequencer.
    // Outside of a procedure, return will correctly bring us back to the sequencer.
    if (this.isProcedure) {
      this.source += 'retire(); yield;\n';
    } else {
      this.source += 'retire(); return;\n';
    }
  }

  yieldLoop() {
    if (this.warpTimer) {
      this.yieldStuckOrNotWarp();
    } else {
      this.yieldNotWarp();
    }
  }
  /**
   * Write JS to yield the current thread if warp mode is disabled.
   */


  yieldNotWarp() {
    if (!this.isWarp) {
      this.source += 'yield;\n';
      this.yielded();
    }
  }
  /**
   * Write JS to yield the current thread if warp mode is disabled or if the script seems to be stuck.
   */


  yieldStuckOrNotWarp() {
    if (this.isWarp) {
      this.source += 'if (isStuck()) yield;\n';
    } else {
      this.source += 'yield;\n';
    }

    this.yielded();
  }

  yielded() {
    if (!this.script.yields) {
      throw new Error('Script yielded but is not marked as yielding.');
    } // Control may have been yielded to another script -- all bets are off.


    this.resetVariableInputs();
  }
  /**
   * Write JS to request a redraw.
   */


  requestRedraw() {
    this.source += 'runtime.requestRedraw();\n';
  }

  safeConstantInput(value) {
    const unsafe = typeof value === 'string' && this.namesOfCostumesAndSounds.has(value);
    return new ConstantInput(value, !unsafe);
  }
  /**
   * Generate a call into the compatibility layer.
   * @param {*} node The "compat" kind node to generate from.
   * @param {boolean} setFlags Whether flags should be set describing how this function was processed.
   * @returns {string} The JS of the call.
   */


  generateCompatibilityLayerCall(node, setFlags) {
    const opcode = node.opcode;
    let result = 'yield* executeInCompatibilityLayer({';

    for (const inputName of Object.keys(node.inputs)) {
      const input = node.inputs[inputName];
      const compiledInput = this.descendInput(input).asSafe();
      result += "\"".concat(sanitize(inputName), "\":").concat(compiledInput, ",");
    }

    for (const fieldName of Object.keys(node.fields)) {
      const field = node.fields[fieldName];
      result += "\"".concat(sanitize(fieldName), "\":\"").concat(sanitize(field), "\",");
    }

    const opcodeFunction = this.evaluateOnce("runtime.getOpcodeFunction(\"".concat(sanitize(opcode), "\")"));
    result += "}, ".concat(opcodeFunction, ", ").concat(this.isWarp, ", ").concat(setFlags, ")");
    return result;
  }

  getScriptFactoryName() {
    return factoryNameVariablePool.next();
  }

  getScriptName(yields) {
    let name = yields ? generatorNameVariablePool.next() : functionNameVariablePool.next();

    if (this.isProcedure) {
      const simplifiedProcedureCode = this.script.procedureCode.replace(/%[\w]/g, '') // remove arguments
      .replace(/[^a-zA-Z0-9]/g, '_') // remove unsafe
      .substring(0, 20); // keep length reasonable

      name += "_".concat(simplifiedProcedureCode);
    }

    return name;
  }
  /**
   * Generate the JS to pass into eval() based on the current state of the compiler.
   * @returns {string} JS to pass into eval()
   */


  createScriptFactory() {
    let script = ''; // Setup the factory

    script += "(function ".concat(this.getScriptFactoryName(), "(thread) { ");
    script += 'const target = thread.target; ';
    script += 'const runtime = target.runtime; ';
    script += 'const stage = runtime.getTargetForStage();\n';

    for (const varValue of Object.keys(this._setupVariables)) {
      const varName = this._setupVariables[varValue];
      script += "const ".concat(varName, " = ").concat(varValue, ";\n");
    } // Generated script


    script += 'return ';

    if (this.script.yields) {
      script += "function* ";
    } else {
      script += "function ";
    }

    script += this.getScriptName(this.script.yields);
    script += ' (';

    if (this.script.arguments.length) {
      const args = [];

      for (let i = 0; i < this.script.arguments.length; i++) {
        args.push("p".concat(i));
      }

      script += args.join(',');
    }

    script += ') {\n';
    script += this.source;

    if (!this.isProcedure) {
      script += 'retire();\n';
    }

    script += '}; })';
    return script;
  }
  /**
   * Compile this script.
   * @returns {Function} The factory function for the script.
   */


  compile() {
    if (this.script.stack) {
      this.descendStack(this.script.stack, new Frame(false));
    }

    const factory = this.createScriptFactory();
    const fn = jsexecute.scopedEval(factory);

    if (this.debug) {
      log.info("JS: ".concat(this.target.getName(), ": compiled ").concat(this.script.procedureCode || 'script'), factory);
    }

    return fn;
  }

}

module.exports = JSGenerator;

/***/ }),

/***/ "./src/compiler/variable-pool.js":
/*!***************************************!*\
  !*** ./src/compiler/variable-pool.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

class VariablePool {
  /**
   * @param {string} prefix The prefix at the start of the variable name.
   */
  constructor(prefix) {
    if (prefix.trim().length === 0) {
      throw new Error('prefix cannot be empty');
    }

    this.prefix = prefix;
    /**
     * @private
     */

    this.count = 0;
  }

  next() {
    return "".concat(this.prefix).concat(this.count++);
  }

}

module.exports = VariablePool;

/***/ }),

/***/ "./src/dispatch/central-dispatch.js":
/*!******************************************!*\
  !*** ./src/dispatch/central-dispatch.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const SharedDispatch = __webpack_require__(/*! ./shared-dispatch */ "./src/dispatch/shared-dispatch.js");

const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");
/**
 * This class serves as the central broker for message dispatch. It expects to operate on the main thread / Window and
 * it must be informed of any Worker threads which will participate in the messaging system. From any context in the
 * messaging system, the dispatcher's "call" method can call any method on any "service" provided in any participating
 * context. The dispatch system will forward function arguments and return values across worker boundaries as needed.
 * @see {WorkerDispatch}
 */


class CentralDispatch extends SharedDispatch {
  constructor() {
    super();
    /**
     * Map of channel name to worker or local service provider.
     * If the entry is a Worker, the service is provided by an object on that worker.
     * Otherwise, the service is provided locally and methods on the service will be called directly.
     * @see {setService}
     * @type {object.<Worker|object>}
     */

    this.services = {};
    /**
     * The constructor we will use to recognize workers.
     * @type {Function}
     */

    this.workerClass = typeof Worker === 'undefined' ? null : Worker;
    /**
     * List of workers attached to this dispatcher.
     * @type {Array}
     */

    this.workers = [];
  }
  /**
   * Synchronously call a particular method on a particular service provided locally.
   * Calling this function on a remote service will fail.
   * @param {string} service - the name of the service.
   * @param {string} method - the name of the method.
   * @param {*} [args] - the arguments to be copied to the method, if any.
   * @returns {*} - the return value of the service method.
   */


  callSync(service, method) {
    const {
      provider,
      isRemote
    } = this._getServiceProvider(service);

    if (provider) {
      if (isRemote) {
        throw new Error("Cannot use 'callSync' on remote provider for service ".concat(service, "."));
      }

      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      return provider[method].apply(provider, args);
    }

    throw new Error("Provider not found for service: ".concat(service));
  }
  /**
   * Synchronously set a local object as the global provider of the specified service.
   * WARNING: Any method on the provider can be called from any worker within the dispatch system.
   * @param {string} service - a globally unique string identifying this service. Examples: 'vm', 'gui', 'extension9'.
   * @param {object} provider - a local object which provides this service.
   */


  setServiceSync(service, provider) {
    if (this.services.hasOwnProperty(service)) {
      log.warn("Central dispatch replacing existing service provider for ".concat(service));
    }

    this.services[service] = provider;
  }
  /**
   * Set a local object as the global provider of the specified service.
   * WARNING: Any method on the provider can be called from any worker within the dispatch system.
   * @param {string} service - a globally unique string identifying this service. Examples: 'vm', 'gui', 'extension9'.
   * @param {object} provider - a local object which provides this service.
   * @returns {Promise} - a promise which will resolve once the service is registered.
   */


  setService(service, provider) {
    /** Return a promise for consistency with {@link WorkerDispatch#setService} */
    try {
      this.setServiceSync(service, provider);
      return Promise.resolve();
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Add a worker to the message dispatch system. The worker must implement a compatible message dispatch framework.
   * The dispatcher will immediately attempt to "handshake" with the worker.
   * @param {Worker} worker - the worker to add into the dispatch system.
   */


  addWorker(worker) {
    if (this.workers.indexOf(worker) === -1) {
      this.workers.push(worker);
      worker.onmessage = this._onMessage.bind(this, worker);

      this._remoteCall(worker, 'dispatch', 'handshake').catch(e => {
        log.error("Could not handshake with worker: ".concat(e));
      });
    } else {
      log.warn('Central dispatch ignoring attempt to add duplicate worker');
    }
  }
  /**
   * Fetch the service provider object for a particular service name.
   * @override
   * @param {string} service - the name of the service to look up
   * @returns {{provider:(object|Worker), isRemote:boolean}} - the means to contact the service, if found
   * @protected
   */


  _getServiceProvider(service) {
    const provider = this.services[service];
    return provider && {
      provider,
      isRemote: Boolean(this.workerClass && provider instanceof this.workerClass || provider.isRemote)
    };
  }
  /**
   * Handle a call message sent to the dispatch service itself
   * @override
   * @param {Worker} worker - the worker which sent the message.
   * @param {DispatchCallMessage} message - the message to be handled.
   * @returns {Promise|undefined} - a promise for the results of this operation, if appropriate
   * @protected
   */


  _onDispatchMessage(worker, message) {
    let promise;

    switch (message.method) {
      case 'setService':
        promise = this.setService(message.args[0], worker);
        break;

      default:
        log.error("Central dispatch received message for unknown method: ".concat(message.method));
    }

    return promise;
  }

}

module.exports = new CentralDispatch();

/***/ }),

/***/ "./src/dispatch/shared-dispatch.js":
/*!*****************************************!*\
  !*** ./src/dispatch/shared-dispatch.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");
/**
 * @typedef {object} DispatchCallMessage - a message to the dispatch system representing a service method call
 * @property {*} responseId - send a response message with this response ID. See {@link DispatchResponseMessage}
 * @property {string} service - the name of the service to be called
 * @property {string} method - the name of the method to be called
 * @property {Array|undefined} args - the arguments to be passed to the method
 */

/**
 * @typedef {object} DispatchResponseMessage - a message to the dispatch system representing the results of a call
 * @property {*} responseId - a copy of the response ID from the call which generated this response
 * @property {*|undefined} error - if this is truthy, then it contains results from a failed call (such as an exception)
 * @property {*|undefined} result - if error is not truthy, then this contains the return value of the call (if any)
 */

/**
 * @typedef {DispatchCallMessage|DispatchResponseMessage} DispatchMessage
 * Any message to the dispatch system.
 */

/**
 * The SharedDispatch class is responsible for dispatch features shared by
 * {@link CentralDispatch} and {@link WorkerDispatch}.
 */


class SharedDispatch {
  constructor() {
    /**
     * List of callback registrations for promises waiting for a response from a call to a service on another
     * worker. A callback registration is an array of [resolve,reject] Promise functions.
     * Calls to local services don't enter this list.
     * @type {Array.<Function[]>}
     */
    this.callbacks = [];
    /**
     * The next response ID to be used.
     * @type {int}
     */

    this.nextResponseId = 0;
  }
  /**
   * Call a particular method on a particular service, regardless of whether that service is provided locally or on
   * a worker. If the service is provided by a worker, the `args` will be copied using the Structured Clone
   * algorithm, except for any items which are also in the `transfer` list. Ownership of those items will be
   * transferred to the worker, and they should not be used after this call.
   * @example
   *      dispatcher.call('vm', 'setData', 'cat', 42);
   *      // this finds the worker for the 'vm' service, then on that worker calls:
   *      vm.setData('cat', 42);
   * @param {string} service - the name of the service.
   * @param {string} method - the name of the method.
   * @param {*} [args] - the arguments to be copied to the method, if any.
   * @returns {Promise} - a promise for the return value of the service method.
   */


  call(service, method) {
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    return this.transferCall(service, method, null, ...args);
  }
  /**
   * Call a particular method on a particular service, regardless of whether that service is provided locally or on
   * a worker. If the service is provided by a worker, the `args` will be copied using the Structured Clone
   * algorithm, except for any items which are also in the `transfer` list. Ownership of those items will be
   * transferred to the worker, and they should not be used after this call.
   * @example
   *      dispatcher.transferCall('vm', 'setData', [myArrayBuffer], 'cat', myArrayBuffer);
   *      // this finds the worker for the 'vm' service, transfers `myArrayBuffer` to it, then on that worker calls:
   *      vm.setData('cat', myArrayBuffer);
   * @param {string} service - the name of the service.
   * @param {string} method - the name of the method.
   * @param {Array} [transfer] - objects to be transferred instead of copied. Must be present in `args` to be useful.
   * @param {*} [args] - the arguments to be copied to the method, if any.
   * @returns {Promise} - a promise for the return value of the service method.
   */


  transferCall(service, method, transfer) {
    try {
      const {
        provider,
        isRemote
      } = this._getServiceProvider(service);

      if (provider) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
          args[_key2 - 3] = arguments[_key2];
        }

        if (isRemote) {
          return this._remoteTransferCall(provider, service, method, transfer, ...args);
        }

        const result = provider[method].apply(provider, args);
        return Promise.resolve(result);
      }

      return Promise.reject(new Error("Service not found: ".concat(service)));
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Check if a particular service lives on another worker.
   * @param {string} service - the service to check.
   * @returns {boolean} - true if the service is remote (calls must cross a Worker boundary), false otherwise.
   * @private
   */


  _isRemoteService(service) {
    return this._getServiceProvider(service).isRemote;
  }
  /**
   * Like {@link call}, but force the call to be posted through a particular communication channel.
   * @param {object} provider - send the call through this object's `postMessage` function.
   * @param {string} service - the name of the service.
   * @param {string} method - the name of the method.
   * @param {*} [args] - the arguments to be copied to the method, if any.
   * @returns {Promise} - a promise for the return value of the service method.
   */


  _remoteCall(provider, service, method) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
      args[_key3 - 3] = arguments[_key3];
    }

    return this._remoteTransferCall(provider, service, method, null, ...args);
  }
  /**
   * Like {@link transferCall}, but force the call to be posted through a particular communication channel.
   * @param {object} provider - send the call through this object's `postMessage` function.
   * @param {string} service - the name of the service.
   * @param {string} method - the name of the method.
   * @param {Array} [transfer] - objects to be transferred instead of copied. Must be present in `args` to be useful.
   * @param {*} [args] - the arguments to be copied to the method, if any.
   * @returns {Promise} - a promise for the return value of the service method.
   */


  _remoteTransferCall(provider, service, method, transfer) {
    for (var _len4 = arguments.length, args = new Array(_len4 > 4 ? _len4 - 4 : 0), _key4 = 4; _key4 < _len4; _key4++) {
      args[_key4 - 4] = arguments[_key4];
    }

    return new Promise((resolve, reject) => {
      const responseId = this._storeCallbacks(resolve, reject);
      /** @TODO: remove this hack! this is just here so we don't try to send `util` to a worker */
      // tw: upstream's logic is broken
      // Args is actually a 3 length list of [args, util, real block info]
      // We only want to send args. The others will throw errors when they try to be cloned


      if (args.length > 0 && typeof args[args.length - 1].func === 'function') {
        args.pop();
        args.pop();
      }

      if (transfer) {
        provider.postMessage({
          service,
          method,
          responseId,
          args
        }, transfer);
      } else {
        provider.postMessage({
          service,
          method,
          responseId,
          args
        });
      }
    });
  }
  /**
   * Store callback functions pending a response message.
   * @param {Function} resolve - function to call if the service method returns.
   * @param {Function} reject - function to call if the service method throws.
   * @returns {*} - a unique response ID for this set of callbacks. See {@link _deliverResponse}.
   * @protected
   */


  _storeCallbacks(resolve, reject) {
    const responseId = this.nextResponseId++;
    this.callbacks[responseId] = [resolve, reject];
    return responseId;
  }
  /**
   * Deliver call response from a worker. This should only be called as the result of a message from a worker.
   * @param {int} responseId - the response ID of the callback set to call.
   * @param {DispatchResponseMessage} message - the message containing the response value(s).
   * @protected
   */


  _deliverResponse(responseId, message) {
    try {
      const [resolve, reject] = this.callbacks[responseId];
      delete this.callbacks[responseId];

      if (message.error) {
        reject(message.error);
      } else {
        resolve(message.result);
      }
    } catch (e) {
      log.error("Dispatch callback failed: ".concat(e));
    }
  }
  /**
   * Handle a message event received from a connected worker.
   * @param {Worker} worker - the worker which sent the message, or the global object if running in a worker.
   * @param {MessageEvent} event - the message event to be handled.
   * @protected
   */


  _onMessage(worker, event) {
    /** @type {DispatchMessage} */
    const message = event.data;
    message.args = message.args || [];
    let promise;

    if (message.service) {
      if (message.service === 'dispatch') {
        promise = this._onDispatchMessage(worker, message);
      } else {
        promise = this.call(message.service, message.method, ...message.args);
      }
    } else if (typeof message.responseId === 'undefined') {
      log.error("Dispatch caught malformed message from a worker: ".concat(JSON.stringify(event)));
    } else {
      this._deliverResponse(message.responseId, message);
    }

    if (promise) {
      if (typeof message.responseId === 'undefined') {
        log.error("Dispatch message missing required response ID: ".concat(JSON.stringify(event)));
      } else {
        promise.then(result => worker.postMessage({
          responseId: message.responseId,
          result
        }), error => worker.postMessage({
          responseId: message.responseId,
          error: "".concat(error)
        }));
      }
    }
  }
  /**
   * Fetch the service provider object for a particular service name.
   * @abstract
   * @param {string} service - the name of the service to look up
   * @returns {{provider:(object|Worker), isRemote:boolean}} - the means to contact the service, if found
   * @protected
   */


  _getServiceProvider(service) {
    throw new Error("Could not get provider for ".concat(service, ": _getServiceProvider not implemented"));
  }
  /**
   * Handle a call message sent to the dispatch service itself
   * @abstract
   * @param {Worker} worker - the worker which sent the message.
   * @param {DispatchCallMessage} message - the message to be handled.
   * @returns {Promise|undefined} - a promise for the results of this operation, if appropriate
   * @private
   */


  _onDispatchMessage(worker, message) {
    throw new Error("Unimplemented dispatch message handler cannot handle ".concat(message.method, " method"));
  }

}

module.exports = SharedDispatch;

/***/ }),

/***/ "./src/engine/adapter.js":
/*!*******************************!*\
  !*** ./src/engine/adapter.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const mutationAdapter = __webpack_require__(/*! ./mutation-adapter */ "./src/engine/mutation-adapter.js");

const html = __webpack_require__(/*! htmlparser2 */ "htmlparser2");

const uid = __webpack_require__(/*! ../util/uid */ "./src/util/uid.js");
/**
 * Convert and an individual block DOM to the representation tree.
 * Based on Blockly's `domToBlockHeadless_`.
 * @param {Element} blockDOM DOM tree for an individual block.
 * @param {object} blocks Collection of blocks to add to.
 * @param {boolean} isTopBlock Whether blocks at this level are "top blocks."
 * @param {?string} parent Parent block ID.
 * @return {undefined}
 */


const domToBlock = function domToBlock(blockDOM, blocks, isTopBlock, parent) {
  if (!blockDOM.attribs.id) {
    blockDOM.attribs.id = uid();
  } // Block skeleton.


  const block = {
    id: blockDOM.attribs.id,
    // Block ID
    opcode: blockDOM.attribs.type,
    // For execution, "event_whengreenflag".
    inputs: {},
    // Inputs to this block and the blocks they point to.
    fields: {},
    // Fields on this block and their values.
    next: null,
    // Next block in the stack, if one exists.
    topLevel: isTopBlock,
    // If this block starts a stack.
    parent: parent,
    // Parent block ID, if available.
    shadow: blockDOM.name === 'shadow',
    // If this represents a shadow/slot.
    x: blockDOM.attribs.x,
    // X position of script, if top-level.
    y: blockDOM.attribs.y // Y position of script, if top-level.

  }; // Add the block to the representation tree.

  blocks[block.id] = block; // Process XML children and find enclosed blocks, fields, etc.

  for (let i = 0; i < blockDOM.children.length; i++) {
    const xmlChild = blockDOM.children[i]; // Enclosed blocks and shadows

    let childBlockNode = null;
    let childShadowNode = null;

    for (let j = 0; j < xmlChild.children.length; j++) {
      const grandChildNode = xmlChild.children[j];

      if (!grandChildNode.name) {
        // Non-XML tag node.
        continue;
      }

      const grandChildNodeName = grandChildNode.name.toLowerCase();

      if (grandChildNodeName === 'block') {
        childBlockNode = grandChildNode;
      } else if (grandChildNodeName === 'shadow') {
        childShadowNode = grandChildNode;
      }
    } // Use shadow block only if there's no real block node.


    if (!childBlockNode && childShadowNode) {
      childBlockNode = childShadowNode;
    } // Not all Blockly-type blocks are handled here,
    // as we won't be using all of them for Scratch.


    switch (xmlChild.name.toLowerCase()) {
      case 'field':
        {
          // Add the field to this block.
          const fieldName = xmlChild.attribs.name; // Add id in case it is a variable field

          const fieldId = xmlChild.attribs.id;
          let fieldData = '';

          if (xmlChild.children.length > 0 && xmlChild.children[0].data) {
            fieldData = xmlChild.children[0].data;
          } else {
            // If the child of the field with a data property
            // doesn't exist, set the data to an empty string.
            fieldData = '';
          }

          block.fields[fieldName] = {
            name: fieldName,
            id: fieldId,
            value: fieldData
          };
          const fieldVarType = xmlChild.attribs.variabletype;

          if (typeof fieldVarType === 'string') {
            block.fields[fieldName].variableType = fieldVarType;
          }

          break;
        }

      case 'comment':
        {
          block.comment = xmlChild.attribs.id;
          break;
        }

      case 'value':
      case 'statement':
        {
          // Recursively generate block structure for input block.
          domToBlock(childBlockNode, blocks, false, block.id);

          if (childShadowNode && childBlockNode !== childShadowNode) {
            // Also generate the shadow block.
            domToBlock(childShadowNode, blocks, false, block.id);
          } // Link this block's input to the child block.


          const inputName = xmlChild.attribs.name;
          block.inputs[inputName] = {
            name: inputName,
            block: childBlockNode.attribs.id,
            shadow: childShadowNode ? childShadowNode.attribs.id : null
          };
          break;
        }

      case 'next':
        {
          if (!childBlockNode || !childBlockNode.attribs) {
            // Invalid child block.
            continue;
          } // Recursively generate block structure for next block.


          domToBlock(childBlockNode, blocks, false, block.id); // Link next block to this block.

          block.next = childBlockNode.attribs.id;
          break;
        }

      case 'mutation':
        {
          block.mutation = mutationAdapter(xmlChild);
          break;
        }
    }
  }
};
/**
 * Convert outer blocks DOM from a Blockly CREATE event
 * to a usable form for the Scratch runtime.
 * This structure is based on Blockly xml.js:`domToWorkspace` and `domToBlock`.
 * @param {Element} blocksDOM DOM tree for this event.
 * @return {Array.<object>} Usable list of blocks from this CREATE event.
 */


const domToBlocks = function domToBlocks(blocksDOM) {
  // At this level, there could be multiple blocks adjacent in the DOM tree.
  const blocks = {};

  for (let i = 0; i < blocksDOM.length; i++) {
    const block = blocksDOM[i];

    if (!block.name || !block.attribs) {
      continue;
    }

    const tagName = block.name.toLowerCase();

    if (tagName === 'block' || tagName === 'shadow') {
      domToBlock(block, blocks, true, null);
    }
  } // Flatten blocks object into a list.


  const blocksList = [];

  for (const b in blocks) {
    if (!blocks.hasOwnProperty(b)) continue;
    blocksList.push(blocks[b]);
  }

  return blocksList;
};
/**
 * Adapter between block creation events and block representation which can be
 * used by the Scratch runtime.
 * @param {object} e `Blockly.events.create` or `Blockly.events.endDrag`
 * @return {Array.<object>} List of blocks from this CREATE event.
 */


const adapter = function adapter(e) {
  // Validate input
  if (typeof e !== 'object') return;
  if (typeof e.xml !== 'object') return;
  return domToBlocks(html.parseDOM(e.xml.outerHTML, {
    decodeEntities: true
  }));
};

module.exports = adapter;

/***/ }),

/***/ "./src/engine/block-utility.js":
/*!*************************************!*\
  !*** ./src/engine/block-utility.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Thread = __webpack_require__(/*! ./thread */ "./src/engine/thread.js");

const Timer = __webpack_require__(/*! ../util/timer */ "./src/util/timer.js");
/**
 * @fileoverview
 * Interface provided to block primitive functions for interacting with the
 * runtime, thread, target, and convenient methods.
 */


class BlockUtility {
  constructor() {
    let sequencer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    let thread = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    /**
     * A sequencer block primitives use to branch or start procedures with
     * @type {?Sequencer}
     */
    this.sequencer = sequencer;
    /**
     * The block primitives thread with the block's target, stackFrame and
     * modifiable status.
     * @type {?Thread}
     */

    this.thread = thread;
    this._nowObj = {
      now: () => this.sequencer.runtime.currentMSecs
    };
  }
  /**
   * The target the primitive is working on.
   * @type {Target}
   */


  get target() {
    return this.thread.target;
  }
  /**
   * The runtime the block primitive is running in.
   * @type {Runtime}
   */


  get runtime() {
    return this.sequencer.runtime;
  }
  /**
   * Use the runtime's currentMSecs value as a timestamp value for now
   * This is useful in some cases where we need compatibility with Scratch 2
   * @type {function}
   */


  get nowObj() {
    if (this.runtime) {
      return this._nowObj;
    }

    return null;
  }
  /**
   * The stack frame used by loop and other blocks to track internal state.
   * @type {object}
   */


  get stackFrame() {
    const frame = this.thread.peekStackFrame();

    if (frame.executionContext === null) {
      frame.executionContext = {};
    }

    return frame.executionContext;
  }
  /**
   * Check the stack timer and return a boolean based on whether it has finished or not.
   * @return {boolean} - true if the stack timer has finished.
   */


  stackTimerFinished() {
    const timeElapsed = this.stackFrame.timer.timeElapsed();

    if (timeElapsed < this.stackFrame.duration) {
      return false;
    }

    return true;
  }
  /**
   * Check if the stack timer needs initialization.
   * @return {boolean} - true if the stack timer needs to be initialized.
   */


  stackTimerNeedsInit() {
    return !this.stackFrame.timer;
  }
  /**
   * Create and start a stack timer
   * @param {number} duration - a duration in milliseconds to set the timer for.
   */


  startStackTimer(duration) {
    if (this.nowObj) {
      this.stackFrame.timer = new Timer(this.nowObj);
    } else {
      this.stackFrame.timer = new Timer();
    }

    this.stackFrame.timer.start();
    this.stackFrame.duration = duration;
  }
  /**
   * Set the thread to yield.
   */


  yield() {
    this.thread.status = Thread.STATUS_YIELD;
  }
  /**
   * Set the thread to yield until the next tick of the runtime.
   */


  yieldTick() {
    this.thread.status = Thread.STATUS_YIELD_TICK;
  }
  /**
   * Start a branch in the current block.
   * @param {number} branchNum Which branch to step to (i.e., 1, 2).
   * @param {boolean} isLoop Whether this block is a loop.
   */


  startBranch(branchNum, isLoop) {
    this.sequencer.stepToBranch(this.thread, branchNum, isLoop);
  }
  /**
   * Stop all threads.
   */


  stopAll() {
    this.sequencer.runtime.stopAll();
  }
  /**
   * Stop threads other on this target other than the thread holding the
   * executed block.
   */


  stopOtherTargetThreads() {
    this.sequencer.runtime.stopForTarget(this.thread.target, this.thread);
  }
  /**
   * Stop this thread.
   */


  stopThisScript() {
    this.thread.stopThisScript();
  }
  /**
   * Start a specified procedure on this thread.
   * @param {string} procedureCode Procedure code for procedure to start.
   */


  startProcedure(procedureCode) {
    const addonBlock = this.runtime.getAddonBlock(procedureCode);

    if (addonBlock) {
      addonBlock.callback(this.thread.getAllparams(), this.thread);
      return;
    }

    this.sequencer.stepToProcedure(this.thread, procedureCode);
  }
  /**
   * Get names and ids of parameters for the given procedure.
   * @param {string} procedureCode Procedure code for procedure to query.
   * @return {Array.<string>} List of param names for a procedure.
   */


  getProcedureParamNamesAndIds(procedureCode) {
    return this.thread.target.blocks.getProcedureParamNamesAndIds(procedureCode);
  }
  /**
   * Get names, ids, and defaults of parameters for the given procedure.
   * @param {string} procedureCode Procedure code for procedure to query.
   * @return {Array.<string>} List of param names for a procedure.
   */


  getProcedureParamNamesIdsAndDefaults(procedureCode) {
    return this.thread.target.blocks.getProcedureParamNamesIdsAndDefaults(procedureCode);
  }
  /**
   * Initialize procedure parameters in the thread before pushing parameters.
   */


  initParams() {
    this.thread.initParams();
  }
  /**
   * Store a procedure parameter value by its name.
   * @param {string} paramName The procedure's parameter name.
   * @param {*} paramValue The procedure's parameter value.
   */


  pushParam(paramName, paramValue) {
    this.thread.pushParam(paramName, paramValue);
  }
  /**
   * Retrieve the stored parameter value for a given parameter name.
   * @param {string} paramName The procedure's parameter name.
   * @return {*} The parameter's current stored value.
   */


  getParam(paramName) {
    return this.thread.getParam(paramName);
  }
  /**
   * Start all relevant hats.
   * @param {!string} requestedHat Opcode of hats to start.
   * @param {object=} optMatchFields Optionally, fields to match on the hat.
   * @param {Target=} optTarget Optionally, a target to restrict to.
   * @return {Array.<Thread>} List of threads started by this function.
   */


  startHats(requestedHat, optMatchFields, optTarget) {
    // Store thread and sequencer to ensure we can return to the calling block's context.
    // startHats may execute further blocks and dirty the BlockUtility's execution context
    // and confuse the calling block when we return to it.
    const callerThread = this.thread;
    const callerSequencer = this.sequencer;
    const result = this.sequencer.runtime.startHats(requestedHat, optMatchFields, optTarget); // Restore thread and sequencer to prior values before we return to the calling block.

    this.thread = callerThread;
    this.sequencer = callerSequencer;
    return result;
  }
  /**
   * Query a named IO device.
   * @param {string} device The name of like the device, like keyboard.
   * @param {string} func The name of the device's function to query.
   * @param {Array.<*>} args Arguments to pass to the device's function.
   * @return {*} The expected output for the device's function.
   */


  ioQuery(device, func, args) {
    // Find the I/O device and execute the query/function call.
    if (this.sequencer.runtime.ioDevices[device] && this.sequencer.runtime.ioDevices[device][func]) {
      const devObject = this.sequencer.runtime.ioDevices[device];
      return devObject[func].apply(devObject, args);
    }
  }

}

module.exports = BlockUtility;

/***/ }),

/***/ "./src/engine/blocks-execute-cache.js":
/*!********************************************!*\
  !*** ./src/engine/blocks-execute-cache.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview
 * Access point for private method shared between blocks.js and execute.js for
 * caching execute information.
 */

/**
 * A private method shared with execute to build an object containing the block
 * information execute needs and that is reset when other cached Blocks info is
 * reset.
 * @param {Blocks} blocks Blocks containing the expected blockId
 * @param {string} blockId blockId for the desired execute cache
 */
exports.getCached = function () {
  throw new Error('blocks.js has not initialized BlocksExecuteCache');
}; // Call after the default throwing getCached is assigned for Blocks to replace.


__webpack_require__(/*! ./blocks */ "./src/engine/blocks.js");

/***/ }),

/***/ "./src/engine/blocks-runtime-cache.js":
/*!********************************************!*\
  !*** ./src/engine/blocks-runtime-cache.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview
 * The BlocksRuntimeCache caches data about the top block of scripts so that
 * Runtime can iterate a targeted opcode and iterate the returned set faster.
 * Many top blocks need to match fields as well as opcode, since that matching
 * compares strings in uppercase we can go ahead and uppercase the cached value
 * so we don't need to in the future.
 */

/**
 * A set of cached data about the top block of a script.
 * @param {Blocks} container - Container holding the block and related data
 * @param {string} blockId - Id for whose block data is cached in this instance
 */
class RuntimeScriptCache {
  constructor(container, blockId) {
    /**
     * Container with block data for blockId.
     * @type {Blocks}
     */
    this.container = container;
    /**
     * ID for block this instance caches.
     * @type {string}
     */

    this.blockId = blockId;
    const block = container.getBlock(blockId);
    const fields = container.getFields(block);
    /**
     * Formatted fields or fields of input blocks ready for comparison in
     * runtime.
     *
     * This is a clone of parts of the targeted blocks. Changes to these
     * clones are limited to copies under RuntimeScriptCache and will not
     * appear in the original blocks in their container. This copy is
     * modified changing the case of strings to uppercase. These uppercase
     * values will be compared later by the VM.
     * @type {object}
     */

    this.fieldsOfInputs = Object.assign({}, fields);

    if (Object.keys(fields).length === 0) {
      const inputs = container.getInputs(block);

      for (const input in inputs) {
        if (!inputs.hasOwnProperty(input)) continue;
        const id = inputs[input].block;
        const inputBlock = container.getBlock(id);
        const inputFields = container.getFields(inputBlock);
        Object.assign(this.fieldsOfInputs, inputFields);
      }
    }

    for (const key in this.fieldsOfInputs) {
      const field = this.fieldsOfInputs[key] = Object.assign({}, this.fieldsOfInputs[key]);

      if (field.value.toUpperCase) {
        field.value = field.value.toUpperCase();
      }
    }
  }

}
/**
 * Get an array of scripts from a block container prefiltered to match opcode.
 * @param {Blocks} container - Container of blocks
 * @param {string} opcode - Opcode to filter top blocks by
 */


exports.getScripts = function () {
  throw new Error('blocks.js has not initialized BlocksRuntimeCache');
};
/**
 * Exposed RuntimeScriptCache class used by integration in blocks.js.
 * @private
 */


exports._RuntimeScriptCache = RuntimeScriptCache;

__webpack_require__(/*! ./blocks */ "./src/engine/blocks.js");

/***/ }),

/***/ "./src/engine/blocks.js":
/*!******************************!*\
  !*** ./src/engine/blocks.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const adapter = __webpack_require__(/*! ./adapter */ "./src/engine/adapter.js");

const mutationAdapter = __webpack_require__(/*! ./mutation-adapter */ "./src/engine/mutation-adapter.js");

const xmlEscape = __webpack_require__(/*! ../util/xml-escape */ "./src/util/xml-escape.js");

const MonitorRecord = __webpack_require__(/*! ./monitor-record */ "./src/engine/monitor-record.js");

const Clone = __webpack_require__(/*! ../util/clone */ "./src/util/clone.js");

const {
  Map
} = __webpack_require__(/*! immutable */ "immutable");

const BlocksExecuteCache = __webpack_require__(/*! ./blocks-execute-cache */ "./src/engine/blocks-execute-cache.js");

const BlocksRuntimeCache = __webpack_require__(/*! ./blocks-runtime-cache */ "./src/engine/blocks-runtime-cache.js");

const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");

const Variable = __webpack_require__(/*! ./variable */ "./src/engine/variable.js");

const getMonitorIdForBlockWithArgs = __webpack_require__(/*! ../util/get-monitor-id */ "./src/util/get-monitor-id.js");
/**
 * @fileoverview
 * Store and mutate the VM block representation,
 * and handle updates from Scratch Blocks events.
 */

/**
 * Create a block container.
 * @param {Runtime} runtime The runtime this block container operates within
 * @param {boolean} optNoGlow Optional flag to indicate that blocks in this container
 * should not request glows. This does not affect glows when clicking on a block to execute it.
 */


class Blocks {
  constructor(runtime, optNoGlow) {
    this.runtime = runtime;
    /**
     * All blocks in the workspace.
     * Keys are block IDs, values are metadata about the block.
     * @type {Object.<string, Object>}
     */

    this._blocks = {};
    /**
     * All top-level scripts in the workspace.
     * A list of block IDs that represent scripts (i.e., first block in script).
     * @type {Array.<String>}
     */

    this._scripts = [];
    /**
     * Runtime Cache
     * @type {{inputs: {}, procedureParamNames: {}, procedureDefinitions: {}}}
     * @private
     */

    Object.defineProperty(this, '_cache', {
      writable: true,
      enumerable: false
    });
    this._cache = {
      /**
       * Cache block inputs by block id
       * @type {object.<string, !Array.<object>>}
       */
      inputs: {},

      /**
       * Cache procedure Param Names by block id
       * @type {object.<string, ?Array.<string>>}
       */
      procedureParamNames: {},

      /**
       * Cache procedure definitions by block id
       * @type {object.<string, ?string>}
       */
      procedureDefinitions: {},

      /**
       * A cache for execute to use and store on. Only available to
       * execute.
       * @type {object.<string, object>}
       */
      _executeCached: {},

      /**
       * A cache of block IDs and targets to start threads on as they are
       * actively monitored.
       * @type {Array<{blockId: string, target: Target}>}
       */
      _monitored: null,

      /**
       * A cache of hat opcodes to collection of theads to execute.
       * @type {object.<string, object>}
       */
      scripts: {},

      /**
       * tw: A cache of top block (usually hat, but not always) opcodes to compiled scripts.
       * @type {object.<string, object>}
       */
      compiledScripts: {},

      /**
       * tw: A cache of procedure code opcodes to a parsed intermediate representation
       * @type {object.<string, object>}
       */
      compiledProcedures: {},

      /**
       * tw: Whether populateProcedureCache has been run
       */
      proceduresPopulated: false
    };
    /**
     * Flag which indicates that blocks in this container should not glow.
     * Blocks will still glow when clicked on, but this flag is used to control
     * whether the blocks in this container can request a glow as part of
     * a running stack. E.g. the flyout block container and the monitor block container
     * should not be able to request a glow, but blocks containers belonging to
     * sprites should.
     * @type {boolean}
     */

    this.forceNoGlow = optNoGlow || false;
  }
  /**
   * Get the cached compilation result of a block.
   * @param {string} blockId ID of the top block.
   * @returns {{success: boolean; value: any}|null} Cached success or error, or null if there is no cached value.
   */


  getCachedCompileResult(blockId) {
    if (this._cache.compiledScripts.hasOwnProperty(blockId)) {
      return this._cache.compiledScripts[blockId];
    }

    return null;
  }
  /**
   * Set the cached compilation result of a script.
   * @param {string} blockId ID of the top block.
   * @param {*} value The compilation result to store.
   */


  cacheCompileResult(blockId, value) {
    this._cache.compiledScripts[blockId] = {
      success: true,
      value: value
    };
  }
  /**
   * Set the cached error of a script.
   * @param {string} blockId ID of the top block.
   * @param {*} error The error to store.
   */


  cacheCompileError(blockId, error) {
    this._cache.compiledScripts[blockId] = {
      success: false,
      value: error
    };
  }
  /**
   * Blockly inputs that represent statements/branch.
   * are prefixed with this string.
   * @const{string}
   */


  static get BRANCH_INPUT_PREFIX() {
    return 'SUBSTACK';
  }
  /**
   * Provide an object with metadata for the requested block ID.
   * @param {!string} blockId ID of block we have stored.
   * @return {?object} Metadata about the block, if it exists.
   */


  getBlock(blockId) {
    return this._blocks[blockId];
  }
  /**
   * Get all known top-level blocks that start scripts.
   * @return {Array.<string>} List of block IDs.
   */


  getScripts() {
    return this._scripts;
  }
  /**
    * Get the next block for a particular block
    * @param {?string} id ID of block to get the next block for
    * @return {?string} ID of next block in the sequence
    */


  getNextBlock(id) {
    const block = this._blocks[id];
    return typeof block === 'undefined' ? null : block.next;
  }
  /**
   * Get the branch for a particular C-shaped block.
   * @param {?string} id ID for block to get the branch for.
   * @param {?number} branchNum Which branch to select (e.g. for if-else).
   * @return {?string} ID of block in the branch.
   */


  getBranch(id, branchNum) {
    const block = this._blocks[id];
    if (typeof block === 'undefined') return null;
    if (!branchNum) branchNum = 1;
    let inputName = Blocks.BRANCH_INPUT_PREFIX;

    if (branchNum > 1) {
      inputName += branchNum;
    } // Empty C-block?


    const input = block.inputs[inputName];
    return typeof input === 'undefined' ? null : input.block;
  }
  /**
   * Get the opcode for a particular block
   * @param {?object} block The block to query
   * @return {?string} the opcode corresponding to that block
   */


  getOpcode(block) {
    return typeof block === 'undefined' ? null : block.opcode;
  }
  /**
   * Get all fields and their values for a block.
   * @param {?object} block The block to query.
   * @return {?object} All fields and their values.
   */


  getFields(block) {
    return typeof block === 'undefined' ? null : block.fields;
  }
  /**
   * Get all non-branch inputs for a block.
   * @param {?object} block the block to query.
   * @return {?Array.<object>} All non-branch inputs and their associated blocks.
   */


  getInputs(block) {
    if (typeof block === 'undefined') return null;
    let inputs = this._cache.inputs[block.id];

    if (typeof inputs !== 'undefined') {
      return inputs;
    }

    inputs = {};

    for (const input in block.inputs) {
      // Ignore blocks prefixed with branch prefix.
      if (input.substring(0, Blocks.BRANCH_INPUT_PREFIX.length) !== Blocks.BRANCH_INPUT_PREFIX) {
        inputs[input] = block.inputs[input];
      }
    }

    this._cache.inputs[block.id] = inputs;
    return inputs;
  }
  /**
   * Get mutation data for a block.
   * @param {?object} block The block to query.
   * @return {?object} Mutation for the block.
   */


  getMutation(block) {
    return typeof block === 'undefined' ? null : block.mutation;
  }
  /**
   * Get the top-level script for a given block.
   * @param {?string} id ID of block to query.
   * @return {?string} ID of top-level script block.
   */


  getTopLevelScript(id) {
    let block = this._blocks[id];
    if (typeof block === 'undefined') return null;

    while (block.parent !== null) {
      block = this._blocks[block.parent];
    }

    return block.id;
  }
  /**
   * Get the procedure definition for a given name.
   * @param {?string} name Name of procedure to query.
   * @return {?string} ID of procedure definition.
   */


  getProcedureDefinition(name) {
    const blockID = this._cache.procedureDefinitions[name];

    if (typeof blockID !== 'undefined') {
      return blockID;
    }

    for (const id in this._blocks) {
      if (!this._blocks.hasOwnProperty(id)) continue;
      const block = this._blocks[id];

      if (block.opcode === 'procedures_definition') {
        // tw: make sure that populateProcedureCache is kept up to date with this method
        const internal = this._getCustomBlockInternal(block);

        if (internal && internal.mutation.proccode === name) {
          this._cache.procedureDefinitions[name] = id; // The outer define block id

          return id;
        }
      }
    }

    this._cache.procedureDefinitions[name] = null;
    return null;
  }
  /**
   * Get names and ids of parameters for the given procedure.
   * @param {?string} name Name of procedure to query.
   * @return {?Array.<string>} List of param names for a procedure.
   */


  getProcedureParamNamesAndIds(name) {
    return this.getProcedureParamNamesIdsAndDefaults(name).slice(0, 2);
  }
  /**
   * Get names, ids, and defaults of parameters for the given procedure.
   * @param {?string} name Name of procedure to query.
   * @return {?Array.<string>} List of param names for a procedure.
   */


  getProcedureParamNamesIdsAndDefaults(name) {
    const cachedNames = this._cache.procedureParamNames[name];

    if (typeof cachedNames !== 'undefined') {
      return cachedNames;
    }

    for (const id in this._blocks) {
      if (!this._blocks.hasOwnProperty(id)) continue;
      const block = this._blocks[id];

      if (block.opcode === 'procedures_prototype' && block.mutation.proccode === name) {
        // tw: make sure that populateProcedureCache is kept up to date with this method
        const names = JSON.parse(block.mutation.argumentnames);
        const ids = JSON.parse(block.mutation.argumentids);
        const defaults = JSON.parse(block.mutation.argumentdefaults);
        this._cache.procedureParamNames[name] = [names, ids, defaults];
        return this._cache.procedureParamNames[name];
      }
    }

    const addonBlock = this.runtime.getAddonBlock(name);

    if (addonBlock) {
      this._cache.procedureParamNames[name] = addonBlock.namesIdsDefaults;
      return addonBlock.namesIdsDefaults;
    }

    this._cache.procedureParamNames[name] = null;
    return null;
  }
  /**
   * tw: Setup the procedureParamNames and procedureDefinitions caches all at once.
   * This makes subsequent calls to these methods faster.
   */


  populateProcedureCache() {
    if (this._cache.proceduresPopulated) {
      return;
    }

    for (const id in this._blocks) {
      if (!this._blocks.hasOwnProperty(id)) continue;
      const block = this._blocks[id];

      if (block.opcode === 'procedures_prototype') {
        const name = block.mutation.proccode;

        if (!this._cache.procedureParamNames[name]) {
          const names = JSON.parse(block.mutation.argumentnames);
          const ids = JSON.parse(block.mutation.argumentids);
          const defaults = JSON.parse(block.mutation.argumentdefaults);
          this._cache.procedureParamNames[name] = [names, ids, defaults];
        }

        continue;
      }

      if (block.opcode === 'procedures_definition') {
        const internal = this._getCustomBlockInternal(block);

        if (internal) {
          const name = internal.mutation.proccode;

          if (!this._cache.procedureDefinitions[name]) {
            this._cache.procedureDefinitions[name] = id;
          }

          continue;
        }
      }
    }

    this._cache.proceduresPopulated = true;
  }

  duplicate() {
    const newBlocks = new Blocks(this.runtime, this.forceNoGlow);
    newBlocks._blocks = Clone.simple(this._blocks);
    newBlocks._scripts = Clone.simple(this._scripts);
    return newBlocks;
  } // ---------------------------------------------------------------------

  /**
   * Create event listener for blocks, variables, and comments. Handles validation and
   * serves as a generic adapter between the blocks, variables, and the
   * runtime interface.
   * @param {object} e Blockly "block" or "variable" event
   */


  blocklyListen(e) {
    // Validate event
    if (typeof e !== 'object') return;

    if (typeof e.blockId !== 'string' && typeof e.varId !== 'string' && typeof e.commentId !== 'string') {
      return;
    }

    const stage = this.runtime.getTargetForStage();
    const editingTarget = this.runtime.getEditingTarget(); // UI event: clicked scripts toggle in the runtime.

    if (e.element === 'stackclick') {
      this.runtime.toggleScript(e.blockId, {
        stackClick: true
      });
      return;
    } // Block create/update/destroy


    switch (e.type) {
      case 'create':
        {
          const newBlocks = adapter(e); // A create event can create many blocks. Add them all.

          for (let i = 0; i < newBlocks.length; i++) {
            this.createBlock(newBlocks[i]);
          }

          break;
        }

      case 'change':
        this.changeBlock({
          id: e.blockId,
          element: e.element,
          name: e.name,
          value: e.newValue
        });
        break;

      case 'move':
        this.moveBlock({
          id: e.blockId,
          oldParent: e.oldParentId,
          oldInput: e.oldInputName,
          newParent: e.newParentId,
          newInput: e.newInputName,
          newCoordinate: e.newCoordinate
        });
        break;

      case 'dragOutside':
        this.runtime.emitBlockDragUpdate(e.isOutside);
        break;

      case 'endDrag':
        this.runtime.emitBlockDragUpdate(false
        /* areBlocksOverGui */
        ); // Drag blocks onto another sprite

        if (e.isOutside) {
          const newBlocks = adapter(e);
          this.runtime.emitBlockEndDrag(newBlocks, e.blockId);
        }

        break;

      case 'delete':
        // Don't accept delete events for missing blocks,
        // or shadow blocks being obscured.
        if (!this._blocks.hasOwnProperty(e.blockId) || this._blocks[e.blockId].shadow) {
          return;
        } // Inform any runtime to forget about glows on this script.


        if (this._blocks[e.blockId].topLevel) {
          this.runtime.quietGlow(e.blockId);
        }

        this.deleteBlock(e.blockId);
        break;

      case 'var_create':
        this.resetCache(); // tw: more aggressive cache resetting
        // Check if the variable being created is global or local
        // If local, create a local var on the current editing target, as long
        // as there are no conflicts, and the current target is actually a sprite
        // If global or if the editing target is not present or we somehow got
        // into a state where a local var was requested for the stage,
        // create a stage (global) var after checking for name conflicts
        // on all the sprites.

        if (e.isLocal && editingTarget && !editingTarget.isStage && !e.isCloud) {
          if (!editingTarget.lookupVariableById(e.varId)) {
            editingTarget.createVariable(e.varId, e.varName, e.varType);
            this.emitProjectChanged();
          }
        } else {
          if (stage.lookupVariableById(e.varId)) {
            // Do not re-create a variable if it already exists
            return;
          } // Check for name conflicts in all of the targets


          const allTargets = this.runtime.targets.filter(t => t.isOriginal);

          for (const target of allTargets) {
            if (target.lookupVariableByNameAndType(e.varName, e.varType, true)) {
              return;
            }
          }

          stage.createVariable(e.varId, e.varName, e.varType, e.isCloud);
          this.emitProjectChanged();
        }

        break;

      case 'var_rename':
        if (editingTarget && editingTarget.variables.hasOwnProperty(e.varId)) {
          // This is a local variable, rename on the current target
          editingTarget.renameVariable(e.varId, e.newName); // Update all the blocks on the current target that use
          // this variable

          editingTarget.blocks.updateBlocksAfterVarRename(e.varId, e.newName);
        } else {
          // This is a global variable
          stage.renameVariable(e.varId, e.newName); // Update all blocks on all targets that use the renamed variable

          const targets = this.runtime.targets;

          for (let i = 0; i < targets.length; i++) {
            const currTarget = targets[i];
            currTarget.blocks.updateBlocksAfterVarRename(e.varId, e.newName);
          }
        }

        this.emitProjectChanged();
        break;

      case 'var_delete':
        {
          this.resetCache(); // tw: more aggressive cache resetting

          const target = editingTarget && editingTarget.variables.hasOwnProperty(e.varId) ? editingTarget : stage;
          target.deleteVariable(e.varId);
          this.emitProjectChanged();
          break;
        }

      case 'comment_create':
        this.resetCache(); // tw: comments can affect compilation

        if (this.runtime.getEditingTarget()) {
          const currTarget = this.runtime.getEditingTarget();
          currTarget.createComment(e.commentId, e.blockId, e.text, e.xy.x, e.xy.y, e.width, e.height, e.minimized);

          if (currTarget.comments[e.commentId].x === null && currTarget.comments[e.commentId].y === null) {
            // Block comments imported from 2.0 projects are imported with their
            // x and y coordinates set to null so that scratch-blocks can
            // auto-position them. If we are receiving a create event for these
            // comments, then the auto positioning should have taken place.
            // Update the x and y position of these comments to match the
            // one from the event.
            currTarget.comments[e.commentId].x = e.xy.x;
            currTarget.comments[e.commentId].y = e.xy.y;
          }
        }

        this.emitProjectChanged();
        break;

      case 'comment_change':
        this.resetCache(); // tw: comments can affect compilation

        if (this.runtime.getEditingTarget()) {
          const currTarget = this.runtime.getEditingTarget();

          if (!currTarget.comments.hasOwnProperty(e.commentId)) {
            log.warn("Cannot change comment with id ".concat(e.commentId, " because it does not exist."));
            return;
          }

          const comment = currTarget.comments[e.commentId];
          const change = e.newContents_;

          if (change.hasOwnProperty('minimized')) {
            comment.minimized = change.minimized;
          }

          if (change.hasOwnProperty('width') && change.hasOwnProperty('height')) {
            comment.width = change.width;
            comment.height = change.height;
          }

          if (change.hasOwnProperty('text')) {
            comment.text = change.text;
          }

          this.emitProjectChanged();
        }

        break;

      case 'comment_move':
        if (this.runtime.getEditingTarget()) {
          const currTarget = this.runtime.getEditingTarget();

          if (currTarget && !currTarget.comments.hasOwnProperty(e.commentId)) {
            log.warn("Cannot change comment with id ".concat(e.commentId, " because it does not exist."));
            return;
          }

          const comment = currTarget.comments[e.commentId];
          const newCoord = e.newCoordinate_;
          comment.x = newCoord.x;
          comment.y = newCoord.y;
          this.emitProjectChanged();
        }

        break;

      case 'comment_delete':
        this.resetCache(); // tw: comments can affect compilation

        if (this.runtime.getEditingTarget()) {
          const currTarget = this.runtime.getEditingTarget();

          if (!currTarget.comments.hasOwnProperty(e.commentId)) {
            // If we're in this state, we have probably received
            // a delete event from a workspace that we switched from
            // (e.g. a delete event for a comment on sprite a's workspace
            // when switching from sprite a to sprite b)
            return;
          }

          delete currTarget.comments[e.commentId];

          if (e.blockId) {
            const block = currTarget.blocks.getBlock(e.blockId);

            if (!block) {
              log.warn("Could not find block referenced by comment with id: ".concat(e.commentId));
              return;
            }

            delete block.comment;
          }

          this.emitProjectChanged();
        }

        break;
    }
  } // ---------------------------------------------------------------------

  /**
   * Reset all runtime caches.
   */


  resetCache() {
    this._cache.inputs = {};
    this._cache.procedureParamNames = {};
    this._cache.procedureDefinitions = {};
    this._cache._executeCached = {};
    this._cache._monitored = null;
    this._cache.scripts = {};
    this._cache.compiledScripts = {};
    this._cache.compiledProcedures = {};
    this._cache.proceduresPopulated = false;
  }
  /**
   * Emit a project changed event if this is a block container
   * that can affect the project state.
   */


  emitProjectChanged() {
    if (!this.forceNoGlow) {
      this.runtime.emitProjectChanged();
    }
  }
  /**
   * Block management: create blocks and scripts from a `create` event
   * @param {!object} block Blockly create event to be processed
   */


  createBlock(block) {
    // Does the block already exist?
    // Could happen, e.g., for an unobscured shadow.
    if (this._blocks.hasOwnProperty(block.id)) {
      return;
    } // Create new block.


    this._blocks[block.id] = block; // Push block id to scripts array.
    // Blocks are added as a top-level stack if they are marked as a top-block
    // (if they were top-level XML in the event).

    if (block.topLevel) {
      this._addScript(block.id);
    }

    this.resetCache(); // A new block was actually added to the block container,
    // emit a project changed event

    this.emitProjectChanged();
  }
  /**
   * Block management: change block field values
   * @param {!object} args Blockly change event to be processed
   */


  changeBlock(args) {
    // Validate
    if (['field', 'mutation', 'checkbox'].indexOf(args.element) === -1) return;
    let block = this._blocks[args.id];
    if (typeof block === 'undefined') return;

    switch (args.element) {
      case 'field':
        // TODO when the field of a monitored block changes,
        // update the checkbox in the flyout based on whether
        // a monitor for that current combination of selected parameters exists
        // e.g.
        // 1. check (current [v year])
        // 2. switch dropdown in flyout block to (current [v minute])
        // 3. the checkbox should become unchecked if we're not already
        //    monitoring current minute
        // Update block value
        if (!block.fields[args.name]) return;

        if (args.name === 'VARIABLE' || args.name === 'LIST' || args.name === 'BROADCAST_OPTION') {
          // Get variable name using the id in args.value.
          const variable = this.runtime.getEditingTarget().lookupVariableById(args.value);

          if (variable) {
            block.fields[args.name].value = variable.name;
            block.fields[args.name].id = args.value;
          }
        } else {
          // Changing the value in a dropdown
          block.fields[args.name].value = args.value; // The selected item in the sensing of block menu needs to change based on the
          // selected target.  Set it to the first item in the menu list.
          // TODO: (#1787)

          if (block.opcode === 'sensing_of_object_menu') {
            if (block.fields.OBJECT.value === '_stage_') {
              this._blocks[block.parent].fields.PROPERTY.value = 'backdrop #';
            } else {
              this._blocks[block.parent].fields.PROPERTY.value = 'x position';
            }

            this.runtime.requestBlocksUpdate();
          }

          const flyoutBlock = block.shadow && block.parent ? this._blocks[block.parent] : block;

          if (flyoutBlock.isMonitored) {
            this.runtime.requestUpdateMonitor(Map({
              id: flyoutBlock.id,
              params: this._getBlockParams(flyoutBlock)
            }));
          }
        }

        break;

      case 'mutation':
        block.mutation = mutationAdapter(args.value);
        break;

      case 'checkbox':
        {
          // A checkbox usually has a one to one correspondence with the monitor
          // block but in the case of monitored reporters that have arguments,
          // map the old id to a new id, creating a new monitor block if necessary
          if (block.fields && Object.keys(block.fields).length > 0 && block.opcode !== 'data_variable' && block.opcode !== 'data_listcontents') {
            // This block has an argument which needs to get separated out into
            // multiple monitor blocks with ids based on the selected argument
            const newId = getMonitorIdForBlockWithArgs(block.id, block.fields); // Note: we're not just constantly creating a longer and longer id everytime we check
            // the checkbox because we're using the id of the block in the flyout as the base
            // check if a block with the new id already exists, otherwise create

            let newBlock = this.runtime.monitorBlocks.getBlock(newId);

            if (!newBlock) {
              newBlock = JSON.parse(JSON.stringify(block));
              newBlock.id = newId;
              this.runtime.monitorBlocks.createBlock(newBlock);
            }

            block = newBlock; // Carry on through the rest of this code with newBlock
          }

          const wasMonitored = block.isMonitored;
          block.isMonitored = args.value; // Variable blocks may be sprite specific depending on the owner of the variable

          let isSpriteLocalVariable = false;

          if (block.opcode === 'data_variable') {
            isSpriteLocalVariable = !this.runtime.getTargetForStage().variables[block.fields.VARIABLE.id];
          } else if (block.opcode === 'data_listcontents') {
            isSpriteLocalVariable = !this.runtime.getTargetForStage().variables[block.fields.LIST.id];
          }

          const isSpriteSpecific = isSpriteLocalVariable || this.runtime.monitorBlockInfo.hasOwnProperty(block.opcode) && this.runtime.monitorBlockInfo[block.opcode].isSpriteSpecific;

          if (isSpriteSpecific) {
            // If creating a new sprite specific monitor, the only possible target is
            // the current editing one b/c you cannot dynamically create monitors.
            // Also, do not change the targetId if it has already been assigned
            block.targetId = block.targetId || this.runtime.getEditingTarget().id;
          } else {
            block.targetId = null;
          }

          if (wasMonitored && !block.isMonitored) {
            this.runtime.requestHideMonitor(block.id);
          } else if (!wasMonitored && block.isMonitored) {
            // Tries to show the monitor for specified block. If it doesn't exist, add the monitor.
            if (!this.runtime.requestShowMonitor(block.id)) {
              this.runtime.requestAddMonitor(MonitorRecord({
                id: block.id,
                targetId: block.targetId,
                spriteName: block.targetId ? this.runtime.getTargetById(block.targetId).getName() : null,
                opcode: block.opcode,
                params: this._getBlockParams(block),
                // @todo(vm#565) for numerical values with decimals, some countries use comma
                value: '',
                mode: block.opcode === 'data_listcontents' ? 'list' : 'default'
              }));
            }
          }

          break;
        }
    }

    this.emitProjectChanged();
    this.resetCache();
  }
  /**
   * Block management: move blocks from parent to parent
   * @param {!object} e Blockly move event to be processed
   */


  moveBlock(e) {
    if (!this._blocks.hasOwnProperty(e.id)) {
      return;
    }

    const block = this._blocks[e.id]; // Track whether a change actually occurred
    // ignoring changes like routine re-positioning
    // of a block when loading a workspace

    let didChange = false; // Move coordinate changes.

    if (e.newCoordinate) {
      didChange = block.x !== e.newCoordinate.x || block.y !== e.newCoordinate.y;
      block.x = e.newCoordinate.x;
      block.y = e.newCoordinate.y;
    } // Remove from any old parent.


    if (typeof e.oldParent !== 'undefined') {
      const oldParent = this._blocks[e.oldParent];

      if (typeof e.oldInput !== 'undefined' && oldParent.inputs[e.oldInput].block === e.id) {
        // This block was connected to the old parent's input.
        oldParent.inputs[e.oldInput].block = null;
      } else if (oldParent.next === e.id) {
        // This block was connected to the old parent's next connection.
        oldParent.next = null;
      }

      this._blocks[e.id].parent = null;
      didChange = true;
    } // Is this block a top-level block?


    if (typeof e.newParent === 'undefined') {
      this._addScript(e.id);
    } else {
      // Remove script, if one exists.
      this._deleteScript(e.id); // Otherwise, try to connect it in its new place.


      if (typeof e.newInput === 'undefined') {
        // Moved to the new parent's next connection.
        this._blocks[e.newParent].next = e.id;
      } else {
        // Moved to the new parent's input.
        // Don't obscure the shadow block.
        let oldShadow = null;

        if (this._blocks[e.newParent].inputs.hasOwnProperty(e.newInput)) {
          oldShadow = this._blocks[e.newParent].inputs[e.newInput].shadow;
        } // If the block being attached is itself a shadow, make sure to set
        // both block and shadow to that blocks ID. This happens when adding
        // inputs to a custom procedure.


        if (this._blocks[e.id].shadow) oldShadow = e.id;
        this._blocks[e.newParent].inputs[e.newInput] = {
          name: e.newInput,
          block: e.id,
          shadow: oldShadow
        };
      }

      this._blocks[e.id].parent = e.newParent;
      didChange = true;
    }

    this.resetCache();
    if (didChange) this.emitProjectChanged();
  }
  /**
   * Block management: run all blocks.
   * @param {!object} runtime Runtime to run all blocks in.
   */


  runAllMonitored(runtime) {
    if (this._cache._monitored === null) {
      this._cache._monitored = Object.keys(this._blocks).filter(blockId => this.getBlock(blockId).isMonitored).map(blockId => {
        const targetId = this.getBlock(blockId).targetId;
        return {
          blockId,
          target: targetId ? runtime.getTargetById(targetId) : null
        };
      });
    }

    const monitored = this._cache._monitored;

    for (let i = 0; i < monitored.length; i++) {
      const {
        blockId,
        target
      } = monitored[i];
      runtime.addMonitorScript(blockId, target);
    }
  }
  /**
   * Block management: delete blocks and their associated scripts. Does nothing if a block
   * with the given ID does not exist.
   * @param {!string} blockId Id of block to delete
   */


  deleteBlock(blockId) {
    // @todo In runtime, stop threads running on this script.
    // Get block
    const block = this._blocks[blockId];

    if (!block) {
      // No block with the given ID exists
      return;
    } // Delete children


    if (block.next !== null) {
      this.deleteBlock(block.next);
    } // Delete inputs (including branches)


    for (const input in block.inputs) {
      // If it's null, the block in this input moved away.
      if (block.inputs[input].block !== null) {
        this.deleteBlock(block.inputs[input].block);
      } // Delete obscured shadow blocks.


      if (block.inputs[input].shadow !== null && block.inputs[input].shadow !== block.inputs[input].block) {
        this.deleteBlock(block.inputs[input].shadow);
      }
    } // Delete any script starting with this block.


    this._deleteScript(blockId); // Delete block itself.


    delete this._blocks[blockId];
    this.resetCache();
    this.emitProjectChanged();
  }
  /**
   * Returns a map of all references to variables or lists from blocks
   * in this block container.
   * @param {Array<object>} optBlocks Optional list of blocks to constrain the search to.
   * This is useful for getting variable/list references for a stack of blocks instead
   * of all blocks on the workspace
   * @param {?boolean} optIncludeBroadcast Optional whether to include broadcast fields.
   * @return {object} A map of variable ID to a list of all variable references
   * for that ID. A variable reference contains the field referencing that variable
   * and also the type of the variable being referenced.
   */


  getAllVariableAndListReferences(optBlocks, optIncludeBroadcast) {
    const blocks = optBlocks ? optBlocks : this._blocks;
    const allReferences = Object.create(null);

    for (const blockId in blocks) {
      let varOrListField = null;
      let varType = null;

      if (blocks[blockId].fields.VARIABLE) {
        varOrListField = blocks[blockId].fields.VARIABLE;
        varType = Variable.SCALAR_TYPE;
      } else if (blocks[blockId].fields.LIST) {
        varOrListField = blocks[blockId].fields.LIST;
        varType = Variable.LIST_TYPE;
      } else if (optIncludeBroadcast && blocks[blockId].fields.BROADCAST_OPTION) {
        varOrListField = blocks[blockId].fields.BROADCAST_OPTION;
        varType = Variable.BROADCAST_MESSAGE_TYPE;
      }

      if (varOrListField) {
        const currVarId = varOrListField.id;

        if (allReferences[currVarId]) {
          allReferences[currVarId].push({
            referencingField: varOrListField,
            type: varType
          });
        } else {
          allReferences[currVarId] = [{
            referencingField: varOrListField,
            type: varType
          }];
        }
      }
    }

    return allReferences;
  }
  /**
   * Keep blocks up to date after a variable gets renamed.
   * @param {string} varId The id of the variable that was renamed
   * @param {string} newName The new name of the variable that was renamed
   */


  updateBlocksAfterVarRename(varId, newName) {
    const blocks = this._blocks;

    for (const blockId in blocks) {
      let varOrListField = null;

      if (blocks[blockId].fields.VARIABLE) {
        varOrListField = blocks[blockId].fields.VARIABLE;
      } else if (blocks[blockId].fields.LIST) {
        varOrListField = blocks[blockId].fields.LIST;
      }

      if (varOrListField) {
        const currFieldId = varOrListField.id;

        if (varId === currFieldId) {
          varOrListField.value = newName;
        }
      }
    }
  }
  /**
   * Keep blocks up to date after they are shared between targets.
   * @param {boolean} isStage If the new target is a stage.
   */


  updateTargetSpecificBlocks(isStage) {
    const blocks = this._blocks;

    for (const blockId in blocks) {
      if (isStage && blocks[blockId].opcode === 'event_whenthisspriteclicked') {
        blocks[blockId].opcode = 'event_whenstageclicked';
      } else if (!isStage && blocks[blockId].opcode === 'event_whenstageclicked') {
        blocks[blockId].opcode = 'event_whenthisspriteclicked';
      }
    }
  }
  /**
   * Update blocks after a sound, costume, or backdrop gets renamed.
   * Any block referring to the old name of the asset should get updated
   * to refer to the new name.
   * @param {string} oldName The old name of the asset that was renamed.
   * @param {string} newName The new name of the asset that was renamed.
   * @param {string} assetType String representation of the kind of asset
   * that was renamed. This can be one of 'sprite','costume', 'sound', or
   * 'backdrop'.
   */


  updateAssetName(oldName, newName, assetType) {
    let getAssetField;

    if (assetType === 'costume') {
      getAssetField = this._getCostumeField.bind(this);
    } else if (assetType === 'sound') {
      getAssetField = this._getSoundField.bind(this);
    } else if (assetType === 'backdrop') {
      getAssetField = this._getBackdropField.bind(this);
    } else if (assetType === 'sprite') {
      getAssetField = this._getSpriteField.bind(this);
    } else {
      return;
    }

    const blocks = this._blocks;

    for (const blockId in blocks) {
      const assetField = getAssetField(blockId);

      if (assetField && assetField.value === oldName) {
        assetField.value = newName;
      }
    }

    this.resetCache();
  }
  /**
   * Update sensing_of blocks after a variable gets renamed.
   * @param {string} oldName The old name of the variable that was renamed.
   * @param {string} newName The new name of the variable that was renamed.
   * @param {string} targetName The name of the target the variable belongs to.
   * @return {boolean} Returns true if any of the blocks were updated.
   */


  updateSensingOfReference(oldName, newName, targetName) {
    const blocks = this._blocks;
    let blockUpdated = false;

    for (const blockId in blocks) {
      const block = blocks[blockId];

      if (block.opcode === 'sensing_of' && block.fields.PROPERTY.value === oldName && // If block and shadow are different, it means a block is inserted to OBJECT, and should be ignored.
      block.inputs.OBJECT.block === block.inputs.OBJECT.shadow) {
        const inputBlock = this.getBlock(block.inputs.OBJECT.block);

        if (inputBlock.fields.OBJECT.value === targetName) {
          block.fields.PROPERTY.value = newName;
          blockUpdated = true;
        }
      }
    }

    if (blockUpdated) this.resetCache();
    return blockUpdated;
  }
  /**
   * Helper function to retrieve a costume menu field from a block given its id.
   * @param {string} blockId A unique identifier for a block
   * @return {?object} The costume menu field of the block with the given block id.
   * Null if either a block with the given id doesn't exist or if a costume menu field
   * does not exist on the block with the given id.
   */


  _getCostumeField(blockId) {
    const block = this.getBlock(blockId);

    if (block && block.fields.hasOwnProperty('COSTUME')) {
      return block.fields.COSTUME;
    }

    return null;
  }
  /**
   * Helper function to retrieve a sound menu field from a block given its id.
   * @param {string} blockId A unique identifier for a block
   * @return {?object} The sound menu field of the block with the given block id.
   * Null, if either a block with the given id doesn't exist or if a sound menu field
   * does not exist on the block with the given id.
   */


  _getSoundField(blockId) {
    const block = this.getBlock(blockId);

    if (block && block.fields.hasOwnProperty('SOUND_MENU')) {
      return block.fields.SOUND_MENU;
    }

    return null;
  }
  /**
   * Helper function to retrieve a backdrop menu field from a block given its id.
   * @param {string} blockId A unique identifier for a block
   * @return {?object} The backdrop menu field of the block with the given block id.
   * Null, if either a block with the given id doesn't exist or if a backdrop menu field
   * does not exist on the block with the given id.
   */


  _getBackdropField(blockId) {
    const block = this.getBlock(blockId);

    if (block && block.fields.hasOwnProperty('BACKDROP')) {
      return block.fields.BACKDROP;
    }

    return null;
  }
  /**
   * Helper function to retrieve a sprite menu field from a block given its id.
   * @param {string} blockId A unique identifier for a block
   * @return {?object} The sprite menu field of the block with the given block id.
   * Null, if either a block with the given id doesn't exist or if a sprite menu field
   * does not exist on the block with the given id.
   */


  _getSpriteField(blockId) {
    const block = this.getBlock(blockId);

    if (!block) {
      return null;
    }

    const spriteMenuNames = ['TOWARDS', 'TO', 'OBJECT', 'VIDEOONMENU2', 'DISTANCETOMENU', 'TOUCHINGOBJECTMENU', 'CLONE_OPTION'];

    for (let i = 0; i < spriteMenuNames.length; i++) {
      const menuName = spriteMenuNames[i];

      if (block.fields.hasOwnProperty(menuName)) {
        return block.fields[menuName];
      }
    }

    return null;
  } // ---------------------------------------------------------------------

  /**
   * Encode all of `this._blocks` as an XML string usable
   * by a Blockly/scratch-blocks workspace.
   * @param {object<string, Comment>} comments Map of comments referenced by id
   * @return {string} String of XML representing this object's blocks.
   */


  toXML(comments) {
    return this._scripts.map(script => this.blockToXML(script, comments)).join();
  }
  /**
   * Recursively encode an individual block and its children
   * into a Blockly/scratch-blocks XML string.
   * @param {!string} blockId ID of block to encode.
   * @param {object<string, Comment>} comments Map of comments referenced by id
   * @return {string} String of XML representing this block and any children.
   */


  blockToXML(blockId, comments) {
    const block = this._blocks[blockId]; // block should exist, but currently some blocks' next property point
    // to a blockId for non-existent blocks. Until we track down that behavior,
    // this early exit allows the project to load.

    if (!block) return; // Encode properties of this block.

    const tagName = block.shadow ? 'shadow' : 'block';
    let xmlString = "<".concat(tagName, "\n                id=\"").concat(block.id, "\"\n                type=\"").concat(block.opcode, "\"\n                ").concat(block.topLevel ? "x=\"".concat(block.x, "\" y=\"").concat(block.y, "\"") : '', "\n            >");
    const commentId = block.comment;

    if (commentId) {
      if (comments) {
        if (comments.hasOwnProperty(commentId)) {
          xmlString += comments[commentId].toXML();
        } else {
          log.warn("Could not find comment with id: ".concat(commentId, " in provided comment descriptions."));
        }
      } else {
        log.warn("Cannot serialize comment with id: ".concat(commentId, "; no comment descriptions provided."));
      }
    } // Add any mutation. Must come before inputs.


    if (block.mutation) {
      xmlString += this.mutationToXML(block.mutation);
    } // Add any inputs on this block.


    for (const input in block.inputs) {
      if (!block.inputs.hasOwnProperty(input)) continue;
      const blockInput = block.inputs[input]; // Only encode a value tag if the value input is occupied.

      if (blockInput.block || blockInput.shadow) {
        xmlString += "<value name=\"".concat(blockInput.name, "\">");

        if (blockInput.block) {
          xmlString += this.blockToXML(blockInput.block, comments);
        }

        if (blockInput.shadow && blockInput.shadow !== blockInput.block) {
          // Obscured shadow.
          xmlString += this.blockToXML(blockInput.shadow, comments);
        }

        xmlString += '</value>';
      }
    } // Add any fields on this block.


    for (const field in block.fields) {
      if (!block.fields.hasOwnProperty(field)) continue;
      const blockField = block.fields[field];
      xmlString += "<field name=\"".concat(blockField.name, "\"");
      const fieldId = blockField.id;

      if (fieldId) {
        xmlString += " id=\"".concat(fieldId, "\"");
      }

      const varType = blockField.variableType;

      if (typeof varType === 'string') {
        xmlString += " variabletype=\"".concat(varType, "\"");
      }

      let value = blockField.value;

      if (typeof value === 'string') {
        value = xmlEscape(blockField.value);
      }

      xmlString += ">".concat(value, "</field>");
    } // Add blocks connected to the next connection.


    if (block.next) {
      xmlString += "<next>".concat(this.blockToXML(block.next, comments), "</next>");
    }

    xmlString += "</".concat(tagName, ">");
    return xmlString;
  }
  /**
   * Recursively encode a mutation object to XML.
   * @param {!object} mutation Object representing a mutation.
   * @return {string} XML string representing a mutation.
   */


  mutationToXML(mutation) {
    let mutationString = "<".concat(mutation.tagName);

    for (const prop in mutation) {
      if (prop === 'children' || prop === 'tagName') continue;
      let mutationValue = typeof mutation[prop] === 'string' ? xmlEscape(mutation[prop]) : mutation[prop]; // Handle dynamic extension blocks

      if (prop === 'blockInfo') {
        mutationValue = xmlEscape(JSON.stringify(mutation[prop]));
      }

      mutationString += " ".concat(prop, "=\"").concat(mutationValue, "\"");
    }

    mutationString += '>';

    for (let i = 0; i < mutation.children.length; i++) {
      mutationString += this.mutationToXML(mutation.children[i]);
    }

    mutationString += "</".concat(mutation.tagName, ">");
    return mutationString;
  } // ---------------------------------------------------------------------

  /**
   * Helper to serialize block fields and input fields for reporting new monitors
   * @param {!object} block Block to be paramified.
   * @return {!object} object of param key/values.
   */


  _getBlockParams(block) {
    const params = {};

    for (const key in block.fields) {
      params[key] = block.fields[key].value;
    }

    for (const inputKey in block.inputs) {
      const inputBlock = this._blocks[block.inputs[inputKey].block];

      for (const key in inputBlock.fields) {
        params[key] = inputBlock.fields[key].value;
      }
    }

    return params;
  }
  /**
   * Helper to get the corresponding internal procedure definition block
   * @param {!object} defineBlock Outer define block.
   * @return {!object} internal definition block which has the mutation.
   */


  _getCustomBlockInternal(defineBlock) {
    if (defineBlock.inputs && defineBlock.inputs.custom_block) {
      return this._blocks[defineBlock.inputs.custom_block.block];
    }
  }
  /**
   * Helper to add a stack to `this._scripts`.
   * @param {?string} topBlockId ID of block that starts the script.
   */


  _addScript(topBlockId) {
    const i = this._scripts.indexOf(topBlockId);

    if (i > -1) return; // Already in scripts.

    this._scripts.push(topBlockId); // Update `topLevel` property on the top block.


    this._blocks[topBlockId].topLevel = true;
  }
  /**
   * Helper to remove a script from `this._scripts`.
   * @param {?string} topBlockId ID of block that starts the script.
   */


  _deleteScript(topBlockId) {
    const i = this._scripts.indexOf(topBlockId);

    if (i > -1) this._scripts.splice(i, 1); // Update `topLevel` property on the top block.

    if (this._blocks[topBlockId]) this._blocks[topBlockId].topLevel = false;
  }

}
/**
 * A private method shared with execute to build an object containing the block
 * information execute needs and that is reset when other cached Blocks info is
 * reset.
 * @param {Blocks} blocks Blocks containing the expected blockId
 * @param {string} blockId blockId for the desired execute cache
 * @param {function} CacheType constructor for cached block information
 * @return {object} execute cache object
 */


BlocksExecuteCache.getCached = function (blocks, blockId, CacheType) {
  let cached = blocks._cache._executeCached[blockId];

  if (typeof cached !== 'undefined') {
    return cached;
  }

  const block = blocks.getBlock(blockId);
  if (typeof block === 'undefined') return null;

  if (typeof CacheType === 'undefined') {
    cached = {
      id: blockId,
      opcode: blocks.getOpcode(block),
      fields: blocks.getFields(block),
      inputs: blocks.getInputs(block),
      mutation: blocks.getMutation(block)
    };
  } else {
    cached = new CacheType(blocks, {
      id: blockId,
      opcode: blocks.getOpcode(block),
      fields: blocks.getFields(block),
      inputs: blocks.getInputs(block),
      mutation: blocks.getMutation(block)
    });
  }

  blocks._cache._executeCached[blockId] = cached;
  return cached;
};
/**
 * Cache class constructor for runtime. Used to consider what threads should
 * start based on hat data.
 * @type {function}
 */


const RuntimeScriptCache = BlocksRuntimeCache._RuntimeScriptCache;
/**
 * Get an array of scripts from a block container prefiltered to match opcode.
 * @param {Blocks} blocks - Container of blocks
 * @param {string} opcode - Opcode to filter top blocks by
 * @returns {Array.<RuntimeScriptCache>} - Array of RuntimeScriptCache cache
 *   objects
 */

BlocksRuntimeCache.getScripts = function (blocks, opcode) {
  let scripts = blocks._cache.scripts[opcode];

  if (!scripts) {
    scripts = blocks._cache.scripts[opcode] = [];
    const allScripts = blocks._scripts;

    for (let i = 0; i < allScripts.length; i++) {
      const topBlockId = allScripts[i];
      const block = blocks.getBlock(topBlockId);

      if (block.opcode === opcode) {
        scripts.push(new RuntimeScriptCache(blocks, topBlockId));
      }
    }
  }

  return scripts;
};

module.exports = Blocks;

/***/ }),

/***/ "./src/engine/comment.js":
/*!*******************************!*\
  !*** ./src/engine/comment.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview
 * Object representing a Scratch Comment (block or workspace).
 */
const uid = __webpack_require__(/*! ../util/uid */ "./src/util/uid.js");

const xmlEscape = __webpack_require__(/*! ../util/xml-escape */ "./src/util/xml-escape.js");

class Comment {
  /**
   * @param {string} id Id of the comment.
   * @param {string} text Text content of the comment.
   * @param {number} x X position of the comment on the workspace.
   * @param {number} y Y position of the comment on the workspace.
   * @param {number} width The width of the comment when it is full size.
   * @param {number} height The height of the comment when it is full size.
   * @param {boolean} minimized Whether the comment is minimized.
   * @constructor
   */
  constructor(id, text, x, y, width, height, minimized) {
    this.id = id || uid();
    this.text = text;
    this.x = x;
    this.y = y;
    this.width = Math.max(Number(width), Comment.MIN_WIDTH);
    this.height = Math.max(Number(height), Comment.MIN_HEIGHT);
    this.minimized = minimized || false;
    this.blockId = null;
  }

  toXML() {
    return "<comment id=\"".concat(this.id, "\" x=\"").concat(this.x, "\" y=\"").concat(this.y, "\" w=\"").concat(this.width, "\" h=\"").concat(this.height, "\" pinned=\"").concat(this.blockId !== null, "\" minimized=\"").concat(this.minimized, "\">").concat(xmlEscape(this.text), "</comment>");
  } // TODO choose min and defaults for width and height


  static get MIN_WIDTH() {
    return 20;
  }

  static get MIN_HEIGHT() {
    return 20;
  }

  static get DEFAULT_WIDTH() {
    return 100;
  }

  static get DEFAULT_HEIGHT() {
    return 100;
  }

}

module.exports = Comment;

/***/ }),

/***/ "./src/engine/execute.js":
/*!*******************************!*\
  !*** ./src/engine/execute.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const BlockUtility = __webpack_require__(/*! ./block-utility */ "./src/engine/block-utility.js");

const BlocksExecuteCache = __webpack_require__(/*! ./blocks-execute-cache */ "./src/engine/blocks-execute-cache.js");

const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");

const Thread = __webpack_require__(/*! ./thread */ "./src/engine/thread.js");

const {
  Map
} = __webpack_require__(/*! immutable */ "immutable");

const cast = __webpack_require__(/*! ../util/cast */ "./src/util/cast.js");
/**
 * Single BlockUtility instance reused by execute for every pritimive ran.
 * @const
 */


const blockUtility = new BlockUtility();
/**
 * Profiler frame name for block functions.
 * @const {string}
 */

const blockFunctionProfilerFrame = 'blockFunction';
/**
 * Profiler frame ID for 'blockFunction'.
 * @type {number}
 */

let blockFunctionProfilerId = -1;
/**
 * Utility function to determine if a value is a Promise.
 * @param {*} value Value to check for a Promise.
 * @return {boolean} True if the value appears to be a Promise.
 */

const isPromise = function isPromise(value) {
  return value !== null && typeof value === 'object' && typeof value.then === 'function';
};
/**
 * Handle any reported value from the primitive, either directly returned
 * or after a promise resolves.
 * @param {*} resolvedValue Value eventually returned from the primitive.
 * @param {!Sequencer} sequencer Sequencer stepping the thread for the ran
 * primitive.
 * @param {!Thread} thread Thread containing the primitive.
 * @param {!string} currentBlockId Id of the block in its thread for value from
 * the primitive.
 * @param {!string} opcode opcode used to identify a block function primitive.
 * @param {!boolean} isHat Is the current block a hat?
 */
// @todo move this to callback attached to the thread when we have performance
// metrics (dd)


const handleReport = function handleReport(resolvedValue, sequencer, thread, blockCached, lastOperation) {
  const currentBlockId = blockCached.id;
  const opcode = blockCached.opcode;
  const isHat = blockCached._isHat;
  thread.pushReportedValue(resolvedValue);

  if (isHat) {
    // Hat predicate was evaluated.
    if (sequencer.runtime.getIsEdgeActivatedHat(opcode)) {
      // If this is an edge-activated hat, only proceed if the value is
      // true and used to be false, or the stack was activated explicitly
      // via stack click
      if (!thread.stackClick) {
        const hasOldEdgeValue = thread.target.hasEdgeActivatedValue(currentBlockId);
        const oldEdgeValue = thread.target.updateEdgeActivatedValue(currentBlockId, resolvedValue);
        const edgeWasActivated = hasOldEdgeValue ? !oldEdgeValue && resolvedValue : resolvedValue;

        if (edgeWasActivated) {
          // TW: Resume the thread if we were paused for a promise.
          thread.status = Thread.STATUS_RUNNING;
        } else {
          sequencer.retireThread(thread);
        }
      }
    } else if (!resolvedValue) {
      // Not an edge-activated hat: retire the thread
      // if predicate was false.
      sequencer.retireThread(thread);
    }
  } else {
    // In a non-hat, report the value visually if necessary if
    // at the top of the thread stack.
    if (lastOperation && typeof resolvedValue !== 'undefined' && thread.atStackTop()) {
      if (thread.stackClick) {
        sequencer.runtime.visualReport(currentBlockId, resolvedValue);
      }

      if (thread.updateMonitor) {
        const targetId = sequencer.runtime.monitorBlocks.getBlock(currentBlockId).targetId;

        if (targetId && !sequencer.runtime.getTargetById(targetId)) {
          // Target no longer exists
          return;
        }

        sequencer.runtime.requestUpdateMonitor(Map({
          id: currentBlockId,
          spriteName: targetId ? sequencer.runtime.getTargetById(targetId).getName() : null,
          value: resolvedValue
        }));
      }
    } // Finished any yields.


    thread.status = Thread.STATUS_RUNNING;
  }
};

const handlePromise = (primitiveReportedValue, sequencer, thread, blockCached, lastOperation) => {
  if (thread.status === Thread.STATUS_RUNNING) {
    // Primitive returned a promise; automatically yield thread.
    thread.status = Thread.STATUS_PROMISE_WAIT;
  } // Promise handlers


  primitiveReportedValue.then(resolvedValue => {
    handleReport(resolvedValue, sequencer, thread, blockCached, lastOperation); // If it's a command block or a top level reporter in a stackClick.
    // TW: Don't mangle the stack when we just finished executing a hat block.
    // Hat block is always the top and first block of the script. There are no loops to find.

    if (lastOperation && !blockCached._isHat) {
      let stackFrame;
      let nextBlockId;

      do {
        // In the case that the promise is the last block in the current thread stack
        // We need to pop out repeatedly until we find the next block.
        const popped = thread.popStack();

        if (popped === null) {
          return;
        }

        nextBlockId = thread.target.blocks.getNextBlock(popped);

        if (nextBlockId !== null) {
          // A next block exists so break out this loop
          break;
        } // Investigate the next block and if not in a loop,
        // then repeat and pop the next item off the stack frame


        stackFrame = thread.peekStackFrame();
      } while (stackFrame !== null && !stackFrame.isLoop);

      thread.pushStack(nextBlockId);
    }
  }, rejectionReason => {
    // Promise rejected: the primitive had some error.
    // Log it and proceed.
    log.warn('Primitive rejected promise: ', rejectionReason);
    thread.status = Thread.STATUS_RUNNING;
    thread.popStack();
  });
};
/**
 * A execute.js internal representation of a block to reduce the time spent in
 * execute as the same blocks are called the most.
 *
 * With the help of the Blocks class create a mutable copy of block
 * information. The members of BlockCached derived values of block information
 * that does not need to be reevaluated until a change in Blocks. Since Blocks
 * handles where the cache instance is stored, it drops all cache versions of a
 * block when any change happens to it. This way we can quickly execute blocks
 * and keep perform the right action according to the current block information
 * in the editor.
 *
 * @param {Blocks} blockContainer the related Blocks instance
 * @param {object} cached default set of cached values
 */


class BlockCached {
  constructor(blockContainer, cached) {
    /**
     * Block id in its parent set of blocks.
     * @type {string}
     */
    this.id = cached.id;
    /**
     * Block operation code for this block.
     * @type {string}
     */

    this.opcode = cached.opcode;
    /**
     * Original block object containing argument values for static fields.
     * @type {object}
     */

    this.fields = cached.fields;
    /**
     * Original block object containing argument values for executable inputs.
     * @type {object}
     */

    this.inputs = cached.inputs;
    /**
     * Procedure mutation.
     * @type {?object}
     */

    this.mutation = cached.mutation;
    /**
     * The profiler the block is configured with.
     * @type {?Profiler}
     */

    this._profiler = null;
    /**
     * Profiler information frame.
     * @type {?ProfilerFrame}
     */

    this._profilerFrame = null;
    /**
     * Is the opcode a hat (event responder) block.
     * @type {boolean}
     */

    this._isHat = false;
    /**
     * The block opcode's implementation function.
     * @type {?function}
     */

    this._blockFunction = null;
    /**
     * Is the block function defined for this opcode?
     * @type {boolean}
     */

    this._definedBlockFunction = false;
    /**
     * Is this block a block with no function but a static value to return.
     * @type {boolean}
     */

    this._isShadowBlock = false;
    /**
     * The static value of this block if it is a shadow block.
     * @type {?any}
     */

    this._shadowValue = null;
    /**
     * A copy of the block's fields that may be modified.
     * @type {object}
     */

    this._fields = Object.assign({}, this.fields);
    /**
     * A copy of the block's inputs that may be modified.
     * @type {object}
     */

    this._inputs = Object.assign({}, this.inputs);
    /**
     * An arguments object for block implementations. All executions of this
     * specific block will use this objecct.
     * @type {object}
     */

    this._argValues = {
      mutation: this.mutation
    };
    /**
     * The inputs key the parent refers to this BlockCached by.
     * @type {string}
     */

    this._parentKey = null;
    /**
     * The target object where the parent wants the resulting value stored
     * with _parentKey as the key.
     * @type {object}
     */

    this._parentValues = null;
    /**
     * A sequence of non-shadow operations that can must be performed. This
     * list recreates the order this block and its children are executed.
     * Since the order is always the same we can safely store that order
     * and iterate over the operations instead of dynamically walking the
     * tree every time.
     * @type {Array<BlockCached>}
     */

    this._ops = [];
    const {
      runtime
    } = blockUtility.sequencer;
    const {
      opcode,
      fields,
      inputs
    } = this; // Assign opcode isHat and blockFunction data to avoid dynamic lookups.

    this._isHat = runtime.getIsHat(opcode);
    this._blockFunction = runtime.getOpcodeFunction(opcode);
    this._definedBlockFunction = typeof this._blockFunction !== 'undefined'; // Store the current shadow value if there is a shadow value.

    const fieldKeys = Object.keys(fields);
    this._isShadowBlock = !this._definedBlockFunction && fieldKeys.length === 1 && Object.keys(inputs).length === 0;
    this._shadowValue = this._isShadowBlock && fields[fieldKeys[0]].value; // Store the static fields onto _argValues.

    for (const fieldName in fields) {
      if (fieldName === 'VARIABLE' || fieldName === 'LIST' || fieldName === 'BROADCAST_OPTION') {
        this._argValues[fieldName] = {
          id: fields[fieldName].id,
          name: fields[fieldName].value
        };
      } else {
        this._argValues[fieldName] = fields[fieldName].value;
      }
    } // Remove custom_block. It is not part of block execution.


    delete this._inputs.custom_block;

    if ('BROADCAST_INPUT' in this._inputs) {
      // BROADCAST_INPUT is called BROADCAST_OPTION in the args and is an
      // object with an unchanging shape.
      this._argValues.BROADCAST_OPTION = {
        id: null,
        name: null
      }; // We can go ahead and compute BROADCAST_INPUT if it is a shadow
      // value.

      const broadcastInput = this._inputs.BROADCAST_INPUT;

      if (broadcastInput.block === broadcastInput.shadow) {
        // Shadow dropdown menu is being used.
        // Get the appropriate information out of it.
        const shadow = blockContainer.getBlock(broadcastInput.shadow);
        const broadcastField = shadow.fields.BROADCAST_OPTION;
        this._argValues.BROADCAST_OPTION.id = broadcastField.id;
        this._argValues.BROADCAST_OPTION.name = broadcastField.value; // Evaluating BROADCAST_INPUT here we do not need to do so
        // later.

        delete this._inputs.BROADCAST_INPUT;
      }
    } // Cache all input children blocks in the operation lists. The
    // operations can later be run in the order they appear in correctly
    // executing the operations quickly in a flat loop instead of needing to
    // recursivly iterate them.


    for (const inputName in this._inputs) {
      const input = this._inputs[inputName];

      if (input.block) {
        const inputCached = BlocksExecuteCache.getCached(blockContainer, input.block, BlockCached);

        if (inputCached._isHat) {
          continue;
        }

        this._ops.push(...inputCached._ops);

        inputCached._parentKey = inputName;
        inputCached._parentValues = this._argValues; // Shadow values are static and do not change, go ahead and
        // store their value on args.

        if (inputCached._isShadowBlock) {
          this._argValues[inputName] = inputCached._shadowValue;
        }
      }
    } // The final operation is this block itself. At the top most block is a
    // command block or a block that is being run as a monitor.


    if (this._definedBlockFunction) {
      this._ops.push(this);
    }
  }

}
/**
 * Initialize a BlockCached instance so its command/hat
 * block and reporters can be profiled during execution.
 * @param {Profiler} profiler - The profiler that is currently enabled.
 * @param {BlockCached} blockCached - The blockCached instance to profile.
 */


const _prepareBlockProfiling = function _prepareBlockProfiling(profiler, blockCached) {
  blockCached._profiler = profiler;

  if (blockFunctionProfilerId === -1) {
    blockFunctionProfilerId = profiler.idByName(blockFunctionProfilerFrame);
  }

  const ops = blockCached._ops;

  for (let i = 0; i < ops.length; i++) {
    ops[i]._profilerFrame = profiler.frame(blockFunctionProfilerId, ops[i].opcode);
  }
};
/**
 * Execute a block.
 * @param {!Sequencer} sequencer Which sequencer is executing.
 * @param {!Thread} thread Thread which to read and execute.
 */


const execute = function execute(sequencer, thread) {
  const runtime = sequencer.runtime; // store sequencer and thread so block functions can access them through
  // convenience methods.

  blockUtility.sequencer = sequencer;
  blockUtility.thread = thread; // Current block to execute is the one on the top of the stack.

  const currentBlockId = thread.peekStack();
  const currentStackFrame = thread.peekStackFrame();
  let blockContainer = thread.blockContainer;
  let blockCached = BlocksExecuteCache.getCached(blockContainer, currentBlockId, BlockCached);

  if (blockCached === null) {
    blockContainer = runtime.flyoutBlocks;
    blockCached = BlocksExecuteCache.getCached(blockContainer, currentBlockId, BlockCached); // Stop if block or target no longer exists.

    if (blockCached === null) {
      // No block found: stop the thread; script no longer exists.
      sequencer.retireThread(thread);
      return;
    }
  }

  const ops = blockCached._ops;
  const length = ops.length;
  let i = 0;

  if (currentStackFrame.reported !== null) {
    const reported = currentStackFrame.reported; // Reinstate all the previous values.

    for (; i < reported.length; i++) {
      const {
        opCached: oldOpCached,
        inputValue
      } = reported[i];
      const opCached = ops.find(op => op.id === oldOpCached);

      if (opCached) {
        const inputName = opCached._parentKey;
        const argValues = opCached._parentValues;

        if (inputName === 'BROADCAST_INPUT') {
          // Something is plugged into the broadcast input.
          // Cast it to a string. We don't need an id here.
          argValues.BROADCAST_OPTION.id = null;
          argValues.BROADCAST_OPTION.name = cast.toString(inputValue);
        } else {
          argValues[inputName] = inputValue;
        }
      }
    } // Find the last reported block that is still in the set of operations.
    // This way if the last operation was removed, we'll find the next
    // candidate. If an earlier block that was performed was removed then
    // we'll find the index where the last operation is now.


    if (reported.length > 0) {
      const lastExisting = reported.reverse().find(report => ops.find(op => op.id === report.opCached));

      if (lastExisting) {
        i = ops.findIndex(opCached => opCached.id === lastExisting.opCached) + 1;
      } else {
        i = 0;
      }
    } // The reporting block must exist and must be the next one in the sequence of operations.


    if (thread.justReported !== null && ops[i] && ops[i].id === currentStackFrame.reporting) {
      const opCached = ops[i];
      const inputValue = thread.justReported;
      thread.justReported = null;
      const inputName = opCached._parentKey;
      const argValues = opCached._parentValues;

      if (inputName === 'BROADCAST_INPUT') {
        // Something is plugged into the broadcast input.
        // Cast it to a string. We don't need an id here.
        argValues.BROADCAST_OPTION.id = null;
        argValues.BROADCAST_OPTION.name = cast.toString(inputValue);
      } else {
        argValues[inputName] = inputValue;
      }

      i += 1;
    }

    currentStackFrame.reporting = null;
    currentStackFrame.reported = null;
  }

  const start = i;

  for (; i < length; i++) {
    const lastOperation = i === length - 1;
    const opCached = ops[i];
    const blockFunction = opCached._blockFunction; // Update values for arguments (inputs).

    const argValues = opCached._argValues; // Fields are set during opCached initialization.
    // Blocks should glow when a script is starting,
    // not after it has finished (see #1404).
    // Only blocks in blockContainers that don't forceNoGlow
    // should request a glow.

    if (!blockContainer.forceNoGlow) {
      thread.requestScriptGlowInFrame = true;
    } // Inputs are set during previous steps in the loop.


    const primitiveReportedValue = blockFunction(argValues, blockUtility); // If it's a promise, wait until promise resolves.

    if (isPromise(primitiveReportedValue)) {
      handlePromise(primitiveReportedValue, sequencer, thread, opCached, lastOperation); // Store the already reported values. They will be thawed into the
      // future versions of the same operations by block id. The reporting
      // operation if it is promise waiting will set its parent value at
      // that time.

      thread.justReported = null;
      currentStackFrame.reporting = ops[i].id;
      currentStackFrame.reported = ops.slice(0, i).map(reportedCached => {
        const inputName = reportedCached._parentKey;
        const reportedValues = reportedCached._parentValues;

        if (inputName === 'BROADCAST_INPUT') {
          return {
            opCached: reportedCached.id,
            inputValue: reportedValues[inputName].BROADCAST_OPTION.name
          };
        }

        return {
          opCached: reportedCached.id,
          inputValue: reportedValues[inputName]
        };
      }); // We are waiting for a promise. Stop running this set of operations
      // and continue them later after thawing the reported values.

      break;
    } else if (thread.status === Thread.STATUS_RUNNING) {
      if (lastOperation) {
        handleReport(primitiveReportedValue, sequencer, thread, opCached, lastOperation);
      } else {
        // By definition a block that is not last in the list has a
        // parent.
        const inputName = opCached._parentKey;
        const parentValues = opCached._parentValues;

        if (inputName === 'BROADCAST_INPUT') {
          // Something is plugged into the broadcast input.
          // Cast it to a string. We don't need an id here.
          parentValues.BROADCAST_OPTION.id = null;
          parentValues.BROADCAST_OPTION.name = cast.toString(primitiveReportedValue);
        } else {
          parentValues[inputName] = primitiveReportedValue;
        }
      }
    }
  }

  if (runtime.profiler !== null) {
    if (blockCached._profiler !== runtime.profiler) {
      _prepareBlockProfiling(runtime.profiler, blockCached);
    } // Determine the index that is after the last executed block. `i` is
    // currently the block that was just executed. `i + 1` will be the block
    // after that. `length` with the min call makes sure we don't try to
    // reference an operation outside of the set of operations.


    const end = Math.min(i + 1, length);

    for (let p = start; p < end; p++) {
      ops[p]._profilerFrame.count += 1;
    }
  }
};

module.exports = execute;

/***/ }),

/***/ "./src/engine/monitor-record.js":
/*!**************************************!*\
  !*** ./src/engine/monitor-record.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const {
  Record
} = __webpack_require__(/*! immutable */ "immutable");

const MonitorRecord = Record({
  id: null,
  // Block Id

  /** Present only if the monitor is sprite-specific, such as x position */
  spriteName: null,

  /** Present only if the monitor is sprite-specific, such as x position */
  targetId: null,
  opcode: null,
  value: null,
  params: null,
  mode: 'default',
  sliderMin: 0,
  sliderMax: 100,
  isDiscrete: true,
  x: null,
  // (x: null, y: null) Indicates that the monitor should be auto-positioned
  y: null,
  width: 0,
  height: 0,
  visible: true
});
module.exports = MonitorRecord;

/***/ }),

/***/ "./src/engine/mutation-adapter.js":
/*!****************************************!*\
  !*** ./src/engine/mutation-adapter.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const html = __webpack_require__(/*! htmlparser2 */ "htmlparser2");

const decodeHtml = __webpack_require__(/*! decode-html */ "decode-html");
/**
 * Convert a part of a mutation DOM to a mutation VM object, recursively.
 * @param {object} dom DOM object for mutation tag.
 * @return {object} Object representing useful parts of this mutation.
 */


const mutatorTagToObject = function mutatorTagToObject(dom) {
  const obj = Object.create(null);
  obj.tagName = dom.name;
  obj.children = [];

  for (const prop in dom.attribs) {
    if (prop === 'xmlns') continue;
    obj[prop] = decodeHtml(dom.attribs[prop]); // Note: the capitalization of block info in the following lines is important.
    // The lowercase is read in from xml which normalizes case. The VM uses camel case everywhere else.

    if (prop === 'blockinfo') {
      obj.blockInfo = JSON.parse(obj.blockinfo);
      delete obj.blockinfo;
    }
  }

  for (let i = 0; i < dom.children.length; i++) {
    obj.children.push(mutatorTagToObject(dom.children[i]));
  }

  return obj;
};
/**
 * Adapter between mutator XML or DOM and block representation which can be
 * used by the Scratch runtime.
 * @param {(object|string)} mutation Mutation XML string or DOM.
 * @return {object} Object representing the mutation.
 */


const mutationAdpater = function mutationAdpater(mutation) {
  let mutationParsed; // Check if the mutation is already parsed; if not, parse it.

  if (typeof mutation === 'object') {
    mutationParsed = mutation;
  } else {
    mutationParsed = html.parseDOM(mutation)[0];
  }

  return mutatorTagToObject(mutationParsed);
};

module.exports = mutationAdpater;

/***/ }),

/***/ "./src/engine/profiler.js":
/*!********************************!*\
  !*** ./src/engine/profiler.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @fileoverview
 * A way to profile Scratch internal performance. Like what blocks run during a
 * step? How much time do they take? How much time is spent inbetween blocks?
 *
 * Profiler aims for to spend as little time inside its functions while
 * recording. For this it has a simple internal record structure that records a
 * series of values for each START and STOP event in a single array. This lets
 * all the values be pushed in one call for the array. This simplicity allows
 * the contents of the start() and stop() calls to be inlined in areas that are
 * called frequently enough to want even greater performance from Profiler so
 * what is recorded better reflects on the profiled code and not Profiler
 * itself.
 */

/**
 * The next id returned for a new profile'd function.
 * @type {number}
 */
let nextId = 0;
/**
 * The mapping of names to ids.
 * @const {Object.<string, number>}
 */

const profilerNames = {};
/**
 * The START event identifier in Profiler records.
 * @const {number}
 */

const START = 0;
/**
 * The STOP event identifier in Profiler records.
 * @const {number}
 */

const STOP = 1;
/**
 * The number of cells used in the records array by a START event.
 * @const {number}
 */

const START_SIZE = 4;
/**
 * The number of cells used in the records array by a STOP event.
 * @const {number}
 */

const STOP_SIZE = 2;
/**
 * Stored reference to Performance instance provided by the Browser.
 * @const {Performance}
 */

const performance = typeof window === 'object' && window.performance;
/**
 * Callback handle called by Profiler for each frame it decodes from its
 * records.
 * @callback FrameCallback
 * @param {ProfilerFrame} frame
 */

/**
 * A set of information about a frame of execution that was recorded.
 */

class ProfilerFrame {
  /**
   * @param {number} depth Depth of the frame in the recorded stack.
   */
  constructor(depth) {
    /**
     * The numeric id of a record symbol like Runtime._step or
     * blockFunction.
     * @type {number}
     */
    this.id = -1;
    /**
     * The amount of time spent inside the recorded frame and any deeper
     * frames.
     * @type {number}
     */

    this.totalTime = 0;
    /**
     * The amount of time spent only inside this record frame. Not
     * including time in any deeper frames.
     * @type {number}
     */

    this.selfTime = 0;
    /**
     * An arbitrary argument for the recorded frame. For example a block
     * function might record its opcode as an argument.
     * @type {*}
     */

    this.arg = null;
    /**
     * The depth of the recorded frame. This can help compare recursive
     * funtions that are recorded. Each level of recursion with have a
     * different depth value.
     * @type {number}
     */

    this.depth = depth;
    /**
     * A summarized count of the number of calls to this frame.
     * @type {number}
     */

    this.count = 0;
  }

}

class Profiler {
  /**
   * @param {FrameCallback} onFrame a handle called for each recorded frame.
   * The passed frame value may not be stored as it'll be updated with later
   * frame information. Any information that is further stored by the handler
   * should make copies or reduce the information.
   */
  constructor() {
    let onFrame = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};

    /**
     * A series of START and STOP values followed by arguments. After
     * recording is complete the full set of records is reported back by
     * stepping through the series to connect the relative START and STOP
     * information.
     * @type {Array.<*>}
     */
    this.records = [];
    /**
     * An array of frames incremented on demand instead as part of start
     * and stop.
     * @type {Array.<ProfilerFrame>}
     */

    this.increments = [];
    /**
     * An array of profiler frames separated by counter argument. Generally
     * for Scratch these frames are separated by block function opcode.
     * This tracks each time an opcode is called.
     * @type {Array.<ProfilerFrame>}
     */

    this.counters = [];
    /**
     * A frame with no id or argument.
     * @type {ProfilerFrame}
     */

    this.nullFrame = new ProfilerFrame(-1);
    /**
     * A cache of ProfilerFrames to reuse when reporting the recorded
     * frames in records.
     * @type {Array.<ProfilerFrame>}
     */

    this._stack = [new ProfilerFrame(0)];
    /**
     * A callback handle called with each decoded frame when reporting back
     * all the recorded times.
     * @type {FrameCallback}
     */

    this.onFrame = onFrame;
    /**
     * A reference to the START record id constant.
     * @const {number}
     */

    this.START = START;
    /**
     * A reference to the STOP record id constant.
     * @const {number}
     */

    this.STOP = STOP;
  }
  /**
   * Start recording a frame of time for an id and optional argument.
   * @param {number} id The id returned by idByName for a name symbol like
   * Runtime._step.
   * @param {?*} arg An arbitrary argument value to store with the frame.
   */


  start(id, arg) {
    this.records.push(START, id, arg, performance.now());
  }
  /**
   * Stop the current frame.
   */


  stop() {
    this.records.push(STOP, performance.now());
  }
  /**
   * Increment the number of times this symbol is called.
   * @param {number} id The id returned by idByName for a name symbol.
   */


  increment(id) {
    if (!this.increments[id]) {
      this.increments[id] = new ProfilerFrame(-1);
      this.increments[id].id = id;
    }

    this.increments[id].count += 1;
  }
  /**
   * Find or create a ProfilerFrame-like object whose counter can be
   * incremented outside of the Profiler.
   * @param {number} id The id returned by idByName for a name symbol.
   * @param {*} arg The argument for a frame that identifies it in addition
   *   to the id.
   * @return {{count: number}} A ProfilerFrame-like whose count should be
   *   incremented for each call.
   */


  frame(id, arg) {
    for (let i = 0; i < this.counters.length; i++) {
      if (this.counters[i].id === id && this.counters[i].arg === arg) {
        return this.counters[i];
      }
    }

    const newCounter = new ProfilerFrame(-1);
    newCounter.id = id;
    newCounter.arg = arg;
    this.counters.push(newCounter);
    return newCounter;
  }
  /**
   * Decode records and report all frames to `this.onFrame`.
   */


  reportFrames() {
    const stack = this._stack;
    let depth = 1; // Step through the records and initialize Frame instances from the
    // START and STOP events. START and STOP events are separated by events
    // for deeper frames run by higher frames. Frames are stored on a stack
    // and reinitialized for each START event. When a stop event is reach
    // the Frame for the current depth has its final values stored and its
    // passed to the current onFrame callback. This way Frames are "pushed"
    // for each START event and "popped" for each STOP and handed to an
    // outside handle to any desired reduction of the collected data.

    for (let i = 0; i < this.records.length;) {
      if (this.records[i] === START) {
        if (depth >= stack.length) {
          stack.push(new ProfilerFrame(depth));
        } // Store id, arg, totalTime, and initialize selfTime.


        const frame = stack[depth++];
        frame.id = this.records[i + 1];
        frame.arg = this.records[i + 2]; // totalTime is first set as the time recorded by this START
        // event. Once the STOP event is reached the stored start time
        // is subtracted from the recorded stop time. The resulting
        // difference is the actual totalTime, and replaces the start
        // time in frame.totalTime.
        //
        // totalTime is used this way as a convenient member to store a
        // value between the two events without needing additional
        // members on the Frame or in a shadow map.

        frame.totalTime = this.records[i + 3]; // selfTime is decremented until we reach the STOP event for
        // this frame. totalTime will be added to it then to get the
        // time difference.

        frame.selfTime = 0;
        i += START_SIZE;
      } else if (this.records[i] === STOP) {
        const now = this.records[i + 1];
        const frame = stack[--depth]; // totalTime is the difference between the start event time
        // stored in totalTime and the stop event time pulled from this
        // record.

        frame.totalTime = now - frame.totalTime; // selfTime is the difference of this frame's totalTime and the
        // sum of totalTime of deeper frames.

        frame.selfTime += frame.totalTime; // Remove this frames totalTime from the parent's selfTime.

        stack[depth - 1].selfTime -= frame.totalTime; // This frame occured once.

        frame.count = 1;
        this.onFrame(frame);
        i += STOP_SIZE;
      } else {
        this.records.length = 0;
        throw new Error('Unable to decode Profiler records.');
      }
    }

    for (let j = 0; j < this.increments.length; j++) {
      if (this.increments[j] && this.increments[j].count > 0) {
        this.onFrame(this.increments[j]);
        this.increments[j].count = 0;
      }
    }

    for (let k = 0; k < this.counters.length; k++) {
      if (this.counters[k].count > 0) {
        this.onFrame(this.counters[k]);
        this.counters[k].count = 0;
      }
    }

    this.records.length = 0;
  }
  /**
   * Lookup or create an id for a frame name.
   * @param {string} name The name to return an id for.
   * @return {number} The id for the passed name.
   */


  idByName(name) {
    return Profiler.idByName(name);
  }
  /**
   * Reverse lookup the name from a given frame id.
   * @param {number} id The id to search for.
   * @return {string} The name for the given id.
   */


  nameById(id) {
    return Profiler.nameById(id);
  }
  /**
   * Lookup or create an id for a frame name.
   * @static
   * @param {string} name The name to return an id for.
   * @return {number} The id for the passed name.
   */


  static idByName(name) {
    if (typeof profilerNames[name] !== 'number') {
      profilerNames[name] = nextId++;
    }

    return profilerNames[name];
  }
  /**
   * Reverse lookup the name from a given frame id.
   * @static
   * @param {number} id The id to search for.
   * @return {string} The name for the given id.
   */


  static nameById(id) {
    for (const name in profilerNames) {
      if (profilerNames[name] === id) {
        return name;
      }
    }

    return null;
  }
  /**
   * Profiler is only available on platforms with the Performance API.
   * @return {boolean} Can the Profiler run in this browser?
   */


  static available() {
    return typeof window === 'object' && typeof window.performance !== 'undefined';
  }

}
/**
 * A reference to the START record id constant.
 * @const {number}
 */


Profiler.START = START;
/**
 * A reference to the STOP record id constant.
 * @const {number}
 */

Profiler.STOP = STOP;
module.exports = Profiler;

/***/ }),

/***/ "./src/engine/runtime.js":
/*!*******************************!*\
  !*** ./src/engine/runtime.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const EventEmitter = __webpack_require__(/*! events */ "events");

const {
  OrderedMap
} = __webpack_require__(/*! immutable */ "immutable");

const ExtendedJSON = __webpack_require__(/*! @turbowarp/json */ "./node_modules/@turbowarp/json/src/index.js");

const ArgumentType = __webpack_require__(/*! ../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const Blocks = __webpack_require__(/*! ./blocks */ "./src/engine/blocks.js");

const BlocksRuntimeCache = __webpack_require__(/*! ./blocks-runtime-cache */ "./src/engine/blocks-runtime-cache.js");

const BlockType = __webpack_require__(/*! ../extension-support/block-type */ "./src/extension-support/block-type.js");

const Profiler = __webpack_require__(/*! ./profiler */ "./src/engine/profiler.js");

const Sequencer = __webpack_require__(/*! ./sequencer */ "./src/engine/sequencer.js");

const execute = __webpack_require__(/*! ./execute.js */ "./src/engine/execute.js");

const ScratchBlocksConstants = __webpack_require__(/*! ./scratch-blocks-constants */ "./src/engine/scratch-blocks-constants.js");

const TargetType = __webpack_require__(/*! ../extension-support/target-type */ "./src/extension-support/target-type.js");

const Thread = __webpack_require__(/*! ./thread */ "./src/engine/thread.js");

const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");

const maybeFormatMessage = __webpack_require__(/*! ../util/maybe-format-message */ "./src/util/maybe-format-message.js");

const StageLayering = __webpack_require__(/*! ./stage-layering */ "./src/engine/stage-layering.js");

const Variable = __webpack_require__(/*! ./variable */ "./src/engine/variable.js");

const xmlEscape = __webpack_require__(/*! ../util/xml-escape */ "./src/util/xml-escape.js");

const ScratchLinkWebSocket = __webpack_require__(/*! ../util/scratch-link-websocket */ "./src/util/scratch-link-websocket.js"); // Virtual I/O devices.


const Clock = __webpack_require__(/*! ../io/clock */ "./src/io/clock.js");

const Cloud = __webpack_require__(/*! ../io/cloud */ "./src/io/cloud.js");

const Keyboard = __webpack_require__(/*! ../io/keyboard */ "./src/io/keyboard.js");

const Mouse = __webpack_require__(/*! ../io/mouse */ "./src/io/mouse.js");

const MouseWheel = __webpack_require__(/*! ../io/mouseWheel */ "./src/io/mouseWheel.js");

const UserData = __webpack_require__(/*! ../io/userData */ "./src/io/userData.js");

const Video = __webpack_require__(/*! ../io/video */ "./src/io/video.js");

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");

const uid = __webpack_require__(/*! ../util/uid */ "./src/util/uid.js");

const defaultBlockPackages = {
  scratch3_control: __webpack_require__(/*! ../blocks/scratch3_control */ "./src/blocks/scratch3_control.js"),
  scratch3_event: __webpack_require__(/*! ../blocks/scratch3_event */ "./src/blocks/scratch3_event.js"),
  scratch3_looks: __webpack_require__(/*! ../blocks/scratch3_looks */ "./src/blocks/scratch3_looks.js"),
  scratch3_motion: __webpack_require__(/*! ../blocks/scratch3_motion */ "./src/blocks/scratch3_motion.js"),
  scratch3_operators: __webpack_require__(/*! ../blocks/scratch3_operators */ "./src/blocks/scratch3_operators.js"),
  scratch3_sound: __webpack_require__(/*! ../blocks/scratch3_sound */ "./src/blocks/scratch3_sound.js"),
  scratch3_sensing: __webpack_require__(/*! ../blocks/scratch3_sensing */ "./src/blocks/scratch3_sensing.js"),
  scratch3_data: __webpack_require__(/*! ../blocks/scratch3_data */ "./src/blocks/scratch3_data.js"),
  scratch3_procedures: __webpack_require__(/*! ../blocks/scratch3_procedures */ "./src/blocks/scratch3_procedures.js")
};

const interpolate = __webpack_require__(/*! ./tw-interpolate */ "./src/engine/tw-interpolate.js");

const FrameLoop = __webpack_require__(/*! ./tw-frame-loop */ "./src/engine/tw-frame-loop.js");

const defaultExtensionColors = ['#0FBD8C', '#0DA57A', '#0B8E69'];
const COMMENT_CONFIG_MAGIC = ' // _twconfig_';
/**
 * Information used for converting Scratch argument types into scratch-blocks data.
 * @type {object.<ArgumentType, {shadowType: string, fieldType: string}>}
 */

const ArgumentTypeMap = (() => {
  const map = {};
  map[ArgumentType.ANGLE] = {
    shadow: {
      type: 'math_angle',
      // We specify fieldNames here so that we can pick
      // create and populate a field with the defaultValue
      // specified in the extension.
      // When the `fieldName` property is not specified,
      // the <field></field> will be left out of the XML and
      // the scratch-blocks defaults for that field will be
      // used instead (e.g. default of 0 for number fields)
      fieldName: 'NUM'
    }
  };
  map[ArgumentType.COLOR] = {
    shadow: {
      type: 'colour_picker',
      fieldName: 'COLOUR'
    }
  };
  map[ArgumentType.NUMBER] = {
    shadow: {
      type: 'math_number',
      fieldName: 'NUM'
    }
  };
  map[ArgumentType.STRING] = {
    shadow: {
      type: 'text',
      fieldName: 'TEXT'
    }
  };
  map[ArgumentType.BOOLEAN] = {
    check: 'Boolean'
  };
  map[ArgumentType.MATRIX] = {
    shadow: {
      type: 'matrix',
      fieldName: 'MATRIX'
    }
  };
  map[ArgumentType.NOTE] = {
    shadow: {
      type: 'note',
      fieldName: 'NOTE'
    }
  };
  map[ArgumentType.IMAGE] = {
    // Inline images are weird because they're not actually "arguments".
    // They are more analagous to the label on a block.
    fieldType: 'field_image'
  };
  return map;
})();
/**
 * A pair of functions used to manage the cloud variable limit,
 * to be used when adding (or attempting to add) or removing a cloud variable.
 * @typedef {object} CloudDataManager
 * @property {function} canAddCloudVariable A function to call to check that
 * a cloud variable can be added.
 * @property {function} addCloudVariable A function to call to track a new
 * cloud variable on the runtime.
 * @property {function} removeCloudVariable A function to call when
 * removing an existing cloud variable.
 * @property {function} hasCloudVariables A function to call to check that
 * the runtime has any cloud variables.
 * @property {function} getNumberOfCloudVariables A function that returns the
 * number of cloud variables in the project.
 */

/**
 * Creates and manages cloud variable limit in a project,
 * and returns two functions to be used to add a new
 * cloud variable (while checking that it can be added)
 * and remove an existing cloud variable.
 * These are to be called whenever attempting to create or delete
 * a cloud variable.
 * @param {Object} cloudOptions
 * @param {number} cloudOptions.limit Maximum number of cloud variables
 * @return {CloudDataManager} The functions to be used when adding or removing a
 * cloud variable.
 */


const cloudDataManager = cloudOptions => {
  let count = 0;

  const canAddCloudVariable = () => count < cloudOptions.limit;

  const addCloudVariable = () => {
    count++;
  };

  const removeCloudVariable = () => {
    count--;
  };

  const hasCloudVariables = () => count > 0;

  const getNumberOfCloudVariables = () => count;

  return {
    canAddCloudVariable,
    addCloudVariable,
    removeCloudVariable,
    hasCloudVariables,
    getNumberOfCloudVariables
  };
};
/**
 * Numeric ID for Runtime._step in Profiler instances.
 * @type {number}
 */


let stepProfilerId = -1;
/**
 * Numeric ID for Sequencer.stepThreads in Profiler instances.
 * @type {number}
 */

let stepThreadsProfilerId = -1;
/**
 * Numeric ID for RenderWebGL.draw in Profiler instances.
 * @type {number}
 */

let rendererDrawProfilerId = -1;
/**
 * Manages targets, scripts, and the sequencer.
 * @constructor
 */

class Runtime extends EventEmitter {
  constructor() {
    super();
    /**
     * Target management and storage.
     * @type {Array.<!Target>}
     */

    this.targets = [];
    /**
     * Targets in reverse order of execution. Shares its order with drawables.
     * @type {Array.<!Target>}
     */

    this.executableTargets = [];
    /**
     * A list of threads that are currently running in the VM.
     * Threads are added when execution starts and pruned when execution ends.
     * @type {Array.<Thread>}
     */

    this.threads = [];
    this.threadMap = new Map();
    /** @type {!Sequencer} */

    this.sequencer = new Sequencer(this);
    /**
     * Storage container for flyout blocks.
     * These will execute on `_editingTarget.`
     * @type {!Blocks}
     */

    this.flyoutBlocks = new Blocks(this, true
    /* force no glow */
    );
    /**
     * Storage container for monitor blocks.
     * These will execute on a target maybe
     * @type {!Blocks}
     */

    this.monitorBlocks = new Blocks(this, true
    /* force no glow */
    );
    /**
     * Currently known editing target for the VM.
     * @type {?Target}
     */

    this._editingTarget = null;
    /**
     * Map to look up a block primitive's implementation function by its opcode.
     * This is a two-step lookup: package name first, then primitive name.
     * @type {Object.<string, Function>}
     */

    this._primitives = {};
    /**
     * Map to look up all block information by extended opcode.
     * @type {Array.<CategoryInfo>}
     * @private
     */

    this._blockInfo = [];
    /**
     * Map to look up hat blocks' metadata.
     * Keys are opcode for hat, values are metadata objects.
     * @type {Object.<string, Object>}
     */

    this._hats = {};
    /**
     * A list of script block IDs that were glowing during the previous frame.
     * @type {!Array.<!string>}
     */

    this._scriptGlowsPreviousFrame = [];
    /**
     * Number of non-monitor threads running during the previous frame.
     * @type {number}
     */

    this._nonMonitorThreadCount = 0;
    /**
     * All threads that finished running and were removed from this.threads
     * by behaviour in Sequencer.stepThreads.
     * @type {Array<Thread>}
     */

    this._lastStepDoneThreads = null;
    /**
     * Currently known number of clones, used to enforce clone limit.
     * @type {number}
     */

    this._cloneCounter = 0;
    /**
     * Flag to emit a targets update at the end of a step. When target data
     * changes, this flag is set to true.
     * @type {boolean}
     */

    this._refreshTargets = false;
    /**
     * Map to look up all monitor block information by opcode.
     * @type {object}
     * @private
     */

    this.monitorBlockInfo = {};
    /**
     * Ordered map of all monitors, which are MonitorReporter objects.
     */

    this._monitorState = OrderedMap({});
    /**
     * Monitor state from last tick
     */

    this._prevMonitorState = OrderedMap({});
    /**
     * Whether the project is in "turbo mode."
     * @type {Boolean}
     */

    this.turboMode = false;
    /**
     * tw: Responsible for managing the VM's many timers.
     */

    this.frameLoop = new FrameLoop(this);
    /**
     * Current length of a step.
     * Changes as mode switches, and used by the sequencer to calculate
     * WORK_TIME.
     * @type {!number}
     */

    this.currentStepTime = 1000 / 30; // Set an intial value for this.currentMSecs

    this.updateCurrentMSecs();
    /**
     * Whether any primitive has requested a redraw.
     * Affects whether `Sequencer.stepThreads` will yield
     * after stepping each thread.
     * Reset on every frame.
     * @type {boolean}
     */

    this.redrawRequested = false; // Register all given block packages.

    this._registerBlockPackages(); // Register and initialize "IO devices", containers for processing
    // I/O related data.

    /** @type {Object.<string, Object>} */


    this.ioDevices = {
      clock: new Clock(this),
      cloud: new Cloud(this),
      keyboard: new Keyboard(this),
      mouse: new Mouse(this),
      mouseWheel: new MouseWheel(this),
      userData: new UserData(),
      video: new Video(this)
    };
    /**
     * A list of extensions, used to manage hardware connection.
     */

    this.peripheralExtensions = {};
    /**
     * A runtime profiler that records timed events for later playback to
     * diagnose Scratch performance.
     * @type {Profiler}
     */

    this.profiler = null;
    this.cloudOptions = {
      limit: 10
    };
    const newCloudDataManager = cloudDataManager(this.cloudOptions);
    /**
     * Check wether the runtime has any cloud data.
     * @type {function}
     * @return {boolean} Whether or not the runtime currently has any
     * cloud variables.
     */

    this.hasCloudData = newCloudDataManager.hasCloudVariables;
    /**
     * A function which checks whether a new cloud variable can be added
     * to the runtime.
     * @type {function}
     * @return {boolean} Whether or not a new cloud variable can be added
     * to the runtime.
     */

    this.canAddCloudVariable = newCloudDataManager.canAddCloudVariable;
    /**
     * A function which returns the number of cloud variables in the runtime.
     * @returns {number}
     */

    this.getNumberOfCloudVariables = newCloudDataManager.getNumberOfCloudVariables;
    /**
     * A function that tracks a new cloud variable in the runtime,
     * updating the cloud variable limit. Calling this function will
     * emit a cloud data update event if this is the first cloud variable
     * being added.
     * @type {function}
     */

    this.addCloudVariable = this._initializeAddCloudVariable(newCloudDataManager);
    /**
     * A function which updates the runtime's cloud variable limit
     * when removing a cloud variable and emits a cloud update event
     * if the last of the cloud variables is being removed.
     * @type {function}
     */

    this.removeCloudVariable = this._initializeRemoveCloudVariable(newCloudDataManager);
    /**
     * A string representing the origin of the current project from outside of the
     * Scratch community, such as CSFirst.
     * @type {?string}
     */

    this.origin = null;
    this._stageTarget = null;
    this.addonBlocks = {};
    this.stageWidth = Runtime.STAGE_WIDTH;
    this.stageHeight = Runtime.STAGE_HEIGHT;
    this.runtimeOptions = {
      maxClones: Runtime.MAX_CLONES,
      miscLimits: true,
      fencing: true
    };
    this.compilerOptions = {
      enabled: true,
      warpTimer: false
    };
    this.debug = false;
    this._lastStepTime = Date.now();
    this.interpolationEnabled = false;
    this._defaultStoredSettings = this._generateAllProjectOptions();
    /**
     * TW: We support a "packaged runtime" mode. This can be used when:
     *  - there will never be an editor attached such as scratch-gui or scratch-blocks
     *  - the project will never be exported with saveProjectSb3()
     *  - original costume and sound data is not needed
     * In this mode, the runtime is able to discard large amounts of data and avoid some processing
     * to make projects load faster and use less memory.
     * This is not designed to protect projects from copying as someone can still copy the data that
     * gets fed into the runtime in the first place.
     * This mode is used by the TurboWarp Packager.
     */

    this.isPackaged = false;
  }
  /**
   * Width of the stage, in pixels.
   * @const {number}
   */


  static get STAGE_WIDTH() {
    // tw: stage size is set per-runtime, this is only the initial value
    return 480;
  }
  /**
   * Height of the stage, in pixels.
   * @const {number}
   */


  static get STAGE_HEIGHT() {
    // tw: stage size is set per-runtime, this is only the initial value
    return 360;
  }
  /**
   * Event name for glowing a script.
   * @const {string}
   */


  static get SCRIPT_GLOW_ON() {
    return 'SCRIPT_GLOW_ON';
  }
  /**
   * Event name for unglowing a script.
   * @const {string}
   */


  static get SCRIPT_GLOW_OFF() {
    return 'SCRIPT_GLOW_OFF';
  }
  /**
   * Event name for glowing a block.
   * @const {string}
   */


  static get BLOCK_GLOW_ON() {
    return 'BLOCK_GLOW_ON';
  }
  /**
   * Event name for unglowing a block.
   * @const {string}
   */


  static get BLOCK_GLOW_OFF() {
    return 'BLOCK_GLOW_OFF';
  }
  /**
   * Event name for a cloud data update
   * to this project.
   * @const {string}
   */


  static get HAS_CLOUD_DATA_UPDATE() {
    return 'HAS_CLOUD_DATA_UPDATE';
  }
  /**
   * Event name for turning on turbo mode.
   * @const {string}
   */


  static get TURBO_MODE_ON() {
    return 'TURBO_MODE_ON';
  }
  /**
   * Event name for turning off turbo mode.
   * @const {string}
   */


  static get TURBO_MODE_OFF() {
    return 'TURBO_MODE_OFF';
  }
  /**
   * Event name for runtime options changing.
   * @const {string}
   */


  static get RUNTIME_OPTIONS_CHANGED() {
    return 'RUNTIME_OPTIONS_CHANGED';
  }
  /**
   * Event name for compiler options changing.
   * @const {string}
   */


  static get COMPILER_OPTIONS_CHANGED() {
    return 'COMPILER_OPTIONS_CHANGED';
  }
  /**
   * Event name for framerate changing.
   * @const {string}
   */


  static get FRAMERATE_CHANGED() {
    return 'FRAMERATE_CHANGED';
  }
  /**
   * Event name for interpolation changing.
   * @const {string}
   */


  static get INTERPOLATION_CHANGED() {
    return 'INTERPOLATION_CHANGED';
  }
  /**
   * Event name for stage size changing.
   * @const {string}
   */


  static get STAGE_SIZE_CHANGED() {
    return 'STAGE_SIZE_CHANGED';
  }
  /**
   * Event name for compiler errors.
   * @const {string}
   */


  static get COMPILE_ERROR() {
    return 'COMPILE_ERROR';
  }
  /**
   * Event name when the project is started (threads may not necessarily be
   * running).
   * @const {string}
   */


  static get PROJECT_START() {
    return 'PROJECT_START';
  }
  /**
   * Event name when threads start running.
   * Used by the UI to indicate running status.
   * @const {string}
   */


  static get PROJECT_RUN_START() {
    return 'PROJECT_RUN_START';
  }
  /**
   * Event name when threads stop running
   * Used by the UI to indicate not-running status.
   * @const {string}
   */


  static get PROJECT_RUN_STOP() {
    return 'PROJECT_RUN_STOP';
  }
  /**
   * Event name for project being stopped or restarted by the user.
   * Used by blocks that need to reset state.
   * @const {string}
   */


  static get PROJECT_STOP_ALL() {
    return 'PROJECT_STOP_ALL';
  }
  /**
   * Event name for target being stopped by a stop for target call.
   * Used by blocks that need to stop individual targets.
   * @const {string}
   */


  static get STOP_FOR_TARGET() {
    return 'STOP_FOR_TARGET';
  }
  /**
   * Event name for visual value report.
   * @const {string}
   */


  static get VISUAL_REPORT() {
    return 'VISUAL_REPORT';
  }
  /**
   * Event name for project loaded report.
   * @const {string}
   */


  static get PROJECT_LOADED() {
    return 'PROJECT_LOADED';
  }
  /**
   * Event name for report that a change was made that can be saved
   * @const {string}
   */


  static get PROJECT_CHANGED() {
    return 'PROJECT_CHANGED';
  }
  /**
   * Event name for report that a change was made to an extension in the toolbox.
   * @const {string}
   */


  static get TOOLBOX_EXTENSIONS_NEED_UPDATE() {
    return 'TOOLBOX_EXTENSIONS_NEED_UPDATE';
  }
  /**
   * Event name for targets update report.
   * @const {string}
   */


  static get TARGETS_UPDATE() {
    return 'TARGETS_UPDATE';
  }
  /**
   * Event name for monitors update.
   * @const {string}
   */


  static get MONITORS_UPDATE() {
    return 'MONITORS_UPDATE';
  }
  /**
   * Event name for block drag update.
   * @const {string}
   */


  static get BLOCK_DRAG_UPDATE() {
    return 'BLOCK_DRAG_UPDATE';
  }
  /**
   * Event name for block drag end.
   * @const {string}
   */


  static get BLOCK_DRAG_END() {
    return 'BLOCK_DRAG_END';
  }
  /**
   * Event name for reporting that an extension was added.
   * @const {string}
   */


  static get EXTENSION_ADDED() {
    return 'EXTENSION_ADDED';
  }
  /**
   * Event name for reporting that an extension as asked for a custom field to be added
   * @const {string}
   */


  static get EXTENSION_FIELD_ADDED() {
    return 'EXTENSION_FIELD_ADDED';
  }
  /**
   * Event name for updating the available set of peripheral devices.
   * This causes the peripheral connection modal to update a list of
   * available peripherals.
   * @const {string}
   */


  static get PERIPHERAL_LIST_UPDATE() {
    return 'PERIPHERAL_LIST_UPDATE';
  }
  /**
   * Event name for when the user picks a bluetooth device to connect to
   * via Companion Device Manager (CDM)
   * @const {string}
   */


  static get USER_PICKED_PERIPHERAL() {
    return 'USER_PICKED_PERIPHERAL';
  }
  /**
   * Event name for reporting that a peripheral has connected.
   * This causes the status button in the blocks menu to indicate 'connected'.
   * @const {string}
   */


  static get PERIPHERAL_CONNECTED() {
    return 'PERIPHERAL_CONNECTED';
  }
  /**
   * Event name for reporting that a peripheral has been intentionally disconnected.
   * This causes the status button in the blocks menu to indicate 'disconnected'.
   * @const {string}
   */


  static get PERIPHERAL_DISCONNECTED() {
    return 'PERIPHERAL_DISCONNECTED';
  }
  /**
   * Event name for reporting that a peripheral has encountered a request error.
   * This causes the peripheral connection modal to switch to an error state.
   * @const {string}
   */


  static get PERIPHERAL_REQUEST_ERROR() {
    return 'PERIPHERAL_REQUEST_ERROR';
  }
  /**
   * Event name for reporting that a peripheral connection has been lost.
   * This causes a 'peripheral connection lost' error alert to display.
   * @const {string}
   */


  static get PERIPHERAL_CONNECTION_LOST_ERROR() {
    return 'PERIPHERAL_CONNECTION_LOST_ERROR';
  }
  /**
   * Event name for reporting that a peripheral has not been discovered.
   * This causes the peripheral connection modal to show a timeout state.
   * @const {string}
   */


  static get PERIPHERAL_SCAN_TIMEOUT() {
    return 'PERIPHERAL_SCAN_TIMEOUT';
  }
  /**
   * Event name to indicate that the microphone is being used to stream audio.
   * @const {string}
   */


  static get MIC_LISTENING() {
    return 'MIC_LISTENING';
  }
  /**
   * Event name for reporting that blocksInfo was updated.
   * @const {string}
   */


  static get BLOCKSINFO_UPDATE() {
    return 'BLOCKSINFO_UPDATE';
  }
  /**
   * Event name when the runtime tick loop has been started.
   * @const {string}
   */


  static get RUNTIME_STARTED() {
    return 'RUNTIME_STARTED';
  }
  /**
   * Event name when the runtime tick loop has been stopped.
   * @const {string}
   */


  static get RUNTIME_STOPPED() {
    return 'RUNTIME_STOPPED';
  }
  /**
   * Event name when the runtime dispose has been called.
   * @const {string}
   */


  static get RUNTIME_DISPOSED() {
    return 'RUNTIME_DISPOSED';
  }
  /**
   * Event name for reporting that a block was updated and needs to be rerendered.
   * @const {string}
   */


  static get BLOCKS_NEED_UPDATE() {
    return 'BLOCKS_NEED_UPDATE';
  }
  /**
   * How rapidly we try to step threads by default, in ms.
   */


  static get THREAD_STEP_INTERVAL() {
    // tw: not used, only exists for compatibility
    return 1000 / 60;
  }
  /**
   * In compatibility mode, how rapidly we try to step threads, in ms.
   */


  static get THREAD_STEP_INTERVAL_COMPATIBILITY() {
    // tw: not used, only exists for compatibility
    return 1000 / 30;
  }
  /**
   * How many clones can be created at a time.
   * @const {number}
   */


  static get MAX_CLONES() {
    // tw: clone limit is set per-runtime in runtimeOptions, this is only the initial value
    return 300;
  } // -----------------------------------------------------------------------------
  // -----------------------------------------------------------------------------
  // Helper function for initializing the addCloudVariable function


  _initializeAddCloudVariable(newCloudDataManager) {
    // The addCloudVariable function
    return () => {
      const hadCloudVarsBefore = this.hasCloudData();
      newCloudDataManager.addCloudVariable();

      if (!hadCloudVarsBefore && this.hasCloudData()) {
        this.emit(Runtime.HAS_CLOUD_DATA_UPDATE, true);
      }
    };
  } // Helper function for initializing the removeCloudVariable function


  _initializeRemoveCloudVariable(newCloudDataManager) {
    return () => {
      const hadCloudVarsBefore = this.hasCloudData();
      newCloudDataManager.removeCloudVariable();

      if (hadCloudVarsBefore && !this.hasCloudData()) {
        this.emit(Runtime.HAS_CLOUD_DATA_UPDATE, false);
      }
    };
  }
  /**
   * Register default block packages with this runtime.
   * @todo Prefix opcodes with package name.
   * @private
   */


  _registerBlockPackages() {
    for (const packageName in defaultBlockPackages) {
      if (defaultBlockPackages.hasOwnProperty(packageName)) {
        // @todo pass a different runtime depending on package privilege?
        const packageObject = new defaultBlockPackages[packageName](this); // Collect primitives from package.

        if (packageObject.getPrimitives) {
          const packagePrimitives = packageObject.getPrimitives();

          for (const op in packagePrimitives) {
            if (packagePrimitives.hasOwnProperty(op)) {
              this._primitives[op] = packagePrimitives[op].bind(packageObject);
            }
          }
        } // Collect hat metadata from package.


        if (packageObject.getHats) {
          const packageHats = packageObject.getHats();

          for (const hatName in packageHats) {
            if (packageHats.hasOwnProperty(hatName)) {
              this._hats[hatName] = packageHats[hatName];
            }
          }
        } // Collect monitored from package.


        if (packageObject.getMonitored) {
          this.monitorBlockInfo = Object.assign({}, this.monitorBlockInfo, packageObject.getMonitored());
        }

        this.compilerRegisterExtension(packageName, packageObject);
      }
    }
  }

  compilerRegisterExtension(name, extensionObject) {
    this["ext_".concat(name)] = extensionObject;
  }

  getMonitorState() {
    return this._monitorState;
  }
  /**
   * Generate an extension-specific menu ID.
   * @param {string} menuName - the name of the menu.
   * @param {string} extensionId - the ID of the extension hosting the menu.
   * @returns {string} - the constructed ID.
   * @private
   */


  _makeExtensionMenuId(menuName, extensionId) {
    return "".concat(extensionId, "_menu_").concat(xmlEscape(menuName));
  }
  /**
   * Create a context ("args") object for use with `formatMessage` on messages which might be target-specific.
   * @param {Target} [target] - the target to use as context. If a target is not provided, default to the current
   * editing target or the stage.
   */


  makeMessageContextForTarget(target) {
    const context = {};
    target = target || this.getEditingTarget() || this.getTargetForStage();

    if (target) {
      context.targetType = target.isStage ? TargetType.STAGE : TargetType.SPRITE;
    }
  }
  /**
   * Register the primitives provided by an extension.
   * @param {ExtensionMetadata} extensionInfo - information about the extension (id, blocks, etc.)
   * @private
   */


  _registerExtensionPrimitives(extensionInfo) {
    const categoryInfo = {
      id: extensionInfo.id,
      name: maybeFormatMessage(extensionInfo.name),
      showStatusButton: extensionInfo.showStatusButton,
      blockIconURI: extensionInfo.blockIconURI,
      menuIconURI: extensionInfo.menuIconURI
    };

    if (extensionInfo.color1) {
      categoryInfo.color1 = extensionInfo.color1;
      categoryInfo.color2 = extensionInfo.color2;
      categoryInfo.color3 = extensionInfo.color3;
    } else {
      categoryInfo.color1 = defaultExtensionColors[0];
      categoryInfo.color2 = defaultExtensionColors[1];
      categoryInfo.color3 = defaultExtensionColors[2];
    }

    this._blockInfo.push(categoryInfo);

    this._fillExtensionCategory(categoryInfo, extensionInfo);

    for (const fieldTypeName in categoryInfo.customFieldTypes) {
      if (extensionInfo.customFieldTypes.hasOwnProperty(fieldTypeName)) {
        const fieldTypeInfo = categoryInfo.customFieldTypes[fieldTypeName]; // Emit events for custom field types from extension

        this.emit(Runtime.EXTENSION_FIELD_ADDED, {
          name: "field_".concat(fieldTypeInfo.extendedName),
          implementation: fieldTypeInfo.fieldImplementation
        });
      }
    }

    this.emit(Runtime.EXTENSION_ADDED, categoryInfo);
  }
  /**
   * Reregister the primitives for an extension
   * @param  {ExtensionMetadata} extensionInfo - new info (results of running getInfo) for an extension
   * @private
   */


  _refreshExtensionPrimitives(extensionInfo) {
    const categoryInfo = this._blockInfo.find(info => info.id === extensionInfo.id);

    if (categoryInfo) {
      categoryInfo.name = maybeFormatMessage(extensionInfo.name);

      this._fillExtensionCategory(categoryInfo, extensionInfo);

      this.emit(Runtime.BLOCKSINFO_UPDATE, categoryInfo);
    }
  }
  /**
   * Read extension information, convert menus, blocks and custom field types
   * and store the results in the provided category object.
   * @param {CategoryInfo} categoryInfo - the category to be filled
   * @param {ExtensionMetadata} extensionInfo - the extension metadata to read
   * @private
   */


  _fillExtensionCategory(categoryInfo, extensionInfo) {
    categoryInfo.blocks = [];
    categoryInfo.customFieldTypes = {};
    categoryInfo.menus = [];
    categoryInfo.menuInfo = {};

    for (const menuName in extensionInfo.menus) {
      if (extensionInfo.menus.hasOwnProperty(menuName)) {
        const menuInfo = extensionInfo.menus[menuName];

        const convertedMenu = this._buildMenuForScratchBlocks(menuName, menuInfo, categoryInfo);

        categoryInfo.menus.push(convertedMenu);
        categoryInfo.menuInfo[menuName] = menuInfo;
      }
    }

    for (const fieldTypeName in extensionInfo.customFieldTypes) {
      if (extensionInfo.customFieldTypes.hasOwnProperty(fieldTypeName)) {
        const fieldType = extensionInfo.customFieldTypes[fieldTypeName];

        const fieldTypeInfo = this._buildCustomFieldInfo(fieldTypeName, fieldType, extensionInfo.id, categoryInfo);

        categoryInfo.customFieldTypes[fieldTypeName] = fieldTypeInfo;
      }
    }

    if (extensionInfo.docsURI) {
      try {
        const url = new URL(extensionInfo.docsURI);

        if (url.protocol !== 'http:' && url.protocol !== 'https:') {
          throw new Error('invalid protocol');
        }

        const xml = '<button ' + "text=\"".concat(xmlEscape(maybeFormatMessage({
          // note: this translation is hardcoded in translation upload scripts
          id: 'tw.blocks.openDocs',
          default: 'Open Documentation',
          description: 'Button to open extensions docsURI'
        })), "\" ") + 'callbackKey="OPEN_DOCUMENTATION" ' + "web-class=\"docs-uri-".concat(xmlEscape(extensionInfo.docsURI), "\"></button>");
        const block = {
          info: {},
          xml
        };
        categoryInfo.blocks.push(block);
      } catch (e) {
        log.warn('cannot create docsURI button', e);
      }
    }

    for (const blockInfo of extensionInfo.blocks) {
      try {
        const convertedBlock = this._convertForScratchBlocks(blockInfo, categoryInfo);

        categoryInfo.blocks.push(convertedBlock);

        if (convertedBlock.json) {
          const opcode = convertedBlock.json.type;

          if (blockInfo.blockType !== BlockType.EVENT) {
            this._primitives[opcode] = convertedBlock.info.func;
          }

          if (blockInfo.blockType === BlockType.EVENT || blockInfo.blockType === BlockType.HAT) {
            this._hats[opcode] = {
              edgeActivated: blockInfo.isEdgeActivated,
              restartExistingThreads: blockInfo.shouldRestartExistingThreads
            };
          }
        }
      } catch (e) {
        log.error('Error parsing block: ', {
          block: blockInfo,
          error: e
        });
      }
    }
  }
  /**
   * Convert the given extension menu items into the scratch-blocks style of list of pairs.
   * If the menu is dynamic (e.g. the passed in argument is a function), return the input unmodified.
   * @param {object} menuItems - an array of menu items or a function to retrieve such an array
   * @returns {object} - an array of 2 element arrays or the original input function
   * @private
   */


  _convertMenuItems(menuItems) {
    if (typeof menuItems !== 'function') {
      const extensionMessageContext = this.makeMessageContextForTarget();
      return menuItems.map(item => {
        const formattedItem = maybeFormatMessage(item, extensionMessageContext);

        switch (typeof formattedItem) {
          case 'string':
            return [formattedItem, formattedItem];

          case 'object':
            return [maybeFormatMessage(item.text, extensionMessageContext), item.value];

          default:
            throw new Error("Can't interpret menu item: ".concat(JSON.stringify(item)));
        }
      });
    }

    return menuItems;
  }
  /**
   * Build the scratch-blocks JSON for a menu. Note that scratch-blocks treats menus as a special kind of block.
   * @param {string} menuName - the name of the menu
   * @param {object} menuInfo - a description of this menu and its items
   * @property {*} items - an array of menu items or a function to retrieve such an array
   * @property {boolean} [acceptReporters] - if true, allow dropping reporters onto this menu
   * @param {CategoryInfo} categoryInfo - the category for this block
   * @returns {object} - a JSON-esque object ready for scratch-blocks' consumption
   * @private
   */


  _buildMenuForScratchBlocks(menuName, menuInfo, categoryInfo) {
    const menuId = this._makeExtensionMenuId(menuName, categoryInfo.id);

    const menuItems = this._convertMenuItems(menuInfo.items);

    return {
      json: {
        message0: '%1',
        type: menuId,
        inputsInline: true,
        output: 'String',
        colour: categoryInfo.color1,
        colourSecondary: categoryInfo.color2,
        colourTertiary: categoryInfo.color3,
        outputShape: menuInfo.acceptReporters ? ScratchBlocksConstants.OUTPUT_SHAPE_ROUND : ScratchBlocksConstants.OUTPUT_SHAPE_SQUARE,
        args0: [{
          type: 'field_dropdown',
          name: menuName,
          options: menuItems
        }]
      }
    };
  }

  _buildCustomFieldInfo(fieldName, fieldInfo, extensionId, categoryInfo) {
    const extendedName = "".concat(extensionId, "_").concat(fieldName);
    return {
      fieldName: fieldName,
      extendedName: extendedName,
      argumentTypeInfo: {
        shadow: {
          type: extendedName,
          fieldName: "field_".concat(extendedName)
        }
      },
      scratchBlocksDefinition: this._buildCustomFieldTypeForScratchBlocks(extendedName, fieldInfo.output, fieldInfo.outputShape, categoryInfo),
      fieldImplementation: fieldInfo.implementation
    };
  }
  /**
   * Build the scratch-blocks JSON needed for a fieldType.
   * Custom field types need to be namespaced to the extension so that extensions can't interfere with each other
   * @param  {string} fieldName - The name of the field
   * @param {string} output - The output of the field
   * @param {number} outputShape - Shape of the field (from ScratchBlocksConstants)
   * @param {object} categoryInfo - The category the field belongs to (Used to set its colors)
   * @returns {object} - Object to be inserted into scratch-blocks
   */


  _buildCustomFieldTypeForScratchBlocks(fieldName, output, outputShape, categoryInfo) {
    return {
      json: {
        type: fieldName,
        message0: '%1',
        inputsInline: true,
        output: output,
        colour: categoryInfo.color1,
        colourSecondary: categoryInfo.color2,
        colourTertiary: categoryInfo.color3,
        outputShape: outputShape,
        args0: [{
          name: "field_".concat(fieldName),
          type: "field_".concat(fieldName)
        }]
      }
    };
  }
  /**
   * Convert ExtensionBlockMetadata into data ready for scratch-blocks.
   * @param {ExtensionBlockMetadata} blockInfo - the block info to convert
   * @param {CategoryInfo} categoryInfo - the category for this block
   * @returns {ConvertedBlockInfo} - the converted & original block information
   * @private
   */


  _convertForScratchBlocks(blockInfo, categoryInfo) {
    if (blockInfo === '---') {
      return this._convertSeparatorForScratchBlocks(blockInfo);
    }

    if (blockInfo.blockType === BlockType.BUTTON) {
      return this._convertButtonForScratchBlocks(blockInfo);
    }

    return this._convertBlockForScratchBlocks(blockInfo, categoryInfo);
  }
  /**
   * Convert ExtensionBlockMetadata into scratch-blocks JSON & XML, and generate a proxy function.
   * @param {ExtensionBlockMetadata} blockInfo - the block to convert
   * @param {CategoryInfo} categoryInfo - the category for this block
   * @returns {ConvertedBlockInfo} - the converted & original block information
   * @private
   */


  _convertBlockForScratchBlocks(blockInfo, categoryInfo) {
    const extendedOpcode = "".concat(categoryInfo.id, "_").concat(blockInfo.opcode);
    const blockJSON = {
      type: extendedOpcode,
      inputsInline: true,
      category: categoryInfo.name,
      colour: categoryInfo.color1,
      colourSecondary: categoryInfo.color2,
      colourTertiary: categoryInfo.color3
    };
    const context = {
      // TODO: store this somewhere so that we can map args appropriately after translation.
      // This maps an arg name to its relative position in the original (usually English) block text.
      // When displaying a block in another language we'll need to run a `replace` action similar to the one
      // below, but each `[ARG]` will need to be replaced with the number in this map.
      argsMap: {},
      blockJSON,
      categoryInfo,
      blockInfo,
      inputList: []
    }; // If an icon for the extension exists, prepend it to each block, with a vertical separator.
    // We can overspecify an icon for each block, but if no icon exists on a block, fall back to
    // the category block icon.

    const iconURI = blockInfo.blockIconURI || categoryInfo.blockIconURI;

    if (iconURI) {
      blockJSON.extensions = ['scratch_extension'];
      blockJSON.message0 = '%1 %2';
      const iconJSON = {
        type: 'field_image',
        src: iconURI,
        width: 40,
        height: 40
      };
      const separatorJSON = {
        type: 'field_vertical_separator'
      };
      blockJSON.args0 = [iconJSON, separatorJSON];
    }

    switch (blockInfo.blockType) {
      case BlockType.COMMAND:
        blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_SQUARE;
        blockJSON.previousStatement = null; // null = available connection; undefined = hat

        if (!blockInfo.isTerminal) {
          blockJSON.nextStatement = null; // null = available connection; undefined = terminal
        }

        break;

      case BlockType.REPORTER:
        blockJSON.output = 'String'; // TODO: distinguish number & string here?

        blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_ROUND;
        break;

      case BlockType.BOOLEAN:
        blockJSON.output = 'Boolean';
        blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_HEXAGONAL;
        break;

      case BlockType.HAT:
      case BlockType.EVENT:
        if (!blockInfo.hasOwnProperty('isEdgeActivated')) {
          // if absent, this property defaults to true
          blockInfo.isEdgeActivated = true;
        }

        blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_SQUARE;
        blockJSON.nextStatement = null; // null = available connection; undefined = terminal

        break;

      case BlockType.CONDITIONAL:
      case BlockType.LOOP:
        blockInfo.branchCount = blockInfo.branchCount || 1;
        blockJSON.outputShape = ScratchBlocksConstants.OUTPUT_SHAPE_SQUARE;
        blockJSON.previousStatement = null; // null = available connection; undefined = hat

        if (!blockInfo.isTerminal) {
          blockJSON.nextStatement = null; // null = available connection; undefined = terminal
        }

        break;
    }

    const blockText = Array.isArray(blockInfo.text) ? blockInfo.text : [blockInfo.text];
    let inTextNum = 0; // text for the next block "arm" is blockText[inTextNum]

    let inBranchNum = 0; // how many branches have we placed into the JSON so far?

    let outLineNum = 0; // used for scratch-blocks `message${outLineNum}` and `args${outLineNum}`

    const convertPlaceholders = this._convertPlaceholders.bind(this, context);

    const extensionMessageContext = this.makeMessageContextForTarget(); // alternate between a block "arm" with text on it and an open slot for a substack

    while (inTextNum < blockText.length || inBranchNum < blockInfo.branchCount) {
      if (inTextNum < blockText.length) {
        context.outLineNum = outLineNum;
        const lineText = maybeFormatMessage(blockText[inTextNum], extensionMessageContext);
        const convertedText = lineText.replace(/\[(.+?)]/g, convertPlaceholders);

        if (blockJSON["message".concat(outLineNum)]) {
          blockJSON["message".concat(outLineNum)] += convertedText;
        } else {
          blockJSON["message".concat(outLineNum)] = convertedText;
        }

        ++inTextNum;
        ++outLineNum;
      }

      if (inBranchNum < blockInfo.branchCount) {
        blockJSON["message".concat(outLineNum)] = '%1';
        blockJSON["args".concat(outLineNum)] = [{
          type: 'input_statement',
          name: "SUBSTACK".concat(inBranchNum > 0 ? inBranchNum + 1 : '')
        }];
        ++inBranchNum;
        ++outLineNum;
      }
    }

    if (blockInfo.blockType === BlockType.REPORTER) {
      if (!blockInfo.disableMonitor && context.inputList.length === 0) {
        blockJSON.checkboxInFlyout = true;
      }
    } else if (blockInfo.blockType === BlockType.LOOP) {
      // Add icon to the bottom right of a loop block
      blockJSON["lastDummyAlign".concat(outLineNum)] = 'RIGHT';
      blockJSON["message".concat(outLineNum)] = '%1';
      blockJSON["args".concat(outLineNum)] = [{
        type: 'field_image',
        src: './static/blocks-media/repeat.svg',
        // TODO: use a constant or make this configurable?
        width: 24,
        height: 24,
        alt: '*',
        // TODO remove this since we don't use collapsed blocks in scratch
        flip_rtl: true
      }];
      ++outLineNum;
    }

    const mutation = blockInfo.isDynamic ? "<mutation blockInfo=\"".concat(xmlEscape(JSON.stringify(blockInfo)), "\"/>") : '';
    const inputs = context.inputList.join('');
    const blockXML = "<block type=\"".concat(extendedOpcode, "\">").concat(mutation).concat(inputs, "</block>");
    return {
      info: context.blockInfo,
      json: context.blockJSON,
      xml: blockXML
    };
  }
  /**
   * Generate a separator between blocks categories or sub-categories.
   * @param {ExtensionBlockMetadata} blockInfo - the block to convert
   * @param {CategoryInfo} categoryInfo - the category for this block
   * @returns {ConvertedBlockInfo} - the converted & original block information
   * @private
   */


  _convertSeparatorForScratchBlocks(blockInfo) {
    return {
      info: blockInfo,
      xml: '<sep gap="36"/>'
    };
  }
  /**
   * Convert a button for scratch-blocks. A button has no opcode but specifies a callback name in the `func` field.
   * @param {ExtensionBlockMetadata} buttonInfo - the button to convert
   * @property {string} func - the callback name
   * @param {CategoryInfo} categoryInfo - the category for this button
   * @returns {ConvertedBlockInfo} - the converted & original button information
   * @private
   */


  _convertButtonForScratchBlocks(buttonInfo) {
    // for now we only support these pre-defined callbacks handled in scratch-blocks
    const supportedCallbackKeys = ['MAKE_A_LIST', 'MAKE_A_PROCEDURE', 'MAKE_A_VARIABLE'];

    if (supportedCallbackKeys.indexOf(buttonInfo.func) < 0) {
      log.error("Custom button callbacks not supported yet: ".concat(buttonInfo.func));
    }

    const extensionMessageContext = this.makeMessageContextForTarget();
    const buttonText = maybeFormatMessage(buttonInfo.text, extensionMessageContext);
    return {
      info: buttonInfo,
      xml: "<button text=\"".concat(buttonText, "\" callbackKey=\"").concat(buttonInfo.func, "\"></button>")
    };
  }
  /**
   * Helper for _convertPlaceholdes which handles inline images which are a specialized case of block "arguments".
   * @param {object} argInfo Metadata about the inline image as specified by the extension
   * @return {object} JSON blob for a scratch-blocks image field.
   * @private
   */


  _constructInlineImageJson(argInfo) {
    if (!argInfo.dataURI) {
      log.warn('Missing data URI in extension block with argument type IMAGE');
    }

    return {
      type: 'field_image',
      src: argInfo.dataURI || '',
      // TODO these probably shouldn't be hardcoded...?
      width: 24,
      height: 24,
      // Whether or not the inline image should be flipped horizontally
      // in RTL languages. Defaults to false, indicating that the
      // image will not be flipped.
      flip_rtl: argInfo.flipRTL || false
    };
  }
  /**
   * Helper for _convertForScratchBlocks which handles linearization of argument placeholders. Called as a callback
   * from string#replace. In addition to the return value the JSON and XML items in the context will be filled.
   * @param {object} context - information shared with _convertForScratchBlocks about the block, etc.
   * @param {string} match - the overall string matched by the placeholder regex, including brackets: '[FOO]'.
   * @param {string} placeholder - the name of the placeholder being matched: 'FOO'.
   * @return {string} scratch-blocks placeholder for the argument: '%1'.
   * @private
   */


  _convertPlaceholders(context, match, placeholder) {
    // Sanitize the placeholder to ensure valid XML
    placeholder = placeholder.replace(/[<"&]/, '_'); // Determine whether the argument type is one of the known standard field types

    const argInfo = context.blockInfo.arguments[placeholder] || {};
    let argTypeInfo = ArgumentTypeMap[argInfo.type] || {}; // Field type not a standard field type, see if extension has registered custom field type

    if (!ArgumentTypeMap[argInfo.type] && context.categoryInfo.customFieldTypes[argInfo.type]) {
      argTypeInfo = context.categoryInfo.customFieldTypes[argInfo.type].argumentTypeInfo;
    } // Start to construct the scratch-blocks style JSON defining how the block should be
    // laid out


    let argJSON; // Most field types are inputs (slots on the block that can have other blocks plugged into them)
    // check if this is not one of those cases. E.g. an inline image on a block.

    if (argTypeInfo.fieldType === 'field_image') {
      argJSON = this._constructInlineImageJson(argInfo);
    } else {
      // Construct input value
      // Layout a block argument (e.g. an input slot on the block)
      argJSON = {
        type: 'input_value',
        name: placeholder
      };
      const defaultValue = typeof argInfo.defaultValue === 'undefined' ? '' : xmlEscape(maybeFormatMessage(argInfo.defaultValue, this.makeMessageContextForTarget()).toString());

      if (argTypeInfo.check) {
        // Right now the only type of 'check' we have specifies that the
        // input slot on the block accepts Boolean reporters, so it should be
        // shaped like a hexagon
        argJSON.check = argTypeInfo.check;
      }

      let valueName;
      let shadowType;
      let fieldName;

      if (argInfo.menu) {
        const menuInfo = context.categoryInfo.menuInfo[argInfo.menu];

        if (menuInfo.acceptReporters) {
          valueName = placeholder;
          shadowType = this._makeExtensionMenuId(argInfo.menu, context.categoryInfo.id);
          fieldName = argInfo.menu;
        } else {
          argJSON.type = 'field_dropdown';
          argJSON.options = this._convertMenuItems(menuInfo.items);
          valueName = null;
          shadowType = null;
          fieldName = placeholder;
        }
      } else {
        valueName = placeholder;
        shadowType = argTypeInfo.shadow && argTypeInfo.shadow.type || null;
        fieldName = argTypeInfo.shadow && argTypeInfo.shadow.fieldName || null;
      } // <value> is the ScratchBlocks name for a block input.


      if (valueName) {
        context.inputList.push("<value name=\"".concat(placeholder, "\">"));
      } // The <shadow> is a placeholder for a reporter and is visible when there's no reporter in this input.
      // Boolean inputs don't need to specify a shadow in the XML.


      if (shadowType) {
        context.inputList.push("<shadow type=\"".concat(shadowType, "\">"));
      } // A <field> displays a dynamic value: a user-editable text field, a drop-down menu, etc.
      // Leave out the field if defaultValue or fieldName are not specified


      if (defaultValue && fieldName) {
        context.inputList.push("<field name=\"".concat(fieldName, "\">").concat(defaultValue, "</field>"));
      }

      if (shadowType) {
        context.inputList.push('</shadow>');
      }

      if (valueName) {
        context.inputList.push('</value>');
      }
    }

    const argsName = "args".concat(context.outLineNum);
    const blockArgs = context.blockJSON[argsName] = context.blockJSON[argsName] || [];
    if (argJSON) blockArgs.push(argJSON);
    const argNum = blockArgs.length;
    context.argsMap[placeholder] = argNum;
    return "%".concat(argNum);
  }
  /**
   * @returns {Array.<object>} scratch-blocks XML for each category of extension blocks, in category order.
   * @param {?Target} [target] - the active editing target (optional)
   * @property {string} id - the category / extension ID
   * @property {string} xml - the XML text for this category, starting with `<category>` and ending with `</category>`
   */


  getBlocksXML(target) {
    return this._blockInfo.map(categoryInfo => {
      const {
        name,
        color1,
        color2
      } = categoryInfo; // Filter out blocks that aren't supposed to be shown on this target, as determined by the block info's
      // `hideFromPalette` and `filter` properties.

      const paletteBlocks = categoryInfo.blocks.filter(block => {
        let blockFilterIncludesTarget = true; // If an editing target is not passed, include all blocks
        // If the block info doesn't include a `filter` property, always include it

        if (target && block.info.filter) {
          blockFilterIncludesTarget = block.info.filter.includes(target.isStage ? TargetType.STAGE : TargetType.SPRITE);
        } // If the block info's `hideFromPalette` is true, then filter out this block


        return blockFilterIncludesTarget && !block.info.hideFromPalette;
      });
      const colorXML = "colour=\"".concat(color1, "\" secondaryColour=\"").concat(color2, "\""); // Use a menu icon if there is one. Otherwise, use the block icon. If there's no icon,
      // the category menu will show its default colored circle.

      let menuIconURI = '';

      if (categoryInfo.menuIconURI) {
        menuIconURI = categoryInfo.menuIconURI;
      } else if (categoryInfo.blockIconURI) {
        menuIconURI = categoryInfo.blockIconURI;
      }

      const menuIconXML = menuIconURI ? "iconURI=\"".concat(menuIconURI, "\"") : '';
      let statusButtonXML = '';

      if (categoryInfo.showStatusButton) {
        statusButtonXML = 'showStatusButton="true"';
      }

      return {
        id: categoryInfo.id,
        xml: "<category name=\"".concat(name, "\" id=\"").concat(categoryInfo.id, "\" ").concat(statusButtonXML, " ").concat(colorXML, " ").concat(menuIconXML, ">").concat(paletteBlocks.map(block => block.xml).join(''), "</category>")
      };
    });
  }
  /**
   * @returns {Array.<string>} - an array containing the scratch-blocks JSON information for each dynamic block.
   */


  getBlocksJSON() {
    return this._blockInfo.reduce((result, categoryInfo) => result.concat(categoryInfo.blocks.map(blockInfo => blockInfo.json)), []);
  }
  /**
   * Get a scratch link socket.
   * @param {string} type Either BLE or BT
   * @returns {ScratchLinkSocket} The scratch link socket.
   */


  getScratchLinkSocket(type) {
    const factory = this._linkSocketFactory || this._defaultScratchLinkSocketFactory;
    return factory(type);
  }
  /**
   * Configure how ScratchLink sockets are created. Factory must consume a "type" parameter
   * either BT or BLE.
   * @param {Function} factory The new factory for creating ScratchLink sockets.
   */


  configureScratchLinkSocketFactory(factory) {
    this._linkSocketFactory = factory;
  }
  /**
   * The default scratch link socket creator, using websockets to the installed device manager.
   * @param {string} type Either BLE or BT
   * @returns {ScratchLinkSocket} The new scratch link socket (a WebSocket object)
   */


  _defaultScratchLinkSocketFactory(type) {
    return new ScratchLinkWebSocket(type);
  }
  /**
   * Register an extension that communications with a hardware peripheral by id,
   * to have access to it and its peripheral functions in the future.
   * @param {string} extensionId - the id of the extension.
   * @param {object} extension - the extension to register.
   */


  registerPeripheralExtension(extensionId, extension) {
    this.peripheralExtensions[extensionId] = extension;
  }
  /**
   * Tell the specified extension to scan for a peripheral.
   * @param {string} extensionId - the id of the extension.
   */


  scanForPeripheral(extensionId) {
    if (this.peripheralExtensions[extensionId]) {
      this.peripheralExtensions[extensionId].scan();
    }
  }
  /**
   * Connect to the extension's specified peripheral.
   * @param {string} extensionId - the id of the extension.
   * @param {number} peripheralId - the id of the peripheral.
   */


  connectPeripheral(extensionId, peripheralId) {
    if (this.peripheralExtensions[extensionId]) {
      this.peripheralExtensions[extensionId].connect(peripheralId);
    }
  }
  /**
   * Disconnect from the extension's connected peripheral.
   * @param {string} extensionId - the id of the extension.
   */


  disconnectPeripheral(extensionId) {
    if (this.peripheralExtensions[extensionId]) {
      this.peripheralExtensions[extensionId].disconnect();
    }
  }
  /**
   * Returns whether the extension has a currently connected peripheral.
   * @param {string} extensionId - the id of the extension.
   * @return {boolean} - whether the extension has a connected peripheral.
   */


  getPeripheralIsConnected(extensionId) {
    let isConnected = false;

    if (this.peripheralExtensions[extensionId]) {
      isConnected = this.peripheralExtensions[extensionId].isConnected();
    }

    return isConnected;
  }
  /**
   * Emit an event to indicate that the microphone is being used to stream audio.
   * @param {boolean} listening - true if the microphone is currently listening.
   */


  emitMicListening(listening) {
    this.emit(Runtime.MIC_LISTENING, listening);
  }
  /**
   * Retrieve the function associated with the given opcode.
   * @param {!string} opcode The opcode to look up.
   * @return {Function} The function which implements the opcode.
   */


  getOpcodeFunction(opcode) {
    return this._primitives[opcode];
  }
  /**
   * Return whether an opcode represents a hat block.
   * @param {!string} opcode The opcode to look up.
   * @return {boolean} True if the op is known to be a hat.
   */


  getIsHat(opcode) {
    return this._hats.hasOwnProperty(opcode);
  }
  /**
   * Return whether an opcode represents an edge-activated hat block.
   * @param {!string} opcode The opcode to look up.
   * @return {boolean} True if the op is known to be a edge-activated hat.
   */


  getIsEdgeActivatedHat(opcode) {
    return this._hats.hasOwnProperty(opcode) && this._hats[opcode].edgeActivated;
  }
  /**
   * Attach the audio engine
   * @param {!AudioEngine} audioEngine The audio engine to attach
   */


  attachAudioEngine(audioEngine) {
    this.audioEngine = audioEngine;
  }
  /**
   * Attach the renderer
   * @param {!RenderWebGL} renderer The renderer to attach
   */


  attachRenderer(renderer) {
    this.renderer = renderer;
    this.renderer.setLayerGroupOrdering(StageLayering.LAYER_GROUPS);
    this.renderer.offscreenTouching = !this.runtimeOptions.fencing;
  }
  /**
   * Set the bitmap adapter for the VM/runtime, which converts scratch 2
   * bitmaps to scratch 3 bitmaps. (Scratch 3 bitmaps are all bitmap resolution 2)
   * @param {!function} bitmapAdapter The adapter to attach
   */


  attachV2BitmapAdapter(bitmapAdapter) {
    this.v2BitmapAdapter = bitmapAdapter;
  }
  /**
   * Attach the storage module
   * @param {!ScratchStorage} storage The storage module to attach
   */


  attachStorage(storage) {
    this.storage = storage;

    if (this.isPackaged) {
      // In packaged runtime mode, generating real asset IDs is a waste of time.
      // We do still want to preserve every asset having a unique ID.
      const originalCreateAsset = storage.createAsset;
      let assetIdCounter = 0; // eslint-disable-next-line no-unused-vars

      storage.createAsset = function packagedCreateAsset(assetType, dataFormat, data, assetId, generateId) {
        if (!assetId) {
          assetId = (++assetIdCounter).toString();
        }

        return originalCreateAsset.call(this, assetType, dataFormat, data, assetId, // Never generate real asset ID
        false);
      };
    }
  } // -----------------------------------------------------------------------------
  // -----------------------------------------------------------------------------

  /**
   * Create a thread and push it to the list of threads.
   * @param {!string} id ID of block that starts the stack.
   * @param {!Target} target Target to run thread on.
   * @param {?object} opts optional arguments
   * @param {?boolean} opts.stackClick true if the script was activated by clicking on the stack
   * @param {?boolean} opts.updateMonitor true if the script should update a monitor value
   * @return {!Thread} The newly created thread.
   */


  _pushThread(id, target, opts) {
    const thread = new Thread(id);
    thread.target = target;
    thread.stackClick = Boolean(opts && opts.stackClick);
    thread.updateMonitor = Boolean(opts && opts.updateMonitor);
    thread.blockContainer = thread.updateMonitor ? this.monitorBlocks : target.blocks;
    thread.pushStack(id);
    this.threads.push(thread);

    if (!thread.stackClick && !thread.updateMonitor) {
      this.threadMap.set(thread.getId(), thread);
    } // tw: compile new threads. Do not attempt to compile monitor threads.


    if (!(opts && opts.updateMonitor) && this.compilerOptions.enabled) {
      thread.tryCompile();
    }

    return thread;
  }
  /**
   * Stop a thread: stop running it immediately, and remove it from the thread list later.
   * @param {!Thread} thread Thread object to remove from actives
   */


  _stopThread(thread) {
    // Mark the thread for later removal
    thread.isKilled = true; // Inform sequencer to stop executing that thread.

    this.sequencer.retireThread(thread);
  }
  /**
   * Restart a thread in place, maintaining its position in the list of threads.
   * This is used by `startHats` to and is necessary to ensure 2.0-like execution order.
   * Test project: https://scratch.mit.edu/projects/130183108/
   * @param {!Thread} thread Thread object to restart.
   * @return {Thread} The restarted thread.
   */


  _restartThread(thread) {
    const newThread = new Thread(thread.topBlock);
    newThread.target = thread.target;
    newThread.stackClick = thread.stackClick;
    newThread.updateMonitor = thread.updateMonitor;
    newThread.blockContainer = thread.blockContainer;
    newThread.pushStack(thread.topBlock); // tw: when a thread is restarted, we have to check whether the previous script was attempted to be compiled.

    if (thread.triedToCompile && this.compilerOptions.enabled) {
      newThread.tryCompile();
    }

    if (!newThread.stackClick && !newThread.updateMonitor) {
      this.threadMap.set(newThread.getId(), newThread);
    }

    const i = this.threads.indexOf(thread);

    if (i > -1) {
      this.threads[i] = newThread;
      return newThread;
    }

    this.threads.push(thread);
    return thread;
  }

  emitCompileError(target, error) {
    this.emit(Runtime.COMPILE_ERROR, target, error);
  }
  /**
   * Return whether a thread is currently active/running.
   * @param {?Thread} thread Thread object to check.
   * @return {boolean} True if the thread is active/running.
   */


  isActiveThread(thread) {
    return thread.stack.length > 0 && thread.status !== Thread.STATUS_DONE && this.threads.indexOf(thread) > -1;
  }
  /**
   * Return whether a thread is waiting for more information or done.
   * @param {?Thread} thread Thread object to check.
   * @return {boolean} True if the thread is waiting
   */


  isWaitingThread(thread) {
    return thread.status === Thread.STATUS_PROMISE_WAIT || thread.status === Thread.STATUS_YIELD_TICK || !this.isActiveThread(thread);
  }
  /**
   * Toggle a script.
   * @param {!string} topBlockId ID of block that starts the script.
   * @param {?object} opts optional arguments to toggle script
   * @param {?string} opts.target target ID for target to run script on. If not supplied, uses editing target.
   * @param {?boolean} opts.stackClick true if the user activated the stack by clicking, false if not. This
   *     determines whether we show a visual report when turning on the script.
   */


  toggleScript(topBlockId, opts) {
    opts = Object.assign({
      target: this._editingTarget,
      stackClick: false
    }, opts); // Remove any existing thread.

    for (let i = 0; i < this.threads.length; i++) {
      // Toggling a script that's already running turns it off
      if (this.threads[i].topBlock === topBlockId && this.threads[i].status !== Thread.STATUS_DONE) {
        const blockContainer = opts.target.blocks;
        const opcode = blockContainer.getOpcode(blockContainer.getBlock(topBlockId));

        if (this.getIsEdgeActivatedHat(opcode) && this.threads[i].stackClick !== opts.stackClick) {
          // Allow edge activated hat thread stack click to coexist with
          // edge activated hat thread that runs every frame
          continue;
        }

        this._stopThread(this.threads[i]);

        return;
      }
    } // Otherwise add it.


    this._pushThread(topBlockId, opts.target, opts);
  }
  /**
   * Enqueue a script that when finished will update the monitor for the block.
   * @param {!string} topBlockId ID of block that starts the script.
   * @param {?Target} optTarget target Target to run script on. If not supplied, uses editing target.
   */


  addMonitorScript(topBlockId, optTarget) {
    if (!optTarget) optTarget = this._editingTarget;

    for (let i = 0; i < this.threads.length; i++) {
      // Don't re-add the script if it's already running
      if (this.threads[i].topBlock === topBlockId && this.threads[i].status !== Thread.STATUS_DONE && this.threads[i].updateMonitor) {
        return;
      }
    } // Otherwise add it.


    this._pushThread(topBlockId, optTarget, {
      updateMonitor: true
    });
  }
  /**
   * Run a function `f` for all scripts in a workspace.
   * `f` will be called with two parameters:
   *  - the top block ID of the script.
   *  - the target that owns the script.
   * @param {!Function} f Function to call for each script.
   * @param {Target=} optTarget Optionally, a target to restrict to.
   */


  allScriptsDo(f, optTarget) {
    let targets = this.executableTargets;

    if (optTarget) {
      targets = [optTarget];
    }

    for (let t = targets.length - 1; t >= 0; t--) {
      const target = targets[t];
      const scripts = target.blocks.getScripts();

      for (let j = 0; j < scripts.length; j++) {
        const topBlockId = scripts[j];
        f(topBlockId, target);
      }
    }
  }

  allScriptsByOpcodeDo(opcode, f, optTarget) {
    let targets = this.executableTargets;

    if (optTarget) {
      targets = [optTarget];
    }

    for (let t = targets.length - 1; t >= 0; t--) {
      const target = targets[t];
      const scripts = BlocksRuntimeCache.getScripts(target.blocks, opcode);

      for (let j = 0; j < scripts.length; j++) {
        f(scripts[j], target);
      }
    }
  }
  /**
   * Start all relevant hats.
   * @param {!string} requestedHatOpcode Opcode of hats to start.
   * @param {object=} optMatchFields Optionally, fields to match on the hat.
   * @param {Target=} optTarget Optionally, a target to restrict to.
   * @return {Array.<Thread>} List of threads started by this function.
   */


  startHats(requestedHatOpcode, optMatchFields, optTarget) {
    if (!this._hats.hasOwnProperty(requestedHatOpcode)) {
      // No known hat with this opcode.
      return;
    }

    const instance = this;
    const newThreads = []; // Look up metadata for the relevant hat.

    const hatMeta = instance._hats[requestedHatOpcode];

    for (const opts in optMatchFields) {
      if (!optMatchFields.hasOwnProperty(opts)) continue;
      optMatchFields[opts] = optMatchFields[opts].toUpperCase();
    } // tw: By assuming that all new threads will not interfere with eachother, we can optimize the loops
    // inside the allScriptsByOpcodeDo callback below.


    const startingThreadListLength = this.threads.length; // Consider all scripts, looking for hats with opcode `requestedHatOpcode`.

    this.allScriptsByOpcodeDo(requestedHatOpcode, (script, target) => {
      const {
        blockId: topBlockId,
        fieldsOfInputs: hatFields
      } = script; // Match any requested fields.
      // For example: ensures that broadcasts match.
      // This needs to happen before the block is evaluated
      // (i.e., before the predicate can be run) because "broadcast and wait"
      // needs to have a precise collection of started threads.

      for (const matchField in optMatchFields) {
        if (hatFields[matchField].value !== optMatchFields[matchField]) {
          // Field mismatch.
          return;
        }
      }

      if (hatMeta.restartExistingThreads) {
        // If `restartExistingThreads` is true, we should stop
        // any existing threads starting with the top block.
        const existingThread = this.threadMap.get(Thread.getIdFromTargetAndBlock(target, topBlockId));

        if (existingThread) {
          newThreads.push(this._restartThread(existingThread));
          return;
        }
      } else {
        // If `restartExistingThreads` is false, we should
        // give up if any threads with the top block are running.
        for (let j = 0; j < startingThreadListLength; j++) {
          if (this.threads[j].target === target && this.threads[j].topBlock === topBlockId && // stack click threads and hat threads can coexist
          !this.threads[j].stackClick && this.threads[j].status !== Thread.STATUS_DONE) {
            // Some thread is already running.
            return;
          }
        }
      } // Start the thread with this top block.


      newThreads.push(this._pushThread(topBlockId, target));
    }, optTarget); // For compatibility with Scratch 2, edge triggered hats need to be processed before
    // threads are stepped. See ScratchRuntime.as for original implementation

    newThreads.forEach(thread => {
      // tw: do not step compiled threads, the hat block can't be executed
      if (!thread.isCompiled) {
        execute(this.sequencer, thread);
        thread.goToNextBlock();
      }
    });
    return newThreads;
  }
  /**
   * Dispose all targets. Return to clean state.
   */


  dispose() {
    this.stopAll(); // Deleting each target's variable's monitors.

    this.targets.forEach(target => {
      if (target.isOriginal) target.deleteMonitors();
    });
    this.targets.map(this.disposeTarget, this); // tw: explicitly emit a MONITORS_UPDATE instead of relying on implicit behavior of _step()

    const emptyMonitorState = OrderedMap({});

    if (!emptyMonitorState.equals(this._monitorState)) {
      this._monitorState = emptyMonitorState;
      this.emit(Runtime.MONITORS_UPDATE, this._monitorState);
    }

    this.emit(Runtime.RUNTIME_DISPOSED);
    this.ioDevices.clock.resetProjectTimer(); // @todo clear out extensions? turboMode? etc.
    // *********** Cloud *******************
    // If the runtime currently has cloud data,
    // emit a has cloud data update event resetting
    // it to false

    if (this.hasCloudData()) {
      this.emit(Runtime.HAS_CLOUD_DATA_UPDATE, false);
    }

    this.ioDevices.cloud.clear(); // Reset runtime cloud data info

    const newCloudDataManager = cloudDataManager(this.cloudOptions);
    this.hasCloudData = newCloudDataManager.hasCloudVariables;
    this.canAddCloudVariable = newCloudDataManager.canAddCloudVariable;
    this.getNumberOfCloudVariables = newCloudDataManager.getNumberOfCloudVariables;
    this.addCloudVariable = this._initializeAddCloudVariable(newCloudDataManager);
    this.removeCloudVariable = this._initializeRemoveCloudVariable(newCloudDataManager);
  }
  /**
   * Add a target to the runtime. This tracks the sprite pane
   * ordering of the target. The target still needs to be put
   * into the correct execution order after calling this function.
   * @param {Target} target target to add
   */


  addTarget(target) {
    this.targets.push(target);
    this.executableTargets.push(target);

    if (target.isStage && !this._stageTarget) {
      this._stageTarget = target;
    }
  }
  /**
   * Move a target in the execution order by a relative amount.
   *
   * A positve number will make the target execute earlier. A negative number
   * will make the target execute later in the order.
   *
   * @param {Target} executableTarget target to move
   * @param {number} delta number of positions to move target by
   * @returns {number} new position in execution order
   */


  moveExecutable(executableTarget, delta) {
    const oldIndex = this.executableTargets.indexOf(executableTarget);
    this.executableTargets.splice(oldIndex, 1);
    let newIndex = oldIndex + delta;

    if (newIndex > this.executableTargets.length) {
      newIndex = this.executableTargets.length;
    }

    if (newIndex <= 0) {
      if (this.executableTargets.length > 0 && this.executableTargets[0].isStage) {
        newIndex = 1;
      } else {
        newIndex = 0;
      }
    }

    this.executableTargets.splice(newIndex, 0, executableTarget);
    return newIndex;
  }
  /**
   * Set a target to execute at a specific position in the execution order.
   *
   * Infinity will set the target to execute first. 0 will set the target to
   * execute last (before the stage).
   *
   * @param {Target} executableTarget target to move
   * @param {number} newIndex position in execution order to place the target
   * @returns {number} new position in the execution order
   */


  setExecutablePosition(executableTarget, newIndex) {
    const oldIndex = this.executableTargets.indexOf(executableTarget);
    return this.moveExecutable(executableTarget, newIndex - oldIndex);
  }
  /**
   * Remove a target from the execution set.
   * @param {Target} executableTarget target to remove
   */


  removeExecutable(executableTarget) {
    const oldIndex = this.executableTargets.indexOf(executableTarget);

    if (oldIndex > -1) {
      this.executableTargets.splice(oldIndex, 1);
    }
  }
  /**
   * Dispose of a target.
   * @param {!Target} disposingTarget Target to dispose of.
   */


  disposeTarget(disposingTarget) {
    this.targets = this.targets.filter(target => {
      if (disposingTarget !== target) return true; // Allow target to do dispose actions.

      target.dispose(); // Remove from list of targets.

      return false;
    });

    if (this._stageTarget === disposingTarget) {
      this._stageTarget = null;
    }
  }
  /**
   * Stop any threads acting on the target.
   * @param {!Target} target Target to stop threads for.
   * @param {Thread=} optThreadException Optional thread to skip.
   */


  stopForTarget(target, optThreadException) {
    // Emit stop event to allow blocks to clean up any state.
    this.emit(Runtime.STOP_FOR_TARGET, target, optThreadException); // Stop any threads on the target.

    for (let i = 0; i < this.threads.length; i++) {
      if (this.threads[i] === optThreadException) {
        continue;
      }

      if (this.threads[i].target === target) {
        this._stopThread(this.threads[i]);
      }
    }
  }
  /**
   * Start all threads that start with the green flag.
   */


  greenFlag() {
    this.stopAll();
    this.emit(Runtime.PROJECT_START);
    this.updateCurrentMSecs();
    this.ioDevices.clock.resetProjectTimer();
    this.targets.forEach(target => target.clearEdgeActivatedValues()); // Inform all targets of the green flag.

    for (let i = 0; i < this.targets.length; i++) {
      this.targets[i].onGreenFlag();
    }

    this.startHats('event_whenflagclicked');
  }
  /**
   * Stop "everything."
   */


  stopAll() {
    // Emit stop event to allow blocks to clean up any state.
    this.emit(Runtime.PROJECT_STOP_ALL); // Dispose all clones.

    const newTargets = [];

    for (let i = 0; i < this.targets.length; i++) {
      this.targets[i].onStopAll();

      if (this.targets[i].hasOwnProperty('isOriginal') && !this.targets[i].isOriginal) {
        this.targets[i].dispose();
      } else {
        newTargets.push(this.targets[i]);
      }
    }

    this.targets = newTargets; // Dispose of the active thread.

    if (this.sequencer.activeThread !== null) {
      this._stopThread(this.sequencer.activeThread);
    } // Remove all remaining threads from executing in the next tick.


    this.threads = [];
    this.threadMap.clear();
  }

  _renderInterpolatedPositions() {
    const frameStarted = this._lastStepTime;
    const now = Date.now();
    const timeSinceStart = now - frameStarted;
    const progressInFrame = Math.min(1, Math.max(0, timeSinceStart / this.currentStepTime));
    interpolate.interpolate(this, progressInFrame);

    if (this.renderer) {
      this.renderer.draw();
    }
  }

  updateThreadMap() {
    this.threadMap.clear();

    for (const thread of this.threads) {
      if (!thread.stackClick && !thread.updateMonitor) {
        this.threadMap.set(thread.getId(), thread);
      }
    }
  }
  /**
   * Repeatedly run `sequencer.stepThreads` and filter out
   * inactive threads after each iteration.
   */


  _step() {
    if (this.interpolationEnabled) {
      interpolate.setupInitialState(this);
    }

    if (this.profiler !== null) {
      if (stepProfilerId === -1) {
        stepProfilerId = this.profiler.idByName('Runtime._step');
      }

      this.profiler.start(stepProfilerId);
    } // Clean up threads that were told to stop during or since the last step


    this.threads = this.threads.filter(thread => !thread.isKilled);
    this.updateThreadMap(); // Find all edge-activated hats, and add them to threads to be evaluated.

    for (const hatType in this._hats) {
      if (!this._hats.hasOwnProperty(hatType)) continue;
      const hat = this._hats[hatType];

      if (hat.edgeActivated) {
        this.startHats(hatType);
      }
    }

    this.redrawRequested = false;

    this._pushMonitors();

    if (this.profiler !== null) {
      if (stepThreadsProfilerId === -1) {
        stepThreadsProfilerId = this.profiler.idByName('Sequencer.stepThreads');
      }

      this.profiler.start(stepThreadsProfilerId);
    }

    const doneThreads = this.sequencer.stepThreads();

    if (this.profiler !== null) {
      this.profiler.stop();
    }

    this._updateGlows(doneThreads); // Add done threads so that even if a thread finishes within 1 frame, the green
    // flag will still indicate that a script ran.


    this._emitProjectRunStatus(this.threads.length + doneThreads.length - this._getMonitorThreadCount([...this.threads, ...doneThreads])); // Store threads that completed this iteration for testing and other
    // internal purposes.


    this._lastStepDoneThreads = doneThreads;

    if (this.renderer) {
      // @todo: Only render when this.redrawRequested or clones rendered.
      if (this.profiler !== null) {
        if (rendererDrawProfilerId === -1) {
          rendererDrawProfilerId = this.profiler.idByName('RenderWebGL.draw');
        }

        this.profiler.start(rendererDrawProfilerId);
      } // tw: do not draw if document is hidden or a rAF loop is running
      // Checking for the animation frame loop is more reliable than using
      // interpolationEnabled in some edge cases


      if (!document.hidden && !this.frameLoop._interpolationAnimation) {
        this.renderer.draw();
      }

      if (this.profiler !== null) {
        this.profiler.stop();
      }
    }

    if (this._refreshTargets) {
      this.emit(Runtime.TARGETS_UPDATE, false
      /* Don't emit project changed */
      );
      this._refreshTargets = false;
    }

    if (!this._prevMonitorState.equals(this._monitorState)) {
      this.emit(Runtime.MONITORS_UPDATE, this._monitorState);
      this._prevMonitorState = this._monitorState;
    }

    if (this.profiler !== null) {
      this.profiler.stop();
      this.profiler.reportFrames();
    }

    if (this.interpolationEnabled) {
      this._lastStepTime = Date.now();
    }
  }
  /**
   * Get the number of threads in the given array that are monitor threads (threads
   * that update monitor values, and don't count as running a script).
   * @param {!Array.<Thread>} threads The set of threads to look through.
   * @return {number} The number of monitor threads in threads.
   */


  _getMonitorThreadCount(threads) {
    let count = 0;
    threads.forEach(thread => {
      if (thread.updateMonitor) count++;
    });
    return count;
  }
  /**
   * Queue monitor blocks to sequencer to be run.
   */


  _pushMonitors() {
    this.monitorBlocks.runAllMonitored(this);
  }
  /**
   * Set the current editing target known by the runtime.
   * @param {!Target} editingTarget New editing target.
   */


  setEditingTarget(editingTarget) {
    const oldEditingTarget = this._editingTarget;
    this._editingTarget = editingTarget; // Script glows must be cleared.

    this._scriptGlowsPreviousFrame = [];

    this._updateGlows();

    if (oldEditingTarget !== this._editingTarget) {
      this.requestToolboxExtensionsUpdate();
    }
  }
  /**
   * Set whether we are in 30 TPS compatibility mode.
   * @param {boolean} compatibilityModeOn True iff in compatibility mode.
   */


  setCompatibilityMode(compatibilityModeOn) {
    // tw: "compatibility mode" is replaced with a generic framerate setter,
    // but this method is kept for compatibility
    if (compatibilityModeOn) {
      this.setFramerate(30);
    } else {
      this.setFramerate(60);
    }
  }
  /**
   * tw: Change runtime target frames per second
   * @param {number} framerate Target frames per second
   */


  setFramerate(framerate) {
    // Setting framerate to anything greater than this is unnecessary and can break the sequencer
    // Additionally, the JS spec says intervals can't run more than once every 4ms (250/s) anyways
    if (framerate > 250) framerate = 250; // Convert negative framerates to 1FPS
    // Note that 0 is a special value which means "matching device screen refresh rate"

    if (framerate < 0) framerate = 1;
    this.frameLoop.setFramerate(framerate);
    this.emit(Runtime.FRAMERATE_CHANGED, framerate);
  }
  /**
   * tw: Enable or disable interpolation.
   * @param {boolean} interpolationEnabled True if interpolation should be enabled.
   */


  setInterpolation(interpolationEnabled) {
    this.interpolationEnabled = interpolationEnabled;
    this.frameLoop.setInterpolation(this.interpolationEnabled);
    this.emit(Runtime.INTERPOLATION_CHANGED, interpolationEnabled);
  }
  /**
   * tw: Update runtime options
   * @param {*} runtimeOptions New options
   */


  setRuntimeOptions(runtimeOptions) {
    this.runtimeOptions = Object.assign({}, this.runtimeOptions, runtimeOptions);
    this.emit(Runtime.RUNTIME_OPTIONS_CHANGED, this.runtimeOptions);

    if (this.renderer) {
      this.renderer.offscreenTouching = !this.runtimeOptions.fencing;
    }
  }
  /**
   * tw: Update compiler options
   * @param {*} compilerOptions New options
   */


  setCompilerOptions(compilerOptions) {
    this.compilerOptions = Object.assign({}, this.compilerOptions, compilerOptions);
    this.resetAllCaches();
    this.emit(Runtime.COMPILER_OPTIONS_CHANGED, this.compilerOptions);
  }
  /**
   * Change width and height of stage. This will also inform the renderer of the new stage size.
   * @param {number} width New stage width
   * @param {number} height New stage height
   */


  setStageSize(width, height) {
    width = Math.round(Math.max(1, width));
    height = Math.round(Math.max(1, height));

    if (this.stageWidth !== width || this.stageHeight !== height) {
      const deltaX = width - this.stageWidth;
      const deltaY = height - this.stageHeight; // Preserve monitor location relative to the center of the stage

      if (this._monitorState.size > 0) {
        const offsetX = deltaX / 2;
        const offsetY = deltaY / 2;

        for (const monitor of this._monitorState.valueSeq()) {
          const newMonitor = monitor.set('x', monitor.get('x') + offsetX).set('y', monitor.get('y') + offsetY);
          this.requestUpdateMonitor(newMonitor);
        }

        this.emit(Runtime.MONITORS_UPDATE, this._monitorState);
      }

      this.stageWidth = width;
      this.stageHeight = height;

      if (this.renderer) {
        this.renderer.setStageSize(-width / 2, width / 2, -height / 2, height / 2);
      }
    }

    this.emit(Runtime.STAGE_SIZE_CHANGED, width, height);
  }

  setInEditor(inEditor) {// no-op
  }
  /**
   * TW: Enable "packaged runtime" mode. This is a one-way operation.
   */


  convertToPackagedRuntime() {
    if (this.storage) {
      throw new Error('convertToPackagedRuntime must be called before attachStorage');
    }

    this.isPackaged = true;
  }
  /**
   * tw: Reset the cache of all block containers.
   */


  resetAllCaches() {
    for (const target of this.targets) {
      if (target.isOriginal) {
        target.blocks.resetCache();
      }
    }

    this.flyoutBlocks.resetCache();
    this.monitorBlocks.resetCache();
  }
  /**
   * Add an "addon block"
   * @param {object} options Options object
   * @param {string} options.procedureCode The ID of the block
   * @param {function} options.callback The callback, called with (args, BlockUtility)
   * @param {string[]} options.arguments Names of the arguments accepted
   * @param {string} options.color Primary color
   * @param {string} options.secondaryColor Secondary color
   */


  addAddonBlock(options) {
    const procedureCode = options.procedureCode;
    const names = options.arguments;
    const ids = options.arguments.map((_, i) => "arg".concat(i));
    const defaults = options.arguments.map(() => '');
    this.addonBlocks[procedureCode] = _objectSpread({
      namesIdsDefaults: [names, ids, defaults]
    }, options);
    const ID = 'a-b';

    let blockInfo = this._blockInfo.find(i => i.id === ID);

    if (!blockInfo) {
      blockInfo = {
        id: ID,
        name: 'Addons',
        color1: options.color,
        color2: options.secondaryColor,
        color3: options.secondaryColor,
        blocks: [],
        customFieldTypes: {},
        menus: []
      };

      this._blockInfo.unshift(blockInfo);
    }

    blockInfo.blocks.push({
      info: {},
      xml: '<block type="procedures_call" gap="16"><mutation generateshadows="true" warp="false"' + " proccode=\"".concat(xmlEscape(procedureCode), "\"") + " argumentnames=\"".concat(xmlEscape(JSON.stringify(names)), "\"") + " argumentids=\"".concat(xmlEscape(JSON.stringify(ids)), "\"") + " argumentdefaults=\"".concat(xmlEscape(JSON.stringify(defaults)), "\"") + '></mutation></block>'
    });
    this.resetAllCaches();
  }

  getAddonBlock(procedureCode) {
    if (Object.prototype.hasOwnProperty.call(this.addonBlocks, procedureCode)) {
      return this.addonBlocks[procedureCode];
    }

    return null;
  }

  findProjectOptionsComment() {
    const target = this.getTargetForStage();
    const comments = target.comments;

    for (const comment of Object.values(comments)) {
      if (comment.text.includes(COMMENT_CONFIG_MAGIC)) {
        return comment;
      }
    }

    return null;
  }

  parseProjectOptions() {
    const comment = this.findProjectOptionsComment();
    if (!comment) return;
    const lineWithMagic = comment.text.split('\n').find(i => i.endsWith(COMMENT_CONFIG_MAGIC));

    if (!lineWithMagic) {
      log.warn('Config comment does not contain valid line');
      return;
    }

    const jsonText = lineWithMagic.substr(0, lineWithMagic.length - COMMENT_CONFIG_MAGIC.length);
    let parsed;

    try {
      parsed = ExtendedJSON.parse(jsonText);

      if (!parsed || typeof parsed !== 'object') {
        throw new Error('Invalid object');
      }
    } catch (e) {
      log.warn('Config comment has invalid JSON', e);
      return;
    }

    if (typeof parsed.framerate === 'number') {
      this.setFramerate(parsed.framerate);
    }

    if (parsed.turbo) {
      this.turboMode = true;
      this.emit(Runtime.TURBO_MODE_ON);
    }

    if (parsed.interpolation) {
      this.setInterpolation(true);
    }

    if (parsed.runtimeOptions) {
      this.setRuntimeOptions(parsed.runtimeOptions);
    }

    if (parsed.hq && this.renderer) {
      this.renderer.setUseHighQualityRender(true);
    }

    const storedWidth = +parsed.width || this.stageWidth;
    const storedHeight = +parsed.height || this.stageHeight;

    if (storedWidth !== this.stageWidth || storedHeight !== this.stageHeight) {
      this.setStageSize(storedWidth, storedHeight);
    }
  }

  _generateAllProjectOptions() {
    return {
      framerate: this.frameLoop.framerate,
      runtimeOptions: this.runtimeOptions,
      interpolation: this.interpolationEnabled,
      turbo: this.turboMode,
      hq: this.renderer ? this.renderer.useHighQualityRender : false,
      width: this.stageWidth,
      height: this.stageHeight
    };
  }

  generateDifferingProjectOptions() {
    const difference = (oldObject, newObject) => {
      const result = {};

      for (const key of Object.keys(newObject)) {
        const newValue = newObject[key];
        const oldValue = oldObject[key];

        if (typeof newValue === 'object' && newValue) {
          const valueDiffering = difference(oldValue, newValue);

          if (Object.keys(valueDiffering).length > 0) {
            result[key] = valueDiffering;
          }
        } else if (newValue !== oldValue) {
          result[key] = newValue;
        }
      }

      return result;
    };

    return difference(this._defaultStoredSettings, this._generateAllProjectOptions());
  }

  storeProjectOptions() {
    const options = this.generateDifferingProjectOptions(); // TODO: translate

    const text = "Configuration for https://turbowarp.org/\nYou can move, resize, and minimize this comment, but don't edit it by hand. This comment can be deleted to remove the stored settings.\n".concat(ExtendedJSON.stringify(options)).concat(COMMENT_CONFIG_MAGIC);
    const existingComment = this.findProjectOptionsComment();

    if (existingComment) {
      existingComment.text = text;
    } else {
      const target = this.getTargetForStage(); // TODO: smarter position logic

      target.createComment(uid(), null, text, 50, 50, 350, 170, false);
    }

    this.emitProjectChanged();
  }
  /**
   * Eagerly (re)compile all scripts within this project.
   */


  precompile() {
    this.allScriptsDo((topBlockId, target) => {
      const topBlock = target.blocks.getBlock(topBlockId);

      if (this.getIsHat(topBlock.opcode)) {
        const thread = new Thread(topBlockId);
        thread.target = target;
        thread.blockContainer = target.blocks;
        thread.tryCompile();
      }
    });
  }

  enableDebug() {
    this.resetAllCaches();
    this.debug = true;
  }
  /**
   * Emit glows/glow clears for scripts after a single tick.
   * Looks at `this.threads` and notices which have turned on/off new glows.
   * @param {Array.<Thread>=} optExtraThreads Optional list of inactive threads.
   */


  _updateGlows(optExtraThreads) {
    const searchThreads = [];
    searchThreads.push.apply(searchThreads, this.threads);

    if (optExtraThreads) {
      searchThreads.push.apply(searchThreads, optExtraThreads);
    } // Set of scripts that request a glow this frame.


    const requestedGlowsThisFrame = []; // Final set of scripts glowing during this frame.

    const finalScriptGlows = []; // Find all scripts that should be glowing.

    for (let i = 0; i < searchThreads.length; i++) {
      const thread = searchThreads[i];
      const target = thread.target;

      if (target === this._editingTarget) {
        const blockForThread = thread.blockGlowInFrame;

        if (thread.requestScriptGlowInFrame || thread.stackClick) {
          let script = target.blocks.getTopLevelScript(blockForThread);

          if (!script) {
            // Attempt to find in flyout blocks.
            script = this.flyoutBlocks.getTopLevelScript(blockForThread);
          }

          if (script) {
            requestedGlowsThisFrame.push(script);
          }
        }
      }
    } // Compare to previous frame.


    for (let j = 0; j < this._scriptGlowsPreviousFrame.length; j++) {
      const previousFrameGlow = this._scriptGlowsPreviousFrame[j];

      if (requestedGlowsThisFrame.indexOf(previousFrameGlow) < 0) {
        // Glow turned off.
        this.glowScript(previousFrameGlow, false);
      } else {
        // Still glowing.
        finalScriptGlows.push(previousFrameGlow);
      }
    }

    for (let k = 0; k < requestedGlowsThisFrame.length; k++) {
      const currentFrameGlow = requestedGlowsThisFrame[k];

      if (this._scriptGlowsPreviousFrame.indexOf(currentFrameGlow) < 0) {
        // Glow turned on.
        this.glowScript(currentFrameGlow, true);
        finalScriptGlows.push(currentFrameGlow);
      }
    }

    this._scriptGlowsPreviousFrame = finalScriptGlows;
  }
  /**
   * Emit run start/stop after each tick. Emits when `this.threads.length` goes
   * between non-zero and zero
   *
   * @param {number} nonMonitorThreadCount The new nonMonitorThreadCount
   */


  _emitProjectRunStatus(nonMonitorThreadCount) {
    if (this._nonMonitorThreadCount === 0 && nonMonitorThreadCount > 0) {
      this.emit(Runtime.PROJECT_RUN_START);
    }

    if (this._nonMonitorThreadCount > 0 && nonMonitorThreadCount === 0) {
      this.emit(Runtime.PROJECT_RUN_STOP);
    }

    this._nonMonitorThreadCount = nonMonitorThreadCount;
  }
  /**
   * "Quiet" a script's glow: stop the VM from generating glow/unglow events
   * about that script. Use when a script has just been deleted, but we may
   * still be tracking glow data about it.
   * @param {!string} scriptBlockId Id of top-level block in script to quiet.
   */


  quietGlow(scriptBlockId) {
    const index = this._scriptGlowsPreviousFrame.indexOf(scriptBlockId);

    if (index > -1) {
      this._scriptGlowsPreviousFrame.splice(index, 1);
    }
  }
  /**
   * Emit feedback for block glowing (used in the sequencer).
   * @param {?string} blockId ID for the block to update glow
   * @param {boolean} isGlowing True to turn on glow; false to turn off.
   */


  glowBlock(blockId, isGlowing) {
    if (isGlowing) {
      this.emit(Runtime.BLOCK_GLOW_ON, {
        id: blockId
      });
    } else {
      this.emit(Runtime.BLOCK_GLOW_OFF, {
        id: blockId
      });
    }
  }
  /**
   * Emit feedback for script glowing.
   * @param {?string} topBlockId ID for the top block to update glow
   * @param {boolean} isGlowing True to turn on glow; false to turn off.
   */


  glowScript(topBlockId, isGlowing) {
    if (isGlowing) {
      this.emit(Runtime.SCRIPT_GLOW_ON, {
        id: topBlockId
      });
    } else {
      this.emit(Runtime.SCRIPT_GLOW_OFF, {
        id: topBlockId
      });
    }
  }
  /**
   * Emit whether blocks are being dragged over gui
   * @param {boolean} areBlocksOverGui True if blocks are dragged out of blocks workspace, false otherwise
   */


  emitBlockDragUpdate(areBlocksOverGui) {
    this.emit(Runtime.BLOCK_DRAG_UPDATE, areBlocksOverGui);
  }
  /**
   * Emit event to indicate that the block drag has ended with the blocks outside the blocks workspace
   * @param {Array.<object>} blocks The set of blocks dragged to the GUI
   * @param {string} topBlockId The original id of the top block being dragged
   */


  emitBlockEndDrag(blocks, topBlockId) {
    this.emit(Runtime.BLOCK_DRAG_END, blocks, topBlockId);
  }
  /**
   * Emit value for reporter to show in the blocks.
   * @param {string} blockId ID for the block.
   * @param {string} value Value to show associated with the block.
   */


  visualReport(blockId, value) {
    this.emit(Runtime.VISUAL_REPORT, {
      id: blockId,
      value: String(value)
    });
  }
  /**
   * Add a monitor to the state. If the monitor already exists in the state,
   * updates those properties that are defined in the given monitor record.
   * @param {!MonitorRecord} monitor Monitor to add.
   */


  requestAddMonitor(monitor) {
    const id = monitor.get('id');

    if (!this.requestUpdateMonitor(monitor)) {
      // update monitor if it exists in the state
      // if the monitor did not exist in the state, add it
      this._monitorState = this._monitorState.set(id, monitor);
    }
  }
  /**
   * Update a monitor in the state and report success/failure of update.
   * @param {!Map} monitor Monitor values to update. Values on the monitor with overwrite
   *     values on the old monitor with the same ID. If a value isn't defined on the new monitor,
   *     the old monitor will keep its old value.
   * @return {boolean} true if monitor exists in the state and was updated, false if it did not exist.
   */


  requestUpdateMonitor(monitor) {
    const id = monitor.get('id');

    if (this._monitorState.has(id)) {
      this._monitorState = // Use mergeWith here to prevent undefined values from overwriting existing ones
      this._monitorState.set(id, this._monitorState.get(id).mergeWith((prev, next) => {
        if (typeof next === 'undefined' || next === null) {
          return prev;
        }

        return next;
      }, monitor));
      return true;
    }

    return false;
  }
  /**
   * Removes a monitor from the state. Does nothing if the monitor already does
   * not exist in the state.
   * @param {!string} monitorId ID of the monitor to remove.
   */


  requestRemoveMonitor(monitorId) {
    this._monitorState = this._monitorState.delete(monitorId);
  }
  /**
   * Hides a monitor and returns success/failure of action.
   * @param {!string} monitorId ID of the monitor to hide.
   * @return {boolean} true if monitor exists and was updated, false otherwise
   */


  requestHideMonitor(monitorId) {
    return this.requestUpdateMonitor(new Map([['id', monitorId], ['visible', false]]));
  }
  /**
   * Shows a monitor and returns success/failure of action.
   * not exist in the state.
   * @param {!string} monitorId ID of the monitor to show.
   * @return {boolean} true if monitor exists and was updated, false otherwise
   */


  requestShowMonitor(monitorId) {
    return this.requestUpdateMonitor(new Map([['id', monitorId], ['visible', true]]));
  }
  /**
   * Removes all monitors with the given target ID from the state. Does nothing if
   * the monitor already does not exist in the state.
   * @param {!string} targetId Remove all monitors with given target ID.
   */


  requestRemoveMonitorByTargetId(targetId) {
    this._monitorState = this._monitorState.filterNot(value => value.targetId === targetId);
  }
  /**
   * Get a target by its id.
   * @param {string} targetId Id of target to find.
   * @return {?Target} The target, if found.
   */


  getTargetById(targetId) {
    for (let i = 0; i < this.targets.length; i++) {
      const target = this.targets[i];

      if (target.id === targetId) {
        return target;
      }
    }
  }
  /**
   * Get the first original (non-clone-block-created) sprite given a name.
   * @param {string} spriteName Name of sprite to look for.
   * @return {?Target} Target representing a sprite of the given name.
   */


  getSpriteTargetByName(spriteName) {
    for (let i = 0; i < this.targets.length; i++) {
      const target = this.targets[i];

      if (target.isStage) {
        continue;
      }

      if (target.sprite && target.sprite.name === spriteName) {
        return target;
      }
    }
  }
  /**
   * Get a target by its drawable id.
   * @param {number} drawableID drawable id of target to find
   * @return {?Target} The target, if found
   */


  getTargetByDrawableId(drawableID) {
    for (let i = 0; i < this.targets.length; i++) {
      const target = this.targets[i];
      if (target.drawableID === drawableID) return target;
    }
  }
  /**
   * Update the clone counter to track how many clones are created.
   * @param {number} changeAmount How many clones have been created/destroyed.
   */


  changeCloneCounter(changeAmount) {
    this._cloneCounter += changeAmount;
  }
  /**
   * Return whether there are clones available.
   * @return {boolean} True until the number of clones hits runtimeOptions.maxClones
   */


  clonesAvailable() {
    return this._cloneCounter < this.runtimeOptions.maxClones;
  }
  /**
   * Report that the project has loaded in the Virtual Machine.
   */


  emitProjectLoaded() {
    this.emit(Runtime.PROJECT_LOADED);
  }
  /**
   * Report that the project has changed in a way that would affect serialization
   */


  emitProjectChanged() {
    this.emit(Runtime.PROJECT_CHANGED);
  }
  /**
   * Report that a new target has been created, possibly by cloning an existing target.
   * @param {Target} newTarget - the newly created target.
   * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
   * @fires Runtime#targetWasCreated
   */


  fireTargetWasCreated(newTarget, sourceTarget) {
    this.emit('targetWasCreated', newTarget, sourceTarget);
  }
  /**
   * Report that a clone target is being removed.
   * @param {Target} target - the target being removed
   * @fires Runtime#targetWasRemoved
   */


  fireTargetWasRemoved(target) {
    this.emit('targetWasRemoved', target);
  }
  /**
   * Get a target representing the Scratch stage, if one exists.
   * @return {?Target} The target, if found.
   */


  getTargetForStage() {
    if (this._stageTarget) {
      return this._stageTarget;
    }

    for (let i = 0; i < this.targets.length; i++) {
      const target = this.targets[i];

      if (target.isStage) {
        this._stageTarget = target;
        return target;
      }
    }
  }
  /**
   * Get the editing target.
   * @return {?Target} The editing target.
   */


  getEditingTarget() {
    return this._editingTarget;
  }

  getAllVarNamesOfType(varType) {
    let varNames = [];

    for (const target of this.targets) {
      const targetVarNames = target.getAllVariableNamesInScopeByType(varType, true);
      varNames = varNames.concat(targetVarNames);
    }

    return varNames;
  }
  /**
   * Get the label or label function for an opcode
   * @param {string} extendedOpcode - the opcode you want a label for
   * @return {object} - object with label and category
   * @property {string} category - the category for this opcode
   * @property {Function} [labelFn] - function to generate the label for this opcode
   * @property {string} [label] - the label for this opcode if `labelFn` is absent
   */


  getLabelForOpcode(extendedOpcode) {
    const [category, opcode] = StringUtil.splitFirst(extendedOpcode, '_');
    if (!(category && opcode)) return;

    const categoryInfo = this._blockInfo.find(ci => ci.id === category);

    if (!categoryInfo) return;
    const block = categoryInfo.blocks.find(b => b.info.opcode === opcode);
    if (!block) return; // TODO: we may want to format the label in a locale-specific way.

    return {
      category: 'extension',
      // This assumes that all extensions have the same monitor color.
      label: "".concat(categoryInfo.name, ": ").concat(block.info.text)
    };
  }
  /**
   * Create a new global variable avoiding conflicts with other variable names.
   * @param {string} variableName The desired variable name for the new global variable.
   * This can be turned into a fresh name as necessary.
   * @param {string} optVarId An optional ID to use for the variable. A new one will be generated
   * if a falsey value for this parameter is provided.
   * @param {string} optVarType The type of the variable to create. Defaults to Variable.SCALAR_TYPE.
   * @return {Variable} The new variable that was created.
   */


  createNewGlobalVariable(variableName, optVarId, optVarType) {
    const varType = typeof optVarType === 'string' ? optVarType : Variable.SCALAR_TYPE;
    const allVariableNames = this.getAllVarNamesOfType(varType);
    const newName = StringUtil.unusedName(variableName, allVariableNames);
    const variable = new Variable(optVarId || uid(), newName, varType);
    const stage = this.getTargetForStage();
    stage.variables[variable.id] = variable;
    return variable;
  }
  /**
   * Tell the runtime to request a redraw.
   * Use after a clone/sprite has completed some visible operation on the stage.
   */


  requestRedraw() {
    this.redrawRequested = true;
  }
  /**
   * Emit a targets update at the end of the step if the provided target is
   * the original sprite
   * @param {!Target} target Target requesting the targets update
   */


  requestTargetsUpdate(target) {
    if (!target.isOriginal) return;
    this._refreshTargets = true;
  }
  /**
   * Emit an event that indicates that the blocks on the workspace need updating.
   */


  requestBlocksUpdate() {
    this.emit(Runtime.BLOCKS_NEED_UPDATE);
  }
  /**
   * Emit an event that indicates that the toolbox extension blocks need updating.
   */


  requestToolboxExtensionsUpdate() {
    this.emit(Runtime.TOOLBOX_EXTENSIONS_NEED_UPDATE);
  }
  /**
   * Set up timers to repeatedly step in a browser.
   */


  start() {
    // Do not start if we are already running
    if (this.frameLoop.running) return;
    this.frameLoop.start();
    this.emit(Runtime.RUNTIME_STARTED);
  }
  /**
   * tw: Stop the tick loop
   * Note: This only stops the loop. It will not stop any threads the next time the VM starts
   */


  stop() {
    if (!this.frameLoop.running) {
      return;
    }

    this.frameLoop.stop();
    this.emit(Runtime.RUNTIME_STOPPED);
  }
  /**
   * Turn on profiling.
   * @param {Profiler/FrameCallback} onFrame A callback handle passed a
   * profiling frame when the profiler reports its collected data.
   */


  enableProfiling(onFrame) {
    if (Profiler.available()) {
      this.profiler = new Profiler(onFrame);
    }
  }
  /**
   * Turn off profiling.
   */


  disableProfiling() {
    this.profiler = null;
  }
  /**
   * Update a millisecond timestamp value that is saved on the Runtime.
   * This value is helpful in certain instances for compatibility with Scratch 2,
   * which sometimes uses a `currentMSecs` timestamp value in Interpreter.as
   */


  updateCurrentMSecs() {
    this.currentMSecs = Date.now();
  }

}
/**
 * Event fired after a new target has been created, possibly by cloning an existing target.
 *
 * @event Runtime#targetWasCreated
 * @param {Target} newTarget - the newly created target.
 * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
 */


module.exports = Runtime;

/***/ }),

/***/ "./src/engine/scratch-blocks-constants.js":
/*!************************************************!*\
  !*** ./src/engine/scratch-blocks-constants.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * These constants are copied from scratch-blocks/core/constants.js
 * @TODO find a way to require() these straight from scratch-blocks... maybe make a scratch-blocks/dist/constants.js?
 * @readonly
 * @enum {int}
 */
const ScratchBlocksConstants = {
  /**
   * ENUM for output shape: hexagonal (booleans/predicates).
   * @const
   */
  OUTPUT_SHAPE_HEXAGONAL: 1,

  /**
   * ENUM for output shape: rounded (numbers).
   * @const
   */
  OUTPUT_SHAPE_ROUND: 2,

  /**
   * ENUM for output shape: squared (any/all values; strings).
   * @const
   */
  OUTPUT_SHAPE_SQUARE: 3
};
module.exports = ScratchBlocksConstants;

/***/ }),

/***/ "./src/engine/sequencer.js":
/*!*********************************!*\
  !*** ./src/engine/sequencer.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Timer = __webpack_require__(/*! ../util/timer */ "./src/util/timer.js");

const Thread = __webpack_require__(/*! ./thread */ "./src/engine/thread.js");

const execute = __webpack_require__(/*! ./execute.js */ "./src/engine/execute.js");

const compilerExecute = __webpack_require__(/*! ../compiler/jsexecute */ "./src/compiler/jsexecute.js");
/**
 * Profiler frame name for stepping a single thread.
 * @const {string}
 */


const stepThreadProfilerFrame = 'Sequencer.stepThread';
/**
 * Profiler frame name for the inner loop of stepThreads.
 * @const {string}
 */

const stepThreadsInnerProfilerFrame = 'Sequencer.stepThreads#inner';
/**
 * Profiler frame name for execute.
 * @const {string}
 */

const executeProfilerFrame = 'execute';
/**
 * Profiler frame ID for stepThreadProfilerFrame.
 * @type {number}
 */

let stepThreadProfilerId = -1;
/**
 * Profiler frame ID for stepThreadsInnerProfilerFrame.
 * @type {number}
 */

let stepThreadsInnerProfilerId = -1;
/**
 * Profiler frame ID for executeProfilerFrame.
 * @type {number}
 */

let executeProfilerId = -1;

class Sequencer {
  constructor(runtime) {
    /**
     * A utility timer for timing thread sequencing.
     * @type {!Timer}
     */
    this.timer = new Timer();
    /**
     * Reference to the runtime owning this sequencer.
     * @type {!Runtime}
     */

    this.runtime = runtime;
    this.activeThread = null;
  }
  /**
   * Time to run a warp-mode thread, in ms.
   * @type {number}
   */


  static get WARP_TIME() {
    return 500;
  }
  /**
   * Step through all threads in `this.runtime.threads`, running them in order.
   * @return {Array.<!Thread>} List of inactive threads after stepping.
   */


  stepThreads() {
    // Work time is 75% of the thread stepping interval.
    const WORK_TIME = 0.75 * this.runtime.currentStepTime; // For compatibility with Scatch 2, update the millisecond clock
    // on the Runtime once per step (see Interpreter.as in Scratch 2
    // for original use of `currentMSecs`)

    this.runtime.updateCurrentMSecs(); // Start counting toward WORK_TIME.

    this.timer.start(); // Count of active threads.

    let numActiveThreads = Infinity; // Whether `stepThreads` has run through a full single tick.

    let ranFirstTick = false;
    const doneThreads = []; // Conditions for continuing to stepping threads:
    // 1. We must have threads in the list, and some must be active.
    // 2. Time elapsed must be less than WORK_TIME.
    // 3. Either turbo mode, or no redraw has been requested by a primitive.

    while (this.runtime.threads.length > 0 && numActiveThreads > 0 && this.timer.timeElapsed() < WORK_TIME && (this.runtime.turboMode || !this.runtime.redrawRequested)) {
      if (this.runtime.profiler !== null) {
        if (stepThreadsInnerProfilerId === -1) {
          stepThreadsInnerProfilerId = this.runtime.profiler.idByName(stepThreadsInnerProfilerFrame);
        }

        this.runtime.profiler.start(stepThreadsInnerProfilerId);
      }

      numActiveThreads = 0;
      let stoppedThread = false; // Attempt to run each thread one time.

      const threads = this.runtime.threads;

      for (let i = 0; i < threads.length; i++) {
        const activeThread = this.activeThread = threads[i]; // Check if the thread is done so it is not executed.

        if (activeThread.stack.length === 0 || activeThread.status === Thread.STATUS_DONE) {
          // Finished with this thread.
          stoppedThread = true;
          continue;
        }

        if (activeThread.status === Thread.STATUS_YIELD_TICK && !ranFirstTick) {
          // Clear single-tick yield from the last call of `stepThreads`.
          activeThread.status = Thread.STATUS_RUNNING;
        }

        if (activeThread.status === Thread.STATUS_RUNNING || activeThread.status === Thread.STATUS_YIELD) {
          // Normal-mode thread: step.
          if (this.runtime.profiler !== null) {
            if (stepThreadProfilerId === -1) {
              stepThreadProfilerId = this.runtime.profiler.idByName(stepThreadProfilerFrame);
            } // Increment the number of times stepThread is called.


            this.runtime.profiler.increment(stepThreadProfilerId);
          }

          this.stepThread(activeThread);
          activeThread.warpTimer = null;

          if (activeThread.isKilled) {
            i--; // if the thread is removed from the list (killed), do not increase index
          }
        }

        if (activeThread.status === Thread.STATUS_RUNNING) {
          numActiveThreads++;
        } // Check if the thread completed while it just stepped to make
        // sure we remove it before the next iteration of all threads.


        if (activeThread.stack.length === 0 || activeThread.status === Thread.STATUS_DONE) {
          // Finished with this thread.
          stoppedThread = true;
        }
      } // We successfully ticked once. Prevents running STATUS_YIELD_TICK
      // threads on the next tick.


      ranFirstTick = true;

      if (this.runtime.profiler !== null) {
        this.runtime.profiler.stop();
      } // Filter inactive threads from `this.runtime.threads`.


      if (stoppedThread) {
        let nextActiveThread = 0;

        for (let i = 0; i < this.runtime.threads.length; i++) {
          const thread = this.runtime.threads[i];

          if (thread.stack.length !== 0 && thread.status !== Thread.STATUS_DONE) {
            this.runtime.threads[nextActiveThread] = thread;
            nextActiveThread++;
          } else {
            this.runtime.threadMap.delete(thread.getId());
            doneThreads.push(thread);
          }
        }

        this.runtime.threads.length = nextActiveThread;
      }
    }

    this.activeThread = null;
    return doneThreads;
  }
  /**
   * Step the requested thread for as long as necessary.
   * @param {!Thread} thread Thread object to step.
   */


  stepThread(thread) {
    if (thread.isCompiled) {
      compilerExecute(thread);
      return;
    }

    let currentBlockId = thread.peekStack();

    if (!currentBlockId) {
      // A "null block" - empty branch.
      thread.popStack(); // Did the null follow a hat block?

      if (thread.stack.length === 0) {
        thread.status = Thread.STATUS_DONE;
        return;
      }
    } // Save the current block ID to notice if we did control flow.


    while (currentBlockId = thread.peekStack()) {
      let isWarpMode = thread.peekStackFrame().warpMode;

      if (isWarpMode && !thread.warpTimer) {
        // Initialize warp-mode timer if it hasn't been already.
        // This will start counting the thread toward `Sequencer.WARP_TIME`.
        thread.warpTimer = new Timer();
        thread.warpTimer.start();
      } // Execute the current block.


      if (this.runtime.profiler !== null) {
        if (executeProfilerId === -1) {
          executeProfilerId = this.runtime.profiler.idByName(executeProfilerFrame);
        } // Increment the number of times execute is called.


        this.runtime.profiler.increment(executeProfilerId);
      }

      if (thread.target === null) {
        this.retireThread(thread);
      } else {
        execute(this, thread);
      }

      thread.blockGlowInFrame = currentBlockId; // If the thread has yielded or is waiting, yield to other threads.

      if (thread.status === Thread.STATUS_YIELD) {
        // Mark as running for next iteration.
        thread.status = Thread.STATUS_RUNNING; // In warp mode, yielded blocks are re-executed immediately.

        if (isWarpMode && thread.warpTimer.timeElapsed() <= Sequencer.WARP_TIME) {
          continue;
        }

        return;
      } else if (thread.status === Thread.STATUS_PROMISE_WAIT) {
        // A promise was returned by the primitive. Yield the thread
        // until the promise resolves. Promise resolution should reset
        // thread.status to Thread.STATUS_RUNNING.
        return;
      } else if (thread.status === Thread.STATUS_YIELD_TICK) {
        // stepThreads will reset the thread to Thread.STATUS_RUNNING
        return;
      } // If no control flow has happened, switch to next block.


      if (thread.peekStack() === currentBlockId) {
        thread.goToNextBlock();
      } // If no next block has been found at this point, look on the stack.


      while (!thread.peekStack()) {
        thread.popStack();

        if (thread.stack.length === 0) {
          // No more stack to run!
          thread.status = Thread.STATUS_DONE;
          return;
        }

        const stackFrame = thread.peekStackFrame();
        isWarpMode = stackFrame.warpMode;

        if (stackFrame.isLoop) {
          // The current level of the stack is marked as a loop.
          // Return to yield for the frame/tick in general.
          // Unless we're in warp mode - then only return if the
          // warp timer is up.
          if (!isWarpMode || thread.warpTimer.timeElapsed() > Sequencer.WARP_TIME) {
            // Don't do anything to the stack, since loops need
            // to be re-executed.
            return;
          } // Don't go to the next block for this level of the stack,
          // since loops need to be re-executed.


          continue;
        } else if (stackFrame.waitingReporter) {
          // This level of the stack was waiting for a value.
          // This means a reporter has just returned - so don't go
          // to the next block for this level of the stack.
          return;
        } // Get next block of existing block on the stack.


        thread.goToNextBlock();
      }
    }
  }
  /**
   * Step a thread into a block's branch.
   * @param {!Thread} thread Thread object to step to branch.
   * @param {number} branchNum Which branch to step to (i.e., 1, 2).
   * @param {boolean} isLoop Whether this block is a loop.
   */


  stepToBranch(thread, branchNum, isLoop) {
    if (!branchNum) {
      branchNum = 1;
    }

    const currentBlockId = thread.peekStack();
    const branchId = thread.target.blocks.getBranch(currentBlockId, branchNum);
    thread.peekStackFrame().isLoop = isLoop;

    if (branchId) {
      // Push branch ID to the thread's stack.
      thread.pushStack(branchId);
    } else {
      thread.pushStack(null);
    }
  }
  /**
   * Step a procedure.
   * @param {!Thread} thread Thread object to step to procedure.
   * @param {!string} procedureCode Procedure code of procedure to step to.
   */


  stepToProcedure(thread, procedureCode) {
    const definition = thread.target.blocks.getProcedureDefinition(procedureCode);

    if (!definition) {
      return;
    } // Check if the call is recursive.
    // If so, set the thread to yield after pushing.


    const isRecursive = thread.isRecursiveCall(procedureCode); // To step to a procedure, we put its definition on the stack.
    // Execution for the thread will proceed through the definition hat
    // and on to the main definition of the procedure.
    // When that set of blocks finishes executing, it will be popped
    // from the stack by the sequencer, returning control to the caller.

    thread.pushStack(definition); // In known warp-mode threads, only yield when time is up.

    if (thread.peekStackFrame().warpMode && thread.warpTimer.timeElapsed() > Sequencer.WARP_TIME) {
      thread.status = Thread.STATUS_YIELD;
    } else {
      // Look for warp-mode flag on definition, and set the thread
      // to warp-mode if needed.
      const definitionBlock = thread.target.blocks.getBlock(definition);
      const innerBlock = thread.target.blocks.getBlock(definitionBlock.inputs.custom_block.block);
      let doWarp = false;

      if (innerBlock && innerBlock.mutation) {
        const warp = innerBlock.mutation.warp;

        if (typeof warp === 'boolean') {
          doWarp = warp;
        } else if (typeof warp === 'string') {
          doWarp = JSON.parse(warp);
        }
      }

      if (doWarp) {
        thread.peekStackFrame().warpMode = true;
      } else if (isRecursive) {
        // In normal-mode threads, yield any time we have a recursive call.
        thread.status = Thread.STATUS_YIELD;
      }
    }
  }
  /**
   * Retire a thread in the middle, without considering further blocks.
   * @param {!Thread} thread Thread object to retire.
   */


  retireThread(thread) {
    thread.stack = [];
    thread.stackFrame = [];
    thread.requestScriptGlowInFrame = false;
    thread.status = Thread.STATUS_DONE;

    if (thread.isCompiled) {
      thread.procedures = null;
      thread.generator = null;
    }
  }

}

module.exports = Sequencer;

/***/ }),

/***/ "./src/engine/stage-layering.js":
/*!**************************************!*\
  !*** ./src/engine/stage-layering.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

class StageLayering {
  static get BACKGROUND_LAYER() {
    return 'background';
  }

  static get VIDEO_LAYER() {
    return 'video';
  }

  static get PEN_LAYER() {
    return 'pen';
  }

  static get SPRITE_LAYER() {
    return 'sprite';
  } // Order of layer groups relative to each other,


  static get LAYER_GROUPS() {
    return [StageLayering.BACKGROUND_LAYER, StageLayering.VIDEO_LAYER, StageLayering.PEN_LAYER, StageLayering.SPRITE_LAYER];
  }

}

module.exports = StageLayering;

/***/ }),

/***/ "./src/engine/target.js":
/*!******************************!*\
  !*** ./src/engine/target.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const EventEmitter = __webpack_require__(/*! events */ "events");

const Blocks = __webpack_require__(/*! ./blocks */ "./src/engine/blocks.js");

const Variable = __webpack_require__(/*! ../engine/variable */ "./src/engine/variable.js");

const Comment = __webpack_require__(/*! ../engine/comment */ "./src/engine/comment.js");

const uid = __webpack_require__(/*! ../util/uid */ "./src/util/uid.js");

const {
  Map
} = __webpack_require__(/*! immutable */ "immutable");

const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");

const VariableUtil = __webpack_require__(/*! ../util/variable-util */ "./src/util/variable-util.js");
/**
 * @fileoverview
 * A Target is an abstract "code-running" object for the Scratch VM.
 * Examples include sprites/clones or potentially physical-world devices.
 */


class Target extends EventEmitter {
  /**
   * @param {Runtime} runtime Reference to the runtime.
   * @param {?Blocks} blocks Blocks instance for the blocks owned by this target.
   * @constructor
   */
  constructor(runtime, blocks) {
    super();

    if (!blocks) {
      blocks = new Blocks(runtime);
    }
    /**
     * Reference to the runtime.
     * @type {Runtime}
     */


    this.runtime = runtime;
    /**
     * A unique ID for this target.
     * @type {string}
     */

    this.id = uid();
    /**
     * Blocks run as code for this target.
     * @type {!Blocks}
     */

    this.blocks = blocks;
    /**
     * Dictionary of variables and their values for this target.
     * Key is the variable id.
     * @type {Object.<string,*>}
     */

    this.variables = {};
    /**
     * Dictionary of comments for this target.
     * Key is the comment id.
     * @type {Object.<string,*>}
     */

    this.comments = {};
    /**
     * Dictionary of custom state for this target.
     * This can be used to store target-specific custom state for blocks which need it.
     * TODO: do we want to persist this in SB3 files?
     * @type {Object.<string,*>}
     */

    this._customState = {};
    /**
     * Currently known values for edge-activated hats.
     * Keys are block ID for the hat; values are the currently known values.
     * @type {Object.<string, *>}
     */

    this._edgeActivatedHatValues = {};
  }
  /**
   * Called when the project receives a "green flag."
   * @abstract
   */


  onGreenFlag() {}
  /**
   * Return a human-readable name for this target.
   * Target implementations should override this.
   * @abstract
   * @returns {string} Human-readable name for the target.
   */


  getName() {
    return this.id;
  }
  /**
   * Update an edge-activated hat block value.
   * @param {!string} blockId ID of hat to store value for.
   * @param {*} newValue Value to store for edge-activated hat.
   * @return {*} The old value for the edge-activated hat.
   */


  updateEdgeActivatedValue(blockId, newValue) {
    const oldValue = this._edgeActivatedHatValues[blockId];
    this._edgeActivatedHatValues[blockId] = newValue;
    return oldValue;
  }

  hasEdgeActivatedValue(blockId) {
    return this._edgeActivatedHatValues.hasOwnProperty(blockId);
  }
  /**
   * Clear all edge-activaed hat values.
   */


  clearEdgeActivatedValues() {
    this._edgeActivatedHatValues = {};
  }
  /**
   * Look up a variable object, first by id, and then by name if the id is not found.
   * Create a new variable if both lookups fail.
   * @param {string} id Id of the variable.
   * @param {string} name Name of the variable.
   * @return {!Variable} Variable object.
   */


  lookupOrCreateVariable(id, name) {
    let variable = this.lookupVariableById(id);
    if (variable) return variable;
    variable = this.lookupVariableByNameAndType(name, Variable.SCALAR_TYPE);
    if (variable) return variable; // No variable with this name exists - create it locally.

    const newVariable = new Variable(id, name, Variable.SCALAR_TYPE, false);
    this.variables[id] = newVariable;
    return newVariable;
  }
  /**
   * Look up a broadcast message object with the given id and return it
   * if it exists.
   * @param {string} id Id of the variable.
   * @param {string} name Name of the variable.
   * @return {?Variable} Variable object.
   */


  lookupBroadcastMsg(id, name) {
    let broadcastMsg;

    if (id) {
      broadcastMsg = this.lookupVariableById(id);
    } else if (name) {
      broadcastMsg = this.lookupBroadcastByInputValue(name);
    } else {
      log.error('Cannot find broadcast message if neither id nor name are provided.');
    }

    if (broadcastMsg) {
      if (name && broadcastMsg.name.toLowerCase() !== name.toLowerCase()) {
        log.error("Found broadcast message with id: ".concat(id, ", but") + "its name, ".concat(broadcastMsg.name, " did not match expected name ").concat(name, "."));
      }

      if (broadcastMsg.type !== Variable.BROADCAST_MESSAGE_TYPE) {
        log.error("Found variable with id: ".concat(id, ", but its type ").concat(broadcastMsg.type) + "did not match expected type ".concat(Variable.BROADCAST_MESSAGE_TYPE));
      }

      return broadcastMsg;
    }
  }
  /**
   * Look up a broadcast message with the given name and return the variable
   * if it exists. Does not create a new broadcast message variable if
   * it doesn't exist.
   * @param {string} name Name of the variable.
   * @return {?Variable} Variable object.
   */


  lookupBroadcastByInputValue(name) {
    const vars = this.variables;

    for (const propName in vars) {
      if (vars[propName].type === Variable.BROADCAST_MESSAGE_TYPE && vars[propName].name.toLowerCase() === name.toLowerCase()) {
        return vars[propName];
      }
    }
  }
  /**
   * Look up a variable object.
   * Search begins for local variables; then look for globals.
   * @param {string} id Id of the variable.
   * @param {string} name Name of the variable.
   * @return {!Variable} Variable object.
   */


  lookupVariableById(id) {
    // If we have a local copy, return it.
    if (this.variables.hasOwnProperty(id)) {
      return this.variables[id];
    } // If the stage has a global copy, return it.


    if (this.runtime && !this.isStage) {
      const stage = this.runtime.getTargetForStage();

      if (stage && stage.variables.hasOwnProperty(id)) {
        return stage.variables[id];
      }
    }
  }
  /**
   * Look up a variable object by its name and variable type.
   * Search begins with local variables; then global variables if a local one
   * was not found.
   * @param {string} name Name of the variable.
   * @param {string} type Type of the variable. Defaults to Variable.SCALAR_TYPE.
   * @param {?bool} skipStage Optional flag to skip checking the stage
   * @return {?Variable} Variable object if found, or null if not.
   */


  lookupVariableByNameAndType(name, type, skipStage) {
    if (typeof name !== 'string') return;
    if (typeof type !== 'string') type = Variable.SCALAR_TYPE;
    skipStage = skipStage || false;

    for (const varId in this.variables) {
      const currVar = this.variables[varId];

      if (currVar.name === name && currVar.type === type) {
        return currVar;
      }
    }

    if (!skipStage && this.runtime && !this.isStage) {
      const stage = this.runtime.getTargetForStage();

      if (stage) {
        for (const varId in stage.variables) {
          const currVar = stage.variables[varId];

          if (currVar.name === name && currVar.type === type) {
            return currVar;
          }
        }
      }
    }

    return null;
  }
  /**
  * Look up a list object for this target, and create it if one doesn't exist.
  * Search begins for local lists; then look for globals.
  * @param {!string} id Id of the list.
  * @param {!string} name Name of the list.
  * @return {!Varible} Variable object representing the found/created list.
   */


  lookupOrCreateList(id, name) {
    let list = this.lookupVariableById(id);
    if (list) return list;
    list = this.lookupVariableByNameAndType(name, Variable.LIST_TYPE);
    if (list) return list; // No variable with this name exists - create it locally.

    const newList = new Variable(id, name, Variable.LIST_TYPE, false);
    this.variables[id] = newList;
    return newList;
  }
  /**
   * Creates a variable with the given id and name and adds it to the
   * dictionary of variables.
   * @param {string} id Id of variable
   * @param {string} name Name of variable.
   * @param {string} type Type of variable, '', 'broadcast_msg', or 'list'
   * @param {boolean} isCloud Whether the variable to create has the isCloud flag set.
   * Additional checks are made that the variable can be created as a cloud variable.
   */


  createVariable(id, name, type, isCloud) {
    if (!this.variables.hasOwnProperty(id)) {
      const newVariable = new Variable(id, name, type, false);

      if (isCloud && this.isStage && this.runtime.canAddCloudVariable()) {
        newVariable.isCloud = true;
        this.runtime.addCloudVariable();
        this.runtime.ioDevices.cloud.requestCreateVariable(newVariable);
      }

      this.variables[id] = newVariable;
    }
  }
  /**
   * Creates a comment with the given properties.
   * @param {string} id Id of the comment.
   * @param {string} blockId Optional id of the block the comment is attached
   * to if it is a block comment.
   * @param {string} text The text the comment contains.
   * @param {number} x The x coordinate of the comment on the workspace.
   * @param {number} y The y coordinate of the comment on the workspace.
   * @param {number} width The width of the comment when it is full size
   * @param {number} height The height of the comment when it is full size
   * @param {boolean} minimized Whether the comment is minimized.
   */


  createComment(id, blockId, text, x, y, width, height, minimized) {
    if (!this.comments.hasOwnProperty(id)) {
      const newComment = new Comment(id, text, x, y, width, height, minimized);

      if (blockId) {
        newComment.blockId = blockId;
        const blockWithComment = this.blocks.getBlock(blockId);

        if (blockWithComment) {
          blockWithComment.comment = id;
        } else {
          log.warn("Could not find block with id ".concat(blockId, " associated with commentId: ").concat(id));
        }
      }

      this.comments[id] = newComment;
    }
  }
  /**
   * Renames the variable with the given id to newName.
   * @param {string} id Id of variable to rename.
   * @param {string} newName New name for the variable.
   */


  renameVariable(id, newName) {
    if (this.variables.hasOwnProperty(id)) {
      const variable = this.variables[id];

      if (variable.id === id) {
        const oldName = variable.name;
        variable.name = newName;

        if (this.runtime) {
          if (variable.isCloud && this.isStage) {
            this.runtime.ioDevices.cloud.requestRenameVariable(oldName, newName);
          }

          if (variable.type === Variable.SCALAR_TYPE) {
            // sensing__of may be referencing to this variable.
            // Change the reference.
            let blockUpdated = false;
            this.runtime.targets.forEach(t => {
              blockUpdated = t.blocks.updateSensingOfReference(oldName, newName, this.isStage ? '_stage_' : this.getName()) || blockUpdated;
            }); // Request workspace change only if sensing_of blocks were actually updated.

            if (blockUpdated) this.runtime.requestBlocksUpdate();
          }

          const blocks = this.runtime.monitorBlocks;
          blocks.changeBlock({
            id: id,
            element: 'field',
            name: variable.type === Variable.LIST_TYPE ? 'LIST' : 'VARIABLE',
            value: id
          }, this.runtime);
          const monitorBlock = blocks.getBlock(variable.id);

          if (monitorBlock) {
            this.runtime.requestUpdateMonitor(Map({
              id: id,
              params: blocks._getBlockParams(monitorBlock)
            }));
          }
        }
      }
    }
  }
  /**
   * Removes the variable with the given id from the dictionary of variables.
   * @param {string} id Id of variable to delete.
   */


  deleteVariable(id) {
    if (this.variables.hasOwnProperty(id)) {
      // Get info about the variable before deleting it
      const deletedVariableName = this.variables[id].name;
      const deletedVariableWasCloud = this.variables[id].isCloud;
      delete this.variables[id];

      if (this.runtime) {
        if (deletedVariableWasCloud && this.isStage) {
          this.runtime.ioDevices.cloud.requestDeleteVariable(deletedVariableName);
          this.runtime.removeCloudVariable();
        }

        this.runtime.monitorBlocks.deleteBlock(id);
        this.runtime.requestRemoveMonitor(id);
      }
    }
  }
  /**
   * Remove this target's monitors from the runtime state and remove the
   * target-specific monitored blocks (e.g. local variables, global variables for the stage, x-position).
   * NOTE: This does not delete any of the stage monitors like backdrop name.
   */


  deleteMonitors() {
    this.runtime.requestRemoveMonitorByTargetId(this.id);
    let targetSpecificMonitorBlockIds;

    if (this.isStage) {
      // This only deletes global variables and not other stage monitors like backdrop number.
      targetSpecificMonitorBlockIds = Object.keys(this.variables);
    } else {
      targetSpecificMonitorBlockIds = Object.keys(this.runtime.monitorBlocks._blocks).filter(key => this.runtime.monitorBlocks._blocks[key].targetId === this.id);
    }

    for (const blockId of targetSpecificMonitorBlockIds) {
      this.runtime.monitorBlocks.deleteBlock(blockId);
    }
  }
  /**
   * Create a clone of the variable with the given id from the dictionary of
   * this target's variables.
   * @param {string} id Id of variable to duplicate.
   * @param {boolean=} optKeepOriginalId Optional flag to keep the original variable ID
   * for the duplicate variable. This is necessary when cloning a sprite, for example.
   * @return {?Variable} The duplicated variable, or null if
   * the original variable was not found.
   */


  duplicateVariable(id, optKeepOriginalId) {
    if (this.variables.hasOwnProperty(id)) {
      const originalVariable = this.variables[id];
      const newVariable = new Variable(optKeepOriginalId ? id : null, // conditionally keep original id or generate a new one
      originalVariable.name, originalVariable.type, originalVariable.isCloud);

      if (newVariable.type === Variable.LIST_TYPE) {
        newVariable.value = originalVariable.value.slice(0);
      } else {
        newVariable.value = originalVariable.value;
      }

      return newVariable;
    }

    return null;
  }
  /**
   * Duplicate the dictionary of this target's variables as part of duplicating.
   * this target or making a clone.
   * @param {object=} optBlocks Optional block container for the target being duplicated.
   * If provided, new variables will be generated with new UIDs and any variable references
   * in this blocks container will be updated to refer to the corresponding new IDs.
   * @return {object} The duplicated dictionary of variables
   */


  duplicateVariables(optBlocks) {
    let allVarRefs;

    if (optBlocks) {
      allVarRefs = optBlocks.getAllVariableAndListReferences();
    }

    return Object.keys(this.variables).reduce((accum, varId) => {
      const newVariable = this.duplicateVariable(varId, !optBlocks);
      accum[newVariable.id] = newVariable;

      if (optBlocks && allVarRefs) {
        const currVarRefs = allVarRefs[varId];

        if (currVarRefs) {
          this.mergeVariables(varId, newVariable.id, currVarRefs);
        }
      }

      return accum;
    }, {});
  }
  /**
   * Post/edit sprite info.
   * @param {object} data An object with sprite info data to set.
   * @abstract
   */


  postSpriteInfo() {}
  /**
   * Retrieve custom state associated with this target and the provided state ID.
   * @param {string} stateId - specify which piece of state to retrieve.
   * @returns {*} the associated state, if any was found.
   */


  getCustomState(stateId) {
    return this._customState[stateId];
  }
  /**
   * Store custom state associated with this target and the provided state ID.
   * @param {string} stateId - specify which piece of state to store on this target.
   * @param {*} newValue - the state value to store.
   */


  setCustomState(stateId, newValue) {
    this._customState[stateId] = newValue;
  }
  /**
   * Call to destroy a target.
   * @abstract
   */


  dispose() {
    this._customState = {};

    if (this.runtime) {
      this.runtime.removeExecutable(this);
    }
  } // Variable Conflict Resolution Helpers

  /**
   * Get the names of all the variables of the given type that are in scope for this target.
   * For targets that are not the stage, this includes any target-specific
   * variables as well as any stage variables unless the skipStage flag is true.
   * For the stage, this is all stage variables.
   * @param {string} type The variable type to search for; defaults to Variable.SCALAR_TYPE
   * @param {?bool} skipStage Optional flag to skip the stage.
   * @return {Array<string>} A list of variable names
   */


  getAllVariableNamesInScopeByType(type, skipStage) {
    if (typeof type !== 'string') type = Variable.SCALAR_TYPE;
    skipStage = skipStage || false;
    const targetVariables = Object.values(this.variables).filter(v => v.type === type).map(variable => variable.name);

    if (skipStage || this.isStage || !this.runtime) {
      return targetVariables;
    }

    const stage = this.runtime.getTargetForStage();
    const stageVariables = stage.getAllVariableNamesInScopeByType(type);
    return targetVariables.concat(stageVariables);
  }
  /**
   * Merge variable references with another variable.
   * @param {string} idToBeMerged ID of the variable whose references need to be updated
   * @param {string} idToMergeWith ID of the variable that the old references should be replaced with
   * @param {?Array<Object>} optReferencesToUpdate Optional context of the change.
   * Defaults to all the blocks in this target.
   * @param {?string} optNewName New variable name to merge with. The old
   * variable name in the references being updated should be replaced with this new name.
   * If this parameter is not provided or is '', no name change occurs.
   */


  mergeVariables(idToBeMerged, idToMergeWith, optReferencesToUpdate, optNewName) {
    const referencesToChange = optReferencesToUpdate || // TODO should there be a separate helper function that traverses the blocks
    // for all references for a given ID instead of doing the below..?
    this.blocks.getAllVariableAndListReferences()[idToBeMerged];
    VariableUtil.updateVariableIdentifiers(referencesToChange, idToMergeWith, optNewName);
  }
  /**
   * Share a local variable (and given references for that variable) to the stage.
   * @param {string} varId The ID of the variable to share.
   * @param {Array<object>} varRefs The list of variable references being shared,
   * that reference the given variable ID. The names and IDs of these variable
   * references will be updated to refer to the new (or pre-existing) global variable.
   */


  shareLocalVariableToStage(varId, varRefs) {
    if (!this.runtime) return;
    const variable = this.variables[varId];

    if (!variable) {
      log.warn("Cannot share a local variable to the stage if it's not local.");
      return;
    }

    const stage = this.runtime.getTargetForStage(); // If a local var is being shared with the stage,
    // sharing will make the variable global, resulting in a conflict
    // with the existing local variable. Preemptively Resolve this conflict
    // by renaming the new global variable.
    // First check if we've already done the local to global transition for this
    // variable. If we have, merge it with the global variable we've already created.

    const varIdForStage = "StageVarFromLocal_".concat(varId);
    let stageVar = stage.lookupVariableById(varIdForStage); // If a global var doesn't already exist, create a new one with a fresh name.
    // Use the ID we created above so that we can lookup this new variable in the
    // future if we decide to share this same variable again.

    if (!stageVar) {
      const varName = variable.name;
      const varType = variable.type;
      const newStageName = "Stage: ".concat(varName);
      stageVar = this.runtime.createNewGlobalVariable(newStageName, varIdForStage, varType);
    } // Update all variable references to use the new name and ID


    this.mergeVariables(varId, stageVar.id, varRefs, stageVar.name);
  }
  /**
   * Share a local variable with a sprite, merging with one of the same name and
   * type if it already exists on the sprite, or create a new one.
   * @param {string} varId Id of the variable to share
   * @param {Target} sprite The sprite to share the variable with
   * @param {Array<object>} varRefs A list of all the variable references currently being shared.
   */


  shareLocalVariableToSprite(varId, sprite, varRefs) {
    if (!this.runtime) return;
    if (this.isStage) return;
    const variable = this.variables[varId];

    if (!variable) {
      log.warn("Tried to call 'shareLocalVariableToSprite' with a non-local variable.");
      return;
    }

    const varName = variable.name;
    const varType = variable.type; // Check if the receiving sprite already has a variable of the same name and type
    // and use the existing variable, otherwise create a new one.

    const existingLocalVar = sprite.lookupVariableByNameAndType(varName, varType);
    let newVarId;

    if (existingLocalVar) {
      newVarId = existingLocalVar.id;
    } else {
      const newVar = new Variable(null, varName, varType);
      newVarId = newVar.id;
      sprite.variables[newVarId] = newVar;
    } // Merge with the local variable on the new sprite.


    this.mergeVariables(varId, newVarId, varRefs);
  }
  /**
   * Given a list of variable referencing fields, shares those variables with
   * the target with the provided id, resolving any variable conflicts that arise
   * using the following rules:
   *
   * If this target is the stage, exit. There are no conflicts that arise
   * from sharing variables from the stage to another sprite. The variables
   * already exist globally, so no further action is needed.
   *
   * If a variable being referenced is a global variable, do nothing. The
   * global variable already exists so no further action is needed.
   *
   * If a variable being referenced is local, and
   * 1) The receiving target is a sprite:
   * create a new local variable or merge with an existing local variable
   * of the same name and type. Update all the referencing fields
   * for the original variable to reference the new variable.
   * 2) The receiving target is the stage:
   * Create a new global variable with a fresh name and update all the referencing
   * fields to reference the new variable.
   *
   * @param {Array<object>} blocks The blocks containing
   * potential conflicting references to variables.
   * @param {Target} receivingTarget The target receiving the variables
   */


  resolveVariableSharingConflictsWithTarget(blocks, receivingTarget) {
    if (this.isStage) return; // Get all the variable references in the given list of blocks

    const allVarListRefs = this.blocks.getAllVariableAndListReferences(blocks); // For all the variables being referenced, check for which ones are local
    // to this target, and resolve conflicts based on whether the receiving target
    // is a sprite (with a conflicting local variable) or whether it is
    // the stage (which cannot have local variables)

    for (const varId in allVarListRefs) {
      const currVar = this.variables[varId];
      if (!currVar) continue; // The current variable is global, there shouldn't be any conflicts here, skip it.
      // Get the list of references for the current variable id

      const currVarListRefs = allVarListRefs[varId];

      if (receivingTarget.isStage) {
        this.shareLocalVariableToStage(varId, currVarListRefs);
      } else {
        this.shareLocalVariableToSprite(varId, receivingTarget, currVarListRefs);
      }
    }
  }
  /**
   * Fixes up variable references in this target avoiding conflicts with
   * pre-existing variables in the same scope.
   * This is used when uploading this target as a new sprite into an existing
   * project, where the new sprite may contain references
   * to variable names that already exist as global variables in the project
   * (and thus are in scope for variable references in the given sprite).
   *
   * If this target has a block that references an existing global variable and that
   * variable *does not* exist in this target (e.g. it was a global variable in the
   * project the sprite was originally exported from), merge the variables. This entails
   * fixing the variable references in this sprite to reference the id of the pre-existing global variable.
   *
   * If this target has a block that references an existing global variable and that
   * variable does exist in the target itself (e.g. it's a local variable in the sprite being uploaded),
   * then the local variable is renamed to distinguish itself from the pre-existing variable.
   * All blocks that reference the local variable will be updated to use the new name.
   */
  // TODO (#1360) This function is too long, add some helpers for the different chunks and cases...


  fixUpVariableReferences() {
    if (!this.runtime) return; // There's no runtime context to conflict with

    if (this.isStage) return; // Stage can't have variable conflicts with itself (and also can't be uploaded)

    const stage = this.runtime.getTargetForStage();
    if (!stage || !stage.variables) return;

    const renameConflictingLocalVar = (id, name, type) => {
      const conflict = stage.lookupVariableByNameAndType(name, type);

      if (conflict) {
        const newName = StringUtil.unusedName("".concat(this.getName(), ": ").concat(name), this.getAllVariableNamesInScopeByType(type));
        this.renameVariable(id, newName);
        return newName;
      }

      return null;
    };

    const allReferences = this.blocks.getAllVariableAndListReferences();
    const unreferencedLocalVarIds = [];

    if (Object.keys(this.variables).length > 0) {
      for (const localVarId in this.variables) {
        if (!this.variables.hasOwnProperty(localVarId)) continue;
        if (!allReferences[localVarId]) unreferencedLocalVarIds.push(localVarId);
      }
    }

    const conflictIdsToReplace = Object.create(null);
    const conflictNamesToReplace = Object.create(null); // Cache the list of all variable names by type so that we don't need to
    // re-calculate this in every iteration of the following loop.

    const varNamesByType = {};

    const allVarNames = type => {
      const namesOfType = varNamesByType[type];
      if (namesOfType) return namesOfType;
      varNamesByType[type] = this.runtime.getAllVarNamesOfType(type);
      return varNamesByType[type];
    };

    for (const varId in allReferences) {
      // We don't care about which var ref we get, they should all have the same var info
      const varRef = allReferences[varId][0];
      const varName = varRef.referencingField.value;
      const varType = varRef.type;

      if (this.lookupVariableById(varId)) {
        // Found a variable with the id in either the target or the stage,
        // figure out which one.
        if (this.variables.hasOwnProperty(varId)) {
          // If the target has the variable, then check whether the stage
          // has one with the same name and type. If it does, then rename
          // this target specific variable so that there is a distinction.
          const newVarName = renameConflictingLocalVar(varId, varName, varType);

          if (newVarName) {
            // We are not calling this.blocks.updateBlocksAfterVarRename
            // here because it will search through all the blocks. We already
            // have access to all the references for this var id.
            allReferences[varId].map(ref => {
              ref.referencingField.value = newVarName;
              return ref;
            });
          }
        }
      } else {
        // We didn't find the referenced variable id anywhere,
        // Treat it as a reference to a global variable (from the original
        // project this sprite was exported from).
        // Check for whether a global variable of the same name and type exists,
        // and if so, track it to merge with the existing global in a second pass of the blocks.
        const existingVar = stage.lookupVariableByNameAndType(varName, varType);

        if (existingVar) {
          if (!conflictIdsToReplace[varId]) {
            conflictIdsToReplace[varId] = existingVar.id;
          }
        } else {
          // A global variable with the same name did not already exist,
          // create a new one such that it does not conflict with any
          // names of local variables of the same type.
          const allNames = allVarNames(varType);
          const freshName = StringUtil.unusedName(varName, allNames);
          stage.createVariable(varId, freshName, varType);

          if (!conflictNamesToReplace[varId]) {
            conflictNamesToReplace[varId] = freshName;
          }
        }
      }
    } // Rename any local variables that were missed above because they aren't
    // referenced by any blocks


    for (const id in unreferencedLocalVarIds) {
      const varId = unreferencedLocalVarIds[id];
      const name = this.variables[varId].name;
      const type = this.variables[varId].type;
      renameConflictingLocalVar(varId, name, type);
    } // Handle global var conflicts with existing global vars (e.g. a sprite is uploaded, and has
    // blocks referencing some variable that the sprite does not own, and this
    // variable conflicts with a global var)
    // In this case, we want to merge the new variable referenes with the
    // existing global variable


    for (const conflictId in conflictIdsToReplace) {
      const existingId = conflictIdsToReplace[conflictId];
      const referencesToUpdate = allReferences[conflictId];
      this.mergeVariables(conflictId, existingId, referencesToUpdate);
    } // Handle global var conflicts existing local vars (e.g a sprite is uploaded,
    // and has blocks referencing some variable that the sprite does not own, and this
    // variable conflcits with another sprite's local var).
    // In this case, we want to go through the variable references and update
    // the name of the variable in that reference.


    for (const conflictId in conflictNamesToReplace) {
      const newName = conflictNamesToReplace[conflictId];
      const referencesToUpdate = allReferences[conflictId];
      referencesToUpdate.map(ref => {
        ref.referencingField.value = newName;
        return ref;
      });
    }
  }

}

module.exports = Target;

/***/ }),

/***/ "./src/engine/thread.js":
/*!******************************!*\
  !*** ./src/engine/thread.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");
/**
 * Recycle bin for empty stackFrame objects
 * @type Array<_StackFrame>
 */


const _stackFrameFreeList = [];
/**
 * A frame used for each level of the stack. A general purpose
 * place to store a bunch of execution context and parameters
 * @param {boolean} warpMode Whether this level of the stack is warping
 * @constructor
 * @private
 */

class _StackFrame {
  constructor(warpMode) {
    /**
     * Whether this level of the stack is a loop.
     * @type {boolean}
     */
    this.isLoop = false;
    /**
     * Whether this level is in warp mode.  Is set by some legacy blocks and
     * "turbo mode"
     * @type {boolean}
     */

    this.warpMode = warpMode;
    /**
     * Reported value from just executed block.
     * @type {Any}
     */

    this.justReported = null;
    /**
     * The active block that is waiting on a promise.
     * @type {string}
     */

    this.reporting = '';
    /**
     * Persists reported inputs during async block.
     * @type {Object}
     */

    this.reported = null;
    /**
     * Name of waiting reporter.
     * @type {string}
     */

    this.waitingReporter = null;
    /**
     * Procedure parameters.
     * @type {Object}
     */

    this.params = null;
    /**
     * A context passed to block implementations.
     * @type {Object}
     */

    this.executionContext = null;
  }
  /**
   * Reset all properties of the frame to pristine null and false states.
   * Used to recycle.
   * @return {_StackFrame} this
   */


  reset() {
    this.isLoop = false;
    this.warpMode = false;
    this.justReported = null;
    this.reported = null;
    this.waitingReporter = null;
    this.params = null;
    this.executionContext = null;
    return this;
  }
  /**
   * Reuse an active stack frame in the stack.
   * @param {?boolean} warpMode defaults to current warpMode
   * @returns {_StackFrame} this
   */


  reuse() {
    let warpMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.warpMode;
    this.reset();
    this.warpMode = Boolean(warpMode);
    return this;
  }
  /**
   * Create or recycle a stack frame object.
   * @param {boolean} warpMode Enable warpMode on this frame.
   * @returns {_StackFrame} The clean stack frame with correct warpMode setting.
   */


  static create(warpMode) {
    const stackFrame = _stackFrameFreeList.pop();

    if (typeof stackFrame !== 'undefined') {
      stackFrame.warpMode = Boolean(warpMode);
      return stackFrame;
    }

    return new _StackFrame(warpMode);
  }
  /**
   * Put a stack frame object into the recycle bin for reuse.
   * @param {_StackFrame} stackFrame The frame to reset and recycle.
   */


  static release(stackFrame) {
    if (typeof stackFrame !== 'undefined') {
      _stackFrameFreeList.push(stackFrame.reset());
    }
  }

}
/**
 * A thread is a running stack context and all the metadata needed.
 * @param {?string} firstBlock First block to execute in the thread.
 * @constructor
 */


class Thread {
  constructor(firstBlock) {
    /**
     * ID of top block of the thread
     * @type {!string}
     */
    this.topBlock = firstBlock;
    /**
     * Stack for the thread. When the sequencer enters a control structure,
     * the block is pushed onto the stack so we know where to exit.
     * @type {Array.<string>}
     */

    this.stack = [];
    /**
     * Stack frames for the thread. Store metadata for the executing blocks.
     * @type {Array.<_StackFrame>}
     */

    this.stackFrames = [];
    /**
     * Status of the thread, one of three states (below)
     * @type {number}
     */

    this.status = 0;
    /* Thread.STATUS_RUNNING */

    /**
     * Whether the thread is killed in the middle of execution.
     * @type {boolean}
     */

    this.isKilled = false;
    /**
     * Target of this thread.
     * @type {?Target}
     */

    this.target = null;
    /**
     * The Blocks this thread will execute.
     * @type {Blocks}
     */

    this.blockContainer = null;
    /**
     * Whether the thread requests its script to glow during this frame.
     * @type {boolean}
     */

    this.requestScriptGlowInFrame = false;
    /**
     * Which block ID should glow during this frame, if any.
     * @type {?string}
     */

    this.blockGlowInFrame = null;
    /**
     * A timer for when the thread enters warp mode.
     * Substitutes the sequencer's count toward WORK_TIME on a per-thread basis.
     * @type {?Timer}
     */

    this.warpTimer = null;
    this.justReported = null;
    this.triedToCompile = false;
    this.isCompiled = false; // compiler data
    // these values only make sense if isCompiled == true

    this.timer = null;
    /**
     * The thread's generator.
     * @type {Generator}
     */

    this.generator = null;
    /**
     * @type {Object.<string, import('../compiler/compile').CompiledScript>}
     */

    this.procedures = null;
  }
  /**
   * Thread status for initialized or running thread.
   * This is the default state for a thread - execution should run normally,
   * stepping from block to block.
   * @const
   */


  static get STATUS_RUNNING() {
    return 0; // used by compiler
  }
  /**
   * Threads are in this state when a primitive is waiting on a promise;
   * execution is paused until the promise changes thread status.
   * @const
   */


  static get STATUS_PROMISE_WAIT() {
    return 1; // used by compiler
  }
  /**
   * Thread status for yield.
   * @const
   */


  static get STATUS_YIELD() {
    return 2; // used by compiler
  }
  /**
   * Thread status for a single-tick yield. This will be cleared when the
   * thread is resumed.
   * @const
   */


  static get STATUS_YIELD_TICK() {
    return 3; // used by compiler
  }
  /**
   * Thread status for a finished/done thread.
   * Thread is in this state when there are no more blocks to execute.
   * @const
   */


  static get STATUS_DONE() {
    return 4; // used by compiler
  }
  /**
   * @param {Target} target The target running the thread.
   * @param {string} topBlock ID of the thread's top block.
   * @returns {string} A unique ID for this target and thread.
   */


  static getIdFromTargetAndBlock(target, topBlock) {
    // & should never appear in any IDs, so we can use it as a separator
    return "".concat(target.id, "&").concat(topBlock);
  }

  getId() {
    return Thread.getIdFromTargetAndBlock(this.target, this.topBlock);
  }
  /**
   * Push stack and update stack frames appropriately.
   * @param {string} blockId Block ID to push to stack.
   */


  pushStack(blockId) {
    this.stack.push(blockId); // Push an empty stack frame, if we need one.
    // Might not, if we just popped the stack.

    if (this.stack.length > this.stackFrames.length) {
      const parent = this.stackFrames[this.stackFrames.length - 1];
      this.stackFrames.push(_StackFrame.create(typeof parent !== 'undefined' && parent.warpMode));
    }
  }
  /**
   * Reset the stack frame for use by the next block.
   * (avoids popping and re-pushing a new stack frame - keeps the warpmode the same
   * @param {string} blockId Block ID to push to stack.
   */


  reuseStackForNextBlock(blockId) {
    this.stack[this.stack.length - 1] = blockId;
    this.stackFrames[this.stackFrames.length - 1].reuse();
  }
  /**
   * Pop last block on the stack and its stack frame.
   * @return {string} Block ID popped from the stack.
   */


  popStack() {
    _StackFrame.release(this.stackFrames.pop());

    return this.stack.pop();
  }
  /**
   * Pop back down the stack frame until we hit a procedure call or the stack frame is emptied
   */


  stopThisScript() {
    let blockID = this.peekStack();

    while (blockID !== null) {
      const block = this.target.blocks.getBlock(blockID);

      if (typeof block !== 'undefined' && block.opcode === 'procedures_call') {
        break;
      }

      this.popStack();
      blockID = this.peekStack();
    }

    if (this.stack.length === 0) {
      // Clean up!
      this.requestScriptGlowInFrame = false;
      this.status = Thread.STATUS_DONE;
    }
  }
  /**
   * Get top stack item.
   * @return {?string} Block ID on top of stack.
   */


  peekStack() {
    return this.stack.length > 0 ? this.stack[this.stack.length - 1] : null;
  }
  /**
   * Get top stack frame.
   * @return {?object} Last stack frame stored on this thread.
   */


  peekStackFrame() {
    return this.stackFrames.length > 0 ? this.stackFrames[this.stackFrames.length - 1] : null;
  }
  /**
   * Get stack frame above the current top.
   * @return {?object} Second to last stack frame stored on this thread.
   */


  peekParentStackFrame() {
    return this.stackFrames.length > 1 ? this.stackFrames[this.stackFrames.length - 2] : null;
  }
  /**
   * Push a reported value to the parent of the current stack frame.
   * @param {*} value Reported value to push.
   */


  pushReportedValue(value) {
    this.justReported = typeof value === 'undefined' ? null : value;
  }
  /**
   * Initialize procedure parameters on this stack frame.
   */


  initParams() {
    const stackFrame = this.peekStackFrame();

    if (stackFrame.params === null) {
      stackFrame.params = {};
    }
  }
  /**
   * Add a parameter to the stack frame.
   * Use when calling a procedure with parameter values.
   * @param {!string} paramName Name of parameter.
   * @param {*} value Value to set for parameter.
   */


  pushParam(paramName, value) {
    const stackFrame = this.peekStackFrame();
    stackFrame.params[paramName] = value;
  }
  /**
   * Get a parameter at the lowest possible level of the stack.
   * @param {!string} paramName Name of parameter.
   * @return {*} value Value for parameter.
   */


  getParam(paramName) {
    for (let i = this.stackFrames.length - 1; i >= 0; i--) {
      const frame = this.stackFrames[i];

      if (frame.params === null) {
        continue;
      }

      if (frame.params.hasOwnProperty(paramName)) {
        return frame.params[paramName];
      }

      return null;
    }

    return null;
  }

  getAllparams() {
    const stackFrame = this.peekStackFrame();
    return stackFrame.params;
  }
  /**
   * Whether the current execution of a thread is at the top of the stack.
   * @return {boolean} True if execution is at top of the stack.
   */


  atStackTop() {
    return this.peekStack() === this.topBlock;
  }
  /**
   * Switch the thread to the next block at the current level of the stack.
   * For example, this is used in a standard sequence of blocks,
   * where execution proceeds from one block to the next.
   */


  goToNextBlock() {
    const nextBlockId = this.target.blocks.getNextBlock(this.peekStack());
    this.reuseStackForNextBlock(nextBlockId);
  }
  /**
   * Attempt to determine whether a procedure call is recursive,
   * by examining the stack.
   * @param {!string} procedureCode Procedure code of procedure being called.
   * @return {boolean} True if the call appears recursive.
   */


  isRecursiveCall(procedureCode) {
    let callCount = 5; // Max number of enclosing procedure calls to examine.

    const sp = this.stack.length - 1;

    for (let i = sp - 1; i >= 0; i--) {
      const block = this.target.blocks.getBlock(this.stack[i]);

      if (block.opcode === 'procedures_call' && block.mutation.proccode === procedureCode) {
        return true;
      }

      if (--callCount < 0) return false;
    }

    return false;
  }
  /**
   * Attempt to compile this thread.
   */


  tryCompile() {
    if (!this.blockContainer) {
      return;
    } // importing the compiler here avoids circular dependency issues


    const compile = __webpack_require__(/*! ../compiler/compile */ "./src/compiler/compile.js");

    this.triedToCompile = true;
    const topBlock = this.topBlock; // Flyout blocks are stored in a special block container.

    const blocks = this.blockContainer.getBlock(topBlock) ? this.blockContainer : this.target.runtime.flyoutBlocks;
    const cachedResult = blocks.getCachedCompileResult(topBlock); // If there is a cached error, do not attempt to recompile.

    if (cachedResult && !cachedResult.success) {
      return;
    }

    let result;

    if (cachedResult) {
      result = cachedResult.value;
    } else {
      try {
        result = compile(this);
        blocks.cacheCompileResult(topBlock, result);
      } catch (error) {
        log.error('cannot compile script', this.target.getName(), error);
        blocks.cacheCompileError(topBlock, error);
        this.target.runtime.emitCompileError(this.target, error);
        return;
      }
    }

    this.procedures = {};

    for (const procedureCode of Object.keys(result.procedures)) {
      this.procedures[procedureCode] = result.procedures[procedureCode](this);
    }

    this.generator = result.startingFunction(this)();

    if (!this.blockContainer.forceNoGlow) {
      this.blockGlowInFrame = this.topBlock;
      this.requestScriptGlowInFrame = true;
    }

    this.isCompiled = true;
  }

}

module.exports = Thread;

/***/ }),

/***/ "./src/engine/tw-frame-loop.js":
/*!*************************************!*\
  !*** ./src/engine/tw-frame-loop.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Due to the existence of features such as interpolation and "0 FPS" being treated as "screen refresh rate",
// The VM loop logic has become much more complex
// Use setTimeout to polyfill requestAnimationFrame in Node.js environments
const _requestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : f => setTimeout(f, 1000 / 60);

const _cancelAnimationFrame = typeof requestAnimationFrame === 'function' ? cancelAnimationFrame : clearTimeout;

const animationFrameWrapper = callback => {
  let id;

  const handle = () => {
    id = _requestAnimationFrame(handle);
    callback();
  };

  const cancel = () => _cancelAnimationFrame(id);

  id = _requestAnimationFrame(handle);
  return {
    cancel
  };
};

class FrameLoop {
  constructor(runtime) {
    this.runtime = runtime;
    this.running = false;
    this.setFramerate(30);
    this.setInterpolation(false);
    this.stepCallback = this.stepCallback.bind(this);
    this.interpolationCallback = this.interpolationCallback.bind(this);
    this._stepInterval = null;
    this._interpolationAnimation = null;
    this._stepAnimation = null;
  }

  setFramerate(fps) {
    this.framerate = fps;

    this._restart();
  }

  setInterpolation(interpolation) {
    this.interpolation = interpolation;

    this._restart();
  }

  stepCallback() {
    this.runtime._step();
  }

  interpolationCallback() {
    this.runtime._renderInterpolatedPositions();
  }

  _restart() {
    if (this.running) {
      this.stop();
      this.start();
    }
  }

  start() {
    this.running = true;

    if (this.framerate === 0) {
      this._stepAnimation = animationFrameWrapper(this.stepCallback);
      this.runtime.currentStepTime = 1000 / 60;
    } else {
      // Interpolation should never be enabled when framerate === 0 as that's just redundant
      if (this.interpolation) {
        this._interpolationAnimation = animationFrameWrapper(this.interpolationCallback);
      }

      this._stepInterval = setInterval(this.stepCallback, 1000 / this.framerate);
      this.runtime.currentStepTime = 1000 / this.framerate;
    }
  }

  stop() {
    this.running = false;
    clearInterval(this._stepInterval);

    if (this._interpolationAnimation) {
      this._interpolationAnimation.cancel();
    }

    if (this._stepAnimation) {
      this._stepAnimation.cancel();
    }

    this._interpolationAnimation = null;
    this._stepAnimation = null;
  }

}

module.exports = FrameLoop;

/***/ }),

/***/ "./src/engine/tw-interpolate.js":
/*!**************************************!*\
  !*** ./src/engine/tw-interpolate.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Prepare the targets of a runtime for interpolation.
 * @param {Runtime} runtime The Runtime with targets to prepare for interpolation.
 */
const setupInitialState = runtime => {
  const renderer = runtime.renderer;

  for (const target of runtime.targets) {
    const directionAndScale = target._getRenderedDirectionAndScale(); // If sprite may have been interpolated in the previous frame, reset its renderer state.


    if (renderer && target.interpolationData) {
      const drawableID = target.drawableID;
      renderer.updateDrawablePosition(drawableID, [target.x, target.y]);
      renderer.updateDrawableDirectionScale(drawableID, directionAndScale.direction, directionAndScale.scale);
      renderer.updateDrawableEffect(drawableID, 'ghost', target.effects.ghost);
    }

    if (target.visible && !target.isStage) {
      target.interpolationData = {
        x: target.x,
        y: target.y,
        direction: directionAndScale.direction,
        scale: directionAndScale.scale,
        costume: target.currentCostume,
        ghost: target.effects.ghost
      };
    } else {
      target.interpolationData = null;
    }
  }
};
/**
 * Interpolate the position of targets.
 * @param {Runtime} runtime The Runtime with targets to interpolate.
 * @param {number} time Relative time in the frame in [0-1].
 */


const interpolate = (runtime, time) => {
  const renderer = runtime.renderer;

  if (!renderer) {
    return;
  }

  for (const target of runtime.targets) {
    // interpolationData is the initial state at the start of the frame (time 0)
    // the state on the target itself is the state at the end of the frame (time 1)
    const interpolationData = target.interpolationData;

    if (!interpolationData) {
      continue;
    } // Don't waste time interpolating sprites that are hidden.


    if (!target.visible) {
      continue;
    }

    const drawableID = target.drawableID; // Position interpolation.

    const xDistance = target.x - interpolationData.x;
    const yDistance = target.y - interpolationData.y;
    const absoluteXDistance = Math.abs(xDistance);
    const absoluteYDistance = Math.abs(yDistance);

    if (absoluteXDistance > 0.1 || absoluteYDistance > 0.1) {
      const drawable = renderer._allDrawables[drawableID]; // Large movements are likely intended to be instantaneous.
      // getAABB is less accurate than getBounds, but it's much faster

      const bounds = drawable.getAABB();
      const tolerance = Math.min(240, Math.max(50, 1.5 * (bounds.width + bounds.height)));
      const distance = Math.sqrt(absoluteXDistance ** 2 + absoluteYDistance ** 2);

      if (distance < tolerance) {
        const newX = interpolationData.x + xDistance * time;
        const newY = interpolationData.y + yDistance * time;
        renderer.updateDrawablePosition(drawableID, [newX, newY]);
      }
    } // Effect interpolation.


    const ghostChange = target.effects.ghost - interpolationData.ghost;
    const absoluteGhostChange = Math.abs(ghostChange); // Large changes are likely intended to be instantaneous.

    if (absoluteGhostChange > 0 && absoluteGhostChange < 25) {
      const newGhost = target.effects.ghost + ghostChange * time;
      renderer.updateDrawableEffect(drawableID, 'ghost', newGhost);
    } // Interpolate scale and direction.


    const costumeUnchanged = interpolationData.costume === target.currentCostume;

    if (costumeUnchanged) {
      let {
        direction,
        scale
      } = target._getRenderedDirectionAndScale();

      let updateDrawableDirectionScale = false; // Interpolate direction.

      if (direction !== interpolationData.direction) {
        // Perfect 90 degree angles should not be interpolated.
        // eg. the foreground tile clones in https://scratch.mit.edu/projects/60917032/
        if (direction % 90 !== 0 || interpolationData.direction % 90 !== 0) {
          const currentRadians = direction * Math.PI / 180;
          const startingRadians = interpolationData.direction * Math.PI / 180;
          direction = Math.atan2(Math.sin(currentRadians) * time + Math.sin(startingRadians) * (1 - time), Math.cos(currentRadians) * time + Math.cos(startingRadians) * (1 - time)) * 180 / Math.PI;
          updateDrawableDirectionScale = true;
        }
      } // Interpolate scale.


      const startingScale = interpolationData.scale;

      if (scale[0] !== startingScale[0] || scale[1] !== startingScale[1]) {
        // Do not interpolate size when the sign of either scale differs.
        if (Math.sign(scale[0]) === Math.sign(startingScale[0]) && Math.sign(scale[1]) === Math.sign(startingScale[1])) {
          const changeX = scale[0] - startingScale[0];
          const changeY = scale[1] - startingScale[1];
          const absoluteChangeX = Math.abs(changeX);
          const absoluteChangeY = Math.abs(changeY); // Large changes are likely intended to be instantaneous.

          if (absoluteChangeX < 100 && absoluteChangeY < 100) {
            scale[0] = startingScale[0] + changeX * time;
            scale[1] = startingScale[1] + changeY * time;
            updateDrawableDirectionScale = true;
          }
        }
      }

      if (updateDrawableDirectionScale) {
        renderer.updateDrawableDirectionScale(drawableID, direction, scale);
      }
    }
  }
};

module.exports = {
  setupInitialState,
  interpolate
};

/***/ }),

/***/ "./src/engine/variable.js":
/*!********************************!*\
  !*** ./src/engine/variable.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview
 * Object representing a Scratch variable.
 */
const uid = __webpack_require__(/*! ../util/uid */ "./src/util/uid.js");

const xmlEscape = __webpack_require__(/*! ../util/xml-escape */ "./src/util/xml-escape.js");

class Variable {
  /**
   * @param {string} id Id of the variable.
   * @param {string} name Name of the variable.
   * @param {string} type Type of the variable, one of '' or 'list'
   * @param {boolean} isCloud Whether the variable is stored in the cloud.
   * @constructor
   */
  constructor(id, name, type, isCloud) {
    this.id = id || uid();
    this.name = name;
    this.type = type;
    this.isCloud = isCloud;

    switch (this.type) {
      case Variable.SCALAR_TYPE:
        this.value = 0;
        break;

      case Variable.LIST_TYPE:
        this.value = [];
        break;

      case Variable.BROADCAST_MESSAGE_TYPE:
        this.value = this.name;
        break;

      default:
        throw new Error("Invalid variable type: ".concat(this.type));
    }
  }

  toXML(isLocal) {
    isLocal = isLocal === true;
    return "<variable type=\"".concat(this.type, "\" id=\"").concat(this.id, "\" islocal=\"").concat(isLocal, "\" iscloud=\"").concat(this.isCloud, "\">").concat(xmlEscape(this.name), "</variable>");
  }
  /**
   * Type representation for scalar variables.
   * This is currently represented as ''
   * for compatibility with blockly.
   * @const {string}
   */


  static get SCALAR_TYPE() {
    return ''; // used by compiler
  }
  /**
   * Type representation for list variables.
   * @const {string}
   */


  static get LIST_TYPE() {
    return 'list'; // used by compiler
  }
  /**
   * Type representation for list variables.
   * @const {string}
   */


  static get BROADCAST_MESSAGE_TYPE() {
    return 'broadcast_msg';
  }

}

module.exports = Variable;

/***/ }),

/***/ "./src/extension-support/argument-type.js":
/*!************************************************!*\
  !*** ./src/extension-support/argument-type.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Block argument types
 * @enum {string}
 */
const ArgumentType = {
  /**
   * Numeric value with angle picker
   */
  ANGLE: 'angle',

  /**
   * Boolean value with hexagonal placeholder
   */
  BOOLEAN: 'Boolean',

  /**
   * Numeric value with color picker
   */
  COLOR: 'color',

  /**
   * Numeric value with text field
   */
  NUMBER: 'number',

  /**
   * String value with text field
   */
  STRING: 'string',

  /**
   * String value with matrix field
   */
  MATRIX: 'matrix',

  /**
   * MIDI note number with note picker (piano) field
   */
  NOTE: 'note',

  /**
   * Inline image on block (as part of the label)
   */
  IMAGE: 'image'
};
module.exports = ArgumentType;

/***/ }),

/***/ "./src/extension-support/block-type.js":
/*!*********************************************!*\
  !*** ./src/extension-support/block-type.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Types of block
 * @enum {string}
 */
const BlockType = {
  /**
   * Boolean reporter with hexagonal shape
   */
  BOOLEAN: 'Boolean',

  /**
   * A button (not an actual block) for some special action, like making a variable
   */
  BUTTON: 'button',

  /**
   * Command block
   */
  COMMAND: 'command',

  /**
   * Specialized command block which may or may not run a child branch
   * The thread continues with the next block whether or not a child branch ran.
   */
  CONDITIONAL: 'conditional',

  /**
   * Specialized hat block with no implementation function
   * This stack only runs if the corresponding event is emitted by other code.
   */
  EVENT: 'event',

  /**
   * Hat block which conditionally starts a block stack
   */
  HAT: 'hat',

  /**
   * Specialized command block which may or may not run a child branch
   * If a child branch runs, the thread evaluates the loop block again.
   */
  LOOP: 'loop',

  /**
   * General reporter with numeric or string value
   */
  REPORTER: 'reporter'
};
module.exports = BlockType;

/***/ }),

/***/ "./src/extension-support/extension-manager.js":
/*!****************************************************!*\
  !*** ./src/extension-support/extension-manager.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const dispatch = __webpack_require__(/*! ../dispatch/central-dispatch */ "./src/dispatch/central-dispatch.js");

const jwUnite = __webpack_require__(/*! ../extensions/jw_unite */ "./src/extensions/jw_unite/index.js");

const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");

const maybeFormatMessage = __webpack_require__(/*! ../util/maybe-format-message */ "./src/util/maybe-format-message.js");

const BlockType = __webpack_require__(/*! ./block-type */ "./src/extension-support/block-type.js"); // These extensions are currently built into the VM repository but should not be loaded at startup.
// TODO: move these out into a separate repository?
// TODO: change extension spec so that library info, including extension ID, can be collected through static methods


const builtinExtensions = {
  // This is an example that isn't loaded with the other core blocks,
  // but serves as a reference for loading core blocks as extensions.
  coreExample: () => __webpack_require__(/*! ../blocks/scratch3_core_example */ "./src/blocks/scratch3_core_example.js"),
  // These are the non-core built-in extensions.
  pen: () => __webpack_require__(/*! ../extensions/scratch3_pen */ "./src/extensions/scratch3_pen/index.js"),
  wedo2: () => __webpack_require__(/*! ../extensions/scratch3_wedo2 */ "./src/extensions/scratch3_wedo2/index.js"),
  music: () => __webpack_require__(/*! ../extensions/scratch3_music */ "./src/extensions/scratch3_music/index.js"),
  microbit: () => __webpack_require__(/*! ../extensions/scratch3_microbit */ "./src/extensions/scratch3_microbit/index.js"),
  text2speech: () => __webpack_require__(/*! ../extensions/scratch3_text2speech */ "./src/extensions/scratch3_text2speech/index.js"),
  translate: () => __webpack_require__(/*! ../extensions/scratch3_translate */ "./src/extensions/scratch3_translate/index.js"),
  videoSensing: () => __webpack_require__(/*! ../extensions/scratch3_video_sensing */ "./src/extensions/scratch3_video_sensing/index.js"),
  ev3: () => __webpack_require__(/*! ../extensions/scratch3_ev3 */ "./src/extensions/scratch3_ev3/index.js"),
  makeymakey: () => __webpack_require__(/*! ../extensions/scratch3_makeymakey */ "./src/extensions/scratch3_makeymakey/index.js"),
  boost: () => __webpack_require__(/*! ../extensions/scratch3_boost */ "./src/extensions/scratch3_boost/index.js"),
  gdxfor: () => __webpack_require__(/*! ../extensions/scratch3_gdx_for */ "./src/extensions/scratch3_gdx_for/index.js"),
  // tw: core extension
  tw: () => __webpack_require__(/*! ../extensions/tw */ "./src/extensions/tw/index.js"),
  // jg: jeremyes esxsitenisonsnsn
  // jgFiles: support for reading user files
  jgFiles: () => __webpack_require__(/*! ../extensions/jg_files */ "./src/extensions/jg_files/index.js"),
  // jgWebsiteRequests: fetch GET and POST requests to apis & websites
  jgWebsiteRequests: () => __webpack_require__(/*! ../extensions/jg_websiteRequests */ "./src/extensions/jg_websiteRequests/index.js"),
  // jgJSON: handle JSON objects
  jgJSON: () => __webpack_require__(/*! ../extensions/jg_json */ "./src/extensions/jg_json/index.js"),
  // jgRuntime: edit stage and other stuff
  jgRuntime: () => __webpack_require__(/*! ../extensions/jg_runtime */ "./src/extensions/jg_runtime/index.js"),
  // jgPrism: blocks for specific use cases or major convenience
  jgPrism: () => __webpack_require__(/*! ../extensions/jg_prism */ "./src/extensions/jg_prism/index.js"),
  // jw: hello it is i jwklong
  // jwUnite: literal features that should of been added in the first place
  jwUnite: () => __webpack_require__(/*! ../extensions/jw_unite */ "./src/extensions/jw_unite/index.js"),
  // griffpatch: *silence*
  griffpatch: () => __webpack_require__(/*! ../extensions/griffpatch_box2d */ "./src/extensions/griffpatch_box2d/index.js") //fresh_js: some js blocks i made like alert,prompt,confirm

}; // CCW limited

const injectExtensions = {};
/**
 * @typedef {object} ArgumentInfo - Information about an extension block argument
 * @property {ArgumentType} type - the type of value this argument can take
 * @property {*|undefined} default - the default value of this argument (default: blank)
 */

/**
 * @typedef {object} ConvertedBlockInfo - Raw extension block data paired with processed data ready for scratch-blocks
 * @property {ExtensionBlockMetadata} info - the raw block info
 * @property {object} json - the scratch-blocks JSON definition for this block
 * @property {string} xml - the scratch-blocks XML definition for this block
 */

/**
 * @typedef {object} CategoryInfo - Information about a block category
 * @property {string} id - the unique ID of this category
 * @property {string} name - the human-readable name of this category
 * @property {string|undefined} blockIconURI - optional URI for the block icon image
 * @property {string} color1 - the primary color for this category, in '#rrggbb' format
 * @property {string} color2 - the secondary color for this category, in '#rrggbb' format
 * @property {string} color3 - the tertiary color for this category, in '#rrggbb' format
 * @property {Array.<ConvertedBlockInfo>} blocks - the blocks, separators, etc. in this category
 * @property {Array.<object>} menus - the menus provided by this category
 */

/**
 * @typedef {object} PendingExtensionWorker - Information about an extension worker still initializing
 * @property {string} extensionURL - the URL of the extension to be loaded by this worker
 * @property {Function} resolve - function to call on successful worker startup
 * @property {Function} reject - function to call on failed worker startup
 */

const createExtensionService = extensionManager => {
  const service = {};
  service.registerExtensionServiceSync = extensionManager.registerExtensionServiceSync.bind(extensionManager);
  service.allocateWorker = extensionManager.allocateWorker.bind(extensionManager);
  service.onWorkerInit = extensionManager.onWorkerInit.bind(extensionManager);
  service.registerExtensionService = extensionManager.registerExtensionService.bind(extensionManager);
  return service;
};

class ExtensionManager {
  constructor(runtime) {
    /**
     * The ID number to provide to the next extension worker.
     * @type {int}
     */
    this.nextExtensionWorker = 0;
    /**
     * FIFO queue of extensions which have been requested but not yet loaded in a worker,
     * along with promise resolution functions to call once the worker is ready or failed.
     *
     * @type {Array.<PendingExtensionWorker>}
     */

    this.pendingExtensions = [];
    /**
     * Map of worker ID to workers which have been allocated but have not yet finished initialization.
     * @type {Array.<PendingExtensionWorker>}
     */

    this.pendingWorkers = [];
    /**
     * Set of loaded extension URLs/IDs (equivalent for built-in extensions).
     * @type {Set.<string>}
     * @private
     */

    this._loadedExtensions = new Map();
    /**
     * Controls how remote custom extensions are loaded.
     * One of the strings:
     *  - "worker" (default)
     *  - "iframe"
     */

    this.workerMode = 'worker';
    /**
     * Keep a reference to the runtime so we can construct internal extension objects.
     * TODO: remove this in favor of extensions accessing the runtime as a service.
     * @type {Runtime}
     */

    this.runtime = runtime;
    this.loadingAsyncExtensions = 0;
    this.asyncExtensionsLoadedCallbacks = [];
    dispatch.setService('extensions', createExtensionService(this)).catch(e => {
      log.error("ExtensionManager was unable to register extension service: ".concat(JSON.stringify(e)));
    });
  }
  /**
   * Check whether an extension is registered or is in the process of loading. This is intended to control loading or
   * adding extensions so it may return `true` before the extension is ready to be used. Use the promise returned by
   * `loadExtensionURL` if you need to wait until the extension is truly ready.
   * @param {string} extensionID - the ID of the extension.
   * @returns {boolean} - true if loaded, false otherwise.
   */


  isExtensionLoaded(extensionID) {
    return this._loadedExtensions.has(extensionID);
  }
  /**
   * Synchronously load an internal extension (core or non-core) by ID. This call will
   * fail if the provided id is not does not match an internal extension.
   * @param {string} extensionId - the ID of an internal extension
   */


  loadExtensionIdSync(extensionId) {
    if (!builtinExtensions.hasOwnProperty(extensionId)) {
      log.warn("Could not find extension ".concat(extensionId, " in the built in extensions."));
      return;
    }
    /** @TODO dupe handling for non-builtin extensions. See commit 670e51d33580e8a2e852b3b038bb3afc282f81b9 */


    if (this.isExtensionLoaded(extensionId)) {
      const message = "Rejecting attempt to load a second extension with ID ".concat(extensionId);
      log.warn(message);
      return;
    }

    const extension = (builtinExtensions[extensionURL] || injectExtensions[extensionURL])();
    const extensionInstance = new extension(this.runtime);

    const serviceName = this._registerInternalExtension(extensionInstance);

    this._loadedExtensions.set(extensionId, serviceName);

    this.runtime.compilerRegisterExtension(extensionId, extensionInstance);
  }
  /**
   * Load an extension by URL or internal extension ID
   * @param {string} extensionURL - the URL for the extension to load OR the ID of an internal extension
   * @returns {Promise} resolved once the extension is loaded and initialized or rejected on failure
   */


  loadExtensionURL(extensionURL) {
    if (builtinExtensions.hasOwnProperty(extensionURL) || injectExtensions.hasOwnProperty(extensionURL)) {
      /** @TODO dupe handling for non-builtin extensions. See commit 670e51d33580e8a2e852b3b038bb3afc282f81b9 */
      if (this.isExtensionLoaded(extensionURL)) {
        const message = "Rejecting attempt to load a second extension with ID ".concat(extensionURL);
        log.warn(message);
        return Promise.resolve();
      }

      const extension = builtinExtensions[extensionURL]();
      const extensionInstance = new extension(this.runtime);

      const serviceName = this._registerInternalExtension(extensionInstance);

      this._loadedExtensions.set(extensionURL, serviceName);

      this.runtime.compilerRegisterExtension(extensionURL, extensionInstance);
      return Promise.resolve();
    }
    /*
    this.loadingAsyncExtensions++;
    
    return new Promise((resolve, reject) => {
        this.pendingExtensions.push({extensionURL, resolve, reject});
        this.createExtensionWorker()
            .then(worker => dispatch.addWorker(worker))
            .catch(error => reject(error));
    });
    */


    this.runtime.emit('EXTENSION_DATA_LOADING', true);
    return this.runtime.loadOnlineExtensionsLibrary() // ccw remote extensions library
    .then(lib => lib.default()).then((_ref) => {
      let {
        default: remoteExtensions
      } = _ref;
      const remoteExtensionConfig = remoteExtensions[extensionURL];

      if (remoteExtensionConfig && remoteExtensionConfig.Extension) {
        return remoteExtensionConfig.Extension().then((_ref2) => {
          let {
            default: remoteExtension
          } = _ref2;
          const extensionInstance = new remoteExtension(this.runtime);

          const serviceName = this._registerInternalExtension(extensionInstance);

          this._loadedExtensions.set(extensionURL, serviceName);

          return Promise.resolve();
        });
      } // eslint-disable-next-line no-console


      log.warn("ccw: [".concat(extensionURL, "] not found in remote extensions library,try load as URL"));
      this.runtime.emit('EXTENSION_NOT_FOUND', extensionURL); // TW

      this.loadingAsyncExtensions++;
      return new Promise((resolve, reject) => {
        this.pendingExtensions.push({
          extensionURL,
          resolve,
          reject
        });
        this.createExtensionWorker().then(worker => dispatch.addWorker(worker)).catch(error => reject(error));
      }); // original
      // return new Promise((resolve, reject) => {
      //     // If we `require` this at the global level it breaks non-webpack targets, including tests
      //     const ExtensionWorker = require('worker-loader?name=extension-worker.js!./extension-worker');
      //     this.pendingExtensions.push({
      //         extensionURL,
      //         resolve,
      //         reject
      //     });
      //     dispatch.addWorker(new ExtensionWorker());
      // });
    }).finally(() => {
      this.runtime.emit('EXTENSION_DATA_LOADING', false); // ccw end loading remote extension event
    });
  }
  /**
   * Wait until all async extensions have loaded
   * @returns {Promise} resolved when all async extensions have loaded
   */


  allAsyncExtensionsLoaded() {
    if (this.loadingAsyncExtensions === 0) {
      return;
    }

    return new Promise(resolve => {
      this.asyncExtensionsLoadedCallbacks.push(resolve);
    });
  }
  /**
   * Creates a new extension worker.
   * @returns {Promise}
   */


  createExtensionWorker() {
    if (this.workerMode === 'worker') {
      // eslint-disable-next-line max-len
      const ExtensionWorker = __webpack_require__(/*! worker-loader?name=js/extension-worker/extension-worker.[hash].js!./extension-worker */ "./node_modules/worker-loader/dist/cjs.js?name=js/extension-worker/extension-worker.[hash].js!./src/extension-support/extension-worker.js");

      return Promise.resolve(new ExtensionWorker());
    } else if (this.workerMode === 'iframe') {
      return __webpack_require__.e(/*! import() | iframe-extension-worker */ "iframe-extension-worker").then(__webpack_require__.t.bind(null, /*! ./tw-iframe-extension-worker */ "./src/extension-support/tw-iframe-extension-worker.js", 7)).then(mod => new mod.default());
    }

    return Promise.reject(new Error('Unknown extension worker mode'));
  }
  /**
   * Regenerate blockinfo for any loaded extensions
   * @returns {Promise} resolved once all the extensions have been reinitialized
   */


  refreshBlocks() {
    const allPromises = Array.from(this._loadedExtensions.values()).map(serviceName => dispatch.call(serviceName, 'getInfo').then(info => {
      info = this._prepareExtensionInfo(serviceName, info);
      dispatch.call('runtime', '_refreshExtensionPrimitives', info);
    }).catch(e => {
      log.error("Failed to refresh built-in extension primitives: ".concat(JSON.stringify(e)));
    }));
    return Promise.all(allPromises);
  }

  allocateWorker() {
    const id = this.nextExtensionWorker++;
    const workerInfo = this.pendingExtensions.shift();
    this.pendingWorkers[id] = workerInfo;
    return [id, workerInfo.extensionURL];
  }
  /**
   * Synchronously collect extension metadata from the specified service and begin the extension registration process.
   * @param {string} serviceName - the name of the service hosting the extension.
   */


  registerExtensionServiceSync(serviceName) {
    const info = dispatch.callSync(serviceName, 'getInfo');

    this._registerExtensionInfo(serviceName, info);
  }
  /**
   * Collect extension metadata from the specified service and begin the extension registration process.
   * @param {string} serviceName - the name of the service hosting the extension.
   */


  registerExtensionService(serviceName) {
    dispatch.call(serviceName, 'getInfo').then(info => {
      this._loadedExtensions.set(info.id, serviceName);

      this._registerExtensionInfo(serviceName, info);

      this.loadingAsyncExtensions--;

      if (this.loadingAsyncExtensions === 0) {
        this.asyncExtensionsLoadedCallbacks.forEach(i => i());
        this.asyncExtensionsLoadedCallbacks = [];
      }
    });
  }
  /**
   * Called by an extension worker to indicate that the worker has finished initialization.
   * @param {int} id - the worker ID.
   * @param {*?} e - the error encountered during initialization, if any.
   */


  onWorkerInit(id, e) {
    const workerInfo = this.pendingWorkers[id];
    delete this.pendingWorkers[id];

    if (e) {
      workerInfo.reject(e);
    } else {
      workerInfo.resolve(id);
    }
  }
  /**
   * Register an internal (non-Worker) extension object
   * @param {object} extensionObject - the extension object to register
   * @returns {string} The name of the registered extension service
   */


  _registerInternalExtension(extensionObject) {
    const extensionInfo = extensionObject.getInfo();
    const fakeWorkerId = this.nextExtensionWorker++;
    const serviceName = "extension_".concat(fakeWorkerId, "_").concat(extensionInfo.id);
    dispatch.setServiceSync(serviceName, extensionObject);
    dispatch.callSync('extensions', 'registerExtensionServiceSync', serviceName);
    return serviceName;
  }
  /**
   * Sanitize extension info then register its primitives with the VM.
   * @param {string} serviceName - the name of the service hosting the extension
   * @param {ExtensionInfo} extensionInfo - the extension's metadata
   * @private
   */


  _registerExtensionInfo(serviceName, extensionInfo) {
    extensionInfo = this._prepareExtensionInfo(serviceName, extensionInfo);
    dispatch.call('runtime', '_registerExtensionPrimitives', extensionInfo).catch(e => {
      log.error("Failed to register primitives for extension on service ".concat(serviceName, ":"), e);
    });
  }
  /**
   * Modify the provided text as necessary to ensure that it may be used as an attribute value in valid XML.
   * @param {string} text - the text to be sanitized
   * @returns {string} - the sanitized text
   * @private
   */


  _sanitizeID(text) {
    return text.toString().replace(/[<"&]/, '_');
  }
  /**
   * Apply minor cleanup and defaults for optional extension fields.
   * TODO: make the ID unique in cases where two copies of the same extension are loaded.
   * @param {string} serviceName - the name of the service hosting this extension block
   * @param {ExtensionInfo} extensionInfo - the extension info to be sanitized
   * @returns {ExtensionInfo} - a new extension info object with cleaned-up values
   * @private
   */


  _prepareExtensionInfo(serviceName, extensionInfo) {
    extensionInfo = Object.assign({}, extensionInfo);

    if (!/^[a-z0-9]+$/i.test(extensionInfo.id)) {
      throw new Error('Invalid extension id');
    }

    extensionInfo.name = extensionInfo.name || extensionInfo.id;
    extensionInfo.blocks = extensionInfo.blocks || [];
    extensionInfo.targetTypes = extensionInfo.targetTypes || [];
    extensionInfo.blocks = extensionInfo.blocks.reduce((results, blockInfo) => {
      try {
        let result;

        switch (blockInfo) {
          case '---':
            // separator
            result = '---';
            break;

          default:
            // an ExtensionBlockMetadata object
            // See https://github.com/CCW-Site/ccw-user-extension/blob/b534ce02b39a3e20c63f3a6c7485ef5429b375d8/Arkos/project.js#L198
            if (typeof blockInfo === 'string' && blockInfo.startsWith('---')) {
              result = blockInfo;
              break;
            }

            result = this._prepareBlockInfo(serviceName, blockInfo);
            break;
        }

        results.push(result);
      } catch (e) {
        // TODO: more meaningful error reporting
        log.error("Error processing block: ".concat(e.message, ", Block:\n").concat(JSON.stringify(blockInfo)));
      }

      return results;
    }, []);
    extensionInfo.menus = extensionInfo.menus || {};
    extensionInfo.menus = this._prepareMenuInfo(serviceName, extensionInfo.menus);
    return extensionInfo;
  }
  /**
   * Prepare extension menus. e.g. setup binding for dynamic menu functions.
   * @param {string} serviceName - the name of the service hosting this extension block
   * @param {Array.<MenuInfo>} menus - the menu defined by the extension.
   * @returns {Array.<MenuInfo>} - a menuInfo object with all preprocessing done.
   * @private
   */


  _prepareMenuInfo(serviceName, menus) {
    const menuNames = Object.getOwnPropertyNames(menus);

    for (let i = 0; i < menuNames.length; i++) {
      const menuName = menuNames[i];
      let menuInfo = menus[menuName]; // If the menu description is in short form (items only) then normalize it to general form: an object with
      // its items listed in an `items` property.

      if (!menuInfo.items) {
        menuInfo = {
          items: menuInfo
        };
        menus[menuName] = menuInfo;
      } // If `items` is a string, it should be the name of a function in the extension object. Calling the
      // function should return an array of items to populate the menu when it is opened.


      if (typeof menuInfo.items === 'string') {
        const menuItemFunctionName = menuInfo.items;
        const serviceObject = dispatch.services[serviceName]; // Bind the function here so we can pass a simple item generation function to Scratch Blocks later.

        menuInfo.items = this._getExtensionMenuItems.bind(this, serviceObject, menuItemFunctionName);
      }
    }

    return menus;
  }
  /**
   * Fetch the items for a particular extension menu, providing the target ID for context.
   * @param {object} extensionObject - the extension object providing the menu.
   * @param {string} menuItemFunctionName - the name of the menu function to call.
   * @returns {Array} menu items ready for scratch-blocks.
   * @private
   */


  _getExtensionMenuItems(extensionObject, menuItemFunctionName) {
    // Fetch the items appropriate for the target currently being edited. This assumes that menus only
    // collect items when opened by the user while editing a particular target.
    const editingTarget = this.runtime.getEditingTarget() || this.runtime.getTargetForStage();
    const editingTargetID = editingTarget ? editingTarget.id : null;
    const extensionMessageContext = this.runtime.makeMessageContextForTarget(editingTarget); // TODO: Fix this to use dispatch.call when extensions are running in workers.

    const menuFunc = extensionObject[menuItemFunctionName];
    const menuItems = menuFunc.call(extensionObject, editingTargetID).map(item => {
      item = maybeFormatMessage(item, extensionMessageContext);

      switch (typeof item) {
        case 'object':
          return [maybeFormatMessage(item.text, extensionMessageContext), item.value];

        case 'string':
          return [item, item];

        default:
          return item;
      }
    });

    if (!menuItems || menuItems.length < 1) {
      throw new Error("Extension menu returned no items: ".concat(menuItemFunctionName));
    }

    return menuItems;
  }
  /**
   * Apply defaults for optional block fields.
   * @param {string} serviceName - the name of the service hosting this extension block
   * @param {ExtensionBlockMetadata} blockInfo - the block info from the extension
   * @returns {ExtensionBlockMetadata} - a new block info object which has values for all relevant optional fields.
   * @private
   */


  _prepareBlockInfo(serviceName, blockInfo) {
    blockInfo = Object.assign({}, {
      blockType: BlockType.COMMAND,
      terminal: false,
      blockAllThreads: false,
      arguments: {}
    }, blockInfo);
    blockInfo.opcode = blockInfo.opcode && this._sanitizeID(blockInfo.opcode);
    blockInfo.text = blockInfo.text || blockInfo.opcode;

    switch (blockInfo.blockType) {
      case BlockType.EVENT:
        if (blockInfo.func) {
          log.warn("Ignoring function \"".concat(blockInfo.func, "\" for event block ").concat(blockInfo.opcode));
        }

        break;

      case BlockType.BUTTON:
        if (blockInfo.opcode) {
          log.warn("Ignoring opcode \"".concat(blockInfo.opcode, "\" for button with text: ").concat(blockInfo.text));
        }

        break;

      default:
        {
          if (!blockInfo.opcode) {
            throw new Error('Missing opcode for block');
          }

          const funcName = blockInfo.func ? this._sanitizeID(blockInfo.func) : blockInfo.opcode;
          const getBlockInfo = blockInfo.isDynamic ? args => args && args.mutation && args.mutation.blockInfo : () => blockInfo;

          const callBlockFunc = (() => {
            if (dispatch._isRemoteService(serviceName)) {
              return (args, util, realBlockInfo) => dispatch.call(serviceName, funcName, args, util, realBlockInfo).then(result => {
                // Scratch is only designed to handle these types.
                // If any other value comes in such as undefined, null, an object, etc.
                // we'll convert it to a string to avoid undefined behavior.
                if (typeof result === 'number' || typeof result === 'string' || typeof result === 'boolean') {
                  return result;
                }

                return "".concat(result);
              }) // When an error happens, instead of returning undefined, we'll return a stringified
              // version of the error so that it can be debugged.
              .catch(err => {
                // We want the full error including stack to be printed but the log helper
                // messes with that.
                // eslint-disable-next-line no-console
                console.error('Custom extension block error', err);
                return "".concat(err);
              });
            } // avoid promise latency if we can call direct


            const serviceObject = dispatch.services[serviceName];

            if (!serviceObject[funcName]) {
              // The function might show up later as a dynamic property of the service object
              log.warn("Could not find extension block function called ".concat(funcName));
            }

            return (args, util, realBlockInfo) => serviceObject[funcName](args, util, realBlockInfo);
          })();

          blockInfo.func = (args, util) => {
            const realBlockInfo = getBlockInfo(args); // TODO: filter args using the keys of realBlockInfo.arguments? maybe only if sandboxed?

            return callBlockFunc(args, util, realBlockInfo);
          };

          break;
        }
    }

    return blockInfo;
  } // CCW Limited


  injectExtension(extensionId, extension) {
    if (builtinExtensions.hasOwnProperty(extensionId) || injectExtensions.hasOwnProperty(extensionId)) {
      log.warn("".concat(extensionId, " existed, replace it."));
    }

    injectExtensions[extensionId] = () => extension;
  }

}

module.exports = ExtensionManager;

/***/ }),

/***/ "./src/extension-support/target-type.js":
/*!**********************************************!*\
  !*** ./src/extension-support/target-type.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Default types of Target supported by the VM
 * @enum {string}
 */
const TargetType = {
  /**
   * Rendered target which can move, change costumes, etc.
   */
  SPRITE: 'sprite',

  /**
   * Rendered target which cannot move but can change backdrops
   */
  STAGE: 'stage'
};
module.exports = TargetType;

/***/ }),

/***/ "./src/extension-support/tw-scratchx-utilities.js":
/*!********************************************************!*\
  !*** ./src/extension-support/tw-scratchx-utilities.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @fileoverview
 * General ScratchX-related utilities used in multiple places.
 * Changing these functions may break projects.
 */

/**
 * @param {string} scratchXName
 * @returns {string}
 */
const generateExtensionId = scratchXName => {
  const sanitizedName = scratchXName.replace(/[^a-z0-9]/gi, '').toLowerCase();
  return "sbx".concat(sanitizedName);
};
/**
 * @param {number} i 0-indexed index of argument in list
 * @returns {string} Scratch 3 argument name
 */


const argumentIndexToId = i => i.toString();

module.exports = {
  generateExtensionId,
  argumentIndexToId
};

/***/ }),

/***/ "./src/extensions/griffpatch_box2d/box2d_es6.js":
/*!******************************************************!*\
  !*** ./src/extensions/griffpatch_box2d/box2d_es6.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
* Copyright (c) 2006-2007 Erin Catto http://www.gphysics.com
*
* This software is provided 'as-is', without any express or implied
* warranty.  In no event will the authors be held liable for any damages
* arising from the use of this software.
* Permission is granted to anyone to use this software for any purpose,
* including commercial applications, and to alter it and redistribute it
* freely, subject to the following restrictions:
* 1. The origin of this software must not be misrepresented; you must not
* claim that you wrote the original software. If you use this software
* in a product, an acknowledgment in the product documentation would be
* appreciated but is not required.
* 2. Altered source versions must be plainly marked as such, and must not be
* misrepresented as being the original software.
* 3. This notice may not be removed or altered from any source distribution.
*/


var Box2D = {};

(function (a2j, undefined) {
  function emptyFn() {}

  ;

  a2j.inherit = function (cls, base) {
    var tmpCtr = cls;
    emptyFn.prototype = base.prototype;
    cls.prototype = new emptyFn();
    cls.prototype.constructor = tmpCtr;
  };

  a2j.generateCallback = function generateCallback(context, cb) {
    return function () {
      cb.apply(context, arguments);
    };
  };

  a2j.NVector = function NVector(length) {
    if (length === undefined) length = 0;
    var tmp = new Array(length || 0);

    for (var i = 0; i < length; ++i) tmp[i] = 0;

    return tmp;
  };

  a2j.is = function is(o1, o2) {
    if (o1 === null) return false;
    if (o2 instanceof Function && o1 instanceof o2) return true;
    if (o1.constructor.__implements != undefined && o1.constructor.__implements[o2]) return true;
    return false;
  };

  a2j.parseUInt = function (v) {
    return Math.abs(parseInt(v));
  };
})(Box2D); //#TODO remove assignments from global namespace


var Vector = Array;
var Vector_a2j_Number = Box2D.NVector; //package structure

if (typeof Box2D === "undefined") Box2D = {};
if (typeof Box2D.Collision === "undefined") Box2D.Collision = {};
if (typeof Box2D.Collision.Shapes === "undefined") Box2D.Collision.Shapes = {};
if (typeof Box2D.Common === "undefined") Box2D.Common = {};
if (typeof Box2D.Common.Math === "undefined") Box2D.Common.Math = {};
if (typeof Box2D.Dynamics === "undefined") Box2D.Dynamics = {};
if (typeof Box2D.Dynamics.Contacts === "undefined") Box2D.Dynamics.Contacts = {};
if (typeof Box2D.Dynamics.Controllers === "undefined") Box2D.Dynamics.Controllers = {};
if (typeof Box2D.Dynamics.Joints === "undefined") Box2D.Dynamics.Joints = {}; //pre-definitions

(function () {
  Box2D.Collision.IBroadPhase = 'Box2D.Collision.IBroadPhase';

  function b2AABB() {
    b2AABB.b2AABB.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2AABB = b2AABB;

  function b2Bound() {
    b2Bound.b2Bound.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2Bound = b2Bound;

  function b2BoundValues() {
    b2BoundValues.b2BoundValues.apply(this, arguments);
    if (this.constructor === b2BoundValues) this.b2BoundValues.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2BoundValues = b2BoundValues;

  function b2Collision() {
    b2Collision.b2Collision.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2Collision = b2Collision;

  function b2ContactID() {
    b2ContactID.b2ContactID.apply(this, arguments);
    if (this.constructor === b2ContactID) this.b2ContactID.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2ContactID = b2ContactID;

  function b2ContactPoint() {
    b2ContactPoint.b2ContactPoint.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2ContactPoint = b2ContactPoint;

  function b2Distance() {
    b2Distance.b2Distance.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2Distance = b2Distance;

  function b2DistanceInput() {
    b2DistanceInput.b2DistanceInput.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2DistanceInput = b2DistanceInput;

  function b2DistanceOutput() {
    b2DistanceOutput.b2DistanceOutput.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2DistanceOutput = b2DistanceOutput;

  function b2DistanceProxy() {
    b2DistanceProxy.b2DistanceProxy.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2DistanceProxy = b2DistanceProxy;

  function b2DynamicTree() {
    b2DynamicTree.b2DynamicTree.apply(this, arguments);
    if (this.constructor === b2DynamicTree) this.b2DynamicTree.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2DynamicTree = b2DynamicTree;

  function b2DynamicTreeBroadPhase() {
    b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2DynamicTreeBroadPhase = b2DynamicTreeBroadPhase;

  function b2DynamicTreeNode() {
    b2DynamicTreeNode.b2DynamicTreeNode.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2DynamicTreeNode = b2DynamicTreeNode;

  function b2DynamicTreePair() {
    b2DynamicTreePair.b2DynamicTreePair.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2DynamicTreePair = b2DynamicTreePair;

  function b2Manifold() {
    b2Manifold.b2Manifold.apply(this, arguments);
    if (this.constructor === b2Manifold) this.b2Manifold.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2Manifold = b2Manifold;

  function b2ManifoldPoint() {
    b2ManifoldPoint.b2ManifoldPoint.apply(this, arguments);
    if (this.constructor === b2ManifoldPoint) this.b2ManifoldPoint.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2ManifoldPoint = b2ManifoldPoint;

  function b2Point() {
    b2Point.b2Point.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2Point = b2Point;

  function b2RayCastInput() {
    b2RayCastInput.b2RayCastInput.apply(this, arguments);
    if (this.constructor === b2RayCastInput) this.b2RayCastInput.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2RayCastInput = b2RayCastInput;

  function b2RayCastOutput() {
    b2RayCastOutput.b2RayCastOutput.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2RayCastOutput = b2RayCastOutput;

  function b2Segment() {
    b2Segment.b2Segment.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2Segment = b2Segment;

  function b2SeparationFunction() {
    b2SeparationFunction.b2SeparationFunction.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2SeparationFunction = b2SeparationFunction;

  function b2Simplex() {
    b2Simplex.b2Simplex.apply(this, arguments);
    if (this.constructor === b2Simplex) this.b2Simplex.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2Simplex = b2Simplex;

  function b2SimplexCache() {
    b2SimplexCache.b2SimplexCache.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2SimplexCache = b2SimplexCache;

  function b2SimplexVertex() {
    b2SimplexVertex.b2SimplexVertex.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2SimplexVertex = b2SimplexVertex;

  function b2TimeOfImpact() {
    b2TimeOfImpact.b2TimeOfImpact.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2TimeOfImpact = b2TimeOfImpact;

  function b2TOIInput() {
    b2TOIInput.b2TOIInput.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2TOIInput = b2TOIInput;

  function b2WorldManifold() {
    b2WorldManifold.b2WorldManifold.apply(this, arguments);
    if (this.constructor === b2WorldManifold) this.b2WorldManifold.apply(this, arguments);
  }

  ;
  Box2D.Collision.b2WorldManifold = b2WorldManifold;

  function ClipVertex() {
    ClipVertex.ClipVertex.apply(this, arguments);
  }

  ;
  Box2D.Collision.ClipVertex = ClipVertex;

  function Features() {
    Features.Features.apply(this, arguments);
  }

  ;
  Box2D.Collision.Features = Features;

  function b2CircleShape() {
    b2CircleShape.b2CircleShape.apply(this, arguments);
    if (this.constructor === b2CircleShape) this.b2CircleShape.apply(this, arguments);
  }

  ;
  Box2D.Collision.Shapes.b2CircleShape = b2CircleShape;

  function b2EdgeChainDef() {
    b2EdgeChainDef.b2EdgeChainDef.apply(this, arguments);
    if (this.constructor === b2EdgeChainDef) this.b2EdgeChainDef.apply(this, arguments);
  }

  ;
  Box2D.Collision.Shapes.b2EdgeChainDef = b2EdgeChainDef;

  function b2EdgeShape() {
    b2EdgeShape.b2EdgeShape.apply(this, arguments);
    if (this.constructor === b2EdgeShape) this.b2EdgeShape.apply(this, arguments);
  }

  ;
  Box2D.Collision.Shapes.b2EdgeShape = b2EdgeShape;

  function b2MassData() {
    b2MassData.b2MassData.apply(this, arguments);
  }

  ;
  Box2D.Collision.Shapes.b2MassData = b2MassData;

  function b2PolygonShape() {
    b2PolygonShape.b2PolygonShape.apply(this, arguments);
    if (this.constructor === b2PolygonShape) this.b2PolygonShape.apply(this, arguments);
  }

  ;
  Box2D.Collision.Shapes.b2PolygonShape = b2PolygonShape;

  function b2Shape() {
    b2Shape.b2Shape.apply(this, arguments);
    if (this.constructor === b2Shape) this.b2Shape.apply(this, arguments);
  }

  ;
  Box2D.Collision.Shapes.b2Shape = b2Shape;
  Box2D.Common.b2internal = 'Box2D.Common.b2internal';

  function b2Color() {
    b2Color.b2Color.apply(this, arguments);
    if (this.constructor === b2Color) this.b2Color.apply(this, arguments);
  }

  ;
  Box2D.Common.b2Color = b2Color;

  function b2Settings() {
    b2Settings.b2Settings.apply(this, arguments);
  }

  ;
  Box2D.Common.b2Settings = b2Settings;

  function b2Mat22() {
    b2Mat22.b2Mat22.apply(this, arguments);
    if (this.constructor === b2Mat22) this.b2Mat22.apply(this, arguments);
  }

  ;
  Box2D.Common.Math.b2Mat22 = b2Mat22;

  function b2Mat33() {
    b2Mat33.b2Mat33.apply(this, arguments);
    if (this.constructor === b2Mat33) this.b2Mat33.apply(this, arguments);
  }

  ;
  Box2D.Common.Math.b2Mat33 = b2Mat33;

  function b2Math() {
    b2Math.b2Math.apply(this, arguments);
  }

  ;
  Box2D.Common.Math.b2Math = b2Math;

  function b2Sweep() {
    b2Sweep.b2Sweep.apply(this, arguments);
  }

  ;
  Box2D.Common.Math.b2Sweep = b2Sweep;

  function b2Transform() {
    b2Transform.b2Transform.apply(this, arguments);
    if (this.constructor === b2Transform) this.b2Transform.apply(this, arguments);
  }

  ;
  Box2D.Common.Math.b2Transform = b2Transform;

  function b2Vec2() {
    b2Vec2.b2Vec2.apply(this, arguments);
    if (this.constructor === b2Vec2) this.b2Vec2.apply(this, arguments);
  }

  ;
  Box2D.Common.Math.b2Vec2 = b2Vec2;

  function b2Vec3() {
    b2Vec3.b2Vec3.apply(this, arguments);
    if (this.constructor === b2Vec3) this.b2Vec3.apply(this, arguments);
  }

  ;
  Box2D.Common.Math.b2Vec3 = b2Vec3;

  function b2Body() {
    b2Body.b2Body.apply(this, arguments);
    if (this.constructor === b2Body) this.b2Body.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.b2Body = b2Body;

  function b2BodyDef() {
    b2BodyDef.b2BodyDef.apply(this, arguments);
    if (this.constructor === b2BodyDef) this.b2BodyDef.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.b2BodyDef = b2BodyDef;

  function b2ContactFilter() {
    b2ContactFilter.b2ContactFilter.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.b2ContactFilter = b2ContactFilter;

  function b2ContactImpulse() {
    b2ContactImpulse.b2ContactImpulse.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.b2ContactImpulse = b2ContactImpulse;

  function b2ContactListener() {
    b2ContactListener.b2ContactListener.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.b2ContactListener = b2ContactListener;

  function b2ContactManager() {
    b2ContactManager.b2ContactManager.apply(this, arguments);
    if (this.constructor === b2ContactManager) this.b2ContactManager.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.b2ContactManager = b2ContactManager;

  function b2DebugDraw() {
    b2DebugDraw.b2DebugDraw.apply(this, arguments);
    if (this.constructor === b2DebugDraw) this.b2DebugDraw.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.b2DebugDraw = b2DebugDraw;

  function b2DestructionListener() {
    b2DestructionListener.b2DestructionListener.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.b2DestructionListener = b2DestructionListener;

  function b2FilterData() {
    b2FilterData.b2FilterData.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.b2FilterData = b2FilterData;

  function b2Fixture() {
    b2Fixture.b2Fixture.apply(this, arguments);
    if (this.constructor === b2Fixture) this.b2Fixture.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.b2Fixture = b2Fixture;

  function b2FixtureDef() {
    b2FixtureDef.b2FixtureDef.apply(this, arguments);
    if (this.constructor === b2FixtureDef) this.b2FixtureDef.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.b2FixtureDef = b2FixtureDef;

  function b2Island() {
    b2Island.b2Island.apply(this, arguments);
    if (this.constructor === b2Island) this.b2Island.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.b2Island = b2Island;

  function b2TimeStep() {
    b2TimeStep.b2TimeStep.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.b2TimeStep = b2TimeStep;

  function b2World() {
    b2World.b2World.apply(this, arguments);
    if (this.constructor === b2World) this.b2World.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.b2World = b2World;

  function b2CircleContact() {
    b2CircleContact.b2CircleContact.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Contacts.b2CircleContact = b2CircleContact;

  function b2Contact() {
    b2Contact.b2Contact.apply(this, arguments);
    if (this.constructor === b2Contact) this.b2Contact.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Contacts.b2Contact = b2Contact;

  function b2ContactConstraint() {
    b2ContactConstraint.b2ContactConstraint.apply(this, arguments);
    if (this.constructor === b2ContactConstraint) this.b2ContactConstraint.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Contacts.b2ContactConstraint = b2ContactConstraint;

  function b2ContactConstraintPoint() {
    b2ContactConstraintPoint.b2ContactConstraintPoint.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Contacts.b2ContactConstraintPoint = b2ContactConstraintPoint;

  function b2ContactEdge() {
    b2ContactEdge.b2ContactEdge.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Contacts.b2ContactEdge = b2ContactEdge;

  function b2ContactFactory() {
    b2ContactFactory.b2ContactFactory.apply(this, arguments);
    if (this.constructor === b2ContactFactory) this.b2ContactFactory.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Contacts.b2ContactFactory = b2ContactFactory;

  function b2ContactRegister() {
    b2ContactRegister.b2ContactRegister.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Contacts.b2ContactRegister = b2ContactRegister;

  function b2ContactResult() {
    b2ContactResult.b2ContactResult.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Contacts.b2ContactResult = b2ContactResult;

  function b2ContactSolver() {
    b2ContactSolver.b2ContactSolver.apply(this, arguments);
    if (this.constructor === b2ContactSolver) this.b2ContactSolver.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Contacts.b2ContactSolver = b2ContactSolver;

  function b2EdgeAndCircleContact() {
    b2EdgeAndCircleContact.b2EdgeAndCircleContact.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Contacts.b2EdgeAndCircleContact = b2EdgeAndCircleContact;

  function b2NullContact() {
    b2NullContact.b2NullContact.apply(this, arguments);
    if (this.constructor === b2NullContact) this.b2NullContact.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Contacts.b2NullContact = b2NullContact;

  function b2PolyAndCircleContact() {
    b2PolyAndCircleContact.b2PolyAndCircleContact.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Contacts.b2PolyAndCircleContact = b2PolyAndCircleContact;

  function b2PolyAndEdgeContact() {
    b2PolyAndEdgeContact.b2PolyAndEdgeContact.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Contacts.b2PolyAndEdgeContact = b2PolyAndEdgeContact;

  function b2PolygonContact() {
    b2PolygonContact.b2PolygonContact.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Contacts.b2PolygonContact = b2PolygonContact;

  function b2PositionSolverManifold() {
    b2PositionSolverManifold.b2PositionSolverManifold.apply(this, arguments);
    if (this.constructor === b2PositionSolverManifold) this.b2PositionSolverManifold.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Contacts.b2PositionSolverManifold = b2PositionSolverManifold;

  function b2BuoyancyController() {
    b2BuoyancyController.b2BuoyancyController.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Controllers.b2BuoyancyController = b2BuoyancyController;

  function b2ConstantAccelController() {
    b2ConstantAccelController.b2ConstantAccelController.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Controllers.b2ConstantAccelController = b2ConstantAccelController;

  function b2ConstantForceController() {
    b2ConstantForceController.b2ConstantForceController.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Controllers.b2ConstantForceController = b2ConstantForceController;

  function b2Controller() {
    b2Controller.b2Controller.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Controllers.b2Controller = b2Controller;

  function b2ControllerEdge() {
    b2ControllerEdge.b2ControllerEdge.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Controllers.b2ControllerEdge = b2ControllerEdge;

  function b2GravityController() {
    b2GravityController.b2GravityController.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Controllers.b2GravityController = b2GravityController;

  function b2TensorDampingController() {
    b2TensorDampingController.b2TensorDampingController.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Controllers.b2TensorDampingController = b2TensorDampingController;

  function b2DistanceJoint() {
    b2DistanceJoint.b2DistanceJoint.apply(this, arguments);
    if (this.constructor === b2DistanceJoint) this.b2DistanceJoint.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Joints.b2DistanceJoint = b2DistanceJoint;

  function b2DistanceJointDef() {
    b2DistanceJointDef.b2DistanceJointDef.apply(this, arguments);
    if (this.constructor === b2DistanceJointDef) this.b2DistanceJointDef.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Joints.b2DistanceJointDef = b2DistanceJointDef;

  function b2FrictionJoint() {
    b2FrictionJoint.b2FrictionJoint.apply(this, arguments);
    if (this.constructor === b2FrictionJoint) this.b2FrictionJoint.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Joints.b2FrictionJoint = b2FrictionJoint;

  function b2FrictionJointDef() {
    b2FrictionJointDef.b2FrictionJointDef.apply(this, arguments);
    if (this.constructor === b2FrictionJointDef) this.b2FrictionJointDef.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Joints.b2FrictionJointDef = b2FrictionJointDef;

  function b2GearJoint() {
    b2GearJoint.b2GearJoint.apply(this, arguments);
    if (this.constructor === b2GearJoint) this.b2GearJoint.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Joints.b2GearJoint = b2GearJoint;

  function b2GearJointDef() {
    b2GearJointDef.b2GearJointDef.apply(this, arguments);
    if (this.constructor === b2GearJointDef) this.b2GearJointDef.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Joints.b2GearJointDef = b2GearJointDef;

  function b2Jacobian() {
    b2Jacobian.b2Jacobian.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Joints.b2Jacobian = b2Jacobian;

  function b2Joint() {
    b2Joint.b2Joint.apply(this, arguments);
    if (this.constructor === b2Joint) this.b2Joint.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Joints.b2Joint = b2Joint;

  function b2JointDef() {
    b2JointDef.b2JointDef.apply(this, arguments);
    if (this.constructor === b2JointDef) this.b2JointDef.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Joints.b2JointDef = b2JointDef;

  function b2JointEdge() {
    b2JointEdge.b2JointEdge.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Joints.b2JointEdge = b2JointEdge;

  function b2LineJoint() {
    b2LineJoint.b2LineJoint.apply(this, arguments);
    if (this.constructor === b2LineJoint) this.b2LineJoint.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Joints.b2LineJoint = b2LineJoint;

  function b2LineJointDef() {
    b2LineJointDef.b2LineJointDef.apply(this, arguments);
    if (this.constructor === b2LineJointDef) this.b2LineJointDef.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Joints.b2LineJointDef = b2LineJointDef;

  function b2MouseJoint() {
    b2MouseJoint.b2MouseJoint.apply(this, arguments);
    if (this.constructor === b2MouseJoint) this.b2MouseJoint.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Joints.b2MouseJoint = b2MouseJoint;

  function b2MouseJointDef() {
    b2MouseJointDef.b2MouseJointDef.apply(this, arguments);
    if (this.constructor === b2MouseJointDef) this.b2MouseJointDef.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Joints.b2MouseJointDef = b2MouseJointDef;

  function b2PrismaticJoint() {
    b2PrismaticJoint.b2PrismaticJoint.apply(this, arguments);
    if (this.constructor === b2PrismaticJoint) this.b2PrismaticJoint.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Joints.b2PrismaticJoint = b2PrismaticJoint;

  function b2PrismaticJointDef() {
    b2PrismaticJointDef.b2PrismaticJointDef.apply(this, arguments);
    if (this.constructor === b2PrismaticJointDef) this.b2PrismaticJointDef.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Joints.b2PrismaticJointDef = b2PrismaticJointDef;

  function b2PulleyJoint() {
    b2PulleyJoint.b2PulleyJoint.apply(this, arguments);
    if (this.constructor === b2PulleyJoint) this.b2PulleyJoint.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Joints.b2PulleyJoint = b2PulleyJoint;

  function b2PulleyJointDef() {
    b2PulleyJointDef.b2PulleyJointDef.apply(this, arguments);
    if (this.constructor === b2PulleyJointDef) this.b2PulleyJointDef.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Joints.b2PulleyJointDef = b2PulleyJointDef;

  function b2RevoluteJoint() {
    b2RevoluteJoint.b2RevoluteJoint.apply(this, arguments);
    if (this.constructor === b2RevoluteJoint) this.b2RevoluteJoint.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Joints.b2RevoluteJoint = b2RevoluteJoint;

  function b2RevoluteJointDef() {
    b2RevoluteJointDef.b2RevoluteJointDef.apply(this, arguments);
    if (this.constructor === b2RevoluteJointDef) this.b2RevoluteJointDef.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Joints.b2RevoluteJointDef = b2RevoluteJointDef;

  function b2WeldJoint() {
    b2WeldJoint.b2WeldJoint.apply(this, arguments);
    if (this.constructor === b2WeldJoint) this.b2WeldJoint.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Joints.b2WeldJoint = b2WeldJoint;

  function b2WeldJointDef() {
    b2WeldJointDef.b2WeldJointDef.apply(this, arguments);
    if (this.constructor === b2WeldJointDef) this.b2WeldJointDef.apply(this, arguments);
  }

  ;
  Box2D.Dynamics.Joints.b2WeldJointDef = b2WeldJointDef;
})(); //definitions


Box2D.postDefs = [];

(function () {
  var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;

  b2AABB.b2AABB = function () {
    this.lowerBound = new b2Vec2();
    this.upperBound = new b2Vec2();
  };

  b2AABB.prototype.IsValid = function () {
    var dX = this.upperBound.x - this.lowerBound.x;
    var dY = this.upperBound.y - this.lowerBound.y;
    var valid = dX >= 0.0 && dY >= 0.0;
    valid = valid && this.lowerBound.IsValid() && this.upperBound.IsValid();
    return valid;
  };

  b2AABB.prototype.GetCenter = function () {
    return new b2Vec2((this.lowerBound.x + this.upperBound.x) / 2, (this.lowerBound.y + this.upperBound.y) / 2);
  };

  b2AABB.prototype.GetExtents = function () {
    return new b2Vec2((this.upperBound.x - this.lowerBound.x) / 2, (this.upperBound.y - this.lowerBound.y) / 2);
  };

  b2AABB.prototype.Contains = function (aabb) {
    var result = true;
    result = result && this.lowerBound.x <= aabb.lowerBound.x;
    result = result && this.lowerBound.y <= aabb.lowerBound.y;
    result = result && aabb.upperBound.x <= this.upperBound.x;
    result = result && aabb.upperBound.y <= this.upperBound.y;
    return result;
  };

  b2AABB.prototype.RayCast = function (output, input) {
    var tmin = -Number.MAX_VALUE;
    var tmax = Number.MAX_VALUE;
    var pX = input.p1.x;
    var pY = input.p1.y;
    var dX = input.p2.x - input.p1.x;
    var dY = input.p2.y - input.p1.y;
    var absDX = Math.abs(dX);
    var absDY = Math.abs(dY);
    var normal = output.normal;
    var inv_d = 0;
    var t1 = 0;
    var t2 = 0;
    var t3 = 0;
    var s = 0;
    {
      if (absDX < Number.MIN_VALUE) {
        if (pX < this.lowerBound.x || this.upperBound.x < pX) return false;
      } else {
        inv_d = 1.0 / dX;
        t1 = (this.lowerBound.x - pX) * inv_d;
        t2 = (this.upperBound.x - pX) * inv_d;
        s = -1.0;

        if (t1 > t2) {
          t3 = t1;
          t1 = t2;
          t2 = t3;
          s = 1.0;
        }

        if (t1 > tmin) {
          normal.x = s;
          normal.y = 0;
          tmin = t1;
        }

        tmax = Math.min(tmax, t2);
        if (tmin > tmax) return false;
      }
    }
    {
      if (absDY < Number.MIN_VALUE) {
        if (pY < this.lowerBound.y || this.upperBound.y < pY) return false;
      } else {
        inv_d = 1.0 / dY;
        t1 = (this.lowerBound.y - pY) * inv_d;
        t2 = (this.upperBound.y - pY) * inv_d;
        s = -1.0;

        if (t1 > t2) {
          t3 = t1;
          t1 = t2;
          t2 = t3;
          s = 1.0;
        }

        if (t1 > tmin) {
          normal.y = s;
          normal.x = 0;
          tmin = t1;
        }

        tmax = Math.min(tmax, t2);
        if (tmin > tmax) return false;
      }
    }
    output.fraction = tmin;
    return true;
  };

  b2AABB.prototype.TestOverlap = function (other) {
    var d1X = other.lowerBound.x - this.upperBound.x;
    var d1Y = other.lowerBound.y - this.upperBound.y;
    var d2X = this.lowerBound.x - other.upperBound.x;
    var d2Y = this.lowerBound.y - other.upperBound.y;
    if (d1X > 0.0 || d1Y > 0.0) return false;
    if (d2X > 0.0 || d2Y > 0.0) return false;
    return true;
  };

  b2AABB.Combine = function (aabb1, aabb2) {
    var aabb = new b2AABB();
    aabb.Combine(aabb1, aabb2);
    return aabb;
  };

  b2AABB.prototype.Combine = function (aabb1, aabb2) {
    this.lowerBound.x = Math.min(aabb1.lowerBound.x, aabb2.lowerBound.x);
    this.lowerBound.y = Math.min(aabb1.lowerBound.y, aabb2.lowerBound.y);
    this.upperBound.x = Math.max(aabb1.upperBound.x, aabb2.upperBound.x);
    this.upperBound.y = Math.max(aabb1.upperBound.y, aabb2.upperBound.y);
  };

  b2Bound.b2Bound = function () {};

  b2Bound.prototype.IsLower = function () {
    return (this.value & 1) == 0;
  };

  b2Bound.prototype.IsUpper = function () {
    return (this.value & 1) == 1;
  };

  b2Bound.prototype.Swap = function (b) {
    var tempValue = this.value;
    var tempProxy = this.proxy;
    var tempStabbingCount = this.stabbingCount;
    this.value = b.value;
    this.proxy = b.proxy;
    this.stabbingCount = b.stabbingCount;
    b.value = tempValue;
    b.proxy = tempProxy;
    b.stabbingCount = tempStabbingCount;
  };

  b2BoundValues.b2BoundValues = function () {};

  b2BoundValues.prototype.b2BoundValues = function () {
    this.lowerValues = new Vector_a2j_Number();
    this.lowerValues[0] = 0.0;
    this.lowerValues[1] = 0.0;
    this.upperValues = new Vector_a2j_Number();
    this.upperValues[0] = 0.0;
    this.upperValues[1] = 0.0;
  };

  b2Collision.b2Collision = function () {};

  b2Collision.ClipSegmentToLine = function (vOut, vIn, normal, offset) {
    if (offset === undefined) offset = 0;
    var cv;
    var numOut = 0;
    cv = vIn[0];
    var vIn0 = cv.v;
    cv = vIn[1];
    var vIn1 = cv.v;
    var distance0 = normal.x * vIn0.x + normal.y * vIn0.y - offset;
    var distance1 = normal.x * vIn1.x + normal.y * vIn1.y - offset;
    if (distance0 <= 0.0) vOut[numOut++].Set(vIn[0]);
    if (distance1 <= 0.0) vOut[numOut++].Set(vIn[1]);

    if (distance0 * distance1 < 0.0) {
      var interp = distance0 / (distance0 - distance1);
      cv = vOut[numOut];
      var tVec = cv.v;
      tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x);
      tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y);
      cv = vOut[numOut];
      var cv2;

      if (distance0 > 0.0) {
        cv2 = vIn[0];
        cv.id = cv2.id;
      } else {
        cv2 = vIn[1];
        cv.id = cv2.id;
      }

      ++numOut;
    }

    return numOut;
  };

  b2Collision.EdgeSeparation = function (poly1, xf1, edge1, poly2, xf2) {
    if (edge1 === undefined) edge1 = 0;
    var count1 = parseInt(poly1.m_vertexCount);
    var vertices1 = poly1.m_vertices;
    var normals1 = poly1.m_normals;
    var count2 = parseInt(poly2.m_vertexCount);
    var vertices2 = poly2.m_vertices;
    var tMat;
    var tVec;
    tMat = xf1.R;
    tVec = normals1[edge1];
    var normal1WorldX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    var normal1WorldY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    tMat = xf2.R;
    var normal1X = tMat.col1.x * normal1WorldX + tMat.col1.y * normal1WorldY;
    var normal1Y = tMat.col2.x * normal1WorldX + tMat.col2.y * normal1WorldY;
    var index = 0;
    var minDot = Number.MAX_VALUE;

    for (var i = 0; i < count2; ++i) {
      tVec = vertices2[i];
      var dot = tVec.x * normal1X + tVec.y * normal1Y;

      if (dot < minDot) {
        minDot = dot;
        index = i;
      }
    }

    tVec = vertices1[edge1];
    tMat = xf1.R;
    var v1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    var v1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    tVec = vertices2[index];
    tMat = xf2.R;
    var v2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    var v2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    v2X -= v1X;
    v2Y -= v1Y;
    var separation = v2X * normal1WorldX + v2Y * normal1WorldY;
    return separation;
  };

  b2Collision.FindMaxSeparation = function (edgeIndex, poly1, xf1, poly2, xf2) {
    var count1 = parseInt(poly1.m_vertexCount);
    var normals1 = poly1.m_normals;
    var tVec;
    var tMat;
    tMat = xf2.R;
    tVec = poly2.m_centroid;
    var dX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    var dY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    tMat = xf1.R;
    tVec = poly1.m_centroid;
    dX -= xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    dY -= xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    var dLocal1X = dX * xf1.R.col1.x + dY * xf1.R.col1.y;
    var dLocal1Y = dX * xf1.R.col2.x + dY * xf1.R.col2.y;
    var edge = 0;
    var maxDot = -Number.MAX_VALUE;

    for (var i = 0; i < count1; ++i) {
      tVec = normals1[i];
      var dot = tVec.x * dLocal1X + tVec.y * dLocal1Y;

      if (dot > maxDot) {
        maxDot = dot;
        edge = i;
      }
    }

    var s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
    var prevEdge = parseInt(edge - 1 >= 0 ? edge - 1 : count1 - 1);
    var sPrev = b2Collision.EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
    var nextEdge = parseInt(edge + 1 < count1 ? edge + 1 : 0);
    var sNext = b2Collision.EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
    var bestEdge = 0;
    var bestSeparation = 0;
    var increment = 0;

    if (sPrev > s && sPrev > sNext) {
      increment = -1;
      bestEdge = prevEdge;
      bestSeparation = sPrev;
    } else if (sNext > s) {
      increment = 1;
      bestEdge = nextEdge;
      bestSeparation = sNext;
    } else {
      edgeIndex[0] = edge;
      return s;
    }

    while (true) {
      if (increment == -1) edge = bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1;else edge = bestEdge + 1 < count1 ? bestEdge + 1 : 0;
      s = b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);

      if (s > bestSeparation) {
        bestEdge = edge;
        bestSeparation = s;
      } else {
        break;
      }
    }

    edgeIndex[0] = bestEdge;
    return bestSeparation;
  };

  b2Collision.FindIncidentEdge = function (c, poly1, xf1, edge1, poly2, xf2) {
    if (edge1 === undefined) edge1 = 0;
    var count1 = parseInt(poly1.m_vertexCount);
    var normals1 = poly1.m_normals;
    var count2 = parseInt(poly2.m_vertexCount);
    var vertices2 = poly2.m_vertices;
    var normals2 = poly2.m_normals;
    var tMat;
    var tVec;
    tMat = xf1.R;
    tVec = normals1[edge1];
    var normal1X = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    var normal1Y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    tMat = xf2.R;
    var tX = tMat.col1.x * normal1X + tMat.col1.y * normal1Y;
    normal1Y = tMat.col2.x * normal1X + tMat.col2.y * normal1Y;
    normal1X = tX;
    var index = 0;
    var minDot = Number.MAX_VALUE;

    for (var i = 0; i < count2; ++i) {
      tVec = normals2[i];
      var dot = normal1X * tVec.x + normal1Y * tVec.y;

      if (dot < minDot) {
        minDot = dot;
        index = i;
      }
    }

    var tClip;
    var i1 = parseInt(index);
    var i2 = parseInt(i1 + 1 < count2 ? i1 + 1 : 0);
    tClip = c[0];
    tVec = vertices2[i1];
    tMat = xf2.R;
    tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    tClip.id.features.referenceEdge = edge1;
    tClip.id.features.incidentEdge = i1;
    tClip.id.features.incidentVertex = 0;
    tClip = c[1];
    tVec = vertices2[i2];
    tMat = xf2.R;
    tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    tClip.id.features.referenceEdge = edge1;
    tClip.id.features.incidentEdge = i2;
    tClip.id.features.incidentVertex = 1;
  };

  b2Collision.MakeClipPointVector = function () {
    var r = new Vector(2);
    r[0] = new ClipVertex();
    r[1] = new ClipVertex();
    return r;
  };

  b2Collision.CollidePolygons = function (manifold, polyA, xfA, polyB, xfB) {
    var cv;
    manifold.m_pointCount = 0;
    var totalRadius = polyA.m_radius + polyB.m_radius;
    var edgeA = 0;
    b2Collision.s_edgeAO[0] = edgeA;
    var separationA = b2Collision.FindMaxSeparation(b2Collision.s_edgeAO, polyA, xfA, polyB, xfB);
    edgeA = b2Collision.s_edgeAO[0];
    if (separationA > totalRadius) return;
    var edgeB = 0;
    b2Collision.s_edgeBO[0] = edgeB;
    var separationB = b2Collision.FindMaxSeparation(b2Collision.s_edgeBO, polyB, xfB, polyA, xfA);
    edgeB = b2Collision.s_edgeBO[0];
    if (separationB > totalRadius) return;
    var poly1;
    var poly2;
    var xf1;
    var xf2;
    var edge1 = 0;
    var flip = 0;
    var k_relativeTol = 0.98;
    var k_absoluteTol = 0.001;
    var tMat;

    if (separationB > k_relativeTol * separationA + k_absoluteTol) {
      poly1 = polyB;
      poly2 = polyA;
      xf1 = xfB;
      xf2 = xfA;
      edge1 = edgeB;
      manifold.m_type = b2Manifold.e_faceB;
      flip = 1;
    } else {
      poly1 = polyA;
      poly2 = polyB;
      xf1 = xfA;
      xf2 = xfB;
      edge1 = edgeA;
      manifold.m_type = b2Manifold.e_faceA;
      flip = 0;
    }

    var incidentEdge = b2Collision.s_incidentEdge;
    b2Collision.FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
    var count1 = parseInt(poly1.m_vertexCount);
    var vertices1 = poly1.m_vertices;
    var local_v11 = vertices1[edge1];
    var local_v12;

    if (edge1 + 1 < count1) {
      local_v12 = vertices1[parseInt(edge1 + 1)];
    } else {
      local_v12 = vertices1[0];
    }

    var localTangent = b2Collision.s_localTangent;
    localTangent.Set(local_v12.x - local_v11.x, local_v12.y - local_v11.y);
    localTangent.Normalize();
    var localNormal = b2Collision.s_localNormal;
    localNormal.x = localTangent.y;
    localNormal.y = -localTangent.x;
    var planePoint = b2Collision.s_planePoint;
    planePoint.Set(0.5 * (local_v11.x + local_v12.x), 0.5 * (local_v11.y + local_v12.y));
    var tangent = b2Collision.s_tangent;
    tMat = xf1.R;
    tangent.x = tMat.col1.x * localTangent.x + tMat.col2.x * localTangent.y;
    tangent.y = tMat.col1.y * localTangent.x + tMat.col2.y * localTangent.y;
    var tangent2 = b2Collision.s_tangent2;
    tangent2.x = -tangent.x;
    tangent2.y = -tangent.y;
    var normal = b2Collision.s_normal;
    normal.x = tangent.y;
    normal.y = -tangent.x;
    var v11 = b2Collision.s_v11;
    var v12 = b2Collision.s_v12;
    v11.x = xf1.position.x + (tMat.col1.x * local_v11.x + tMat.col2.x * local_v11.y);
    v11.y = xf1.position.y + (tMat.col1.y * local_v11.x + tMat.col2.y * local_v11.y);
    v12.x = xf1.position.x + (tMat.col1.x * local_v12.x + tMat.col2.x * local_v12.y);
    v12.y = xf1.position.y + (tMat.col1.y * local_v12.x + tMat.col2.y * local_v12.y);
    var frontOffset = normal.x * v11.x + normal.y * v11.y;
    var sideOffset1 = -tangent.x * v11.x - tangent.y * v11.y + totalRadius;
    var sideOffset2 = tangent.x * v12.x + tangent.y * v12.y + totalRadius;
    var clipPoints1 = b2Collision.s_clipPoints1;
    var clipPoints2 = b2Collision.s_clipPoints2;
    var np = 0;
    np = b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, tangent2, sideOffset1);
    if (np < 2) return;
    np = b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);
    if (np < 2) return;
    manifold.m_localPlaneNormal.SetV(localNormal);
    manifold.m_localPoint.SetV(planePoint);
    var pointCount = 0;

    for (var i = 0; i < b2Settings.b2_maxManifoldPoints; ++i) {
      cv = clipPoints2[i];
      var separation = normal.x * cv.v.x + normal.y * cv.v.y - frontOffset;

      if (separation <= totalRadius) {
        var cp = manifold.m_points[pointCount];
        tMat = xf2.R;
        var tX = cv.v.x - xf2.position.x;
        var tY = cv.v.y - xf2.position.y;
        cp.m_localPoint.x = tX * tMat.col1.x + tY * tMat.col1.y;
        cp.m_localPoint.y = tX * tMat.col2.x + tY * tMat.col2.y;
        cp.m_id.Set(cv.id);
        cp.m_id.features.flip = flip;
        ++pointCount;
      }
    }

    manifold.m_pointCount = pointCount;
  };

  b2Collision.CollideCircles = function (manifold, circle1, xf1, circle2, xf2) {
    manifold.m_pointCount = 0;
    var tMat;
    var tVec;
    tMat = xf1.R;
    tVec = circle1.m_p;
    var p1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    var p1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    tMat = xf2.R;
    tVec = circle2.m_p;
    var p2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    var p2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    var dX = p2X - p1X;
    var dY = p2Y - p1Y;
    var distSqr = dX * dX + dY * dY;
    var radius = circle1.m_radius + circle2.m_radius;

    if (distSqr > radius * radius) {
      return;
    }

    manifold.m_type = b2Manifold.e_circles;
    manifold.m_localPoint.SetV(circle1.m_p);
    manifold.m_localPlaneNormal.SetZero();
    manifold.m_pointCount = 1;
    manifold.m_points[0].m_localPoint.SetV(circle2.m_p);
    manifold.m_points[0].m_id.key = 0;
  };

  b2Collision.CollidePolygonAndCircle = function (manifold, polygon, xf1, circle, xf2) {
    manifold.m_pointCount = 0;
    var tPoint;
    var dX = 0;
    var dY = 0;
    var positionX = 0;
    var positionY = 0;
    var tVec;
    var tMat;
    tMat = xf2.R;
    tVec = circle.m_p;
    var cX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    var cY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    dX = cX - xf1.position.x;
    dY = cY - xf1.position.y;
    tMat = xf1.R;
    var cLocalX = dX * tMat.col1.x + dY * tMat.col1.y;
    var cLocalY = dX * tMat.col2.x + dY * tMat.col2.y;
    var dist = 0;
    var normalIndex = 0;
    var separation = -Number.MAX_VALUE;
    var radius = polygon.m_radius + circle.m_radius;
    var vertexCount = parseInt(polygon.m_vertexCount);
    var vertices = polygon.m_vertices;
    var normals = polygon.m_normals;

    for (var i = 0; i < vertexCount; ++i) {
      tVec = vertices[i];
      dX = cLocalX - tVec.x;
      dY = cLocalY - tVec.y;
      tVec = normals[i];
      var s = tVec.x * dX + tVec.y * dY;

      if (s > radius) {
        return;
      }

      if (s > separation) {
        separation = s;
        normalIndex = i;
      }
    }

    var vertIndex1 = parseInt(normalIndex);
    var vertIndex2 = parseInt(vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0);
    var v1 = vertices[vertIndex1];
    var v2 = vertices[vertIndex2];

    if (separation < Number.MIN_VALUE) {
      manifold.m_pointCount = 1;
      manifold.m_type = b2Manifold.e_faceA;
      manifold.m_localPlaneNormal.SetV(normals[normalIndex]);
      manifold.m_localPoint.x = 0.5 * (v1.x + v2.x);
      manifold.m_localPoint.y = 0.5 * (v1.y + v2.y);
      manifold.m_points[0].m_localPoint.SetV(circle.m_p);
      manifold.m_points[0].m_id.key = 0;
      return;
    }

    var u1 = (cLocalX - v1.x) * (v2.x - v1.x) + (cLocalY - v1.y) * (v2.y - v1.y);
    var u2 = (cLocalX - v2.x) * (v1.x - v2.x) + (cLocalY - v2.y) * (v1.y - v2.y);

    if (u1 <= 0.0) {
      if ((cLocalX - v1.x) * (cLocalX - v1.x) + (cLocalY - v1.y) * (cLocalY - v1.y) > radius * radius) return;
      manifold.m_pointCount = 1;
      manifold.m_type = b2Manifold.e_faceA;
      manifold.m_localPlaneNormal.x = cLocalX - v1.x;
      manifold.m_localPlaneNormal.y = cLocalY - v1.y;
      manifold.m_localPlaneNormal.Normalize();
      manifold.m_localPoint.SetV(v1);
      manifold.m_points[0].m_localPoint.SetV(circle.m_p);
      manifold.m_points[0].m_id.key = 0;
    } else if (u2 <= 0) {
      if ((cLocalX - v2.x) * (cLocalX - v2.x) + (cLocalY - v2.y) * (cLocalY - v2.y) > radius * radius) return;
      manifold.m_pointCount = 1;
      manifold.m_type = b2Manifold.e_faceA;
      manifold.m_localPlaneNormal.x = cLocalX - v2.x;
      manifold.m_localPlaneNormal.y = cLocalY - v2.y;
      manifold.m_localPlaneNormal.Normalize();
      manifold.m_localPoint.SetV(v2);
      manifold.m_points[0].m_localPoint.SetV(circle.m_p);
      manifold.m_points[0].m_id.key = 0;
    } else {
      var faceCenterX = 0.5 * (v1.x + v2.x);
      var faceCenterY = 0.5 * (v1.y + v2.y);
      separation = (cLocalX - faceCenterX) * normals[vertIndex1].x + (cLocalY - faceCenterY) * normals[vertIndex1].y;
      if (separation > radius) return;
      manifold.m_pointCount = 1;
      manifold.m_type = b2Manifold.e_faceA;
      manifold.m_localPlaneNormal.x = normals[vertIndex1].x;
      manifold.m_localPlaneNormal.y = normals[vertIndex1].y;
      manifold.m_localPlaneNormal.Normalize();
      manifold.m_localPoint.Set(faceCenterX, faceCenterY);
      manifold.m_points[0].m_localPoint.SetV(circle.m_p);
      manifold.m_points[0].m_id.key = 0;
    }
  };

  b2Collision.TestOverlap = function (a, b) {
    var t1 = b.lowerBound;
    var t2 = a.upperBound;
    var d1X = t1.x - t2.x;
    var d1Y = t1.y - t2.y;
    t1 = a.lowerBound;
    t2 = b.upperBound;
    var d2X = t1.x - t2.x;
    var d2Y = t1.y - t2.y;
    if (d1X > 0.0 || d1Y > 0.0) return false;
    if (d2X > 0.0 || d2Y > 0.0) return false;
    return true;
  };

  Box2D.postDefs.push(function () {
    Box2D.Collision.b2Collision.s_incidentEdge = b2Collision.MakeClipPointVector();
    Box2D.Collision.b2Collision.s_clipPoints1 = b2Collision.MakeClipPointVector();
    Box2D.Collision.b2Collision.s_clipPoints2 = b2Collision.MakeClipPointVector();
    Box2D.Collision.b2Collision.s_edgeAO = new Vector_a2j_Number(1);
    Box2D.Collision.b2Collision.s_edgeBO = new Vector_a2j_Number(1);
    Box2D.Collision.b2Collision.s_localTangent = new b2Vec2();
    Box2D.Collision.b2Collision.s_localNormal = new b2Vec2();
    Box2D.Collision.b2Collision.s_planePoint = new b2Vec2();
    Box2D.Collision.b2Collision.s_normal = new b2Vec2();
    Box2D.Collision.b2Collision.s_tangent = new b2Vec2();
    Box2D.Collision.b2Collision.s_tangent2 = new b2Vec2();
    Box2D.Collision.b2Collision.s_v11 = new b2Vec2();
    Box2D.Collision.b2Collision.s_v12 = new b2Vec2();
    Box2D.Collision.b2Collision.b2CollidePolyTempVec = new b2Vec2();
    Box2D.Collision.b2Collision.b2_nullFeature = 0x000000ff;
  });

  b2ContactID.b2ContactID = function () {
    this.features = new Features();
  };

  b2ContactID.prototype.b2ContactID = function () {
    this.features._m_id = this;
  };

  b2ContactID.prototype.Set = function (id) {
    this.key = id._key;
  };

  b2ContactID.prototype.Copy = function () {
    var id = new b2ContactID();
    id.key = this.key;
    return id;
  };

  Object.defineProperty(b2ContactID.prototype, 'key', {
    enumerable: false,
    configurable: true,
    get: function get() {
      return this._key;
    }
  });
  Object.defineProperty(b2ContactID.prototype, 'key', {
    enumerable: false,
    configurable: true,
    set: function set(value) {
      if (value === undefined) value = 0;
      this._key = value;
      this.features._referenceEdge = this._key & 0x000000ff;
      this.features._incidentEdge = (this._key & 0x0000ff00) >> 8 & 0x000000ff;
      this.features._incidentVertex = (this._key & 0x00ff0000) >> 16 & 0x000000ff;
      this.features._flip = (this._key & 0xff000000) >> 24 & 0x000000ff;
    }
  });

  b2ContactPoint.b2ContactPoint = function () {
    this.position = new b2Vec2();
    this.velocity = new b2Vec2();
    this.normal = new b2Vec2();
    this.id = new b2ContactID();
  };

  b2Distance.b2Distance = function () {};

  b2Distance.Distance = function (output, cache, input) {
    ++b2Distance.b2_gjkCalls;
    var proxyA = input.proxyA;
    var proxyB = input.proxyB;
    var transformA = input.transformA;
    var transformB = input.transformB;
    var simplex = b2Distance.s_simplex;
    simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
    var vertices = simplex.m_vertices;
    var k_maxIters = 20;
    var saveA = b2Distance.s_saveA;
    var saveB = b2Distance.s_saveB;
    var saveCount = 0;
    var closestPoint = simplex.GetClosestPoint();
    var distanceSqr1 = closestPoint.LengthSquared();
    var distanceSqr2 = distanceSqr1;
    var i = 0;
    var p;
    var iter = 0;

    while (iter < k_maxIters) {
      saveCount = simplex.m_count;

      for (i = 0; i < saveCount; i++) {
        saveA[i] = vertices[i].indexA;
        saveB[i] = vertices[i].indexB;
      }

      switch (simplex.m_count) {
        case 1:
          break;

        case 2:
          simplex.Solve2();
          break;

        case 3:
          simplex.Solve3();
          break;

        default:
          b2Settings.b2Assert(false);
      }

      if (simplex.m_count == 3) {
        break;
      }

      p = simplex.GetClosestPoint();
      distanceSqr2 = p.LengthSquared();

      if (distanceSqr2 > distanceSqr1) {}

      distanceSqr1 = distanceSqr2;
      var d = simplex.GetSearchDirection();

      if (d.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) {
        break;
      }

      var vertex = vertices[simplex.m_count];
      vertex.indexA = proxyA.GetSupport(b2Math.MulTMV(transformA.R, d.GetNegative()));
      vertex.wA = b2Math.MulX(transformA, proxyA.GetVertex(vertex.indexA));
      vertex.indexB = proxyB.GetSupport(b2Math.MulTMV(transformB.R, d));
      vertex.wB = b2Math.MulX(transformB, proxyB.GetVertex(vertex.indexB));
      vertex.w = b2Math.SubtractVV(vertex.wB, vertex.wA);
      ++iter;
      ++b2Distance.b2_gjkIters;
      var duplicate = false;

      for (i = 0; i < saveCount; i++) {
        if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
          duplicate = true;
          break;
        }
      }

      if (duplicate) {
        break;
      }

      ++simplex.m_count;
    }

    b2Distance.b2_gjkMaxIters = b2Math.Max(b2Distance.b2_gjkMaxIters, iter);
    simplex.GetWitnessPoints(output.pointA, output.pointB);
    output.distance = b2Math.SubtractVV(output.pointA, output.pointB).Length();
    output.iterations = iter;
    simplex.WriteCache(cache);

    if (input.useRadii) {
      var rA = proxyA.m_radius;
      var rB = proxyB.m_radius;

      if (output.distance > rA + rB && output.distance > Number.MIN_VALUE) {
        output.distance -= rA + rB;
        var normal = b2Math.SubtractVV(output.pointB, output.pointA);
        normal.Normalize();
        output.pointA.x += rA * normal.x;
        output.pointA.y += rA * normal.y;
        output.pointB.x -= rB * normal.x;
        output.pointB.y -= rB * normal.y;
      } else {
        p = new b2Vec2();
        p.x = .5 * (output.pointA.x + output.pointB.x);
        p.y = .5 * (output.pointA.y + output.pointB.y);
        output.pointA.x = output.pointB.x = p.x;
        output.pointA.y = output.pointB.y = p.y;
        output.distance = 0.0;
      }
    }
  };

  Box2D.postDefs.push(function () {
    Box2D.Collision.b2Distance.s_simplex = new b2Simplex();
    Box2D.Collision.b2Distance.s_saveA = new Vector_a2j_Number(3);
    Box2D.Collision.b2Distance.s_saveB = new Vector_a2j_Number(3);
  });

  b2DistanceInput.b2DistanceInput = function () {};

  b2DistanceOutput.b2DistanceOutput = function () {
    this.pointA = new b2Vec2();
    this.pointB = new b2Vec2();
  };

  b2DistanceProxy.b2DistanceProxy = function () {};

  b2DistanceProxy.prototype.Set = function (shape) {
    switch (shape.GetType()) {
      case b2Shape.e_circleShape:
        {
          var circle = shape instanceof b2CircleShape ? shape : null;
          this.m_vertices = new Vector(1, true);
          this.m_vertices[0] = circle.m_p;
          this.m_count = 1;
          this.m_radius = circle.m_radius;
        }
        break;

      case b2Shape.e_polygonShape:
        {
          var polygon = shape instanceof b2PolygonShape ? shape : null;
          this.m_vertices = polygon.m_vertices;
          this.m_count = polygon.m_vertexCount;
          this.m_radius = polygon.m_radius;
        }
        break;

      default:
        b2Settings.b2Assert(false);
    }
  };

  b2DistanceProxy.prototype.GetSupport = function (d) {
    var bestIndex = 0;
    var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;

    for (var i = 1; i < this.m_count; ++i) {
      var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;

      if (value > bestValue) {
        bestIndex = i;
        bestValue = value;
      }
    }

    return bestIndex;
  };

  b2DistanceProxy.prototype.GetSupportVertex = function (d) {
    var bestIndex = 0;
    var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;

    for (var i = 1; i < this.m_count; ++i) {
      var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;

      if (value > bestValue) {
        bestIndex = i;
        bestValue = value;
      }
    }

    return this.m_vertices[bestIndex];
  };

  b2DistanceProxy.prototype.GetVertexCount = function () {
    return this.m_count;
  };

  b2DistanceProxy.prototype.GetVertex = function (index) {
    if (index === undefined) index = 0;
    b2Settings.b2Assert(0 <= index && index < this.m_count);
    return this.m_vertices[index];
  };

  b2DynamicTree.b2DynamicTree = function () {};

  b2DynamicTree.prototype.b2DynamicTree = function () {
    this.m_root = null;
    this.m_freeList = null;
    this.m_path = 0;
    this.m_insertionCount = 0;
  };

  b2DynamicTree.prototype.CreateProxy = function (aabb, userData) {
    var node = this.AllocateNode();
    var extendX = b2Settings.b2_aabbExtension;
    var extendY = b2Settings.b2_aabbExtension;
    node.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
    node.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
    node.aabb.upperBound.x = aabb.upperBound.x + extendX;
    node.aabb.upperBound.y = aabb.upperBound.y + extendY;
    node.userData = userData;
    this.InsertLeaf(node);
    return node;
  };

  b2DynamicTree.prototype.DestroyProxy = function (proxy) {
    this.RemoveLeaf(proxy);
    this.FreeNode(proxy);
  };

  b2DynamicTree.prototype.MoveProxy = function (proxy, aabb, displacement) {
    b2Settings.b2Assert(proxy.IsLeaf());

    if (proxy.aabb.Contains(aabb)) {
      return false;
    }

    this.RemoveLeaf(proxy);
    var extendX = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : -displacement.x);
    var extendY = b2Settings.b2_aabbExtension + b2Settings.b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : -displacement.y);
    proxy.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
    proxy.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
    proxy.aabb.upperBound.x = aabb.upperBound.x + extendX;
    proxy.aabb.upperBound.y = aabb.upperBound.y + extendY;
    this.InsertLeaf(proxy);
    return true;
  };

  b2DynamicTree.prototype.Rebalance = function (iterations) {
    if (iterations === undefined) iterations = 0;
    if (this.m_root == null) return;

    for (var i = 0; i < iterations; i++) {
      var node = this.m_root;
      var bit = 0;

      while (node.IsLeaf() == false) {
        node = this.m_path >> bit & 1 ? node.child2 : node.child1;
        bit = bit + 1 & 31;
      }

      ++this.m_path;
      this.RemoveLeaf(node);
      this.InsertLeaf(node);
    }
  };

  b2DynamicTree.prototype.GetFatAABB = function (proxy) {
    return proxy.aabb;
  };

  b2DynamicTree.prototype.GetUserData = function (proxy) {
    return proxy.userData;
  };

  b2DynamicTree.prototype.Query = function (callback, aabb) {
    if (this.m_root == null) return;
    var stack = new Vector();
    var count = 0;
    stack[count++] = this.m_root;

    while (count > 0) {
      var node = stack[--count];

      if (node.aabb.TestOverlap(aabb)) {
        if (node.IsLeaf()) {
          var proceed = callback(node);
          if (!proceed) return;
        } else {
          stack[count++] = node.child1;
          stack[count++] = node.child2;
        }
      }
    }
  };

  b2DynamicTree.prototype.RayCast = function (callback, input) {
    if (this.m_root == null) return;
    var p1 = input.p1;
    var p2 = input.p2;
    var r = b2Math.SubtractVV(p1, p2);
    r.Normalize();
    var v = b2Math.CrossFV(1.0, r);
    var abs_v = b2Math.AbsV(v);
    var maxFraction = input.maxFraction;
    var segmentAABB = new b2AABB();
    var tX = 0;
    var tY = 0;
    {
      tX = p1.x + maxFraction * (p2.x - p1.x);
      tY = p1.y + maxFraction * (p2.y - p1.y);
      segmentAABB.lowerBound.x = Math.min(p1.x, tX);
      segmentAABB.lowerBound.y = Math.min(p1.y, tY);
      segmentAABB.upperBound.x = Math.max(p1.x, tX);
      segmentAABB.upperBound.y = Math.max(p1.y, tY);
    }
    var stack = new Vector();
    var count = 0;
    stack[count++] = this.m_root;

    while (count > 0) {
      var node = stack[--count];

      if (node.aabb.TestOverlap(segmentAABB) == false) {
        continue;
      }

      var c = node.aabb.GetCenter();
      var h = node.aabb.GetExtents();
      var separation = Math.abs(v.x * (p1.x - c.x) + v.y * (p1.y - c.y)) - abs_v.x * h.x - abs_v.y * h.y;
      if (separation > 0.0) continue;

      if (node.IsLeaf()) {
        var subInput = new b2RayCastInput();
        subInput.p1 = input.p1;
        subInput.p2 = input.p2;
        subInput.maxFraction = input.maxFraction;
        maxFraction = callback(subInput, node);
        if (maxFraction == 0.0) return;

        if (maxFraction > 0.0) {
          tX = p1.x + maxFraction * (p2.x - p1.x);
          tY = p1.y + maxFraction * (p2.y - p1.y);
          segmentAABB.lowerBound.x = Math.min(p1.x, tX);
          segmentAABB.lowerBound.y = Math.min(p1.y, tY);
          segmentAABB.upperBound.x = Math.max(p1.x, tX);
          segmentAABB.upperBound.y = Math.max(p1.y, tY);
        }
      } else {
        stack[count++] = node.child1;
        stack[count++] = node.child2;
      }
    }
  };

  b2DynamicTree.prototype.AllocateNode = function () {
    if (this.m_freeList) {
      var node = this.m_freeList;
      this.m_freeList = node.parent;
      node.parent = null;
      node.child1 = null;
      node.child2 = null;
      return node;
    }

    return new b2DynamicTreeNode();
  };

  b2DynamicTree.prototype.FreeNode = function (node) {
    node.parent = this.m_freeList;
    this.m_freeList = node;
  };

  b2DynamicTree.prototype.InsertLeaf = function (leaf) {
    ++this.m_insertionCount;

    if (this.m_root == null) {
      this.m_root = leaf;
      this.m_root.parent = null;
      return;
    }

    var center = leaf.aabb.GetCenter();
    var sibling = this.m_root;

    if (sibling.IsLeaf() == false) {
      do {
        var child1 = sibling.child1;
        var child2 = sibling.child2;
        var norm1 = Math.abs((child1.aabb.lowerBound.x + child1.aabb.upperBound.x) / 2 - center.x) + Math.abs((child1.aabb.lowerBound.y + child1.aabb.upperBound.y) / 2 - center.y);
        var norm2 = Math.abs((child2.aabb.lowerBound.x + child2.aabb.upperBound.x) / 2 - center.x) + Math.abs((child2.aabb.lowerBound.y + child2.aabb.upperBound.y) / 2 - center.y);

        if (norm1 < norm2) {
          sibling = child1;
        } else {
          sibling = child2;
        }
      } while (sibling.IsLeaf() == false);
    }

    var node1 = sibling.parent;
    var node2 = this.AllocateNode();
    node2.parent = node1;
    node2.userData = null;
    node2.aabb.Combine(leaf.aabb, sibling.aabb);

    if (node1) {
      if (sibling.parent.child1 == sibling) {
        node1.child1 = node2;
      } else {
        node1.child2 = node2;
      }

      node2.child1 = sibling;
      node2.child2 = leaf;
      sibling.parent = node2;
      leaf.parent = node2;

      do {
        if (node1.aabb.Contains(node2.aabb)) break;
        node1.aabb.Combine(node1.child1.aabb, node1.child2.aabb);
        node2 = node1;
        node1 = node1.parent;
      } while (node1);
    } else {
      node2.child1 = sibling;
      node2.child2 = leaf;
      sibling.parent = node2;
      leaf.parent = node2;
      this.m_root = node2;
    }
  };

  b2DynamicTree.prototype.RemoveLeaf = function (leaf) {
    if (leaf == this.m_root) {
      this.m_root = null;
      return;
    }

    var node2 = leaf.parent;
    var node1 = node2.parent;
    var sibling;

    if (node2.child1 == leaf) {
      sibling = node2.child2;
    } else {
      sibling = node2.child1;
    }

    if (node1) {
      if (node1.child1 == node2) {
        node1.child1 = sibling;
      } else {
        node1.child2 = sibling;
      }

      sibling.parent = node1;
      this.FreeNode(node2);

      while (node1) {
        var oldAABB = node1.aabb;
        node1.aabb = b2AABB.Combine(node1.child1.aabb, node1.child2.aabb);
        if (oldAABB.Contains(node1.aabb)) break;
        node1 = node1.parent;
      }
    } else {
      this.m_root = sibling;
      sibling.parent = null;
      this.FreeNode(node2);
    }
  };

  b2DynamicTreeBroadPhase.b2DynamicTreeBroadPhase = function () {
    this.m_tree = new b2DynamicTree();
    this.m_moveBuffer = new Vector();
    this.m_pairBuffer = new Vector();
    this.m_pairCount = 0;
  };

  b2DynamicTreeBroadPhase.prototype.CreateProxy = function (aabb, userData) {
    var proxy = this.m_tree.CreateProxy(aabb, userData);
    ++this.m_proxyCount;
    this.BufferMove(proxy);
    return proxy;
  };

  b2DynamicTreeBroadPhase.prototype.DestroyProxy = function (proxy) {
    this.UnBufferMove(proxy);
    --this.m_proxyCount;
    this.m_tree.DestroyProxy(proxy);
  };

  b2DynamicTreeBroadPhase.prototype.MoveProxy = function (proxy, aabb, displacement) {
    var buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);

    if (buffer) {
      this.BufferMove(proxy);
    }
  };

  b2DynamicTreeBroadPhase.prototype.TestOverlap = function (proxyA, proxyB) {
    var aabbA = this.m_tree.GetFatAABB(proxyA);
    var aabbB = this.m_tree.GetFatAABB(proxyB);
    return aabbA.TestOverlap(aabbB);
  };

  b2DynamicTreeBroadPhase.prototype.GetUserData = function (proxy) {
    return this.m_tree.GetUserData(proxy);
  };

  b2DynamicTreeBroadPhase.prototype.GetFatAABB = function (proxy) {
    return this.m_tree.GetFatAABB(proxy);
  };

  b2DynamicTreeBroadPhase.prototype.GetProxyCount = function () {
    return this.m_proxyCount;
  };

  b2DynamicTreeBroadPhase.prototype.UpdatePairs = function (callback) {
    var __this = this;

    __this.m_pairCount = 0;
    var i = 0,
        queryProxy;

    function QueryCallback(proxy) {
      if (proxy == queryProxy) return true;

      if (__this.m_pairCount == __this.m_pairBuffer.length) {
        __this.m_pairBuffer[__this.m_pairCount] = new b2DynamicTreePair();
      }

      var pair = __this.m_pairBuffer[__this.m_pairCount];
      pair.proxyA = proxy < queryProxy ? proxy : queryProxy;
      pair.proxyB = proxy >= queryProxy ? proxy : queryProxy;
      ++__this.m_pairCount;
      return true;
    }

    ;

    for (i = 0; i < __this.m_moveBuffer.length; ++i) {
      queryProxy = __this.m_moveBuffer[i];

      var fatAABB = __this.m_tree.GetFatAABB(queryProxy);

      __this.m_tree.Query(QueryCallback, fatAABB);
    }

    __this.m_moveBuffer.length = 0;

    for (var i = 0; i < __this.m_pairCount;) {
      var primaryPair = __this.m_pairBuffer[i];

      var userDataA = __this.m_tree.GetUserData(primaryPair.proxyA);

      var userDataB = __this.m_tree.GetUserData(primaryPair.proxyB);

      callback(userDataA, userDataB);
      ++i;

      while (i < __this.m_pairCount) {
        var pair = __this.m_pairBuffer[i];

        if (pair.proxyA != primaryPair.proxyA || pair.proxyB != primaryPair.proxyB) {
          break;
        }

        ++i;
      }
    }
  };

  b2DynamicTreeBroadPhase.prototype.Query = function (callback, aabb) {
    this.m_tree.Query(callback, aabb);
  };

  b2DynamicTreeBroadPhase.prototype.RayCast = function (callback, input) {
    this.m_tree.RayCast(callback, input);
  };

  b2DynamicTreeBroadPhase.prototype.Validate = function () {};

  b2DynamicTreeBroadPhase.prototype.Rebalance = function (iterations) {
    if (iterations === undefined) iterations = 0;
    this.m_tree.Rebalance(iterations);
  };

  b2DynamicTreeBroadPhase.prototype.BufferMove = function (proxy) {
    this.m_moveBuffer[this.m_moveBuffer.length] = proxy;
  };

  b2DynamicTreeBroadPhase.prototype.UnBufferMove = function (proxy) {
    var i = parseInt(this.m_moveBuffer.indexOf(proxy));
    this.m_moveBuffer.splice(i, 1);
  };

  b2DynamicTreeBroadPhase.prototype.ComparePairs = function (pair1, pair2) {
    return 0;
  };

  b2DynamicTreeBroadPhase.__implements = {};
  b2DynamicTreeBroadPhase.__implements[IBroadPhase] = true;

  b2DynamicTreeNode.b2DynamicTreeNode = function () {
    this.aabb = new b2AABB();
  };

  b2DynamicTreeNode.prototype.IsLeaf = function () {
    return this.child1 == null;
  };

  b2DynamicTreePair.b2DynamicTreePair = function () {};

  b2Manifold.b2Manifold = function () {
    this.m_pointCount = 0;
  };

  b2Manifold.prototype.b2Manifold = function () {
    this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);

    for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
      this.m_points[i] = new b2ManifoldPoint();
    }

    this.m_localPlaneNormal = new b2Vec2();
    this.m_localPoint = new b2Vec2();
  };

  b2Manifold.prototype.Reset = function () {
    for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
      (this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null).Reset();
    }

    this.m_localPlaneNormal.SetZero();
    this.m_localPoint.SetZero();
    this.m_type = 0;
    this.m_pointCount = 0;
  };

  b2Manifold.prototype.Set = function (m) {
    this.m_pointCount = m.m_pointCount;

    for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
      (this.m_points[i] instanceof b2ManifoldPoint ? this.m_points[i] : null).Set(m.m_points[i]);
    }

    this.m_localPlaneNormal.SetV(m.m_localPlaneNormal);
    this.m_localPoint.SetV(m.m_localPoint);
    this.m_type = m.m_type;
  };

  b2Manifold.prototype.Copy = function () {
    var copy = new b2Manifold();
    copy.Set(this);
    return copy;
  };

  Box2D.postDefs.push(function () {
    Box2D.Collision.b2Manifold.e_circles = 0x0001;
    Box2D.Collision.b2Manifold.e_faceA = 0x0002;
    Box2D.Collision.b2Manifold.e_faceB = 0x0004;
  });

  b2ManifoldPoint.b2ManifoldPoint = function () {
    this.m_localPoint = new b2Vec2();
    this.m_id = new b2ContactID();
  };

  b2ManifoldPoint.prototype.b2ManifoldPoint = function () {
    this.Reset();
  };

  b2ManifoldPoint.prototype.Reset = function () {
    this.m_localPoint.SetZero();
    this.m_normalImpulse = 0.0;
    this.m_tangentImpulse = 0.0;
    this.m_id.key = 0;
  };

  b2ManifoldPoint.prototype.Set = function (m) {
    this.m_localPoint.SetV(m.m_localPoint);
    this.m_normalImpulse = m.m_normalImpulse;
    this.m_tangentImpulse = m.m_tangentImpulse;
    this.m_id.Set(m.m_id);
  };

  b2Point.b2Point = function () {
    this.p = new b2Vec2();
  };

  b2Point.prototype.Support = function (xf, vX, vY) {
    if (vX === undefined) vX = 0;
    if (vY === undefined) vY = 0;
    return this.p;
  };

  b2Point.prototype.GetFirstVertex = function (xf) {
    return this.p;
  };

  b2RayCastInput.b2RayCastInput = function () {
    this.p1 = new b2Vec2();
    this.p2 = new b2Vec2();
  };

  b2RayCastInput.prototype.b2RayCastInput = function (p1, p2, maxFraction) {
    if (p1 === undefined) p1 = null;
    if (p2 === undefined) p2 = null;
    if (maxFraction === undefined) maxFraction = 1;
    if (p1) this.p1.SetV(p1);
    if (p2) this.p2.SetV(p2);
    this.maxFraction = maxFraction;
  };

  b2RayCastOutput.b2RayCastOutput = function () {
    this.normal = new b2Vec2();
  };

  b2Segment.b2Segment = function () {
    this.p1 = new b2Vec2();
    this.p2 = new b2Vec2();
  };

  b2Segment.prototype.TestSegment = function (lambda, normal, segment, maxLambda) {
    if (maxLambda === undefined) maxLambda = 0;
    var s = segment.p1;
    var rX = segment.p2.x - s.x;
    var rY = segment.p2.y - s.y;
    var dX = this.p2.x - this.p1.x;
    var dY = this.p2.y - this.p1.y;
    var nX = dY;
    var nY = -dX;
    var k_slop = 100.0 * Number.MIN_VALUE;
    var denom = -(rX * nX + rY * nY);

    if (denom > k_slop) {
      var bX = s.x - this.p1.x;
      var bY = s.y - this.p1.y;
      var a = bX * nX + bY * nY;

      if (0.0 <= a && a <= maxLambda * denom) {
        var mu2 = -rX * bY + rY * bX;

        if (-k_slop * denom <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
          a /= denom;
          var nLen = Math.sqrt(nX * nX + nY * nY);
          nX /= nLen;
          nY /= nLen;
          lambda[0] = a;
          normal.Set(nX, nY);
          return true;
        }
      }
    }

    return false;
  };

  b2Segment.prototype.Extend = function (aabb) {
    this.ExtendForward(aabb);
    this.ExtendBackward(aabb);
  };

  b2Segment.prototype.ExtendForward = function (aabb) {
    var dX = this.p2.x - this.p1.x;
    var dY = this.p2.y - this.p1.y;
    var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p1.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p1.x) / dX : Number.POSITIVE_INFINITY, dY > 0 ? (aabb.upperBound.y - this.p1.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p1.y) / dY : Number.POSITIVE_INFINITY);
    this.p2.x = this.p1.x + dX * lambda;
    this.p2.y = this.p1.y + dY * lambda;
  };

  b2Segment.prototype.ExtendBackward = function (aabb) {
    var dX = -this.p2.x + this.p1.x;
    var dY = -this.p2.y + this.p1.y;
    var lambda = Math.min(dX > 0 ? (aabb.upperBound.x - this.p2.x) / dX : dX < 0 ? (aabb.lowerBound.x - this.p2.x) / dX : Number.POSITIVE_INFINITY, dY > 0 ? (aabb.upperBound.y - this.p2.y) / dY : dY < 0 ? (aabb.lowerBound.y - this.p2.y) / dY : Number.POSITIVE_INFINITY);
    this.p1.x = this.p2.x + dX * lambda;
    this.p1.y = this.p2.y + dY * lambda;
  };

  b2SeparationFunction.b2SeparationFunction = function () {
    this.m_localPoint = new b2Vec2();
    this.m_axis = new b2Vec2();
  };

  b2SeparationFunction.prototype.Initialize = function (cache, proxyA, transformA, proxyB, transformB) {
    this.m_proxyA = proxyA;
    this.m_proxyB = proxyB;
    var count = parseInt(cache.count);
    b2Settings.b2Assert(0 < count && count < 3);
    var localPointA;
    var localPointA1;
    var localPointA2;
    var localPointB;
    var localPointB1;
    var localPointB2;
    var pointAX = 0;
    var pointAY = 0;
    var pointBX = 0;
    var pointBY = 0;
    var normalX = 0;
    var normalY = 0;
    var tMat;
    var tVec;
    var s = 0;
    var sgn = 0;

    if (count == 1) {
      this.m_type = b2SeparationFunction.e_points;
      localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
      localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
      tVec = localPointA;
      tMat = transformA.R;
      pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tVec = localPointB;
      tMat = transformB.R;
      pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      this.m_axis.x = pointBX - pointAX;
      this.m_axis.y = pointBY - pointAY;
      this.m_axis.Normalize();
    } else if (cache.indexB[0] == cache.indexB[1]) {
      this.m_type = b2SeparationFunction.e_faceA;
      localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
      localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
      localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);
      this.m_localPoint.x = 0.5 * (localPointA1.x + localPointA2.x);
      this.m_localPoint.y = 0.5 * (localPointA1.y + localPointA2.y);
      this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
      this.m_axis.Normalize();
      tVec = this.m_axis;
      tMat = transformA.R;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tVec = this.m_localPoint;
      tMat = transformA.R;
      pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tVec = localPointB;
      tMat = transformB.R;
      pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      s = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;

      if (s < 0.0) {
        this.m_axis.NegativeSelf();
      }
    } else if (cache.indexA[0] == cache.indexA[0]) {
      this.m_type = b2SeparationFunction.e_faceB;
      localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
      localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
      localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);
      this.m_localPoint.x = 0.5 * (localPointB1.x + localPointB2.x);
      this.m_localPoint.y = 0.5 * (localPointB1.y + localPointB2.y);
      this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
      this.m_axis.Normalize();
      tVec = this.m_axis;
      tMat = transformB.R;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tVec = this.m_localPoint;
      tMat = transformB.R;
      pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tVec = localPointA;
      tMat = transformA.R;
      pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      s = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;

      if (s < 0.0) {
        this.m_axis.NegativeSelf();
      }
    } else {
      localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);
      localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);
      localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);
      localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);
      var pA = b2Math.MulX(transformA, localPointA);
      var dA = b2Math.MulMV(transformA.R, b2Math.SubtractVV(localPointA2, localPointA1));
      var pB = b2Math.MulX(transformB, localPointB);
      var dB = b2Math.MulMV(transformB.R, b2Math.SubtractVV(localPointB2, localPointB1));
      var a = dA.x * dA.x + dA.y * dA.y;
      var e = dB.x * dB.x + dB.y * dB.y;
      var r = b2Math.SubtractVV(dB, dA);
      var c = dA.x * r.x + dA.y * r.y;
      var f = dB.x * r.x + dB.y * r.y;
      var b = dA.x * dB.x + dA.y * dB.y;
      var denom = a * e - b * b;
      s = 0.0;

      if (denom != 0.0) {
        s = b2Math.Clamp((b * f - c * e) / denom, 0.0, 1.0);
      }

      var t = (b * s + f) / e;

      if (t < 0.0) {
        t = 0.0;
        s = b2Math.Clamp((b - c) / a, 0.0, 1.0);
      }

      localPointA = new b2Vec2();
      localPointA.x = localPointA1.x + s * (localPointA2.x - localPointA1.x);
      localPointA.y = localPointA1.y + s * (localPointA2.y - localPointA1.y);
      localPointB = new b2Vec2();
      localPointB.x = localPointB1.x + s * (localPointB2.x - localPointB1.x);
      localPointB.y = localPointB1.y + s * (localPointB2.y - localPointB1.y);

      if (s == 0.0 || s == 1.0) {
        this.m_type = b2SeparationFunction.e_faceB;
        this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
        this.m_axis.Normalize();
        this.m_localPoint = localPointB;
        tVec = this.m_axis;
        tMat = transformB.R;
        normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        tVec = this.m_localPoint;
        tMat = transformB.R;
        pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tVec = localPointA;
        tMat = transformA.R;
        pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        sgn = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;

        if (s < 0.0) {
          this.m_axis.NegativeSelf();
        }
      } else {
        this.m_type = b2SeparationFunction.e_faceA;
        this.m_axis = b2Math.CrossVF(b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
        this.m_localPoint = localPointA;
        tVec = this.m_axis;
        tMat = transformA.R;
        normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        tVec = this.m_localPoint;
        tMat = transformA.R;
        pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        tVec = localPointB;
        tMat = transformB.R;
        pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
        pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
        sgn = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;

        if (s < 0.0) {
          this.m_axis.NegativeSelf();
        }
      }
    }
  };

  b2SeparationFunction.prototype.Evaluate = function (transformA, transformB) {
    var axisA;
    var axisB;
    var localPointA;
    var localPointB;
    var pointA;
    var pointB;
    var seperation = 0;
    var normal;

    switch (this.m_type) {
      case b2SeparationFunction.e_points:
        {
          axisA = b2Math.MulTMV(transformA.R, this.m_axis);
          axisB = b2Math.MulTMV(transformB.R, this.m_axis.GetNegative());
          localPointA = this.m_proxyA.GetSupportVertex(axisA);
          localPointB = this.m_proxyB.GetSupportVertex(axisB);
          pointA = b2Math.MulX(transformA, localPointA);
          pointB = b2Math.MulX(transformB, localPointB);
          seperation = (pointB.x - pointA.x) * this.m_axis.x + (pointB.y - pointA.y) * this.m_axis.y;
          return seperation;
        }

      case b2SeparationFunction.e_faceA:
        {
          normal = b2Math.MulMV(transformA.R, this.m_axis);
          pointA = b2Math.MulX(transformA, this.m_localPoint);
          axisB = b2Math.MulTMV(transformB.R, normal.GetNegative());
          localPointB = this.m_proxyB.GetSupportVertex(axisB);
          pointB = b2Math.MulX(transformB, localPointB);
          seperation = (pointB.x - pointA.x) * normal.x + (pointB.y - pointA.y) * normal.y;
          return seperation;
        }

      case b2SeparationFunction.e_faceB:
        {
          normal = b2Math.MulMV(transformB.R, this.m_axis);
          pointB = b2Math.MulX(transformB, this.m_localPoint);
          axisA = b2Math.MulTMV(transformA.R, normal.GetNegative());
          localPointA = this.m_proxyA.GetSupportVertex(axisA);
          pointA = b2Math.MulX(transformA, localPointA);
          seperation = (pointA.x - pointB.x) * normal.x + (pointA.y - pointB.y) * normal.y;
          return seperation;
        }

      default:
        b2Settings.b2Assert(false);
        return 0.0;
    }
  };

  Box2D.postDefs.push(function () {
    Box2D.Collision.b2SeparationFunction.e_points = 0x01;
    Box2D.Collision.b2SeparationFunction.e_faceA = 0x02;
    Box2D.Collision.b2SeparationFunction.e_faceB = 0x04;
  });

  b2Simplex.b2Simplex = function () {
    this.m_v1 = new b2SimplexVertex();
    this.m_v2 = new b2SimplexVertex();
    this.m_v3 = new b2SimplexVertex();
    this.m_vertices = new Vector(3);
  };

  b2Simplex.prototype.b2Simplex = function () {
    this.m_vertices[0] = this.m_v1;
    this.m_vertices[1] = this.m_v2;
    this.m_vertices[2] = this.m_v3;
  };

  b2Simplex.prototype.ReadCache = function (cache, proxyA, transformA, proxyB, transformB) {
    b2Settings.b2Assert(0 <= cache.count && cache.count <= 3);
    var wALocal;
    var wBLocal;
    this.m_count = cache.count;
    var vertices = this.m_vertices;

    for (var i = 0; i < this.m_count; i++) {
      var v = vertices[i];
      v.indexA = cache.indexA[i];
      v.indexB = cache.indexB[i];
      wALocal = proxyA.GetVertex(v.indexA);
      wBLocal = proxyB.GetVertex(v.indexB);
      v.wA = b2Math.MulX(transformA, wALocal);
      v.wB = b2Math.MulX(transformB, wBLocal);
      v.w = b2Math.SubtractVV(v.wB, v.wA);
      v.a = 0;
    }

    if (this.m_count > 1) {
      var metric1 = cache.metric;
      var metric2 = this.GetMetric();

      if (metric2 < .5 * metric1 || 2.0 * metric1 < metric2 || metric2 < Number.MIN_VALUE) {
        this.m_count = 0;
      }
    }

    if (this.m_count == 0) {
      v = vertices[0];
      v.indexA = 0;
      v.indexB = 0;
      wALocal = proxyA.GetVertex(0);
      wBLocal = proxyB.GetVertex(0);
      v.wA = b2Math.MulX(transformA, wALocal);
      v.wB = b2Math.MulX(transformB, wBLocal);
      v.w = b2Math.SubtractVV(v.wB, v.wA);
      this.m_count = 1;
    }
  };

  b2Simplex.prototype.WriteCache = function (cache) {
    cache.metric = this.GetMetric();
    cache.count = Box2D.parseUInt(this.m_count);
    var vertices = this.m_vertices;

    for (var i = 0; i < this.m_count; i++) {
      cache.indexA[i] = Box2D.parseUInt(vertices[i].indexA);
      cache.indexB[i] = Box2D.parseUInt(vertices[i].indexB);
    }
  };

  b2Simplex.prototype.GetSearchDirection = function () {
    switch (this.m_count) {
      case 1:
        return this.m_v1.w.GetNegative();

      case 2:
        {
          var e12 = b2Math.SubtractVV(this.m_v2.w, this.m_v1.w);
          var sgn = b2Math.CrossVV(e12, this.m_v1.w.GetNegative());

          if (sgn > 0.0) {
            return b2Math.CrossFV(1.0, e12);
          } else {
            return b2Math.CrossVF(e12, 1.0);
          }
        }

      default:
        b2Settings.b2Assert(false);
        return new b2Vec2();
    }
  };

  b2Simplex.prototype.GetClosestPoint = function () {
    switch (this.m_count) {
      case 0:
        b2Settings.b2Assert(false);
        return new b2Vec2();

      case 1:
        return this.m_v1.w;

      case 2:
        return new b2Vec2(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);

      default:
        b2Settings.b2Assert(false);
        return new b2Vec2();
    }
  };

  b2Simplex.prototype.GetWitnessPoints = function (pA, pB) {
    switch (this.m_count) {
      case 0:
        b2Settings.b2Assert(false);
        break;

      case 1:
        pA.SetV(this.m_v1.wA);
        pB.SetV(this.m_v1.wB);
        break;

      case 2:
        pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;
        pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;
        pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;
        pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;
        break;

      case 3:
        pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;
        pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;
        break;

      default:
        b2Settings.b2Assert(false);
        break;
    }
  };

  b2Simplex.prototype.GetMetric = function () {
    switch (this.m_count) {
      case 0:
        b2Settings.b2Assert(false);
        return 0.0;

      case 1:
        return 0.0;

      case 2:
        return b2Math.SubtractVV(this.m_v1.w, this.m_v2.w).Length();

      case 3:
        return b2Math.CrossVV(b2Math.SubtractVV(this.m_v2.w, this.m_v1.w), b2Math.SubtractVV(this.m_v3.w, this.m_v1.w));

      default:
        b2Settings.b2Assert(false);
        return 0.0;
    }
  };

  b2Simplex.prototype.Solve2 = function () {
    var w1 = this.m_v1.w;
    var w2 = this.m_v2.w;
    var e12 = b2Math.SubtractVV(w2, w1);
    var d12_2 = -(w1.x * e12.x + w1.y * e12.y);

    if (d12_2 <= 0.0) {
      this.m_v1.a = 1.0;
      this.m_count = 1;
      return;
    }

    var d12_1 = w2.x * e12.x + w2.y * e12.y;

    if (d12_1 <= 0.0) {
      this.m_v2.a = 1.0;
      this.m_count = 1;
      this.m_v1.Set(this.m_v2);
      return;
    }

    var inv_d12 = 1.0 / (d12_1 + d12_2);
    this.m_v1.a = d12_1 * inv_d12;
    this.m_v2.a = d12_2 * inv_d12;
    this.m_count = 2;
  };

  b2Simplex.prototype.Solve3 = function () {
    var w1 = this.m_v1.w;
    var w2 = this.m_v2.w;
    var w3 = this.m_v3.w;
    var e12 = b2Math.SubtractVV(w2, w1);
    var w1e12 = b2Math.Dot(w1, e12);
    var w2e12 = b2Math.Dot(w2, e12);
    var d12_1 = w2e12;
    var d12_2 = -w1e12;
    var e13 = b2Math.SubtractVV(w3, w1);
    var w1e13 = b2Math.Dot(w1, e13);
    var w3e13 = b2Math.Dot(w3, e13);
    var d13_1 = w3e13;
    var d13_2 = -w1e13;
    var e23 = b2Math.SubtractVV(w3, w2);
    var w2e23 = b2Math.Dot(w2, e23);
    var w3e23 = b2Math.Dot(w3, e23);
    var d23_1 = w3e23;
    var d23_2 = -w2e23;
    var n123 = b2Math.CrossVV(e12, e13);
    var d123_1 = n123 * b2Math.CrossVV(w2, w3);
    var d123_2 = n123 * b2Math.CrossVV(w3, w1);
    var d123_3 = n123 * b2Math.CrossVV(w1, w2);

    if (d12_2 <= 0.0 && d13_2 <= 0.0) {
      this.m_v1.a = 1.0;
      this.m_count = 1;
      return;
    }

    if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {
      var inv_d12 = 1.0 / (d12_1 + d12_2);
      this.m_v1.a = d12_1 * inv_d12;
      this.m_v2.a = d12_2 * inv_d12;
      this.m_count = 2;
      return;
    }

    if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {
      var inv_d13 = 1.0 / (d13_1 + d13_2);
      this.m_v1.a = d13_1 * inv_d13;
      this.m_v3.a = d13_2 * inv_d13;
      this.m_count = 2;
      this.m_v2.Set(this.m_v3);
      return;
    }

    if (d12_1 <= 0.0 && d23_2 <= 0.0) {
      this.m_v2.a = 1.0;
      this.m_count = 1;
      this.m_v1.Set(this.m_v2);
      return;
    }

    if (d13_1 <= 0.0 && d23_1 <= 0.0) {
      this.m_v3.a = 1.0;
      this.m_count = 1;
      this.m_v1.Set(this.m_v3);
      return;
    }

    if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {
      var inv_d23 = 1.0 / (d23_1 + d23_2);
      this.m_v2.a = d23_1 * inv_d23;
      this.m_v3.a = d23_2 * inv_d23;
      this.m_count = 2;
      this.m_v1.Set(this.m_v3);
      return;
    }

    var inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);
    this.m_v1.a = d123_1 * inv_d123;
    this.m_v2.a = d123_2 * inv_d123;
    this.m_v3.a = d123_3 * inv_d123;
    this.m_count = 3;
  };

  b2SimplexCache.b2SimplexCache = function () {
    this.indexA = new Vector_a2j_Number(3);
    this.indexB = new Vector_a2j_Number(3);
  };

  b2SimplexVertex.b2SimplexVertex = function () {};

  b2SimplexVertex.prototype.Set = function (other) {
    this.wA.SetV(other.wA);
    this.wB.SetV(other.wB);
    this.w.SetV(other.w);
    this.a = other.a;
    this.indexA = other.indexA;
    this.indexB = other.indexB;
  };

  b2TimeOfImpact.b2TimeOfImpact = function () {};

  b2TimeOfImpact.TimeOfImpact = function (input) {
    ++b2TimeOfImpact.b2_toiCalls;
    var proxyA = input.proxyA;
    var proxyB = input.proxyB;
    var sweepA = input.sweepA;
    var sweepB = input.sweepB;
    b2Settings.b2Assert(sweepA.t0 == sweepB.t0);
    b2Settings.b2Assert(1.0 - sweepA.t0 > Number.MIN_VALUE);
    var radius = proxyA.m_radius + proxyB.m_radius;
    var tolerance = input.tolerance;
    var alpha = 0.0;
    var k_maxIterations = 1000;
    var iter = 0;
    var target = 0.0;
    b2TimeOfImpact.s_cache.count = 0;
    b2TimeOfImpact.s_distanceInput.useRadii = false;

    for (;;) {
      sweepA.GetTransform(b2TimeOfImpact.s_xfA, alpha);
      sweepB.GetTransform(b2TimeOfImpact.s_xfB, alpha);
      b2TimeOfImpact.s_distanceInput.proxyA = proxyA;
      b2TimeOfImpact.s_distanceInput.proxyB = proxyB;
      b2TimeOfImpact.s_distanceInput.transformA = b2TimeOfImpact.s_xfA;
      b2TimeOfImpact.s_distanceInput.transformB = b2TimeOfImpact.s_xfB;
      b2Distance.Distance(b2TimeOfImpact.s_distanceOutput, b2TimeOfImpact.s_cache, b2TimeOfImpact.s_distanceInput);

      if (b2TimeOfImpact.s_distanceOutput.distance <= 0.0) {
        alpha = 1.0;
        break;
      }

      b2TimeOfImpact.s_fcn.Initialize(b2TimeOfImpact.s_cache, proxyA, b2TimeOfImpact.s_xfA, proxyB, b2TimeOfImpact.s_xfB);
      var separation = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);

      if (separation <= 0.0) {
        alpha = 1.0;
        break;
      }

      if (iter == 0) {
        if (separation > radius) {
          target = b2Math.Max(radius - tolerance, 0.75 * radius);
        } else {
          target = b2Math.Max(separation - tolerance, 0.02 * radius);
        }
      }

      if (separation - target < 0.5 * tolerance) {
        if (iter == 0) {
          alpha = 1.0;
          break;
        }

        break;
      }

      var newAlpha = alpha;
      {
        var x1 = alpha;
        var x2 = 1.0;
        var f1 = separation;
        sweepA.GetTransform(b2TimeOfImpact.s_xfA, x2);
        sweepB.GetTransform(b2TimeOfImpact.s_xfB, x2);
        var f2 = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);

        if (f2 >= target) {
          alpha = 1.0;
          break;
        }

        var rootIterCount = 0;

        for (;;) {
          var x = 0;

          if (rootIterCount & 1) {
            x = x1 + (target - f1) * (x2 - x1) / (f2 - f1);
          } else {
            x = 0.5 * (x1 + x2);
          }

          sweepA.GetTransform(b2TimeOfImpact.s_xfA, x);
          sweepB.GetTransform(b2TimeOfImpact.s_xfB, x);
          var f = b2TimeOfImpact.s_fcn.Evaluate(b2TimeOfImpact.s_xfA, b2TimeOfImpact.s_xfB);

          if (b2Math.Abs(f - target) < 0.025 * tolerance) {
            newAlpha = x;
            break;
          }

          if (f > target) {
            x1 = x;
            f1 = f;
          } else {
            x2 = x;
            f2 = f;
          }

          ++rootIterCount;
          ++b2TimeOfImpact.b2_toiRootIters;

          if (rootIterCount == 50) {
            break;
          }
        }

        b2TimeOfImpact.b2_toiMaxRootIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxRootIters, rootIterCount);
      }

      if (newAlpha < (1.0 + 100.0 * Number.MIN_VALUE) * alpha) {
        break;
      }

      alpha = newAlpha;
      iter++;
      ++b2TimeOfImpact.b2_toiIters;

      if (iter == k_maxIterations) {
        break;
      }
    }

    b2TimeOfImpact.b2_toiMaxIters = b2Math.Max(b2TimeOfImpact.b2_toiMaxIters, iter);
    return alpha;
  };

  Box2D.postDefs.push(function () {
    Box2D.Collision.b2TimeOfImpact.b2_toiCalls = 0;
    Box2D.Collision.b2TimeOfImpact.b2_toiIters = 0;
    Box2D.Collision.b2TimeOfImpact.b2_toiMaxIters = 0;
    Box2D.Collision.b2TimeOfImpact.b2_toiRootIters = 0;
    Box2D.Collision.b2TimeOfImpact.b2_toiMaxRootIters = 0;
    Box2D.Collision.b2TimeOfImpact.s_cache = new b2SimplexCache();
    Box2D.Collision.b2TimeOfImpact.s_distanceInput = new b2DistanceInput();
    Box2D.Collision.b2TimeOfImpact.s_xfA = new b2Transform();
    Box2D.Collision.b2TimeOfImpact.s_xfB = new b2Transform();
    Box2D.Collision.b2TimeOfImpact.s_fcn = new b2SeparationFunction();
    Box2D.Collision.b2TimeOfImpact.s_distanceOutput = new b2DistanceOutput();
  });

  b2TOIInput.b2TOIInput = function () {
    this.proxyA = new b2DistanceProxy();
    this.proxyB = new b2DistanceProxy();
    this.sweepA = new b2Sweep();
    this.sweepB = new b2Sweep();
  };

  b2WorldManifold.b2WorldManifold = function () {
    this.m_normal = new b2Vec2();
  };

  b2WorldManifold.prototype.b2WorldManifold = function () {
    this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);

    for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
      this.m_points[i] = new b2Vec2();
    }
  };

  b2WorldManifold.prototype.Initialize = function (manifold, xfA, radiusA, xfB, radiusB) {
    if (radiusA === undefined) radiusA = 0;
    if (radiusB === undefined) radiusB = 0;

    if (manifold.m_pointCount == 0) {
      return;
    }

    var i = 0;
    var tVec;
    var tMat;
    var normalX = 0;
    var normalY = 0;
    var planePointX = 0;
    var planePointY = 0;
    var clipPointX = 0;
    var clipPointY = 0;

    switch (manifold.m_type) {
      case b2Manifold.e_circles:
        {
          tMat = xfA.R;
          tVec = manifold.m_localPoint;
          var pointAX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
          var pointAY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
          tMat = xfB.R;
          tVec = manifold.m_points[0].m_localPoint;
          var pointBX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
          var pointBY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
          var dX = pointBX - pointAX;
          var dY = pointBY - pointAY;
          var d2 = dX * dX + dY * dY;

          if (d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
            var d = Math.sqrt(d2);
            this.m_normal.x = dX / d;
            this.m_normal.y = dY / d;
          } else {
            this.m_normal.x = 1;
            this.m_normal.y = 0;
          }

          var cAX = pointAX + radiusA * this.m_normal.x;
          var cAY = pointAY + radiusA * this.m_normal.y;
          var cBX = pointBX - radiusB * this.m_normal.x;
          var cBY = pointBY - radiusB * this.m_normal.y;
          this.m_points[0].x = 0.5 * (cAX + cBX);
          this.m_points[0].y = 0.5 * (cAY + cBY);
        }
        break;

      case b2Manifold.e_faceA:
        {
          tMat = xfA.R;
          tVec = manifold.m_localPlaneNormal;
          normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
          normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
          tMat = xfA.R;
          tVec = manifold.m_localPoint;
          planePointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
          planePointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
          this.m_normal.x = normalX;
          this.m_normal.y = normalY;

          for (i = 0; i < manifold.m_pointCount; i++) {
            tMat = xfB.R;
            tVec = manifold.m_points[i].m_localPoint;
            clipPointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            clipPointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            this.m_points[i].x = clipPointX + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalX;
            this.m_points[i].y = clipPointY + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalY;
          }
        }
        break;

      case b2Manifold.e_faceB:
        {
          tMat = xfB.R;
          tVec = manifold.m_localPlaneNormal;
          normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
          normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
          tMat = xfB.R;
          tVec = manifold.m_localPoint;
          planePointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
          planePointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
          this.m_normal.x = -normalX;
          this.m_normal.y = -normalY;

          for (i = 0; i < manifold.m_pointCount; i++) {
            tMat = xfA.R;
            tVec = manifold.m_points[i].m_localPoint;
            clipPointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
            clipPointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
            this.m_points[i].x = clipPointX + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalX;
            this.m_points[i].y = clipPointY + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalY;
          }
        }
        break;
    }
  };

  ClipVertex.ClipVertex = function () {
    this.v = new b2Vec2();
    this.id = new b2ContactID();
  };

  ClipVertex.prototype.Set = function (other) {
    this.v.SetV(other.v);
    this.id.Set(other.id);
  };

  Features.Features = function () {};

  Object.defineProperty(Features.prototype, 'referenceEdge', {
    enumerable: false,
    configurable: true,
    get: function get() {
      return this._referenceEdge;
    }
  });
  Object.defineProperty(Features.prototype, 'referenceEdge', {
    enumerable: false,
    configurable: true,
    set: function set(value) {
      if (value === undefined) value = 0;
      this._referenceEdge = value;
      this._m_id._key = this._m_id._key & 0xffffff00 | this._referenceEdge & 0x000000ff;
    }
  });
  Object.defineProperty(Features.prototype, 'incidentEdge', {
    enumerable: false,
    configurable: true,
    get: function get() {
      return this._incidentEdge;
    }
  });
  Object.defineProperty(Features.prototype, 'incidentEdge', {
    enumerable: false,
    configurable: true,
    set: function set(value) {
      if (value === undefined) value = 0;
      this._incidentEdge = value;
      this._m_id._key = this._m_id._key & 0xffff00ff | this._incidentEdge << 8 & 0x0000ff00;
    }
  });
  Object.defineProperty(Features.prototype, 'incidentVertex', {
    enumerable: false,
    configurable: true,
    get: function get() {
      return this._incidentVertex;
    }
  });
  Object.defineProperty(Features.prototype, 'incidentVertex', {
    enumerable: false,
    configurable: true,
    set: function set(value) {
      if (value === undefined) value = 0;
      this._incidentVertex = value;
      this._m_id._key = this._m_id._key & 0xff00ffff | this._incidentVertex << 16 & 0x00ff0000;
    }
  });
  Object.defineProperty(Features.prototype, 'flip', {
    enumerable: false,
    configurable: true,
    get: function get() {
      return this._flip;
    }
  });
  Object.defineProperty(Features.prototype, 'flip', {
    enumerable: false,
    configurable: true,
    set: function set(value) {
      if (value === undefined) value = 0;
      this._flip = value;
      this._m_id._key = this._m_id._key & 0x00ffffff | this._flip << 24 & 0xff000000;
    }
  });
})();

(function () {
  var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;
  Box2D.inherit(b2CircleShape, Box2D.Collision.Shapes.b2Shape);
  b2CircleShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;

  b2CircleShape.b2CircleShape = function () {
    Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
    this.m_p = new b2Vec2();
  };

  b2CircleShape.prototype.Copy = function () {
    var s = new b2CircleShape();
    s.Set(this);
    return s;
  };

  b2CircleShape.prototype.Set = function (other) {
    this.__super.Set.call(this, other);

    if (Box2D.is(other, b2CircleShape)) {
      var other2 = other instanceof b2CircleShape ? other : null;
      this.m_p.SetV(other2.m_p);
    }
  };

  b2CircleShape.prototype.TestPoint = function (transform, p) {
    var tMat = transform.R;
    var dX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
    var dY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
    dX = p.x - dX;
    dY = p.y - dY;
    return dX * dX + dY * dY <= this.m_radius * this.m_radius;
  };

  b2CircleShape.prototype.RayCast = function (output, input, transform) {
    var tMat = transform.R;
    var positionX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
    var positionY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
    var sX = input.p1.x - positionX;
    var sY = input.p1.y - positionY;
    var b = sX * sX + sY * sY - this.m_radius * this.m_radius;
    var rX = input.p2.x - input.p1.x;
    var rY = input.p2.y - input.p1.y;
    var c = sX * rX + sY * rY;
    var rr = rX * rX + rY * rY;
    var sigma = c * c - rr * b;

    if (sigma < 0.0 || rr < Number.MIN_VALUE) {
      return false;
    }

    var a = -(c + Math.sqrt(sigma));

    if (0.0 <= a && a <= input.maxFraction * rr) {
      a /= rr;
      output.fraction = a;
      output.normal.x = sX + a * rX;
      output.normal.y = sY + a * rY;
      output.normal.Normalize();
      return true;
    }

    return false;
  };

  b2CircleShape.prototype.ComputeAABB = function (aabb, transform) {
    var tMat = transform.R;
    var pX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
    var pY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
    aabb.lowerBound.Set(pX - this.m_radius, pY - this.m_radius);
    aabb.upperBound.Set(pX + this.m_radius, pY + this.m_radius);
  };

  b2CircleShape.prototype.ComputeMass = function (massData, density) {
    if (density === undefined) density = 0;
    massData.mass = density * b2Settings.b2_pi * this.m_radius * this.m_radius;
    massData.center.SetV(this.m_p);
    massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y));
  };

  b2CircleShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
    if (offset === undefined) offset = 0;
    var p = b2Math.MulX(xf, this.m_p);
    var l = -(b2Math.Dot(normal, p) - offset);

    if (l < -this.m_radius + Number.MIN_VALUE) {
      return 0;
    }

    if (l > this.m_radius) {
      c.SetV(p);
      return Math.PI * this.m_radius * this.m_radius;
    }

    var r2 = this.m_radius * this.m_radius;
    var l2 = l * l;
    var area = r2 * (Math.asin(l / this.m_radius) + Math.PI / 2) + l * Math.sqrt(r2 - l2);
    var com = -2 / 3 * Math.pow(r2 - l2, 1.5) / area;
    c.x = p.x + normal.x * com;
    c.y = p.y + normal.y * com;
    return area;
  };

  b2CircleShape.prototype.GetLocalPosition = function () {
    return this.m_p;
  };

  b2CircleShape.prototype.SetLocalPosition = function (position) {
    this.m_p.SetV(position);
  };

  b2CircleShape.prototype.GetRadius = function () {
    return this.m_radius;
  };

  b2CircleShape.prototype.SetRadius = function (radius) {
    if (radius === undefined) radius = 0;
    this.m_radius = radius;
  };

  b2CircleShape.prototype.b2CircleShape = function (radius) {
    if (radius === undefined) radius = 0;

    this.__super.b2Shape.call(this);

    this.m_type = b2Shape.e_circleShape;
    this.m_radius = radius;
  };

  b2EdgeChainDef.b2EdgeChainDef = function () {};

  b2EdgeChainDef.prototype.b2EdgeChainDef = function () {
    this.vertexCount = 0;
    this.isALoop = true;
    this.vertices = [];
  };

  Box2D.inherit(b2EdgeShape, Box2D.Collision.Shapes.b2Shape);
  b2EdgeShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;

  b2EdgeShape.b2EdgeShape = function () {
    Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
    this.s_supportVec = new b2Vec2();
    this.m_v1 = new b2Vec2();
    this.m_v2 = new b2Vec2();
    this.m_coreV1 = new b2Vec2();
    this.m_coreV2 = new b2Vec2();
    this.m_normal = new b2Vec2();
    this.m_direction = new b2Vec2();
    this.m_cornerDir1 = new b2Vec2();
    this.m_cornerDir2 = new b2Vec2();
  };

  b2EdgeShape.prototype.TestPoint = function (transform, p) {
    return false;
  };

  b2EdgeShape.prototype.RayCast = function (output, input, transform) {
    var tMat;
    var rX = input.p2.x - input.p1.x;
    var rY = input.p2.y - input.p1.y;
    tMat = transform.R;
    var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
    var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
    var nX = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y) - v1Y;
    var nY = -(transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y) - v1X);
    var k_slop = 100.0 * Number.MIN_VALUE;
    var denom = -(rX * nX + rY * nY);

    if (denom > k_slop) {
      var bX = input.p1.x - v1X;
      var bY = input.p1.y - v1Y;
      var a = bX * nX + bY * nY;

      if (0.0 <= a && a <= input.maxFraction * denom) {
        var mu2 = -rX * bY + rY * bX;

        if (-k_slop * denom <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
          a /= denom;
          output.fraction = a;
          var nLen = Math.sqrt(nX * nX + nY * nY);
          output.normal.x = nX / nLen;
          output.normal.y = nY / nLen;
          return true;
        }
      }
    }

    return false;
  };

  b2EdgeShape.prototype.ComputeAABB = function (aabb, transform) {
    var tMat = transform.R;
    var v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
    var v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
    var v2X = transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y);
    var v2Y = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y);

    if (v1X < v2X) {
      aabb.lowerBound.x = v1X;
      aabb.upperBound.x = v2X;
    } else {
      aabb.lowerBound.x = v2X;
      aabb.upperBound.x = v1X;
    }

    if (v1Y < v2Y) {
      aabb.lowerBound.y = v1Y;
      aabb.upperBound.y = v2Y;
    } else {
      aabb.lowerBound.y = v2Y;
      aabb.upperBound.y = v1Y;
    }
  };

  b2EdgeShape.prototype.ComputeMass = function (massData, density) {
    if (density === undefined) density = 0;
    massData.mass = 0;
    massData.center.SetV(this.m_v1);
    massData.I = 0;
  };

  b2EdgeShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
    if (offset === undefined) offset = 0;
    var v0 = new b2Vec2(normal.x * offset, normal.y * offset);
    var v1 = b2Math.MulX(xf, this.m_v1);
    var v2 = b2Math.MulX(xf, this.m_v2);
    var d1 = b2Math.Dot(normal, v1) - offset;
    var d2 = b2Math.Dot(normal, v2) - offset;

    if (d1 > 0) {
      if (d2 > 0) {
        return 0;
      } else {
        v1.x = -d2 / (d1 - d2) * v1.x + d1 / (d1 - d2) * v2.x;
        v1.y = -d2 / (d1 - d2) * v1.y + d1 / (d1 - d2) * v2.y;
      }
    } else {
      if (d2 > 0) {
        v2.x = -d2 / (d1 - d2) * v1.x + d1 / (d1 - d2) * v2.x;
        v2.y = -d2 / (d1 - d2) * v1.y + d1 / (d1 - d2) * v2.y;
      } else {}
    }

    c.x = (v0.x + v1.x + v2.x) / 3;
    c.y = (v0.y + v1.y + v2.y) / 3;
    return 0.5 * ((v1.x - v0.x) * (v2.y - v0.y) - (v1.y - v0.y) * (v2.x - v0.x));
  };

  b2EdgeShape.prototype.GetLength = function () {
    return this.m_length;
  };

  b2EdgeShape.prototype.GetVertex1 = function () {
    return this.m_v1;
  };

  b2EdgeShape.prototype.GetVertex2 = function () {
    return this.m_v2;
  };

  b2EdgeShape.prototype.GetCoreVertex1 = function () {
    return this.m_coreV1;
  };

  b2EdgeShape.prototype.GetCoreVertex2 = function () {
    return this.m_coreV2;
  };

  b2EdgeShape.prototype.GetNormalVector = function () {
    return this.m_normal;
  };

  b2EdgeShape.prototype.GetDirectionVector = function () {
    return this.m_direction;
  };

  b2EdgeShape.prototype.GetCorner1Vector = function () {
    return this.m_cornerDir1;
  };

  b2EdgeShape.prototype.GetCorner2Vector = function () {
    return this.m_cornerDir2;
  };

  b2EdgeShape.prototype.Corner1IsConvex = function () {
    return this.m_cornerConvex1;
  };

  b2EdgeShape.prototype.Corner2IsConvex = function () {
    return this.m_cornerConvex2;
  };

  b2EdgeShape.prototype.GetFirstVertex = function (xf) {
    var tMat = xf.R;
    return new b2Vec2(xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y), xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y));
  };

  b2EdgeShape.prototype.GetNextEdge = function () {
    return this.m_nextEdge;
  };

  b2EdgeShape.prototype.GetPrevEdge = function () {
    return this.m_prevEdge;
  };

  b2EdgeShape.prototype.Support = function (xf, dX, dY) {
    if (dX === undefined) dX = 0;
    if (dY === undefined) dY = 0;
    var tMat = xf.R;
    var v1X = xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y);
    var v1Y = xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y);
    var v2X = xf.position.x + (tMat.col1.x * this.m_coreV2.x + tMat.col2.x * this.m_coreV2.y);
    var v2Y = xf.position.y + (tMat.col1.y * this.m_coreV2.x + tMat.col2.y * this.m_coreV2.y);

    if (v1X * dX + v1Y * dY > v2X * dX + v2Y * dY) {
      this.s_supportVec.x = v1X;
      this.s_supportVec.y = v1Y;
    } else {
      this.s_supportVec.x = v2X;
      this.s_supportVec.y = v2Y;
    }

    return this.s_supportVec;
  };

  b2EdgeShape.prototype.b2EdgeShape = function (v1, v2) {
    this.__super.b2Shape.call(this);

    this.m_type = b2Shape.e_edgeShape;
    this.m_prevEdge = null;
    this.m_nextEdge = null;
    this.m_v1 = v1;
    this.m_v2 = v2;
    this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y);
    this.m_length = this.m_direction.Normalize();
    this.m_normal.Set(this.m_direction.y, -this.m_direction.x);
    this.m_coreV1.Set(-b2Settings.b2_toiSlop * (this.m_normal.x - this.m_direction.x) + this.m_v1.x, -b2Settings.b2_toiSlop * (this.m_normal.y - this.m_direction.y) + this.m_v1.y);
    this.m_coreV2.Set(-b2Settings.b2_toiSlop * (this.m_normal.x + this.m_direction.x) + this.m_v2.x, -b2Settings.b2_toiSlop * (this.m_normal.y + this.m_direction.y) + this.m_v2.y);
    this.m_cornerDir1 = this.m_normal;
    this.m_cornerDir2.Set(-this.m_normal.x, -this.m_normal.y);
  };

  b2EdgeShape.prototype.SetPrevEdge = function (edge, core, cornerDir, convex) {
    this.m_prevEdge = edge;
    this.m_coreV1 = core;
    this.m_cornerDir1 = cornerDir;
    this.m_cornerConvex1 = convex;
  };

  b2EdgeShape.prototype.SetNextEdge = function (edge, core, cornerDir, convex) {
    this.m_nextEdge = edge;
    this.m_coreV2 = core;
    this.m_cornerDir2 = cornerDir;
    this.m_cornerConvex2 = convex;
  };

  b2MassData.b2MassData = function () {
    this.mass = 0.0;
    this.center = new b2Vec2(0, 0);
    this.I = 0.0;
  };

  Box2D.inherit(b2PolygonShape, Box2D.Collision.Shapes.b2Shape);
  b2PolygonShape.prototype.__super = Box2D.Collision.Shapes.b2Shape.prototype;

  b2PolygonShape.b2PolygonShape = function () {
    Box2D.Collision.Shapes.b2Shape.b2Shape.apply(this, arguments);
  };

  b2PolygonShape.prototype.Copy = function () {
    var s = new b2PolygonShape();
    s.Set(this);
    return s;
  };

  b2PolygonShape.prototype.Set = function (other) {
    this.__super.Set.call(this, other);

    if (Box2D.is(other, b2PolygonShape)) {
      var other2 = other instanceof b2PolygonShape ? other : null;
      this.m_centroid.SetV(other2.m_centroid);
      this.m_vertexCount = other2.m_vertexCount;
      this.Reserve(this.m_vertexCount);

      for (var i = 0; i < this.m_vertexCount; i++) {
        this.m_vertices[i].SetV(other2.m_vertices[i]);
        this.m_normals[i].SetV(other2.m_normals[i]);
      }
    }
  };

  b2PolygonShape.prototype.SetAsArray = function (vertices, vertexCount) {
    if (vertexCount === undefined) vertexCount = 0;
    var v = new Vector();
    var i = 0,
        tVec;

    for (i = 0; i < vertices.length; ++i) {
      tVec = vertices[i];
      v.push(tVec);
    }

    this.SetAsVector(v, vertexCount);
  };

  b2PolygonShape.AsArray = function (vertices, vertexCount) {
    if (vertexCount === undefined) vertexCount = 0;
    var polygonShape = new b2PolygonShape();
    polygonShape.SetAsArray(vertices, vertexCount);
    return polygonShape;
  };

  b2PolygonShape.prototype.SetAsVector = function (vertices, vertexCount) {
    if (vertexCount === undefined) vertexCount = 0;
    if (vertexCount == 0) vertexCount = vertices.length;
    b2Settings.b2Assert(2 <= vertexCount);
    this.m_vertexCount = vertexCount;
    this.Reserve(vertexCount);
    var i = 0;

    for (i = 0; i < this.m_vertexCount; i++) {
      this.m_vertices[i].SetV(vertices[i]);
    }

    for (i = 0; i < this.m_vertexCount; ++i) {
      var i1 = parseInt(i);
      var i2 = parseInt(i + 1 < this.m_vertexCount ? i + 1 : 0);
      var edge = b2Math.SubtractVV(this.m_vertices[i2], this.m_vertices[i1]);
      b2Settings.b2Assert(edge.LengthSquared() > Number.MIN_VALUE);
      this.m_normals[i].SetV(b2Math.CrossVF(edge, 1.0));
      this.m_normals[i].Normalize();
    }

    this.m_centroid = b2PolygonShape.ComputeCentroid(this.m_vertices, this.m_vertexCount);
  };

  b2PolygonShape.AsVector = function (vertices, vertexCount) {
    if (vertexCount === undefined) vertexCount = 0;
    var polygonShape = new b2PolygonShape();
    polygonShape.SetAsVector(vertices, vertexCount);
    return polygonShape;
  };

  b2PolygonShape.prototype.SetAsBox = function (hx, hy) {
    if (hx === undefined) hx = 0;
    if (hy === undefined) hy = 0;
    this.m_vertexCount = 4;
    this.Reserve(4);
    this.m_vertices[0].Set(-hx, -hy);
    this.m_vertices[1].Set(hx, -hy);
    this.m_vertices[2].Set(hx, hy);
    this.m_vertices[3].Set(-hx, hy);
    this.m_normals[0].Set(0.0, -1.0);
    this.m_normals[1].Set(1.0, 0.0);
    this.m_normals[2].Set(0.0, 1.0);
    this.m_normals[3].Set(-1.0, 0.0);
    this.m_centroid.SetZero();
  };

  b2PolygonShape.AsBox = function (hx, hy) {
    if (hx === undefined) hx = 0;
    if (hy === undefined) hy = 0;
    var polygonShape = new b2PolygonShape();
    polygonShape.SetAsBox(hx, hy);
    return polygonShape;
  };

  b2PolygonShape.prototype.SetAsOrientedBox = function (hx, hy, center, angle) {
    if (hx === undefined) hx = 0;
    if (hy === undefined) hy = 0;
    if (center === undefined) center = null;
    if (angle === undefined) angle = 0.0;
    this.m_vertexCount = 4;
    this.Reserve(4);
    this.m_vertices[0].Set(-hx, -hy);
    this.m_vertices[1].Set(hx, -hy);
    this.m_vertices[2].Set(hx, hy);
    this.m_vertices[3].Set(-hx, hy);
    this.m_normals[0].Set(0.0, -1.0);
    this.m_normals[1].Set(1.0, 0.0);
    this.m_normals[2].Set(0.0, 1.0);
    this.m_normals[3].Set(-1.0, 0.0);
    this.m_centroid = center;
    var xf = new b2Transform();
    xf.position = center;
    xf.R.Set(angle);

    for (var i = 0; i < this.m_vertexCount; ++i) {
      this.m_vertices[i] = b2Math.MulX(xf, this.m_vertices[i]);
      this.m_normals[i] = b2Math.MulMV(xf.R, this.m_normals[i]);
    }
  };

  b2PolygonShape.AsOrientedBox = function (hx, hy, center, angle) {
    if (hx === undefined) hx = 0;
    if (hy === undefined) hy = 0;
    if (center === undefined) center = null;
    if (angle === undefined) angle = 0.0;
    var polygonShape = new b2PolygonShape();
    polygonShape.SetAsOrientedBox(hx, hy, center, angle);
    return polygonShape;
  };

  b2PolygonShape.prototype.SetAsEdge = function (v1, v2) {
    this.m_vertexCount = 2;
    this.Reserve(2);
    this.m_vertices[0].SetV(v1);
    this.m_vertices[1].SetV(v2);
    this.m_centroid.x = 0.5 * (v1.x + v2.x);
    this.m_centroid.y = 0.5 * (v1.y + v2.y);
    this.m_normals[0] = b2Math.CrossVF(b2Math.SubtractVV(v2, v1), 1.0);
    this.m_normals[0].Normalize();
    this.m_normals[1].x = -this.m_normals[0].x;
    this.m_normals[1].y = -this.m_normals[0].y;
  };

  b2PolygonShape.AsEdge = function (v1, v2) {
    var polygonShape = new b2PolygonShape();
    polygonShape.SetAsEdge(v1, v2);
    return polygonShape;
  };

  b2PolygonShape.prototype.TestPoint = function (xf, p) {
    var tVec;
    var tMat = xf.R;
    var tX = p.x - xf.position.x;
    var tY = p.y - xf.position.y;
    var pLocalX = tX * tMat.col1.x + tY * tMat.col1.y;
    var pLocalY = tX * tMat.col2.x + tY * tMat.col2.y;

    for (var i = 0; i < this.m_vertexCount; ++i) {
      tVec = this.m_vertices[i];
      tX = pLocalX - tVec.x;
      tY = pLocalY - tVec.y;
      tVec = this.m_normals[i];
      var dot = tVec.x * tX + tVec.y * tY;

      if (dot > 0.0) {
        return false;
      }
    }

    return true;
  };

  b2PolygonShape.prototype.RayCast = function (output, input, transform) {
    var lower = 0.0;
    var upper = input.maxFraction;
    var tX = 0;
    var tY = 0;
    var tMat;
    var tVec;
    tX = input.p1.x - transform.position.x;
    tY = input.p1.y - transform.position.y;
    tMat = transform.R;
    var p1X = tX * tMat.col1.x + tY * tMat.col1.y;
    var p1Y = tX * tMat.col2.x + tY * tMat.col2.y;
    tX = input.p2.x - transform.position.x;
    tY = input.p2.y - transform.position.y;
    tMat = transform.R;
    var p2X = tX * tMat.col1.x + tY * tMat.col1.y;
    var p2Y = tX * tMat.col2.x + tY * tMat.col2.y;
    var dX = p2X - p1X;
    var dY = p2Y - p1Y;
    var index = parseInt(-1);

    for (var i = 0; i < this.m_vertexCount; ++i) {
      tVec = this.m_vertices[i];
      tX = tVec.x - p1X;
      tY = tVec.y - p1Y;
      tVec = this.m_normals[i];
      var numerator = tVec.x * tX + tVec.y * tY;
      var denominator = tVec.x * dX + tVec.y * dY;

      if (denominator == 0.0) {
        if (numerator < 0.0) {
          return false;
        }
      } else {
        if (denominator < 0.0 && numerator < lower * denominator) {
          lower = numerator / denominator;
          index = i;
        } else if (denominator > 0.0 && numerator < upper * denominator) {
          upper = numerator / denominator;
        }
      }

      if (upper < lower - Number.MIN_VALUE) {
        return false;
      }
    }

    if (index >= 0) {
      output.fraction = lower;
      tMat = transform.R;
      tVec = this.m_normals[index];
      output.normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      output.normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      return true;
    }

    return false;
  };

  b2PolygonShape.prototype.ComputeAABB = function (aabb, xf) {
    var tMat = xf.R;
    var tVec = this.m_vertices[0];
    var lowerX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    var lowerY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    var upperX = lowerX;
    var upperY = lowerY;

    for (var i = 1; i < this.m_vertexCount; ++i) {
      tVec = this.m_vertices[i];
      var vX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      var vY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      lowerX = lowerX < vX ? lowerX : vX;
      lowerY = lowerY < vY ? lowerY : vY;
      upperX = upperX > vX ? upperX : vX;
      upperY = upperY > vY ? upperY : vY;
    }

    aabb.lowerBound.x = lowerX - this.m_radius;
    aabb.lowerBound.y = lowerY - this.m_radius;
    aabb.upperBound.x = upperX + this.m_radius;
    aabb.upperBound.y = upperY + this.m_radius;
  };

  b2PolygonShape.prototype.ComputeMass = function (massData, density) {
    if (density === undefined) density = 0;

    if (this.m_vertexCount == 2) {
      massData.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x);
      massData.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y);
      massData.mass = 0.0;
      massData.I = 0.0;
      return;
    }

    var centerX = 0.0;
    var centerY = 0.0;
    var area = 0.0;
    var I = 0.0;
    var p1X = 0.0;
    var p1Y = 0.0;
    var k_inv3 = 1.0 / 3.0;

    for (var i = 0; i < this.m_vertexCount; ++i) {
      var p2 = this.m_vertices[i];
      var p3 = i + 1 < this.m_vertexCount ? this.m_vertices[parseInt(i + 1)] : this.m_vertices[0];
      var e1X = p2.x - p1X;
      var e1Y = p2.y - p1Y;
      var e2X = p3.x - p1X;
      var e2Y = p3.y - p1Y;
      var D = e1X * e2Y - e1Y * e2X;
      var triangleArea = 0.5 * D;
      area += triangleArea;
      centerX += triangleArea * k_inv3 * (p1X + p2.x + p3.x);
      centerY += triangleArea * k_inv3 * (p1Y + p2.y + p3.y);
      var px = p1X;
      var py = p1Y;
      var ex1 = e1X;
      var ey1 = e1Y;
      var ex2 = e2X;
      var ey2 = e2Y;
      var intx2 = k_inv3 * (0.25 * (ex1 * ex1 + ex2 * ex1 + ex2 * ex2) + (px * ex1 + px * ex2)) + 0.5 * px * px;
      var inty2 = k_inv3 * (0.25 * (ey1 * ey1 + ey2 * ey1 + ey2 * ey2) + (py * ey1 + py * ey2)) + 0.5 * py * py;
      I += D * (intx2 + inty2);
    }

    massData.mass = density * area;
    centerX *= 1.0 / area;
    centerY *= 1.0 / area;
    massData.center.Set(centerX, centerY);
    massData.I = density * I;
  };

  b2PolygonShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
    if (offset === undefined) offset = 0;
    var normalL = b2Math.MulTMV(xf.R, normal);
    var offsetL = offset - b2Math.Dot(normal, xf.position);
    var depths = new Vector_a2j_Number();
    var diveCount = 0;
    var intoIndex = parseInt(-1);
    var outoIndex = parseInt(-1);
    var lastSubmerged = false;
    var i = 0;

    for (i = 0; i < this.m_vertexCount; ++i) {
      depths[i] = b2Math.Dot(normalL, this.m_vertices[i]) - offsetL;
      var isSubmerged = depths[i] < -Number.MIN_VALUE;

      if (i > 0) {
        if (isSubmerged) {
          if (!lastSubmerged) {
            intoIndex = i - 1;
            diveCount++;
          }
        } else {
          if (lastSubmerged) {
            outoIndex = i - 1;
            diveCount++;
          }
        }
      }

      lastSubmerged = isSubmerged;
    }

    switch (diveCount) {
      case 0:
        if (lastSubmerged) {
          var md = new b2MassData();
          this.ComputeMass(md, 1);
          c.SetV(b2Math.MulX(xf, md.center));
          return md.mass;
        } else {
          return 0;
        }

        break;

      case 1:
        if (intoIndex == -1) {
          intoIndex = this.m_vertexCount - 1;
        } else {
          outoIndex = this.m_vertexCount - 1;
        }

        break;
    }

    var intoIndex2 = parseInt((intoIndex + 1) % this.m_vertexCount);
    var outoIndex2 = parseInt((outoIndex + 1) % this.m_vertexCount);
    var intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
    var outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
    var intoVec = new b2Vec2(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
    var outoVec = new b2Vec2(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);
    var area = 0;
    var center = new b2Vec2();
    var p2 = this.m_vertices[intoIndex2];
    var p3;
    i = intoIndex2;

    while (i != outoIndex2) {
      i = (i + 1) % this.m_vertexCount;
      if (i == outoIndex2) p3 = outoVec;else p3 = this.m_vertices[i];
      var triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
      area += triangleArea;
      center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
      center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;
      p2 = p3;
    }

    center.Multiply(1 / area);
    c.SetV(b2Math.MulX(xf, center));
    return area;
  };

  b2PolygonShape.prototype.GetVertexCount = function () {
    return this.m_vertexCount;
  };

  b2PolygonShape.prototype.GetVertices = function () {
    return this.m_vertices;
  };

  b2PolygonShape.prototype.GetNormals = function () {
    return this.m_normals;
  };

  b2PolygonShape.prototype.GetSupport = function (d) {
    var bestIndex = 0;
    var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;

    for (var i = 1; i < this.m_vertexCount; ++i) {
      var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;

      if (value > bestValue) {
        bestIndex = i;
        bestValue = value;
      }
    }

    return bestIndex;
  };

  b2PolygonShape.prototype.GetSupportVertex = function (d) {
    var bestIndex = 0;
    var bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;

    for (var i = 1; i < this.m_vertexCount; ++i) {
      var value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;

      if (value > bestValue) {
        bestIndex = i;
        bestValue = value;
      }
    }

    return this.m_vertices[bestIndex];
  };

  b2PolygonShape.prototype.Validate = function () {
    return false;
  };

  b2PolygonShape.prototype.b2PolygonShape = function () {
    this.__super.b2Shape.call(this);

    this.m_type = b2Shape.e_polygonShape;
    this.m_centroid = new b2Vec2();
    this.m_vertices = new Vector();
    this.m_normals = new Vector();
  };

  b2PolygonShape.prototype.Reserve = function (count) {
    if (count === undefined) count = 0;

    for (var i = parseInt(this.m_vertices.length); i < count; i++) {
      this.m_vertices[i] = new b2Vec2();
      this.m_normals[i] = new b2Vec2();
    }
  };

  b2PolygonShape.ComputeCentroid = function (vs, count) {
    if (count === undefined) count = 0;
    var c = new b2Vec2();
    var area = 0.0;
    var p1X = 0.0;
    var p1Y = 0.0;
    var inv3 = 1.0 / 3.0;

    for (var i = 0; i < count; ++i) {
      var p2 = vs[i];
      var p3 = i + 1 < count ? vs[parseInt(i + 1)] : vs[0];
      var e1X = p2.x - p1X;
      var e1Y = p2.y - p1Y;
      var e2X = p3.x - p1X;
      var e2Y = p3.y - p1Y;
      var D = e1X * e2Y - e1Y * e2X;
      var triangleArea = 0.5 * D;
      area += triangleArea;
      c.x += triangleArea * inv3 * (p1X + p2.x + p3.x);
      c.y += triangleArea * inv3 * (p1Y + p2.y + p3.y);
    }

    c.x *= 1.0 / area;
    c.y *= 1.0 / area;
    return c;
  };

  b2PolygonShape.ComputeOBB = function (obb, vs, count) {
    if (count === undefined) count = 0;
    var i = 0;
    var p = new Vector(count + 1);

    for (i = 0; i < count; ++i) {
      p[i] = vs[i];
    }

    p[count] = p[0];
    var minArea = Number.MAX_VALUE;

    for (i = 1; i <= count; ++i) {
      var root = p[parseInt(i - 1)];
      var uxX = p[i].x - root.x;
      var uxY = p[i].y - root.y;
      var length = Math.sqrt(uxX * uxX + uxY * uxY);
      uxX /= length;
      uxY /= length;
      var uyX = -uxY;
      var uyY = uxX;
      var lowerX = Number.MAX_VALUE;
      var lowerY = Number.MAX_VALUE;
      var upperX = -Number.MAX_VALUE;
      var upperY = -Number.MAX_VALUE;

      for (var j = 0; j < count; ++j) {
        var dX = p[j].x - root.x;
        var dY = p[j].y - root.y;
        var rX = uxX * dX + uxY * dY;
        var rY = uyX * dX + uyY * dY;
        if (rX < lowerX) lowerX = rX;
        if (rY < lowerY) lowerY = rY;
        if (rX > upperX) upperX = rX;
        if (rY > upperY) upperY = rY;
      }

      var area = (upperX - lowerX) * (upperY - lowerY);

      if (area < 0.95 * minArea) {
        minArea = area;
        obb.R.col1.x = uxX;
        obb.R.col1.y = uxY;
        obb.R.col2.x = uyX;
        obb.R.col2.y = uyY;
        var centerX = 0.5 * (lowerX + upperX);
        var centerY = 0.5 * (lowerY + upperY);
        var tMat = obb.R;
        obb.center.x = root.x + (tMat.col1.x * centerX + tMat.col2.x * centerY);
        obb.center.y = root.y + (tMat.col1.y * centerX + tMat.col2.y * centerY);
        obb.extents.x = 0.5 * (upperX - lowerX);
        obb.extents.y = 0.5 * (upperY - lowerY);
      }
    }
  };

  Box2D.postDefs.push(function () {
    Box2D.Collision.Shapes.b2PolygonShape.s_mat = new b2Mat22();
  });

  b2Shape.b2Shape = function () {};

  b2Shape.prototype.Copy = function () {
    return null;
  };

  b2Shape.prototype.Set = function (other) {
    this.m_radius = other.m_radius;
  };

  b2Shape.prototype.GetType = function () {
    return this.m_type;
  };

  b2Shape.prototype.TestPoint = function (xf, p) {
    return false;
  };

  b2Shape.prototype.RayCast = function (output, input, transform) {
    return false;
  };

  b2Shape.prototype.ComputeAABB = function (aabb, xf) {};

  b2Shape.prototype.ComputeMass = function (massData, density) {
    if (density === undefined) density = 0;
  };

  b2Shape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {
    if (offset === undefined) offset = 0;
    return 0;
  };

  b2Shape.TestOverlap = function (shape1, transform1, shape2, transform2) {
    var input = new b2DistanceInput();
    input.proxyA = new b2DistanceProxy();
    input.proxyA.Set(shape1);
    input.proxyB = new b2DistanceProxy();
    input.proxyB.Set(shape2);
    input.transformA = transform1;
    input.transformB = transform2;
    input.useRadii = true;
    var simplexCache = new b2SimplexCache();
    simplexCache.count = 0;
    var output = new b2DistanceOutput();
    b2Distance.Distance(output, simplexCache, input);
    return output.distance < 10.0 * Number.MIN_VALUE;
  };

  b2Shape.prototype.b2Shape = function () {
    this.m_type = b2Shape.e_unknownShape;
    this.m_radius = b2Settings.b2_linearSlop;
  };

  Box2D.postDefs.push(function () {
    Box2D.Collision.Shapes.b2Shape.e_unknownShape = parseInt(-1);
    Box2D.Collision.Shapes.b2Shape.e_circleShape = 0;
    Box2D.Collision.Shapes.b2Shape.e_polygonShape = 1;
    Box2D.Collision.Shapes.b2Shape.e_edgeShape = 2;
    Box2D.Collision.Shapes.b2Shape.e_shapeTypeCount = 3;
    Box2D.Collision.Shapes.b2Shape.e_hitCollide = 1;
    Box2D.Collision.Shapes.b2Shape.e_missCollide = 0;
    Box2D.Collision.Shapes.b2Shape.e_startsInsideCollide = parseInt(-1);
  });
})();

(function () {
  var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3;

  b2Color.b2Color = function () {
    this._r = 0;
    this._g = 0;
    this._b = 0;
  };

  b2Color.prototype.b2Color = function (rr, gg, bb) {
    if (rr === undefined) rr = 0;
    if (gg === undefined) gg = 0;
    if (bb === undefined) bb = 0;
    this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
    this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
    this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
  };

  b2Color.prototype.Set = function (rr, gg, bb) {
    if (rr === undefined) rr = 0;
    if (gg === undefined) gg = 0;
    if (bb === undefined) bb = 0;
    this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
    this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
    this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
  };

  Object.defineProperty(b2Color.prototype, 'r', {
    enumerable: false,
    configurable: true,
    set: function set(rr) {
      if (rr === undefined) rr = 0;
      this._r = Box2D.parseUInt(255 * b2Math.Clamp(rr, 0.0, 1.0));
    }
  });
  Object.defineProperty(b2Color.prototype, 'g', {
    enumerable: false,
    configurable: true,
    set: function set(gg) {
      if (gg === undefined) gg = 0;
      this._g = Box2D.parseUInt(255 * b2Math.Clamp(gg, 0.0, 1.0));
    }
  });
  Object.defineProperty(b2Color.prototype, 'b', {
    enumerable: false,
    configurable: true,
    set: function set(bb) {
      if (bb === undefined) bb = 0;
      this._b = Box2D.parseUInt(255 * b2Math.Clamp(bb, 0.0, 1.0));
    }
  });
  Object.defineProperty(b2Color.prototype, 'color', {
    enumerable: false,
    configurable: true,
    get: function get() {
      return this._r << 16 | this._g << 8 | this._b;
    }
  });

  b2Settings.b2Settings = function () {};

  b2Settings.b2MixFriction = function (friction1, friction2) {
    if (friction1 === undefined) friction1 = 0;
    if (friction2 === undefined) friction2 = 0;
    return Math.sqrt(friction1 * friction2);
  };

  b2Settings.b2MixRestitution = function (restitution1, restitution2) {
    if (restitution1 === undefined) restitution1 = 0;
    if (restitution2 === undefined) restitution2 = 0;
    return restitution1 > restitution2 ? restitution1 : restitution2;
  };

  b2Settings.b2Assert = function (a) {
    if (!a) {
      throw "Assertion Failed";
    }
  };

  Box2D.postDefs.push(function () {
    Box2D.Common.b2Settings.VERSION = "2.1alpha";
    Box2D.Common.b2Settings.USHRT_MAX = 0x0000ffff;
    Box2D.Common.b2Settings.b2_pi = Math.PI;
    Box2D.Common.b2Settings.b2_maxManifoldPoints = 2;
    Box2D.Common.b2Settings.b2_aabbExtension = 0.1;
    Box2D.Common.b2Settings.b2_aabbMultiplier = 2.0;
    Box2D.Common.b2Settings.b2_polygonRadius = 2.0 * b2Settings.b2_linearSlop;
    Box2D.Common.b2Settings.b2_linearSlop = 0.005;
    Box2D.Common.b2Settings.b2_angularSlop = 2.0 / 180.0 * b2Settings.b2_pi;
    Box2D.Common.b2Settings.b2_toiSlop = 8.0 * b2Settings.b2_linearSlop;
    Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland = 32;
    Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland = 32;
    Box2D.Common.b2Settings.b2_velocityThreshold = 1.0;
    Box2D.Common.b2Settings.b2_maxLinearCorrection = 0.2;
    Box2D.Common.b2Settings.b2_maxAngularCorrection = 8.0 / 180.0 * b2Settings.b2_pi;
    Box2D.Common.b2Settings.b2_maxTranslation = 2.0;
    Box2D.Common.b2Settings.b2_maxTranslationSquared = b2Settings.b2_maxTranslation * b2Settings.b2_maxTranslation;
    Box2D.Common.b2Settings.b2_maxRotation = 0.5 * b2Settings.b2_pi;
    Box2D.Common.b2Settings.b2_maxRotationSquared = b2Settings.b2_maxRotation * b2Settings.b2_maxRotation;
    Box2D.Common.b2Settings.b2_contactBaumgarte = 0.2;
    Box2D.Common.b2Settings.b2_timeToSleep = 0.5;
    Box2D.Common.b2Settings.b2_linearSleepTolerance = 0.01;
    Box2D.Common.b2Settings.b2_angularSleepTolerance = 2.0 / 180.0 * b2Settings.b2_pi;
  });
})();

(function () {
  var b2AABB = Box2D.Collision.b2AABB,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3;

  b2Mat22.b2Mat22 = function () {
    this.col1 = new b2Vec2();
    this.col2 = new b2Vec2();
  };

  b2Mat22.prototype.b2Mat22 = function () {
    this.SetIdentity();
  };

  b2Mat22.FromAngle = function (angle) {
    if (angle === undefined) angle = 0;
    var mat = new b2Mat22();
    mat.Set(angle);
    return mat;
  };

  b2Mat22.FromVV = function (c1, c2) {
    var mat = new b2Mat22();
    mat.SetVV(c1, c2);
    return mat;
  };

  b2Mat22.prototype.Set = function (angle) {
    if (angle === undefined) angle = 0;
    var c = Math.cos(angle);
    var s = Math.sin(angle);
    this.col1.x = c;
    this.col2.x = -s;
    this.col1.y = s;
    this.col2.y = c;
  };

  b2Mat22.prototype.SetVV = function (c1, c2) {
    this.col1.SetV(c1);
    this.col2.SetV(c2);
  };

  b2Mat22.prototype.Copy = function () {
    var mat = new b2Mat22();
    mat.SetM(this);
    return mat;
  };

  b2Mat22.prototype.SetM = function (m) {
    this.col1.SetV(m.col1);
    this.col2.SetV(m.col2);
  };

  b2Mat22.prototype.AddM = function (m) {
    this.col1.x += m.col1.x;
    this.col1.y += m.col1.y;
    this.col2.x += m.col2.x;
    this.col2.y += m.col2.y;
  };

  b2Mat22.prototype.SetIdentity = function () {
    this.col1.x = 1.0;
    this.col2.x = 0.0;
    this.col1.y = 0.0;
    this.col2.y = 1.0;
  };

  b2Mat22.prototype.SetZero = function () {
    this.col1.x = 0.0;
    this.col2.x = 0.0;
    this.col1.y = 0.0;
    this.col2.y = 0.0;
  };

  b2Mat22.prototype.GetAngle = function () {
    return Math.atan2(this.col1.y, this.col1.x);
  };

  b2Mat22.prototype.GetInverse = function (out) {
    var a = this.col1.x;
    var b = this.col2.x;
    var c = this.col1.y;
    var d = this.col2.y;
    var det = a * d - b * c;

    if (det != 0.0) {
      det = 1.0 / det;
    }

    out.col1.x = det * d;
    out.col2.x = -det * b;
    out.col1.y = -det * c;
    out.col2.y = det * a;
    return out;
  };

  b2Mat22.prototype.Solve = function (out, bX, bY) {
    if (bX === undefined) bX = 0;
    if (bY === undefined) bY = 0;
    var a11 = this.col1.x;
    var a12 = this.col2.x;
    var a21 = this.col1.y;
    var a22 = this.col2.y;
    var det = a11 * a22 - a12 * a21;

    if (det != 0.0) {
      det = 1.0 / det;
    }

    out.x = det * (a22 * bX - a12 * bY);
    out.y = det * (a11 * bY - a21 * bX);
    return out;
  };

  b2Mat22.prototype.Abs = function () {
    this.col1.Abs();
    this.col2.Abs();
  };

  b2Mat33.b2Mat33 = function () {
    this.col1 = new b2Vec3();
    this.col2 = new b2Vec3();
    this.col3 = new b2Vec3();
  };

  b2Mat33.prototype.b2Mat33 = function (c1, c2, c3) {
    if (c1 === undefined) c1 = null;
    if (c2 === undefined) c2 = null;
    if (c3 === undefined) c3 = null;

    if (!c1 && !c2 && !c3) {
      this.col1.SetZero();
      this.col2.SetZero();
      this.col3.SetZero();
    } else {
      this.col1.SetV(c1);
      this.col2.SetV(c2);
      this.col3.SetV(c3);
    }
  };

  b2Mat33.prototype.SetVVV = function (c1, c2, c3) {
    this.col1.SetV(c1);
    this.col2.SetV(c2);
    this.col3.SetV(c3);
  };

  b2Mat33.prototype.Copy = function () {
    return new b2Mat33(this.col1, this.col2, this.col3);
  };

  b2Mat33.prototype.SetM = function (m) {
    this.col1.SetV(m.col1);
    this.col2.SetV(m.col2);
    this.col3.SetV(m.col3);
  };

  b2Mat33.prototype.AddM = function (m) {
    this.col1.x += m.col1.x;
    this.col1.y += m.col1.y;
    this.col1.z += m.col1.z;
    this.col2.x += m.col2.x;
    this.col2.y += m.col2.y;
    this.col2.z += m.col2.z;
    this.col3.x += m.col3.x;
    this.col3.y += m.col3.y;
    this.col3.z += m.col3.z;
  };

  b2Mat33.prototype.SetIdentity = function () {
    this.col1.x = 1.0;
    this.col2.x = 0.0;
    this.col3.x = 0.0;
    this.col1.y = 0.0;
    this.col2.y = 1.0;
    this.col3.y = 0.0;
    this.col1.z = 0.0;
    this.col2.z = 0.0;
    this.col3.z = 1.0;
  };

  b2Mat33.prototype.SetZero = function () {
    this.col1.x = 0.0;
    this.col2.x = 0.0;
    this.col3.x = 0.0;
    this.col1.y = 0.0;
    this.col2.y = 0.0;
    this.col3.y = 0.0;
    this.col1.z = 0.0;
    this.col2.z = 0.0;
    this.col3.z = 0.0;
  };

  b2Mat33.prototype.Solve22 = function (out, bX, bY) {
    if (bX === undefined) bX = 0;
    if (bY === undefined) bY = 0;
    var a11 = this.col1.x;
    var a12 = this.col2.x;
    var a21 = this.col1.y;
    var a22 = this.col2.y;
    var det = a11 * a22 - a12 * a21;

    if (det != 0.0) {
      det = 1.0 / det;
    }

    out.x = det * (a22 * bX - a12 * bY);
    out.y = det * (a11 * bY - a21 * bX);
    return out;
  };

  b2Mat33.prototype.Solve33 = function (out, bX, bY, bZ) {
    if (bX === undefined) bX = 0;
    if (bY === undefined) bY = 0;
    if (bZ === undefined) bZ = 0;
    var a11 = this.col1.x;
    var a21 = this.col1.y;
    var a31 = this.col1.z;
    var a12 = this.col2.x;
    var a22 = this.col2.y;
    var a32 = this.col2.z;
    var a13 = this.col3.x;
    var a23 = this.col3.y;
    var a33 = this.col3.z;
    var det = a11 * (a22 * a33 - a32 * a23) + a21 * (a32 * a13 - a12 * a33) + a31 * (a12 * a23 - a22 * a13);

    if (det != 0.0) {
      det = 1.0 / det;
    }

    out.x = det * (bX * (a22 * a33 - a32 * a23) + bY * (a32 * a13 - a12 * a33) + bZ * (a12 * a23 - a22 * a13));
    out.y = det * (a11 * (bY * a33 - bZ * a23) + a21 * (bZ * a13 - bX * a33) + a31 * (bX * a23 - bY * a13));
    out.z = det * (a11 * (a22 * bZ - a32 * bY) + a21 * (a32 * bX - a12 * bZ) + a31 * (a12 * bY - a22 * bX));
    return out;
  };

  b2Math.b2Math = function () {};

  b2Math.IsValid = function (x) {
    if (x === undefined) x = 0;
    return isFinite(x);
  };

  b2Math.Dot = function (a, b) {
    return a.x * b.x + a.y * b.y;
  };

  b2Math.CrossVV = function (a, b) {
    return a.x * b.y - a.y * b.x;
  };

  b2Math.CrossVF = function (a, s) {
    if (s === undefined) s = 0;
    var v = new b2Vec2(s * a.y, -s * a.x);
    return v;
  };

  b2Math.CrossFV = function (s, a) {
    if (s === undefined) s = 0;
    var v = new b2Vec2(-s * a.y, s * a.x);
    return v;
  };

  b2Math.MulMV = function (A, v) {
    var u = new b2Vec2(A.col1.x * v.x + A.col2.x * v.y, A.col1.y * v.x + A.col2.y * v.y);
    return u;
  };

  b2Math.MulTMV = function (A, v) {
    var u = new b2Vec2(b2Math.Dot(v, A.col1), b2Math.Dot(v, A.col2));
    return u;
  };

  b2Math.MulX = function (T, v) {
    var a = b2Math.MulMV(T.R, v);
    a.x += T.position.x;
    a.y += T.position.y;
    return a;
  };

  b2Math.MulXT = function (T, v) {
    var a = b2Math.SubtractVV(v, T.position);
    var tX = a.x * T.R.col1.x + a.y * T.R.col1.y;
    a.y = a.x * T.R.col2.x + a.y * T.R.col2.y;
    a.x = tX;
    return a;
  };

  b2Math.AddVV = function (a, b) {
    var v = new b2Vec2(a.x + b.x, a.y + b.y);
    return v;
  };

  b2Math.SubtractVV = function (a, b) {
    var v = new b2Vec2(a.x - b.x, a.y - b.y);
    return v;
  };

  b2Math.Distance = function (a, b) {
    var cX = a.x - b.x;
    var cY = a.y - b.y;
    return Math.sqrt(cX * cX + cY * cY);
  };

  b2Math.DistanceSquared = function (a, b) {
    var cX = a.x - b.x;
    var cY = a.y - b.y;
    return cX * cX + cY * cY;
  };

  b2Math.MulFV = function (s, a) {
    if (s === undefined) s = 0;
    var v = new b2Vec2(s * a.x, s * a.y);
    return v;
  };

  b2Math.AddMM = function (A, B) {
    var C = b2Mat22.FromVV(b2Math.AddVV(A.col1, B.col1), b2Math.AddVV(A.col2, B.col2));
    return C;
  };

  b2Math.MulMM = function (A, B) {
    var C = b2Mat22.FromVV(b2Math.MulMV(A, B.col1), b2Math.MulMV(A, B.col2));
    return C;
  };

  b2Math.MulTMM = function (A, B) {
    var c1 = new b2Vec2(b2Math.Dot(A.col1, B.col1), b2Math.Dot(A.col2, B.col1));
    var c2 = new b2Vec2(b2Math.Dot(A.col1, B.col2), b2Math.Dot(A.col2, B.col2));
    var C = b2Mat22.FromVV(c1, c2);
    return C;
  };

  b2Math.Abs = function (a) {
    if (a === undefined) a = 0;
    return a > 0.0 ? a : -a;
  };

  b2Math.AbsV = function (a) {
    var b = new b2Vec2(b2Math.Abs(a.x), b2Math.Abs(a.y));
    return b;
  };

  b2Math.AbsM = function (A) {
    var B = b2Mat22.FromVV(b2Math.AbsV(A.col1), b2Math.AbsV(A.col2));
    return B;
  };

  b2Math.Min = function (a, b) {
    if (a === undefined) a = 0;
    if (b === undefined) b = 0;
    return a < b ? a : b;
  };

  b2Math.MinV = function (a, b) {
    var c = new b2Vec2(b2Math.Min(a.x, b.x), b2Math.Min(a.y, b.y));
    return c;
  };

  b2Math.Max = function (a, b) {
    if (a === undefined) a = 0;
    if (b === undefined) b = 0;
    return a > b ? a : b;
  };

  b2Math.MaxV = function (a, b) {
    var c = new b2Vec2(b2Math.Max(a.x, b.x), b2Math.Max(a.y, b.y));
    return c;
  };

  b2Math.Clamp = function (a, low, high) {
    if (a === undefined) a = 0;
    if (low === undefined) low = 0;
    if (high === undefined) high = 0;
    return a < low ? low : a > high ? high : a;
  };

  b2Math.ClampV = function (a, low, high) {
    return b2Math.MaxV(low, b2Math.MinV(a, high));
  };

  b2Math.Swap = function (a, b) {
    var tmp = a[0];
    a[0] = b[0];
    b[0] = tmp;
  };

  b2Math.Random = function () {
    return Math.random() * 2 - 1;
  };

  b2Math.RandomRange = function (lo, hi) {
    if (lo === undefined) lo = 0;
    if (hi === undefined) hi = 0;
    var r = Math.random();
    r = (hi - lo) * r + lo;
    return r;
  };

  b2Math.NextPowerOfTwo = function (x) {
    if (x === undefined) x = 0;
    x |= x >> 1 & 0x7FFFFFFF;
    x |= x >> 2 & 0x3FFFFFFF;
    x |= x >> 4 & 0x0FFFFFFF;
    x |= x >> 8 & 0x00FFFFFF;
    x |= x >> 16 & 0x0000FFFF;
    return x + 1;
  };

  b2Math.IsPowerOfTwo = function (x) {
    if (x === undefined) x = 0;
    var result = x > 0 && (x & x - 1) == 0;
    return result;
  };

  Box2D.postDefs.push(function () {
    Box2D.Common.Math.b2Math.b2Vec2_zero = new b2Vec2(0.0, 0.0);
    Box2D.Common.Math.b2Math.b2Mat22_identity = b2Mat22.FromVV(new b2Vec2(1.0, 0.0), new b2Vec2(0.0, 1.0));
    Box2D.Common.Math.b2Math.b2Transform_identity = new b2Transform(b2Math.b2Vec2_zero, b2Math.b2Mat22_identity);
  });

  b2Sweep.b2Sweep = function () {
    this.localCenter = new b2Vec2();
    this.c0 = new b2Vec2();
    this.c = new b2Vec2();
  };

  b2Sweep.prototype.Set = function (other) {
    this.localCenter.SetV(other.localCenter);
    this.c0.SetV(other.c0);
    this.c.SetV(other.c);
    this.a0 = other.a0;
    this.a = other.a;
    this.t0 = other.t0;
  };

  b2Sweep.prototype.Copy = function () {
    var copy = new b2Sweep();
    copy.localCenter.SetV(this.localCenter);
    copy.c0.SetV(this.c0);
    copy.c.SetV(this.c);
    copy.a0 = this.a0;
    copy.a = this.a;
    copy.t0 = this.t0;
    return copy;
  };

  b2Sweep.prototype.GetTransform = function (xf, alpha) {
    if (alpha === undefined) alpha = 0;
    xf.position.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
    xf.position.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
    var angle = (1.0 - alpha) * this.a0 + alpha * this.a;
    xf.R.Set(angle);
    var tMat = xf.R;
    xf.position.x -= tMat.col1.x * this.localCenter.x + tMat.col2.x * this.localCenter.y;
    xf.position.y -= tMat.col1.y * this.localCenter.x + tMat.col2.y * this.localCenter.y;
  };

  b2Sweep.prototype.Advance = function (t) {
    if (t === undefined) t = 0;

    if (this.t0 < t && 1.0 - this.t0 > Number.MIN_VALUE) {
      var alpha = (t - this.t0) / (1.0 - this.t0);
      this.c0.x = (1.0 - alpha) * this.c0.x + alpha * this.c.x;
      this.c0.y = (1.0 - alpha) * this.c0.y + alpha * this.c.y;
      this.a0 = (1.0 - alpha) * this.a0 + alpha * this.a;
      this.t0 = t;
    }
  };

  b2Transform.b2Transform = function () {
    this.position = new b2Vec2();
    this.R = new b2Mat22();
  };

  b2Transform.prototype.b2Transform = function (pos, r) {
    if (pos === undefined) pos = null;
    if (r === undefined) r = null;

    if (pos) {
      this.position.SetV(pos);
      this.R.SetM(r);
    }
  };

  b2Transform.prototype.Initialize = function (pos, r) {
    this.position.SetV(pos);
    this.R.SetM(r);
  };

  b2Transform.prototype.SetIdentity = function () {
    this.position.SetZero();
    this.R.SetIdentity();
  };

  b2Transform.prototype.Set = function (x) {
    this.position.SetV(x.position);
    this.R.SetM(x.R);
  };

  b2Transform.prototype.GetAngle = function () {
    return Math.atan2(this.R.col1.y, this.R.col1.x);
  };

  b2Vec2.b2Vec2 = function () {};

  b2Vec2.prototype.b2Vec2 = function (x_, y_) {
    if (x_ === undefined) x_ = 0;
    if (y_ === undefined) y_ = 0;
    this.x = x_;
    this.y = y_;
  };

  b2Vec2.prototype.SetZero = function () {
    this.x = 0.0;
    this.y = 0.0;
  };

  b2Vec2.prototype.Set = function (x_, y_) {
    if (x_ === undefined) x_ = 0;
    if (y_ === undefined) y_ = 0;
    this.x = x_;
    this.y = y_;
  };

  b2Vec2.prototype.SetV = function (v) {
    this.x = v.x;
    this.y = v.y;
  };

  b2Vec2.prototype.GetNegative = function () {
    return new b2Vec2(-this.x, -this.y);
  };

  b2Vec2.prototype.NegativeSelf = function () {
    this.x = -this.x;
    this.y = -this.y;
  };

  b2Vec2.Make = function (x_, y_) {
    if (x_ === undefined) x_ = 0;
    if (y_ === undefined) y_ = 0;
    return new b2Vec2(x_, y_);
  };

  b2Vec2.prototype.Copy = function () {
    return new b2Vec2(this.x, this.y);
  };

  b2Vec2.prototype.Add = function (v) {
    this.x += v.x;
    this.y += v.y;
  };

  b2Vec2.prototype.Subtract = function (v) {
    this.x -= v.x;
    this.y -= v.y;
  };

  b2Vec2.prototype.Multiply = function (a) {
    if (a === undefined) a = 0;
    this.x *= a;
    this.y *= a;
  };

  b2Vec2.prototype.MulM = function (A) {
    var tX = this.x;
    this.x = A.col1.x * tX + A.col2.x * this.y;
    this.y = A.col1.y * tX + A.col2.y * this.y;
  };

  b2Vec2.prototype.MulTM = function (A) {
    var tX = b2Math.Dot(this, A.col1);
    this.y = b2Math.Dot(this, A.col2);
    this.x = tX;
  };

  b2Vec2.prototype.CrossVF = function (s) {
    if (s === undefined) s = 0;
    var tX = this.x;
    this.x = s * this.y;
    this.y = -s * tX;
  };

  b2Vec2.prototype.CrossFV = function (s) {
    if (s === undefined) s = 0;
    var tX = this.x;
    this.x = -s * this.y;
    this.y = s * tX;
  };

  b2Vec2.prototype.MinV = function (b) {
    this.x = this.x < b.x ? this.x : b.x;
    this.y = this.y < b.y ? this.y : b.y;
  };

  b2Vec2.prototype.MaxV = function (b) {
    this.x = this.x > b.x ? this.x : b.x;
    this.y = this.y > b.y ? this.y : b.y;
  };

  b2Vec2.prototype.Abs = function () {
    if (this.x < 0) this.x = -this.x;
    if (this.y < 0) this.y = -this.y;
  };

  b2Vec2.prototype.Length = function () {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  };

  b2Vec2.prototype.LengthSquared = function () {
    return this.x * this.x + this.y * this.y;
  };

  b2Vec2.prototype.Normalize = function () {
    var length = Math.sqrt(this.x * this.x + this.y * this.y);

    if (length < Number.MIN_VALUE) {
      return 0.0;
    }

    var invLength = 1.0 / length;
    this.x *= invLength;
    this.y *= invLength;
    return length;
  };

  b2Vec2.prototype.IsValid = function () {
    return b2Math.IsValid(this.x) && b2Math.IsValid(this.y);
  };

  b2Vec3.b2Vec3 = function () {};

  b2Vec3.prototype.b2Vec3 = function (x, y, z) {
    if (x === undefined) x = 0;
    if (y === undefined) y = 0;
    if (z === undefined) z = 0;
    this.x = x;
    this.y = y;
    this.z = z;
  };

  b2Vec3.prototype.SetZero = function () {
    this.x = this.y = this.z = 0.0;
  };

  b2Vec3.prototype.Set = function (x, y, z) {
    if (x === undefined) x = 0;
    if (y === undefined) y = 0;
    if (z === undefined) z = 0;
    this.x = x;
    this.y = y;
    this.z = z;
  };

  b2Vec3.prototype.SetV = function (v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
  };

  b2Vec3.prototype.GetNegative = function () {
    return new b2Vec3(-this.x, -this.y, -this.z);
  };

  b2Vec3.prototype.NegativeSelf = function () {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
  };

  b2Vec3.prototype.Copy = function () {
    return new b2Vec3(this.x, this.y, this.z);
  };

  b2Vec3.prototype.Add = function (v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
  };

  b2Vec3.prototype.Subtract = function (v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
  };

  b2Vec3.prototype.Multiply = function (a) {
    if (a === undefined) a = 0;
    this.x *= a;
    this.y *= a;
    this.z *= a;
  };
})();

(function () {
  var b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
      b2Contact = Box2D.Dynamics.Contacts.b2Contact,
      b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
      b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
      b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
      b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
      b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
      b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
      b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
      b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
      b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
      b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
      b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
      b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
      b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
      b2Controller = Box2D.Dynamics.Controllers.b2Controller,
      b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
      b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
      b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
      b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
      b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
      b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
      b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
      b2Joint = Box2D.Dynamics.Joints.b2Joint,
      b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
      b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
      b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
      b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
      b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
      b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
      b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
      b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
      b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
      b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
      b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
      b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
      b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
      b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef;

  b2Body.b2Body = function () {
    this.m_xf = new b2Transform();
    this.m_sweep = new b2Sweep();
    this.m_linearVelocity = new b2Vec2();
    this.m_force = new b2Vec2();
  };

  b2Body.prototype.connectEdges = function (s1, s2, angle1) {
    if (angle1 === undefined) angle1 = 0;
    var angle2 = Math.atan2(s2.GetDirectionVector().y, s2.GetDirectionVector().x);
    var coreOffset = Math.tan((angle2 - angle1) * 0.5);
    var core = b2Math.MulFV(coreOffset, s2.GetDirectionVector());
    core = b2Math.SubtractVV(core, s2.GetNormalVector());
    core = b2Math.MulFV(b2Settings.b2_toiSlop, core);
    core = b2Math.AddVV(core, s2.GetVertex1());
    var cornerDir = b2Math.AddVV(s1.GetDirectionVector(), s2.GetDirectionVector());
    cornerDir.Normalize();
    var convex = b2Math.Dot(s1.GetDirectionVector(), s2.GetNormalVector()) > 0.0;
    s1.SetNextEdge(s2, core, cornerDir, convex);
    s2.SetPrevEdge(s1, core, cornerDir, convex);
    return angle2;
  };

  b2Body.prototype.CreateFixture = function (def) {
    if (this.m_world.IsLocked() == true) {
      return null;
    }

    var fixture = new b2Fixture();
    fixture.Create(this, this.m_xf, def);

    if (this.m_flags & b2Body.e_activeFlag) {
      var broadPhase = this.m_world.m_contactManager.m_broadPhase;
      fixture.CreateProxy(broadPhase, this.m_xf);
    }

    fixture.m_next = this.m_fixtureList;
    this.m_fixtureList = fixture;
    ++this.m_fixtureCount;
    fixture.m_body = this;

    if (fixture.m_density > 0.0) {
      this.ResetMassData();
    }

    this.m_world.m_flags |= b2World.e_newFixture;
    return fixture;
  };

  b2Body.prototype.CreateFixture2 = function (shape, density) {
    if (density === undefined) density = 0.0;
    var def = new b2FixtureDef();
    def.shape = shape;
    def.density = density;
    return this.CreateFixture(def);
  };

  b2Body.prototype.DestroyFixture = function (fixture) {
    if (this.m_world.IsLocked() == true) {
      return;
    }

    var node = this.m_fixtureList;
    var ppF = null;
    var found = false;

    while (node != null) {
      if (node == fixture) {
        if (ppF) ppF.m_next = fixture.m_next;else this.m_fixtureList = fixture.m_next;
        found = true;
        break;
      }

      ppF = node;
      node = node.m_next;
    }

    var edge = this.m_contactList;

    while (edge) {
      var c = edge.contact;
      edge = edge.next;
      var fixtureA = c.GetFixtureA();
      var fixtureB = c.GetFixtureB();

      if (fixture == fixtureA || fixture == fixtureB) {
        this.m_world.m_contactManager.Destroy(c);
      }
    }

    if (this.m_flags & b2Body.e_activeFlag) {
      var broadPhase = this.m_world.m_contactManager.m_broadPhase;
      fixture.DestroyProxy(broadPhase);
    } else {}

    fixture.Destroy();
    fixture.m_body = null;
    fixture.m_next = null;
    --this.m_fixtureCount;
    this.ResetMassData();
  };

  b2Body.prototype.SetPositionAndAngle = function (position, angle) {
    if (angle === undefined) angle = 0;
    var f;

    if (this.m_world.IsLocked() == true) {
      return;
    }

    this.m_xf.R.Set(angle);
    this.m_xf.position.SetV(position);
    var tMat = this.m_xf.R;
    var tVec = this.m_sweep.localCenter;
    this.m_sweep.c.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    this.m_sweep.c.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    this.m_sweep.c.x += this.m_xf.position.x;
    this.m_sweep.c.y += this.m_xf.position.y;
    this.m_sweep.c0.SetV(this.m_sweep.c);
    this.m_sweep.a0 = this.m_sweep.a = angle;
    var broadPhase = this.m_world.m_contactManager.m_broadPhase;

    for (f = this.m_fixtureList; f; f = f.m_next) {
      f.Synchronize(broadPhase, this.m_xf, this.m_xf);
    }

    this.m_world.m_contactManager.FindNewContacts();
  };

  b2Body.prototype.SetTransform = function (xf) {
    this.SetPositionAndAngle(xf.position, xf.GetAngle());
  };

  b2Body.prototype.GetTransform = function () {
    return this.m_xf;
  };

  b2Body.prototype.GetPosition = function () {
    return this.m_xf.position;
  };

  b2Body.prototype.SetPosition = function (position) {
    this.SetPositionAndAngle(position, this.GetAngle());
  };

  b2Body.prototype.GetAngle = function () {
    return this.m_sweep.a;
  };

  b2Body.prototype.SetAngle = function (angle) {
    if (angle === undefined) angle = 0;
    this.SetPositionAndAngle(this.GetPosition(), angle);
  };

  b2Body.prototype.GetWorldCenter = function () {
    return this.m_sweep.c;
  };

  b2Body.prototype.GetLocalCenter = function () {
    return this.m_sweep.localCenter;
  };

  b2Body.prototype.SetLinearVelocity = function (v) {
    if (this.m_type == b2Body.b2_staticBody) {
      return;
    }

    this.m_linearVelocity.SetV(v);
  };

  b2Body.prototype.GetLinearVelocity = function () {
    return this.m_linearVelocity;
  };

  b2Body.prototype.SetAngularVelocity = function (omega) {
    if (omega === undefined) omega = 0;

    if (this.m_type == b2Body.b2_staticBody) {
      return;
    }

    this.m_angularVelocity = omega;
  };

  b2Body.prototype.GetAngularVelocity = function () {
    return this.m_angularVelocity;
  };

  b2Body.prototype.GetDefinition = function () {
    var bd = new b2BodyDef();
    bd.type = this.GetType();
    bd.allowSleep = (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
    bd.angle = this.GetAngle();
    bd.angularDamping = this.m_angularDamping;
    bd.angularVelocity = this.m_angularVelocity;
    bd.fixedRotation = (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
    bd.bullet = (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
    bd.awake = (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
    bd.linearDamping = this.m_linearDamping;
    bd.linearVelocity.SetV(this.GetLinearVelocity());
    bd.position = this.GetPosition();
    bd.userData = this.GetUserData();
    return bd;
  };

  b2Body.prototype.ApplyForce = function (force, point) {
    if (this.m_type != b2Body.b2_dynamicBody) {
      return;
    }

    if (this.IsAwake() == false) {
      this.SetAwake(true);
    }

    this.m_force.x += force.x;
    this.m_force.y += force.y;
    this.m_torque += (point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x;
  };

  b2Body.prototype.ApplyTorque = function (torque) {
    if (torque === undefined) torque = 0;

    if (this.m_type != b2Body.b2_dynamicBody) {
      return;
    }

    if (this.IsAwake() == false) {
      this.SetAwake(true);
    }

    this.m_torque += torque;
  };

  b2Body.prototype.ApplyImpulse = function (impulse, point) {
    if (this.m_type != b2Body.b2_dynamicBody) {
      return;
    }

    if (this.IsAwake() == false) {
      this.SetAwake(true);
    }

    this.m_linearVelocity.x += this.m_invMass * impulse.x;
    this.m_linearVelocity.y += this.m_invMass * impulse.y;
    this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x);
  };

  b2Body.prototype.Split = function (callback) {
    var linearVelocity = this.GetLinearVelocity().Copy();
    var angularVelocity = this.GetAngularVelocity();
    var center = this.GetWorldCenter();
    var body1 = this;
    var body2 = this.m_world.CreateBody(this.GetDefinition());
    var prev;

    for (var f = body1.m_fixtureList; f;) {
      if (callback(f)) {
        var next = f.m_next;

        if (prev) {
          prev.m_next = next;
        } else {
          body1.m_fixtureList = next;
        }

        body1.m_fixtureCount--;
        f.m_next = body2.m_fixtureList;
        body2.m_fixtureList = f;
        body2.m_fixtureCount++;
        f.m_body = body2;
        f = next;
      } else {
        prev = f;
        f = f.m_next;
      }
    }

    body1.ResetMassData();
    body2.ResetMassData();
    var center1 = body1.GetWorldCenter();
    var center2 = body2.GetWorldCenter();
    var velocity1 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center1, center)));
    var velocity2 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center2, center)));
    body1.SetLinearVelocity(velocity1);
    body2.SetLinearVelocity(velocity2);
    body1.SetAngularVelocity(angularVelocity);
    body2.SetAngularVelocity(angularVelocity);
    body1.SynchronizeFixtures();
    body2.SynchronizeFixtures();
    return body2;
  };

  b2Body.prototype.Merge = function (other) {
    var f;

    for (f = other.m_fixtureList; f;) {
      var next = f.m_next;
      other.m_fixtureCount--;
      f.m_next = this.m_fixtureList;
      this.m_fixtureList = f;
      this.m_fixtureCount++;
      f.m_body = body2;
      f = next;
    }

    body1.m_fixtureCount = 0;
    var body1 = this;
    var body2 = other;
    var center1 = body1.GetWorldCenter();
    var center2 = body2.GetWorldCenter();
    var velocity1 = body1.GetLinearVelocity().Copy();
    var velocity2 = body2.GetLinearVelocity().Copy();
    var angular1 = body1.GetAngularVelocity();
    var angular = body2.GetAngularVelocity();
    body1.ResetMassData();
    this.SynchronizeFixtures();
  };

  b2Body.prototype.GetMass = function () {
    return this.m_mass;
  };

  b2Body.prototype.GetInertia = function () {
    return this.m_I;
  };

  b2Body.prototype.GetMassData = function (data) {
    data.mass = this.m_mass;
    data.I = this.m_I;
    data.center.SetV(this.m_sweep.localCenter);
  };

  b2Body.prototype.SetMassData = function (massData) {
    b2Settings.b2Assert(this.m_world.IsLocked() == false);

    if (this.m_world.IsLocked() == true) {
      return;
    }

    if (this.m_type != b2Body.b2_dynamicBody) {
      return;
    }

    this.m_invMass = 0.0;
    this.m_I = 0.0;
    this.m_invI = 0.0;
    this.m_mass = massData.mass;

    if (this.m_mass <= 0.0) {
      this.m_mass = 1.0;
    }

    this.m_invMass = 1.0 / this.m_mass;

    if (massData.I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
      this.m_I = massData.I - this.m_mass * (massData.center.x * massData.center.x + massData.center.y * massData.center.y);
      this.m_invI = 1.0 / this.m_I;
    }

    var oldCenter = this.m_sweep.c.Copy();
    this.m_sweep.localCenter.SetV(massData.center);
    this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
    this.m_sweep.c.SetV(this.m_sweep.c0);
    this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - oldCenter.y);
    this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - oldCenter.x);
  };

  b2Body.prototype.ResetMassData = function () {
    this.m_mass = 0.0;
    this.m_invMass = 0.0;
    this.m_I = 0.0;
    this.m_invI = 0.0;
    this.m_sweep.localCenter.SetZero();

    if (this.m_type == b2Body.b2_staticBody || this.m_type == b2Body.b2_kinematicBody) {
      return;
    }

    var center = b2Vec2.Make(0, 0);

    for (var f = this.m_fixtureList; f; f = f.m_next) {
      if (f.m_density == 0.0) {
        continue;
      }

      var massData = f.GetMassData();
      this.m_mass += massData.mass;
      center.x += massData.center.x * massData.mass;
      center.y += massData.center.y * massData.mass;
      this.m_I += massData.I;
    }

    if (this.m_mass > 0.0) {
      this.m_invMass = 1.0 / this.m_mass;
      center.x *= this.m_invMass;
      center.y *= this.m_invMass;
    } else {
      this.m_mass = 1.0;
      this.m_invMass = 1.0;
    }

    if (this.m_I > 0.0 && (this.m_flags & b2Body.e_fixedRotationFlag) == 0) {
      this.m_I -= this.m_mass * (center.x * center.x + center.y * center.y);
      this.m_I *= this.m_inertiaScale;
      b2Settings.b2Assert(this.m_I > 0);
      this.m_invI = 1.0 / this.m_I;
    } else {
      this.m_I = 0.0;
      this.m_invI = 0.0;
    }

    var oldCenter = this.m_sweep.c.Copy();
    this.m_sweep.localCenter.SetV(center);
    this.m_sweep.c0.SetV(b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
    this.m_sweep.c.SetV(this.m_sweep.c0);
    this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - oldCenter.y);
    this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - oldCenter.x);
  };

  b2Body.prototype.GetWorldPoint = function (localPoint) {
    var A = this.m_xf.R;
    var u = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
    u.x += this.m_xf.position.x;
    u.y += this.m_xf.position.y;
    return u;
  };

  b2Body.prototype.GetWorldVector = function (localVector) {
    return b2Math.MulMV(this.m_xf.R, localVector);
  };

  b2Body.prototype.GetLocalPoint = function (worldPoint) {
    return b2Math.MulXT(this.m_xf, worldPoint);
  };

  b2Body.prototype.GetLocalVector = function (worldVector) {
    return b2Math.MulTMV(this.m_xf.R, worldVector);
  };

  b2Body.prototype.GetLinearVelocityFromWorldPoint = function (worldPoint) {
    return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
  };

  b2Body.prototype.GetLinearVelocityFromLocalPoint = function (localPoint) {
    var A = this.m_xf.R;
    var worldPoint = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
    worldPoint.x += this.m_xf.position.x;
    worldPoint.y += this.m_xf.position.y;
    return new b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
  };

  b2Body.prototype.GetLinearDamping = function () {
    return this.m_linearDamping;
  };

  b2Body.prototype.SetLinearDamping = function (linearDamping) {
    if (linearDamping === undefined) linearDamping = 0;
    this.m_linearDamping = linearDamping;
  };

  b2Body.prototype.GetAngularDamping = function () {
    return this.m_angularDamping;
  };

  b2Body.prototype.SetAngularDamping = function (angularDamping) {
    if (angularDamping === undefined) angularDamping = 0;
    this.m_angularDamping = angularDamping;
  };

  b2Body.prototype.SetType = function (type) {
    if (type === undefined) type = 0;

    if (this.m_type == type) {
      return;
    }

    this.m_type = type;
    this.ResetMassData();

    if (this.m_type == b2Body.b2_staticBody) {
      this.m_linearVelocity.SetZero();
      this.m_angularVelocity = 0.0;
    }

    this.SetAwake(true);
    this.m_force.SetZero();
    this.m_torque = 0.0;

    for (var ce = this.m_contactList; ce; ce = ce.next) {
      ce.contact.FlagForFiltering();
    }
  };

  b2Body.prototype.GetType = function () {
    return this.m_type;
  };

  b2Body.prototype.SetBullet = function (flag) {
    if (flag) {
      this.m_flags |= b2Body.e_bulletFlag;
    } else {
      this.m_flags &= ~b2Body.e_bulletFlag;
    }
  };

  b2Body.prototype.IsBullet = function () {
    return (this.m_flags & b2Body.e_bulletFlag) == b2Body.e_bulletFlag;
  };

  b2Body.prototype.SetSleepingAllowed = function (flag) {
    if (flag) {
      this.m_flags |= b2Body.e_allowSleepFlag;
    } else {
      this.m_flags &= ~b2Body.e_allowSleepFlag;
      this.SetAwake(true);
    }
  };

  b2Body.prototype.SetAwake = function (flag) {
    if (flag) {
      this.m_flags |= b2Body.e_awakeFlag;
      this.m_sleepTime = 0.0;
    } else {
      this.m_flags &= ~b2Body.e_awakeFlag;
      this.m_sleepTime = 0.0;
      this.m_linearVelocity.SetZero();
      this.m_angularVelocity = 0.0;
      this.m_force.SetZero();
      this.m_torque = 0.0;
    }
  };

  b2Body.prototype.IsAwake = function () {
    return (this.m_flags & b2Body.e_awakeFlag) == b2Body.e_awakeFlag;
  };

  b2Body.prototype.SetFixedRotation = function (fixed) {
    if (fixed) {
      this.m_flags |= b2Body.e_fixedRotationFlag;
    } else {
      this.m_flags &= ~b2Body.e_fixedRotationFlag;
    }

    this.ResetMassData();
  };

  b2Body.prototype.IsFixedRotation = function () {
    return (this.m_flags & b2Body.e_fixedRotationFlag) == b2Body.e_fixedRotationFlag;
  };

  b2Body.prototype.SetActive = function (flag) {
    if (flag == this.IsActive()) {
      return;
    }

    var broadPhase;
    var f;

    if (flag) {
      this.m_flags |= b2Body.e_activeFlag;
      broadPhase = this.m_world.m_contactManager.m_broadPhase;

      for (f = this.m_fixtureList; f; f = f.m_next) {
        f.CreateProxy(broadPhase, this.m_xf);
      }
    } else {
      this.m_flags &= ~b2Body.e_activeFlag;
      broadPhase = this.m_world.m_contactManager.m_broadPhase;

      for (f = this.m_fixtureList; f; f = f.m_next) {
        f.DestroyProxy(broadPhase);
      }

      var ce = this.m_contactList;

      while (ce) {
        var ce0 = ce;
        ce = ce.next;
        this.m_world.m_contactManager.Destroy(ce0.contact);
      }

      this.m_contactList = null;
    }
  };

  b2Body.prototype.IsActive = function () {
    return (this.m_flags & b2Body.e_activeFlag) == b2Body.e_activeFlag;
  };

  b2Body.prototype.IsSleepingAllowed = function () {
    return (this.m_flags & b2Body.e_allowSleepFlag) == b2Body.e_allowSleepFlag;
  };

  b2Body.prototype.GetFixtureList = function () {
    return this.m_fixtureList;
  };

  b2Body.prototype.GetJointList = function () {
    return this.m_jointList;
  };

  b2Body.prototype.GetControllerList = function () {
    return this.m_controllerList;
  };

  b2Body.prototype.GetContactList = function () {
    return this.m_contactList;
  };

  b2Body.prototype.GetNext = function () {
    return this.m_next;
  };

  b2Body.prototype.GetUserData = function () {
    return this.m_userData;
  };

  b2Body.prototype.SetUserData = function (data) {
    this.m_userData = data;
  };

  b2Body.prototype.GetWorld = function () {
    return this.m_world;
  };

  b2Body.prototype.b2Body = function (bd, world) {
    this.m_flags = 0;

    if (bd.bullet) {
      this.m_flags |= b2Body.e_bulletFlag;
    }

    if (bd.fixedRotation) {
      this.m_flags |= b2Body.e_fixedRotationFlag;
    }

    if (bd.allowSleep) {
      this.m_flags |= b2Body.e_allowSleepFlag;
    }

    if (bd.awake) {
      this.m_flags |= b2Body.e_awakeFlag;
    }

    if (bd.active) {
      this.m_flags |= b2Body.e_activeFlag;
    }

    this.m_world = world;
    this.m_xf.position.SetV(bd.position);
    this.m_xf.R.Set(bd.angle);
    this.m_sweep.localCenter.SetZero();
    this.m_sweep.t0 = 1.0;
    this.m_sweep.a0 = this.m_sweep.a = bd.angle;
    var tMat = this.m_xf.R;
    var tVec = this.m_sweep.localCenter;
    this.m_sweep.c.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    this.m_sweep.c.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    this.m_sweep.c.x += this.m_xf.position.x;
    this.m_sweep.c.y += this.m_xf.position.y;
    this.m_sweep.c0.SetV(this.m_sweep.c);
    this.m_jointList = null;
    this.m_controllerList = null;
    this.m_contactList = null;
    this.m_controllerCount = 0;
    this.m_prev = null;
    this.m_next = null;
    this.m_linearVelocity.SetV(bd.linearVelocity);
    this.m_angularVelocity = bd.angularVelocity;
    this.m_linearDamping = bd.linearDamping;
    this.m_angularDamping = bd.angularDamping;
    this.m_force.Set(0.0, 0.0);
    this.m_torque = 0.0;
    this.m_sleepTime = 0.0;
    this.m_type = bd.type;

    if (this.m_type == b2Body.b2_dynamicBody) {
      this.m_mass = 1.0;
      this.m_invMass = 1.0;
    } else {
      this.m_mass = 0.0;
      this.m_invMass = 0.0;
    }

    this.m_I = 0.0;
    this.m_invI = 0.0;
    this.m_inertiaScale = bd.inertiaScale;
    this.m_userData = bd.userData;
    this.m_fixtureList = null;
    this.m_fixtureCount = 0;
  };

  b2Body.prototype.SynchronizeFixtures = function () {
    var xf1 = b2Body.s_xf1;
    xf1.R.Set(this.m_sweep.a0);
    var tMat = xf1.R;
    var tVec = this.m_sweep.localCenter;
    xf1.position.x = this.m_sweep.c0.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    xf1.position.y = this.m_sweep.c0.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    var f;
    var broadPhase = this.m_world.m_contactManager.m_broadPhase;

    for (f = this.m_fixtureList; f; f = f.m_next) {
      f.Synchronize(broadPhase, xf1, this.m_xf);
    }
  };

  b2Body.prototype.SynchronizeTransform = function () {
    this.m_xf.R.Set(this.m_sweep.a);
    var tMat = this.m_xf.R;
    var tVec = this.m_sweep.localCenter;
    this.m_xf.position.x = this.m_sweep.c.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    this.m_xf.position.y = this.m_sweep.c.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  };

  b2Body.prototype.ShouldCollide = function (other) {
    if (this.m_type != b2Body.b2_dynamicBody && other.m_type != b2Body.b2_dynamicBody) {
      return false;
    }

    for (var jn = this.m_jointList; jn; jn = jn.next) {
      if (jn.other == other) if (jn.joint.m_collideConnected == false) {
        return false;
      }
    }

    return true;
  };

  b2Body.prototype.Advance = function (t) {
    if (t === undefined) t = 0;
    this.m_sweep.Advance(t);
    this.m_sweep.c.SetV(this.m_sweep.c0);
    this.m_sweep.a = this.m_sweep.a0;
    this.SynchronizeTransform();
  };

  Box2D.postDefs.push(function () {
    Box2D.Dynamics.b2Body.s_xf1 = new b2Transform();
    Box2D.Dynamics.b2Body.e_islandFlag = 0x0001;
    Box2D.Dynamics.b2Body.e_awakeFlag = 0x0002;
    Box2D.Dynamics.b2Body.e_allowSleepFlag = 0x0004;
    Box2D.Dynamics.b2Body.e_bulletFlag = 0x0008;
    Box2D.Dynamics.b2Body.e_fixedRotationFlag = 0x0010;
    Box2D.Dynamics.b2Body.e_activeFlag = 0x0020;
    Box2D.Dynamics.b2Body.b2_staticBody = 0;
    Box2D.Dynamics.b2Body.b2_kinematicBody = 1;
    Box2D.Dynamics.b2Body.b2_dynamicBody = 2;
  });

  b2BodyDef.b2BodyDef = function () {
    this.position = new b2Vec2();
    this.linearVelocity = new b2Vec2();
  };

  b2BodyDef.prototype.b2BodyDef = function () {
    this.userData = null;
    this.position.Set(0.0, 0.0);
    this.angle = 0.0;
    this.linearVelocity.Set(0, 0);
    this.angularVelocity = 0.0;
    this.linearDamping = 0.0;
    this.angularDamping = 0.0;
    this.allowSleep = true;
    this.awake = true;
    this.fixedRotation = false;
    this.bullet = false;
    this.type = b2Body.b2_staticBody;
    this.active = true;
    this.inertiaScale = 1.0;
  };

  b2ContactFilter.b2ContactFilter = function () {};

  b2ContactFilter.prototype.ShouldCollide = function (fixtureA, fixtureB) {
    var filter1 = fixtureA.GetFilterData();
    var filter2 = fixtureB.GetFilterData();

    if (filter1.groupIndex == filter2.groupIndex && filter1.groupIndex != 0) {
      return filter1.groupIndex > 0;
    }

    var collide = (filter1.maskBits & filter2.categoryBits) != 0 && (filter1.categoryBits & filter2.maskBits) != 0;
    return collide;
  };

  b2ContactFilter.prototype.RayCollide = function (userData, fixture) {
    if (!userData) return true;
    return this.ShouldCollide(userData instanceof b2Fixture ? userData : null, fixture);
  };

  Box2D.postDefs.push(function () {
    Box2D.Dynamics.b2ContactFilter.b2_defaultFilter = new b2ContactFilter();
  });

  b2ContactImpulse.b2ContactImpulse = function () {
    this.normalImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
    this.tangentImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
  };

  b2ContactListener.b2ContactListener = function () {};

  b2ContactListener.prototype.BeginContact = function (contact) {};

  b2ContactListener.prototype.EndContact = function (contact) {};

  b2ContactListener.prototype.PreSolve = function (contact, oldManifold) {};

  b2ContactListener.prototype.PostSolve = function (contact, impulse) {};

  Box2D.postDefs.push(function () {
    Box2D.Dynamics.b2ContactListener.b2_defaultListener = new b2ContactListener();
  });

  b2ContactManager.b2ContactManager = function () {};

  b2ContactManager.prototype.b2ContactManager = function () {
    this.m_world = null;
    this.m_contactCount = 0;
    this.m_contactFilter = b2ContactFilter.b2_defaultFilter;
    this.m_contactListener = b2ContactListener.b2_defaultListener;
    this.m_contactFactory = new b2ContactFactory(this.m_allocator);
    this.m_broadPhase = new b2DynamicTreeBroadPhase();
  };

  b2ContactManager.prototype.AddPair = function (proxyUserDataA, proxyUserDataB) {
    var fixtureA = proxyUserDataA instanceof b2Fixture ? proxyUserDataA : null;
    var fixtureB = proxyUserDataB instanceof b2Fixture ? proxyUserDataB : null;
    var bodyA = fixtureA.GetBody();
    var bodyB = fixtureB.GetBody();
    if (bodyA == bodyB) return;
    var edge = bodyB.GetContactList();

    while (edge) {
      if (edge.other == bodyA) {
        var fA = edge.contact.GetFixtureA();
        var fB = edge.contact.GetFixtureB();
        if (fA == fixtureA && fB == fixtureB) return;
        if (fA == fixtureB && fB == fixtureA) return;
      }

      edge = edge.next;
    }

    if (bodyB.ShouldCollide(bodyA) == false) {
      return;
    }

    if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
      return;
    }

    var c = this.m_contactFactory.Create(fixtureA, fixtureB);
    fixtureA = c.GetFixtureA();
    fixtureB = c.GetFixtureB();
    bodyA = fixtureA.m_body;
    bodyB = fixtureB.m_body;
    c.m_prev = null;
    c.m_next = this.m_world.m_contactList;

    if (this.m_world.m_contactList != null) {
      this.m_world.m_contactList.m_prev = c;
    }

    this.m_world.m_contactList = c;
    c.m_nodeA.contact = c;
    c.m_nodeA.other = bodyB;
    c.m_nodeA.prev = null;
    c.m_nodeA.next = bodyA.m_contactList;

    if (bodyA.m_contactList != null) {
      bodyA.m_contactList.prev = c.m_nodeA;
    }

    bodyA.m_contactList = c.m_nodeA;
    c.m_nodeB.contact = c;
    c.m_nodeB.other = bodyA;
    c.m_nodeB.prev = null;
    c.m_nodeB.next = bodyB.m_contactList;

    if (bodyB.m_contactList != null) {
      bodyB.m_contactList.prev = c.m_nodeB;
    }

    bodyB.m_contactList = c.m_nodeB;
    ++this.m_world.m_contactCount;
    return;
  };

  b2ContactManager.prototype.FindNewContacts = function () {
    this.m_broadPhase.UpdatePairs(Box2D.generateCallback(this, this.AddPair));
  };

  b2ContactManager.prototype.Destroy = function (c) {
    var fixtureA = c.GetFixtureA();
    var fixtureB = c.GetFixtureB();
    var bodyA = fixtureA.GetBody();
    var bodyB = fixtureB.GetBody();

    if (c.IsTouching()) {
      this.m_contactListener.EndContact(c);
    }

    if (c.m_prev) {
      c.m_prev.m_next = c.m_next;
    }

    if (c.m_next) {
      c.m_next.m_prev = c.m_prev;
    }

    if (c == this.m_world.m_contactList) {
      this.m_world.m_contactList = c.m_next;
    }

    if (c.m_nodeA.prev) {
      c.m_nodeA.prev.next = c.m_nodeA.next;
    }

    if (c.m_nodeA.next) {
      c.m_nodeA.next.prev = c.m_nodeA.prev;
    }

    if (c.m_nodeA == bodyA.m_contactList) {
      bodyA.m_contactList = c.m_nodeA.next;
    }

    if (c.m_nodeB.prev) {
      c.m_nodeB.prev.next = c.m_nodeB.next;
    }

    if (c.m_nodeB.next) {
      c.m_nodeB.next.prev = c.m_nodeB.prev;
    }

    if (c.m_nodeB == bodyB.m_contactList) {
      bodyB.m_contactList = c.m_nodeB.next;
    }

    this.m_contactFactory.Destroy(c);
    --this.m_contactCount;
  };

  b2ContactManager.prototype.Collide = function () {
    var c = this.m_world.m_contactList;

    while (c) {
      var fixtureA = c.GetFixtureA();
      var fixtureB = c.GetFixtureB();
      var bodyA = fixtureA.GetBody();
      var bodyB = fixtureB.GetBody();

      if (bodyA.IsAwake() == false && bodyB.IsAwake() == false) {
        c = c.GetNext();
        continue;
      }

      if (c.m_flags & b2Contact.e_filterFlag) {
        if (bodyB.ShouldCollide(bodyA) == false) {
          var cNuke = c;
          c = cNuke.GetNext();
          this.Destroy(cNuke);
          continue;
        }

        if (this.m_contactFilter.ShouldCollide(fixtureA, fixtureB) == false) {
          cNuke = c;
          c = cNuke.GetNext();
          this.Destroy(cNuke);
          continue;
        }

        c.m_flags &= ~b2Contact.e_filterFlag;
      }

      var proxyA = fixtureA.m_proxy;
      var proxyB = fixtureB.m_proxy;
      var overlap = this.m_broadPhase.TestOverlap(proxyA, proxyB);

      if (overlap == false) {
        cNuke = c;
        c = cNuke.GetNext();
        this.Destroy(cNuke);
        continue;
      }

      c.Update(this.m_contactListener);
      c = c.GetNext();
    }
  };

  Box2D.postDefs.push(function () {
    Box2D.Dynamics.b2ContactManager.s_evalCP = new b2ContactPoint();
  });

  b2DebugDraw.b2DebugDraw = function () {};

  b2DebugDraw.prototype.b2DebugDraw = function () {};

  b2DebugDraw.prototype.SetFlags = function (flags) {
    if (flags === undefined) flags = 0;
  };

  b2DebugDraw.prototype.GetFlags = function () {};

  b2DebugDraw.prototype.AppendFlags = function (flags) {
    if (flags === undefined) flags = 0;
  };

  b2DebugDraw.prototype.ClearFlags = function (flags) {
    if (flags === undefined) flags = 0;
  };

  b2DebugDraw.prototype.SetSprite = function (sprite) {};

  b2DebugDraw.prototype.GetSprite = function () {};

  b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
    if (drawScale === undefined) drawScale = 0;
  };

  b2DebugDraw.prototype.GetDrawScale = function () {};

  b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
    if (lineThickness === undefined) lineThickness = 0;
  };

  b2DebugDraw.prototype.GetLineThickness = function () {};

  b2DebugDraw.prototype.SetAlpha = function (alpha) {
    if (alpha === undefined) alpha = 0;
  };

  b2DebugDraw.prototype.GetAlpha = function () {};

  b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
    if (alpha === undefined) alpha = 0;
  };

  b2DebugDraw.prototype.GetFillAlpha = function () {};

  b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
    if (xformScale === undefined) xformScale = 0;
  };

  b2DebugDraw.prototype.GetXFormScale = function () {};

  b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
    if (vertexCount === undefined) vertexCount = 0;
  };

  b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
    if (vertexCount === undefined) vertexCount = 0;
  };

  b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
    if (radius === undefined) radius = 0;
  };

  b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
    if (radius === undefined) radius = 0;
  };

  b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {};

  b2DebugDraw.prototype.DrawTransform = function (xf) {};

  Box2D.postDefs.push(function () {
    Box2D.Dynamics.b2DebugDraw.e_shapeBit = 0x0001;
    Box2D.Dynamics.b2DebugDraw.e_jointBit = 0x0002;
    Box2D.Dynamics.b2DebugDraw.e_aabbBit = 0x0004;
    Box2D.Dynamics.b2DebugDraw.e_pairBit = 0x0008;
    Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit = 0x0010;
    Box2D.Dynamics.b2DebugDraw.e_controllerBit = 0x0020;
  });

  b2DestructionListener.b2DestructionListener = function () {};

  b2DestructionListener.prototype.SayGoodbyeJoint = function (joint) {};

  b2DestructionListener.prototype.SayGoodbyeFixture = function (fixture) {};

  b2FilterData.b2FilterData = function () {
    this.categoryBits = 0x0001;
    this.maskBits = 0xFFFF;
    this.groupIndex = 0;
  };

  b2FilterData.prototype.Copy = function () {
    var copy = new b2FilterData();
    copy.categoryBits = this.categoryBits;
    copy.maskBits = this.maskBits;
    copy.groupIndex = this.groupIndex;
    return copy;
  };

  b2Fixture.b2Fixture = function () {
    this.m_filter = new b2FilterData();
  };

  b2Fixture.prototype.GetType = function () {
    return this.m_shape.GetType();
  };

  b2Fixture.prototype.GetShape = function () {
    return this.m_shape;
  };

  b2Fixture.prototype.SetSensor = function (sensor) {
    if (this.m_isSensor == sensor) return;
    this.m_isSensor = sensor;
    if (this.m_body == null) return;
    var edge = this.m_body.GetContactList();

    while (edge) {
      var contact = edge.contact;
      var fixtureA = contact.GetFixtureA();
      var fixtureB = contact.GetFixtureB();
      if (fixtureA == this || fixtureB == this) contact.SetSensor(fixtureA.IsSensor() || fixtureB.IsSensor());
      edge = edge.next;
    }
  };

  b2Fixture.prototype.IsSensor = function () {
    return this.m_isSensor;
  };

  b2Fixture.prototype.SetFilterData = function (filter) {
    this.m_filter = filter.Copy();
    if (this.m_body) return;
    var edge = this.m_body.GetContactList();

    while (edge) {
      var contact = edge.contact;
      var fixtureA = contact.GetFixtureA();
      var fixtureB = contact.GetFixtureB();
      if (fixtureA == this || fixtureB == this) contact.FlagForFiltering();
      edge = edge.next;
    }
  };

  b2Fixture.prototype.GetFilterData = function () {
    return this.m_filter.Copy();
  };

  b2Fixture.prototype.GetBody = function () {
    return this.m_body;
  };

  b2Fixture.prototype.GetNext = function () {
    return this.m_next;
  };

  b2Fixture.prototype.GetUserData = function () {
    return this.m_userData;
  };

  b2Fixture.prototype.SetUserData = function (data) {
    this.m_userData = data;
  };

  b2Fixture.prototype.TestPoint = function (p) {
    return this.m_shape.TestPoint(this.m_body.GetTransform(), p);
  };

  b2Fixture.prototype.RayCast = function (output, input) {
    return this.m_shape.RayCast(output, input, this.m_body.GetTransform());
  };

  b2Fixture.prototype.GetMassData = function (massData) {
    if (massData === undefined) massData = null;

    if (massData == null) {
      massData = new b2MassData();
    }

    this.m_shape.ComputeMass(massData, this.m_density);
    return massData;
  };

  b2Fixture.prototype.SetDensity = function (density) {
    if (density === undefined) density = 0;
    this.m_density = density;
  };

  b2Fixture.prototype.GetDensity = function () {
    return this.m_density;
  };

  b2Fixture.prototype.GetFriction = function () {
    return this.m_friction;
  };

  b2Fixture.prototype.SetFriction = function (friction) {
    if (friction === undefined) friction = 0;
    this.m_friction = friction;
  };

  b2Fixture.prototype.GetRestitution = function () {
    return this.m_restitution;
  };

  b2Fixture.prototype.SetRestitution = function (restitution) {
    if (restitution === undefined) restitution = 0;
    this.m_restitution = restitution;
  };

  b2Fixture.prototype.GetAABB = function () {
    return this.m_aabb;
  };

  b2Fixture.prototype.b2Fixture = function () {
    this.m_aabb = new b2AABB();
    this.m_userData = null;
    this.m_body = null;
    this.m_next = null;
    this.m_shape = null;
    this.m_density = 0.0;
    this.m_friction = 0.0;
    this.m_restitution = 0.0;
  };

  b2Fixture.prototype.Create = function (body, xf, def) {
    this.m_userData = def.userData;
    this.m_friction = def.friction;
    this.m_restitution = def.restitution;
    this.m_body = body;
    this.m_next = null;
    this.m_filter = def.filter.Copy();
    this.m_isSensor = def.isSensor;
    this.m_shape = def.shape.Copy();
    this.m_density = def.density;
  };

  b2Fixture.prototype.Destroy = function () {
    this.m_shape = null;
  };

  b2Fixture.prototype.CreateProxy = function (broadPhase, xf) {
    this.m_shape.ComputeAABB(this.m_aabb, xf);
    this.m_proxy = broadPhase.CreateProxy(this.m_aabb, this);
  };

  b2Fixture.prototype.DestroyProxy = function (broadPhase) {
    if (this.m_proxy == null) {
      return;
    }

    broadPhase.DestroyProxy(this.m_proxy);
    this.m_proxy = null;
  };

  b2Fixture.prototype.Synchronize = function (broadPhase, transform1, transform2) {
    if (!this.m_proxy) return;
    var aabb1 = new b2AABB();
    var aabb2 = new b2AABB();
    this.m_shape.ComputeAABB(aabb1, transform1);
    this.m_shape.ComputeAABB(aabb2, transform2);
    this.m_aabb.Combine(aabb1, aabb2);
    var displacement = b2Math.SubtractVV(transform2.position, transform1.position);
    broadPhase.MoveProxy(this.m_proxy, this.m_aabb, displacement);
  };

  b2FixtureDef.b2FixtureDef = function () {
    this.filter = new b2FilterData();
  };

  b2FixtureDef.prototype.b2FixtureDef = function () {
    this.shape = null;
    this.userData = null;
    this.friction = 0.2;
    this.restitution = 0.0;
    this.density = 0.0;
    this.filter.categoryBits = 0x0001;
    this.filter.maskBits = 0xFFFF;
    this.filter.groupIndex = 0;
    this.isSensor = false;
  };

  b2Island.b2Island = function () {};

  b2Island.prototype.b2Island = function () {
    this.m_bodies = new Vector();
    this.m_contacts = new Vector();
    this.m_joints = new Vector();
  };

  b2Island.prototype.Initialize = function (bodyCapacity, contactCapacity, jointCapacity, allocator, listener, contactSolver) {
    if (bodyCapacity === undefined) bodyCapacity = 0;
    if (contactCapacity === undefined) contactCapacity = 0;
    if (jointCapacity === undefined) jointCapacity = 0;
    var i = 0;
    this.m_bodyCapacity = bodyCapacity;
    this.m_contactCapacity = contactCapacity;
    this.m_jointCapacity = jointCapacity;
    this.m_bodyCount = 0;
    this.m_contactCount = 0;
    this.m_jointCount = 0;
    this.m_allocator = allocator;
    this.m_listener = listener;
    this.m_contactSolver = contactSolver;

    for (i = this.m_bodies.length; i < bodyCapacity; i++) this.m_bodies[i] = null;

    for (i = this.m_contacts.length; i < contactCapacity; i++) this.m_contacts[i] = null;

    for (i = this.m_joints.length; i < jointCapacity; i++) this.m_joints[i] = null;
  };

  b2Island.prototype.Clear = function () {
    this.m_bodyCount = 0;
    this.m_contactCount = 0;
    this.m_jointCount = 0;
  };

  b2Island.prototype.Solve = function (step, gravity, allowSleep) {
    var i = 0;
    var j = 0;
    var b;
    var joint;

    for (i = 0; i < this.m_bodyCount; ++i) {
      b = this.m_bodies[i];
      if (b.GetType() != b2Body.b2_dynamicBody) continue;
      b.m_linearVelocity.x += step.dt * (gravity.x + b.m_invMass * b.m_force.x);
      b.m_linearVelocity.y += step.dt * (gravity.y + b.m_invMass * b.m_force.y);
      b.m_angularVelocity += step.dt * b.m_invI * b.m_torque;
      b.m_linearVelocity.Multiply(b2Math.Clamp(1.0 - step.dt * b.m_linearDamping, 0.0, 1.0));
      b.m_angularVelocity *= b2Math.Clamp(1.0 - step.dt * b.m_angularDamping, 0.0, 1.0);
    }

    this.m_contactSolver.Initialize(step, this.m_contacts, this.m_contactCount, this.m_allocator);
    var contactSolver = this.m_contactSolver;
    contactSolver.InitVelocityConstraints(step);

    for (i = 0; i < this.m_jointCount; ++i) {
      joint = this.m_joints[i];
      joint.InitVelocityConstraints(step);
    }

    for (i = 0; i < step.velocityIterations; ++i) {
      for (j = 0; j < this.m_jointCount; ++j) {
        joint = this.m_joints[j];
        joint.SolveVelocityConstraints(step);
      }

      contactSolver.SolveVelocityConstraints();
    }

    for (i = 0; i < this.m_jointCount; ++i) {
      joint = this.m_joints[i];
      joint.FinalizeVelocityConstraints();
    }

    contactSolver.FinalizeVelocityConstraints();

    for (i = 0; i < this.m_bodyCount; ++i) {
      b = this.m_bodies[i];
      if (b.GetType() == b2Body.b2_staticBody) continue;
      var translationX = step.dt * b.m_linearVelocity.x;
      var translationY = step.dt * b.m_linearVelocity.y;

      if (translationX * translationX + translationY * translationY > b2Settings.b2_maxTranslationSquared) {
        b.m_linearVelocity.Normalize();
        b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * step.inv_dt;
        b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * step.inv_dt;
      }

      var rotation = step.dt * b.m_angularVelocity;

      if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
        if (b.m_angularVelocity < 0.0) {
          b.m_angularVelocity = -b2Settings.b2_maxRotation * step.inv_dt;
        } else {
          b.m_angularVelocity = b2Settings.b2_maxRotation * step.inv_dt;
        }
      }

      b.m_sweep.c0.SetV(b.m_sweep.c);
      b.m_sweep.a0 = b.m_sweep.a;
      b.m_sweep.c.x += step.dt * b.m_linearVelocity.x;
      b.m_sweep.c.y += step.dt * b.m_linearVelocity.y;
      b.m_sweep.a += step.dt * b.m_angularVelocity;
      b.SynchronizeTransform();
    }

    for (i = 0; i < step.positionIterations; ++i) {
      var contactsOkay = contactSolver.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
      var jointsOkay = true;

      for (j = 0; j < this.m_jointCount; ++j) {
        joint = this.m_joints[j];
        var jointOkay = joint.SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
        jointsOkay = jointsOkay && jointOkay;
      }

      if (contactsOkay && jointsOkay) {
        break;
      }
    }

    this.Report(contactSolver.m_constraints);

    if (allowSleep) {
      var minSleepTime = Number.MAX_VALUE;
      var linTolSqr = b2Settings.b2_linearSleepTolerance * b2Settings.b2_linearSleepTolerance;
      var angTolSqr = b2Settings.b2_angularSleepTolerance * b2Settings.b2_angularSleepTolerance;

      for (i = 0; i < this.m_bodyCount; ++i) {
        b = this.m_bodies[i];

        if (b.GetType() == b2Body.b2_staticBody) {
          continue;
        }

        if ((b.m_flags & b2Body.e_allowSleepFlag) == 0) {
          b.m_sleepTime = 0.0;
          minSleepTime = 0.0;
        }

        if ((b.m_flags & b2Body.e_allowSleepFlag) == 0 || b.m_angularVelocity * b.m_angularVelocity > angTolSqr || b2Math.Dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {
          b.m_sleepTime = 0.0;
          minSleepTime = 0.0;
        } else {
          b.m_sleepTime += step.dt;
          minSleepTime = b2Math.Min(minSleepTime, b.m_sleepTime);
        }
      }

      if (minSleepTime >= b2Settings.b2_timeToSleep) {
        for (i = 0; i < this.m_bodyCount; ++i) {
          b = this.m_bodies[i];
          b.SetAwake(false);
        }
      }
    }
  };

  b2Island.prototype.SolveTOI = function (subStep) {
    var i = 0;
    var j = 0;
    this.m_contactSolver.Initialize(subStep, this.m_contacts, this.m_contactCount, this.m_allocator);
    var contactSolver = this.m_contactSolver;

    for (i = 0; i < this.m_jointCount; ++i) {
      this.m_joints[i].InitVelocityConstraints(subStep);
    }

    for (i = 0; i < subStep.velocityIterations; ++i) {
      contactSolver.SolveVelocityConstraints();

      for (j = 0; j < this.m_jointCount; ++j) {
        this.m_joints[j].SolveVelocityConstraints(subStep);
      }
    }

    for (i = 0; i < this.m_bodyCount; ++i) {
      var b = this.m_bodies[i];
      if (b.GetType() == b2Body.b2_staticBody) continue;
      var translationX = subStep.dt * b.m_linearVelocity.x;
      var translationY = subStep.dt * b.m_linearVelocity.y;

      if (translationX * translationX + translationY * translationY > b2Settings.b2_maxTranslationSquared) {
        b.m_linearVelocity.Normalize();
        b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * subStep.inv_dt;
        b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * subStep.inv_dt;
      }

      var rotation = subStep.dt * b.m_angularVelocity;

      if (rotation * rotation > b2Settings.b2_maxRotationSquared) {
        if (b.m_angularVelocity < 0.0) {
          b.m_angularVelocity = -b2Settings.b2_maxRotation * subStep.inv_dt;
        } else {
          b.m_angularVelocity = b2Settings.b2_maxRotation * subStep.inv_dt;
        }
      }

      b.m_sweep.c0.SetV(b.m_sweep.c);
      b.m_sweep.a0 = b.m_sweep.a;
      b.m_sweep.c.x += subStep.dt * b.m_linearVelocity.x;
      b.m_sweep.c.y += subStep.dt * b.m_linearVelocity.y;
      b.m_sweep.a += subStep.dt * b.m_angularVelocity;
      b.SynchronizeTransform();
    }

    var k_toiBaumgarte = 0.75;

    for (i = 0; i < subStep.positionIterations; ++i) {
      var contactsOkay = contactSolver.SolvePositionConstraints(k_toiBaumgarte);
      var jointsOkay = true;

      for (j = 0; j < this.m_jointCount; ++j) {
        var jointOkay = this.m_joints[j].SolvePositionConstraints(b2Settings.b2_contactBaumgarte);
        jointsOkay = jointsOkay && jointOkay;
      }

      if (contactsOkay && jointsOkay) {
        break;
      }
    }

    this.Report(contactSolver.m_constraints);
  };

  b2Island.prototype.Report = function (constraints) {
    if (this.m_listener == null) {
      return;
    }

    for (var i = 0; i < this.m_contactCount; ++i) {
      var c = this.m_contacts[i];
      var cc = constraints[i];

      for (var j = 0; j < cc.pointCount; ++j) {
        b2Island.s_impulse.normalImpulses[j] = cc.points[j].normalImpulse;
        b2Island.s_impulse.tangentImpulses[j] = cc.points[j].tangentImpulse;
      }

      this.m_listener.PostSolve(c, b2Island.s_impulse);
    }
  };

  b2Island.prototype.AddBody = function (body) {
    body.m_islandIndex = this.m_bodyCount;
    this.m_bodies[this.m_bodyCount++] = body;
  };

  b2Island.prototype.AddContact = function (contact) {
    this.m_contacts[this.m_contactCount++] = contact;
  };

  b2Island.prototype.AddJoint = function (joint) {
    this.m_joints[this.m_jointCount++] = joint;
  };

  Box2D.postDefs.push(function () {
    Box2D.Dynamics.b2Island.s_impulse = new b2ContactImpulse();
  });

  b2TimeStep.b2TimeStep = function () {};

  b2TimeStep.prototype.Set = function (step) {
    this.dt = step.dt;
    this.inv_dt = step.inv_dt;
    this.positionIterations = step.positionIterations;
    this.velocityIterations = step.velocityIterations;
    this.warmStarting = step.warmStarting;
  };

  b2World.b2World = function () {
    this.s_stack = new Vector();
    this.m_contactManager = new b2ContactManager();
    this.m_contactSolver = new b2ContactSolver();
    this.m_island = new b2Island();
  };

  b2World.prototype.b2World = function (gravity, doSleep) {
    this.m_destructionListener = null;
    this.m_debugDraw = null;
    this.m_bodyList = null;
    this.m_contactList = null;
    this.m_jointList = null;
    this.m_controllerList = null;
    this.m_bodyCount = 0;
    this.m_contactCount = 0;
    this.m_jointCount = 0;
    this.m_controllerCount = 0;
    b2World.m_warmStarting = true;
    b2World.m_continuousPhysics = true;
    this.m_allowSleep = doSleep;
    this.m_gravity = gravity;
    this.m_inv_dt0 = 0.0;
    this.m_contactManager.m_world = this;
    var bd = new b2BodyDef();
    this.m_groundBody = this.CreateBody(bd);
  };

  b2World.prototype.SetDestructionListener = function (listener) {
    this.m_destructionListener = listener;
  };

  b2World.prototype.SetContactFilter = function (filter) {
    this.m_contactManager.m_contactFilter = filter;
  };

  b2World.prototype.SetContactListener = function (listener) {
    this.m_contactManager.m_contactListener = listener;
  };

  b2World.prototype.SetDebugDraw = function (debugDraw) {
    this.m_debugDraw = debugDraw;
  };

  b2World.prototype.SetBroadPhase = function (broadPhase) {
    var oldBroadPhase = this.m_contactManager.m_broadPhase;
    this.m_contactManager.m_broadPhase = broadPhase;

    for (var b = this.m_bodyList; b; b = b.m_next) {
      for (var f = b.m_fixtureList; f; f = f.m_next) {
        f.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f);
      }
    }
  };

  b2World.prototype.Validate = function () {
    this.m_contactManager.m_broadPhase.Validate();
  };

  b2World.prototype.GetProxyCount = function () {
    return this.m_contactManager.m_broadPhase.GetProxyCount();
  };

  b2World.prototype.CreateBody = function (def) {
    if (this.IsLocked() == true) {
      return null;
    }

    var b = new b2Body(def, this);
    b.m_prev = null;
    b.m_next = this.m_bodyList;

    if (this.m_bodyList) {
      this.m_bodyList.m_prev = b;
    }

    this.m_bodyList = b;
    ++this.m_bodyCount;
    return b;
  };

  b2World.prototype.DestroyBody = function (b) {
    if (this.IsLocked() == true) {
      return;
    }

    var jn = b.m_jointList;

    while (jn) {
      var jn0 = jn;
      jn = jn.next;

      if (this.m_destructionListener) {
        this.m_destructionListener.SayGoodbyeJoint(jn0.joint);
      }

      this.DestroyJoint(jn0.joint);
    }

    var coe = b.m_controllerList;

    while (coe) {
      var coe0 = coe;
      coe = coe.nextController;
      coe0.controller.RemoveBody(b);
    }

    var ce = b.m_contactList;

    while (ce) {
      var ce0 = ce;
      ce = ce.next;
      this.m_contactManager.Destroy(ce0.contact);
    }

    b.m_contactList = null;
    var f = b.m_fixtureList;

    while (f) {
      var f0 = f;
      f = f.m_next;

      if (this.m_destructionListener) {
        this.m_destructionListener.SayGoodbyeFixture(f0);
      }

      f0.DestroyProxy(this.m_contactManager.m_broadPhase);
      f0.Destroy();
    }

    b.m_fixtureList = null;
    b.m_fixtureCount = 0;

    if (b.m_prev) {
      b.m_prev.m_next = b.m_next;
    }

    if (b.m_next) {
      b.m_next.m_prev = b.m_prev;
    }

    if (b == this.m_bodyList) {
      this.m_bodyList = b.m_next;
    }

    --this.m_bodyCount;
  };

  b2World.prototype.CreateJoint = function (def) {
    var j = b2Joint.Create(def, null);
    j.m_prev = null;
    j.m_next = this.m_jointList;

    if (this.m_jointList) {
      this.m_jointList.m_prev = j;
    }

    this.m_jointList = j;
    ++this.m_jointCount;
    j.m_edgeA.joint = j;
    j.m_edgeA.other = j.m_bodyB;
    j.m_edgeA.prev = null;
    j.m_edgeA.next = j.m_bodyA.m_jointList;
    if (j.m_bodyA.m_jointList) j.m_bodyA.m_jointList.prev = j.m_edgeA;
    j.m_bodyA.m_jointList = j.m_edgeA;
    j.m_edgeB.joint = j;
    j.m_edgeB.other = j.m_bodyA;
    j.m_edgeB.prev = null;
    j.m_edgeB.next = j.m_bodyB.m_jointList;
    if (j.m_bodyB.m_jointList) j.m_bodyB.m_jointList.prev = j.m_edgeB;
    j.m_bodyB.m_jointList = j.m_edgeB;
    var bodyA = def.bodyA;
    var bodyB = def.bodyB;

    if (def.collideConnected == false) {
      var edge = bodyB.GetContactList();

      while (edge) {
        if (edge.other == bodyA) {
          edge.contact.FlagForFiltering();
        }

        edge = edge.next;
      }
    }

    return j;
  };

  b2World.prototype.DestroyJoint = function (j) {
    var collideConnected = j.m_collideConnected;

    if (j.m_prev) {
      j.m_prev.m_next = j.m_next;
    }

    if (j.m_next) {
      j.m_next.m_prev = j.m_prev;
    }

    if (j == this.m_jointList) {
      this.m_jointList = j.m_next;
    }

    var bodyA = j.m_bodyA;
    var bodyB = j.m_bodyB;
    bodyA.SetAwake(true);
    bodyB.SetAwake(true);

    if (j.m_edgeA.prev) {
      j.m_edgeA.prev.next = j.m_edgeA.next;
    }

    if (j.m_edgeA.next) {
      j.m_edgeA.next.prev = j.m_edgeA.prev;
    }

    if (j.m_edgeA == bodyA.m_jointList) {
      bodyA.m_jointList = j.m_edgeA.next;
    }

    j.m_edgeA.prev = null;
    j.m_edgeA.next = null;

    if (j.m_edgeB.prev) {
      j.m_edgeB.prev.next = j.m_edgeB.next;
    }

    if (j.m_edgeB.next) {
      j.m_edgeB.next.prev = j.m_edgeB.prev;
    }

    if (j.m_edgeB == bodyB.m_jointList) {
      bodyB.m_jointList = j.m_edgeB.next;
    }

    j.m_edgeB.prev = null;
    j.m_edgeB.next = null;
    b2Joint.Destroy(j, null);
    --this.m_jointCount;

    if (collideConnected == false) {
      var edge = bodyB.GetContactList();

      while (edge) {
        if (edge.other == bodyA) {
          edge.contact.FlagForFiltering();
        }

        edge = edge.next;
      }
    }
  };

  b2World.prototype.AddController = function (c) {
    c.m_next = this.m_controllerList;
    c.m_prev = null;
    this.m_controllerList = c;
    c.m_world = this;
    this.m_controllerCount++;
    return c;
  };

  b2World.prototype.RemoveController = function (c) {
    if (c.m_prev) c.m_prev.m_next = c.m_next;
    if (c.m_next) c.m_next.m_prev = c.m_prev;
    if (this.m_controllerList == c) this.m_controllerList = c.m_next;
    this.m_controllerCount--;
  };

  b2World.prototype.CreateController = function (controller) {
    if (controller.m_world != this) throw new Error("Controller can only be a member of one world");
    controller.m_next = this.m_controllerList;
    controller.m_prev = null;
    if (this.m_controllerList) this.m_controllerList.m_prev = controller;
    this.m_controllerList = controller;
    ++this.m_controllerCount;
    controller.m_world = this;
    return controller;
  };

  b2World.prototype.DestroyController = function (controller) {
    controller.Clear();
    if (controller.m_next) controller.m_next.m_prev = controller.m_prev;
    if (controller.m_prev) controller.m_prev.m_next = controller.m_next;
    if (controller == this.m_controllerList) this.m_controllerList = controller.m_next;
    --this.m_controllerCount;
  };

  b2World.prototype.SetWarmStarting = function (flag) {
    b2World.m_warmStarting = flag;
  };

  b2World.prototype.SetContinuousPhysics = function (flag) {
    b2World.m_continuousPhysics = flag;
  };

  b2World.prototype.GetBodyCount = function () {
    return this.m_bodyCount;
  };

  b2World.prototype.GetJointCount = function () {
    return this.m_jointCount;
  };

  b2World.prototype.GetContactCount = function () {
    return this.m_contactCount;
  };

  b2World.prototype.SetGravity = function (gravity) {
    this.m_gravity = gravity;
  };

  b2World.prototype.GetGravity = function () {
    return this.m_gravity;
  };

  b2World.prototype.GetGroundBody = function () {
    return this.m_groundBody;
  };

  b2World.prototype.Step = function (dt, velocityIterations, positionIterations) {
    if (dt === undefined) dt = 0;
    if (velocityIterations === undefined) velocityIterations = 0;
    if (positionIterations === undefined) positionIterations = 0;

    if (this.m_flags & b2World.e_newFixture) {
      this.m_contactManager.FindNewContacts();
      this.m_flags &= ~b2World.e_newFixture;
    }

    this.m_flags |= b2World.e_locked;
    var step = b2World.s_timestep2;
    step.dt = dt;
    step.velocityIterations = velocityIterations;
    step.positionIterations = positionIterations;

    if (dt > 0.0) {
      step.inv_dt = 1.0 / dt;
    } else {
      step.inv_dt = 0.0;
    }

    step.dtRatio = this.m_inv_dt0 * dt;
    step.warmStarting = b2World.m_warmStarting;
    this.m_contactManager.Collide();

    if (step.dt > 0.0) {
      this.Solve(step);
    }

    if (b2World.m_continuousPhysics && step.dt > 0.0) {
      this.SolveTOI(step);
    }

    if (step.dt > 0.0) {
      this.m_inv_dt0 = step.inv_dt;
    }

    this.m_flags &= ~b2World.e_locked;
  };

  b2World.prototype.ClearForces = function () {
    for (var body = this.m_bodyList; body; body = body.m_next) {
      body.m_force.SetZero();
      body.m_torque = 0.0;
    }
  };

  b2World.prototype.DrawDebugData = function () {
    if (this.m_debugDraw == null) {
      return;
    }

    this.m_debugDraw.m_sprite.graphics.clear();
    var flags = this.m_debugDraw.GetFlags();
    var i = 0;
    var b;
    var f;
    var s;
    var j;
    var bp;
    var invQ = new b2Vec2();
    var x1 = new b2Vec2();
    var x2 = new b2Vec2();
    var xf;
    var b1 = new b2AABB();
    var b2 = new b2AABB();
    var vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];
    var color = new b2Color(0, 0, 0);

    if (flags & b2DebugDraw.e_shapeBit) {
      for (b = this.m_bodyList; b; b = b.m_next) {
        xf = b.m_xf;

        for (f = b.GetFixtureList(); f; f = f.m_next) {
          s = f.GetShape();

          if (b.IsActive() == false) {
            color.Set(0.5, 0.5, 0.3);
            this.DrawShape(s, xf, color);
          } else if (b.GetType() == b2Body.b2_staticBody) {
            color.Set(0.5, 0.9, 0.5);
            this.DrawShape(s, xf, color);
          } else if (b.GetType() == b2Body.b2_kinematicBody) {
            color.Set(0.5, 0.5, 0.9);
            this.DrawShape(s, xf, color);
          } else if (b.IsAwake() == false) {
            color.Set(0.6, 0.6, 0.6);
            this.DrawShape(s, xf, color);
          } else {
            color.Set(0.9, 0.7, 0.7);
            this.DrawShape(s, xf, color);
          }
        }
      }
    }

    if (flags & b2DebugDraw.e_jointBit) {
      for (j = this.m_jointList; j; j = j.m_next) {
        this.DrawJoint(j);
      }
    }

    if (flags & b2DebugDraw.e_controllerBit) {
      for (var c = this.m_controllerList; c; c = c.m_next) {
        c.Draw(this.m_debugDraw);
      }
    }

    if (flags & b2DebugDraw.e_pairBit) {
      color.Set(0.3, 0.9, 0.9);

      for (var contact = this.m_contactManager.m_contactList; contact; contact = contact.GetNext()) {
        var fixtureA = contact.GetFixtureA();
        var fixtureB = contact.GetFixtureB();
        var cA = fixtureA.GetAABB().GetCenter();
        var cB = fixtureB.GetAABB().GetCenter();
        this.m_debugDraw.DrawSegment(cA, cB, color);
      }
    }

    if (flags & b2DebugDraw.e_aabbBit) {
      bp = this.m_contactManager.m_broadPhase;
      vs = [new b2Vec2(), new b2Vec2(), new b2Vec2(), new b2Vec2()];

      for (b = this.m_bodyList; b; b = b.GetNext()) {
        if (b.IsActive() == false) {
          continue;
        }

        for (f = b.GetFixtureList(); f; f = f.GetNext()) {
          var aabb = bp.GetFatAABB(f.m_proxy);
          vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
          vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
          vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
          vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
          this.m_debugDraw.DrawPolygon(vs, 4, color);
        }
      }
    }

    if (flags & b2DebugDraw.e_centerOfMassBit) {
      for (b = this.m_bodyList; b; b = b.m_next) {
        xf = b2World.s_xf;
        xf.R = b.m_xf.R;
        xf.position = b.GetWorldCenter();
        this.m_debugDraw.DrawTransform(xf);
      }
    }
  };

  b2World.prototype.QueryAABB = function (callback, aabb) {
    var __this = this;

    var broadPhase = __this.m_contactManager.m_broadPhase;

    function WorldQueryWrapper(proxy) {
      return callback(broadPhase.GetUserData(proxy));
    }

    ;
    broadPhase.Query(WorldQueryWrapper, aabb);
  };

  b2World.prototype.QueryShape = function (callback, shape, transform) {
    var __this = this;

    if (transform === undefined) transform = null;

    if (transform == null) {
      transform = new b2Transform();
      transform.SetIdentity();
    }

    var broadPhase = __this.m_contactManager.m_broadPhase;

    function WorldQueryWrapper(proxy) {
      var fixture = broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null;
      if (b2Shape.TestOverlap(shape, transform, fixture.GetShape(), fixture.GetBody().GetTransform())) return callback(fixture);
      return true;
    }

    ;
    var aabb = new b2AABB();
    shape.ComputeAABB(aabb, transform);
    broadPhase.Query(WorldQueryWrapper, aabb);
  };

  b2World.prototype.QueryPoint = function (callback, p) {
    var __this = this;

    var broadPhase = __this.m_contactManager.m_broadPhase;

    function WorldQueryWrapper(proxy) {
      var fixture = broadPhase.GetUserData(proxy) instanceof b2Fixture ? broadPhase.GetUserData(proxy) : null;
      if (fixture.TestPoint(p)) return callback(fixture);
      return true;
    }

    ;
    var aabb = new b2AABB();
    aabb.lowerBound.Set(p.x - b2Settings.b2_linearSlop, p.y - b2Settings.b2_linearSlop);
    aabb.upperBound.Set(p.x + b2Settings.b2_linearSlop, p.y + b2Settings.b2_linearSlop);
    broadPhase.Query(WorldQueryWrapper, aabb);
  };

  b2World.prototype.RayCast = function (callback, point1, point2) {
    var __this = this;

    var broadPhase = __this.m_contactManager.m_broadPhase;
    var output = new b2RayCastOutput();

    function RayCastWrapper(input, proxy) {
      var userData = broadPhase.GetUserData(proxy);
      var fixture = userData instanceof b2Fixture ? userData : null;
      var hit = fixture.RayCast(output, input);

      if (hit) {
        var fraction = output.fraction;
        var point = new b2Vec2((1.0 - fraction) * point1.x + fraction * point2.x, (1.0 - fraction) * point1.y + fraction * point2.y);
        return callback(fixture, point, output.normal, fraction);
      }

      return input.maxFraction;
    }

    ;
    var input = new b2RayCastInput(point1, point2);
    broadPhase.RayCast(RayCastWrapper, input);
  };

  b2World.prototype.RayCastOne = function (point1, point2) {
    var __this = this;

    var result;

    function RayCastOneWrapper(fixture, point, normal, fraction) {
      if (fraction === undefined) fraction = 0;
      result = fixture;
      return fraction;
    }

    ;

    __this.RayCast(RayCastOneWrapper, point1, point2);

    return result;
  };

  b2World.prototype.RayCastAll = function (point1, point2) {
    var __this = this;

    var result = new Vector();

    function RayCastAllWrapper(fixture, point, normal, fraction) {
      if (fraction === undefined) fraction = 0;
      result[result.length] = fixture;
      return 1;
    }

    ;

    __this.RayCast(RayCastAllWrapper, point1, point2);

    return result;
  };

  b2World.prototype.GetBodyList = function () {
    return this.m_bodyList;
  };

  b2World.prototype.GetJointList = function () {
    return this.m_jointList;
  };

  b2World.prototype.GetContactList = function () {
    return this.m_contactList;
  };

  b2World.prototype.IsLocked = function () {
    return (this.m_flags & b2World.e_locked) > 0;
  };

  b2World.prototype.Solve = function (step) {
    var b;

    for (var controller = this.m_controllerList; controller; controller = controller.m_next) {
      controller.Step(step);
    }

    var island = this.m_island;
    island.Initialize(this.m_bodyCount, this.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener, this.m_contactSolver);

    for (b = this.m_bodyList; b; b = b.m_next) {
      b.m_flags &= ~b2Body.e_islandFlag;
    }

    for (var c = this.m_contactList; c; c = c.m_next) {
      c.m_flags &= ~b2Contact.e_islandFlag;
    }

    for (var j = this.m_jointList; j; j = j.m_next) {
      j.m_islandFlag = false;
    }

    var stackSize = parseInt(this.m_bodyCount);
    var stack = this.s_stack;

    for (var seed = this.m_bodyList; seed; seed = seed.m_next) {
      if (seed.m_flags & b2Body.e_islandFlag) {
        continue;
      }

      if (seed.IsAwake() == false || seed.IsActive() == false) {
        continue;
      }

      if (seed.GetType() == b2Body.b2_staticBody) {
        continue;
      }

      island.Clear();
      var stackCount = 0;
      stack[stackCount++] = seed;
      seed.m_flags |= b2Body.e_islandFlag;

      while (stackCount > 0) {
        b = stack[--stackCount];
        island.AddBody(b);

        if (b.IsAwake() == false) {
          b.SetAwake(true);
        }

        if (b.GetType() == b2Body.b2_staticBody) {
          continue;
        }

        var other;

        for (var ce = b.m_contactList; ce; ce = ce.next) {
          if (ce.contact.m_flags & b2Contact.e_islandFlag) {
            continue;
          }

          if (ce.contact.IsSensor() == true || ce.contact.IsEnabled() == false || ce.contact.IsTouching() == false) {
            continue;
          }

          island.AddContact(ce.contact);
          ce.contact.m_flags |= b2Contact.e_islandFlag;
          other = ce.other;

          if (other.m_flags & b2Body.e_islandFlag) {
            continue;
          }

          stack[stackCount++] = other;
          other.m_flags |= b2Body.e_islandFlag;
        }

        for (var jn = b.m_jointList; jn; jn = jn.next) {
          if (jn.joint.m_islandFlag == true) {
            continue;
          }

          other = jn.other;

          if (other.IsActive() == false) {
            continue;
          }

          island.AddJoint(jn.joint);
          jn.joint.m_islandFlag = true;

          if (other.m_flags & b2Body.e_islandFlag) {
            continue;
          }

          stack[stackCount++] = other;
          other.m_flags |= b2Body.e_islandFlag;
        }
      }

      island.Solve(step, this.m_gravity, this.m_allowSleep);

      for (var i = 0; i < island.m_bodyCount; ++i) {
        b = island.m_bodies[i];

        if (b.GetType() == b2Body.b2_staticBody) {
          b.m_flags &= ~b2Body.e_islandFlag;
        }
      }
    }

    for (i = 0; i < stack.length; ++i) {
      if (!stack[i]) break;
      stack[i] = null;
    }

    for (b = this.m_bodyList; b; b = b.m_next) {
      if (b.IsAwake() == false || b.IsActive() == false) {
        continue;
      }

      if (b.GetType() == b2Body.b2_staticBody) {
        continue;
      }

      b.SynchronizeFixtures();
    }

    this.m_contactManager.FindNewContacts();
  };

  b2World.prototype.SolveTOI = function (step) {
    var b;
    var fA;
    var fB;
    var bA;
    var bB;
    var cEdge;
    var j;
    var island = this.m_island;
    island.Initialize(this.m_bodyCount, b2Settings.b2_maxTOIContactsPerIsland, b2Settings.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.m_contactSolver);
    var queue = b2World.s_queue;

    for (b = this.m_bodyList; b; b = b.m_next) {
      b.m_flags &= ~b2Body.e_islandFlag;
      b.m_sweep.t0 = 0.0;
    }

    var c;

    for (c = this.m_contactList; c; c = c.m_next) {
      c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag);
    }

    for (j = this.m_jointList; j; j = j.m_next) {
      j.m_islandFlag = false;
    }

    for (;;) {
      var minContact = null;
      var minTOI = 1.0;

      for (c = this.m_contactList; c; c = c.m_next) {
        if (c.IsSensor() == true || c.IsEnabled() == false || c.IsContinuous() == false) {
          continue;
        }

        var toi = 1.0;

        if (c.m_flags & b2Contact.e_toiFlag) {
          toi = c.m_toi;
        } else {
          fA = c.m_fixtureA;
          fB = c.m_fixtureB;
          bA = fA.m_body;
          bB = fB.m_body;

          if ((bA.GetType() != b2Body.b2_dynamicBody || bA.IsAwake() == false) && (bB.GetType() != b2Body.b2_dynamicBody || bB.IsAwake() == false)) {
            continue;
          }

          var t0 = bA.m_sweep.t0;

          if (bA.m_sweep.t0 < bB.m_sweep.t0) {
            t0 = bB.m_sweep.t0;
            bA.m_sweep.Advance(t0);
          } else if (bB.m_sweep.t0 < bA.m_sweep.t0) {
            t0 = bA.m_sweep.t0;
            bB.m_sweep.Advance(t0);
          }

          toi = c.ComputeTOI(bA.m_sweep, bB.m_sweep);
          b2Settings.b2Assert(0.0 <= toi && toi <= 1.0);

          if (toi > 0.0 && toi < 1.0) {
            toi = (1.0 - toi) * t0 + toi;
            if (toi > 1) toi = 1;
          }

          c.m_toi = toi;
          c.m_flags |= b2Contact.e_toiFlag;
        }

        if (Number.MIN_VALUE < toi && toi < minTOI) {
          minContact = c;
          minTOI = toi;
        }
      }

      if (minContact == null || 1.0 - 100.0 * Number.MIN_VALUE < minTOI) {
        break;
      }

      fA = minContact.m_fixtureA;
      fB = minContact.m_fixtureB;
      bA = fA.m_body;
      bB = fB.m_body;
      b2World.s_backupA.Set(bA.m_sweep);
      b2World.s_backupB.Set(bB.m_sweep);
      bA.Advance(minTOI);
      bB.Advance(minTOI);
      minContact.Update(this.m_contactManager.m_contactListener);
      minContact.m_flags &= ~b2Contact.e_toiFlag;

      if (minContact.IsSensor() == true || minContact.IsEnabled() == false) {
        bA.m_sweep.Set(b2World.s_backupA);
        bB.m_sweep.Set(b2World.s_backupB);
        bA.SynchronizeTransform();
        bB.SynchronizeTransform();
        continue;
      }

      if (minContact.IsTouching() == false) {
        continue;
      }

      var seed = bA;

      if (seed.GetType() != b2Body.b2_dynamicBody) {
        seed = bB;
      }

      island.Clear();
      var queueStart = 0;
      var queueSize = 0;
      queue[queueStart + queueSize++] = seed;
      seed.m_flags |= b2Body.e_islandFlag;

      while (queueSize > 0) {
        b = queue[queueStart++];
        --queueSize;
        island.AddBody(b);

        if (b.IsAwake() == false) {
          b.SetAwake(true);
        }

        if (b.GetType() != b2Body.b2_dynamicBody) {
          continue;
        }

        for (cEdge = b.m_contactList; cEdge; cEdge = cEdge.next) {
          if (island.m_contactCount == island.m_contactCapacity) {
            break;
          }

          if (cEdge.contact.m_flags & b2Contact.e_islandFlag) {
            continue;
          }

          if (cEdge.contact.IsSensor() == true || cEdge.contact.IsEnabled() == false || cEdge.contact.IsTouching() == false) {
            continue;
          }

          island.AddContact(cEdge.contact);
          cEdge.contact.m_flags |= b2Contact.e_islandFlag;
          var other = cEdge.other;

          if (other.m_flags & b2Body.e_islandFlag) {
            continue;
          }

          if (other.GetType() != b2Body.b2_staticBody) {
            other.Advance(minTOI);
            other.SetAwake(true);
          }

          queue[queueStart + queueSize] = other;
          ++queueSize;
          other.m_flags |= b2Body.e_islandFlag;
        }

        for (var jEdge = b.m_jointList; jEdge; jEdge = jEdge.next) {
          if (island.m_jointCount == island.m_jointCapacity) continue;
          if (jEdge.joint.m_islandFlag == true) continue;
          other = jEdge.other;

          if (other.IsActive() == false) {
            continue;
          }

          island.AddJoint(jEdge.joint);
          jEdge.joint.m_islandFlag = true;
          if (other.m_flags & b2Body.e_islandFlag) continue;

          if (other.GetType() != b2Body.b2_staticBody) {
            other.Advance(minTOI);
            other.SetAwake(true);
          }

          queue[queueStart + queueSize] = other;
          ++queueSize;
          other.m_flags |= b2Body.e_islandFlag;
        }
      }

      var subStep = b2World.s_timestep;
      subStep.warmStarting = false;
      subStep.dt = (1.0 - minTOI) * step.dt;
      subStep.inv_dt = 1.0 / subStep.dt;
      subStep.dtRatio = 0.0;
      subStep.velocityIterations = step.velocityIterations;
      subStep.positionIterations = step.positionIterations;
      island.SolveTOI(subStep);
      var i = 0;

      for (i = 0; i < island.m_bodyCount; ++i) {
        b = island.m_bodies[i];
        b.m_flags &= ~b2Body.e_islandFlag;

        if (b.IsAwake() == false) {
          continue;
        }

        if (b.GetType() != b2Body.b2_dynamicBody) {
          continue;
        }

        b.SynchronizeFixtures();

        for (cEdge = b.m_contactList; cEdge; cEdge = cEdge.next) {
          cEdge.contact.m_flags &= ~b2Contact.e_toiFlag;
        }
      }

      for (i = 0; i < island.m_contactCount; ++i) {
        c = island.m_contacts[i];
        c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag);
      }

      for (i = 0; i < island.m_jointCount; ++i) {
        j = island.m_joints[i];
        j.m_islandFlag = false;
      }

      this.m_contactManager.FindNewContacts();
    }
  };

  b2World.prototype.DrawJoint = function (joint) {
    var b1 = joint.GetBodyA();
    var b2 = joint.GetBodyB();
    var xf1 = b1.m_xf;
    var xf2 = b2.m_xf;
    var x1 = xf1.position;
    var x2 = xf2.position;
    var p1 = joint.GetAnchorA();
    var p2 = joint.GetAnchorB();
    var color = b2World.s_jointColor;

    switch (joint.m_type) {
      case b2Joint.e_distanceJoint:
        this.m_debugDraw.DrawSegment(p1, p2, color);
        break;

      case b2Joint.e_pulleyJoint:
        {
          var pulley = joint instanceof b2PulleyJoint ? joint : null;
          var s1 = pulley.GetGroundAnchorA();
          var s2 = pulley.GetGroundAnchorB();
          this.m_debugDraw.DrawSegment(s1, p1, color);
          this.m_debugDraw.DrawSegment(s2, p2, color);
          this.m_debugDraw.DrawSegment(s1, s2, color);
        }
        break;

      case b2Joint.e_mouseJoint:
        this.m_debugDraw.DrawSegment(p1, p2, color);
        break;

      default:
        if (b1 != this.m_groundBody) this.m_debugDraw.DrawSegment(x1, p1, color);
        this.m_debugDraw.DrawSegment(p1, p2, color);
        if (b2 != this.m_groundBody) this.m_debugDraw.DrawSegment(x2, p2, color);
    }
  };

  b2World.prototype.DrawShape = function (shape, xf, color) {
    switch (shape.m_type) {
      case b2Shape.e_circleShape:
        {
          var circle = shape instanceof b2CircleShape ? shape : null;
          var center = b2Math.MulX(xf, circle.m_p);
          var radius = circle.m_radius;
          var axis = xf.R.col1;
          this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);
        }
        break;

      case b2Shape.e_polygonShape:
        {
          var i = 0;
          var poly = shape instanceof b2PolygonShape ? shape : null;
          var vertexCount = parseInt(poly.GetVertexCount());
          var localVertices = poly.GetVertices();
          var vertices = new Vector(vertexCount);

          for (i = 0; i < vertexCount; ++i) {
            vertices[i] = b2Math.MulX(xf, localVertices[i]);
          }

          this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
        }
        break;

      case b2Shape.e_edgeShape:
        {
          var edge = shape instanceof b2EdgeShape ? shape : null;
          this.m_debugDraw.DrawSegment(b2Math.MulX(xf, edge.GetVertex1()), b2Math.MulX(xf, edge.GetVertex2()), color);
        }
        break;
    }
  };

  Box2D.postDefs.push(function () {
    Box2D.Dynamics.b2World.s_timestep2 = new b2TimeStep();
    Box2D.Dynamics.b2World.s_xf = new b2Transform();
    Box2D.Dynamics.b2World.s_backupA = new b2Sweep();
    Box2D.Dynamics.b2World.s_backupB = new b2Sweep();
    Box2D.Dynamics.b2World.s_timestep = new b2TimeStep();
    Box2D.Dynamics.b2World.s_queue = new Vector();
    Box2D.Dynamics.b2World.s_jointColor = new b2Color(0.5, 0.8, 0.8);
    Box2D.Dynamics.b2World.e_newFixture = 0x0001;
    Box2D.Dynamics.b2World.e_locked = 0x0002;
  });
})();

(function () {
  var b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact,
      b2Contact = Box2D.Dynamics.Contacts.b2Contact,
      b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint,
      b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint,
      b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge,
      b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory,
      b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister,
      b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult,
      b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver,
      b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact,
      b2NullContact = Box2D.Dynamics.Contacts.b2NullContact,
      b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact,
      b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact,
      b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact,
      b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2AABB = Box2D.Collision.b2AABB,
      b2Bound = Box2D.Collision.b2Bound,
      b2BoundValues = Box2D.Collision.b2BoundValues,
      b2Collision = Box2D.Collision.b2Collision,
      b2ContactID = Box2D.Collision.b2ContactID,
      b2ContactPoint = Box2D.Collision.b2ContactPoint,
      b2Distance = Box2D.Collision.b2Distance,
      b2DistanceInput = Box2D.Collision.b2DistanceInput,
      b2DistanceOutput = Box2D.Collision.b2DistanceOutput,
      b2DistanceProxy = Box2D.Collision.b2DistanceProxy,
      b2DynamicTree = Box2D.Collision.b2DynamicTree,
      b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase,
      b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode,
      b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair,
      b2Manifold = Box2D.Collision.b2Manifold,
      b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint,
      b2Point = Box2D.Collision.b2Point,
      b2RayCastInput = Box2D.Collision.b2RayCastInput,
      b2RayCastOutput = Box2D.Collision.b2RayCastOutput,
      b2Segment = Box2D.Collision.b2Segment,
      b2SeparationFunction = Box2D.Collision.b2SeparationFunction,
      b2Simplex = Box2D.Collision.b2Simplex,
      b2SimplexCache = Box2D.Collision.b2SimplexCache,
      b2SimplexVertex = Box2D.Collision.b2SimplexVertex,
      b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact,
      b2TOIInput = Box2D.Collision.b2TOIInput,
      b2WorldManifold = Box2D.Collision.b2WorldManifold,
      ClipVertex = Box2D.Collision.ClipVertex,
      Features = Box2D.Collision.Features,
      IBroadPhase = Box2D.Collision.IBroadPhase;
  Box2D.inherit(b2CircleContact, Box2D.Dynamics.Contacts.b2Contact);
  b2CircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;

  b2CircleContact.b2CircleContact = function () {
    Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
  };

  b2CircleContact.Create = function (allocator) {
    return new b2CircleContact();
  };

  b2CircleContact.Destroy = function (contact, allocator) {};

  b2CircleContact.prototype.Reset = function (fixtureA, fixtureB) {
    this.__super.Reset.call(this, fixtureA, fixtureB);
  };

  b2CircleContact.prototype.Evaluate = function () {
    var bA = this.m_fixtureA.GetBody();
    var bB = this.m_fixtureB.GetBody();
    b2Collision.CollideCircles(this.m_manifold, this.m_fixtureA.GetShape() instanceof b2CircleShape ? this.m_fixtureA.GetShape() : null, bA.m_xf, this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null, bB.m_xf);
  };

  b2Contact.b2Contact = function () {
    this.m_nodeA = new b2ContactEdge();
    this.m_nodeB = new b2ContactEdge();
    this.m_manifold = new b2Manifold();
    this.m_oldManifold = new b2Manifold();
  };

  b2Contact.prototype.GetManifold = function () {
    return this.m_manifold;
  };

  b2Contact.prototype.GetWorldManifold = function (worldManifold) {
    var bodyA = this.m_fixtureA.GetBody();
    var bodyB = this.m_fixtureB.GetBody();
    var shapeA = this.m_fixtureA.GetShape();
    var shapeB = this.m_fixtureB.GetShape();
    worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius);
  };

  b2Contact.prototype.IsTouching = function () {
    return (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
  };

  b2Contact.prototype.IsContinuous = function () {
    return (this.m_flags & b2Contact.e_continuousFlag) == b2Contact.e_continuousFlag;
  };

  b2Contact.prototype.SetSensor = function (sensor) {
    if (sensor) {
      this.m_flags |= b2Contact.e_sensorFlag;
    } else {
      this.m_flags &= ~b2Contact.e_sensorFlag;
    }
  };

  b2Contact.prototype.IsSensor = function () {
    return (this.m_flags & b2Contact.e_sensorFlag) == b2Contact.e_sensorFlag;
  };

  b2Contact.prototype.SetEnabled = function (flag) {
    if (flag) {
      this.m_flags |= b2Contact.e_enabledFlag;
    } else {
      this.m_flags &= ~b2Contact.e_enabledFlag;
    }
  };

  b2Contact.prototype.IsEnabled = function () {
    return (this.m_flags & b2Contact.e_enabledFlag) == b2Contact.e_enabledFlag;
  };

  b2Contact.prototype.GetNext = function () {
    return this.m_next;
  };

  b2Contact.prototype.GetFixtureA = function () {
    return this.m_fixtureA;
  };

  b2Contact.prototype.GetFixtureB = function () {
    return this.m_fixtureB;
  };

  b2Contact.prototype.FlagForFiltering = function () {
    this.m_flags |= b2Contact.e_filterFlag;
  };

  b2Contact.prototype.b2Contact = function () {};

  b2Contact.prototype.Reset = function (fixtureA, fixtureB) {
    if (fixtureA === undefined) fixtureA = null;
    if (fixtureB === undefined) fixtureB = null;
    this.m_flags = b2Contact.e_enabledFlag;

    if (!fixtureA || !fixtureB) {
      this.m_fixtureA = null;
      this.m_fixtureB = null;
      return;
    }

    if (fixtureA.IsSensor() || fixtureB.IsSensor()) {
      this.m_flags |= b2Contact.e_sensorFlag;
    }

    var bodyA = fixtureA.GetBody();
    var bodyB = fixtureB.GetBody();

    if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
      this.m_flags |= b2Contact.e_continuousFlag;
    }

    this.m_fixtureA = fixtureA;
    this.m_fixtureB = fixtureB;
    this.m_manifold.m_pointCount = 0;
    this.m_prev = null;
    this.m_next = null;
    this.m_nodeA.contact = null;
    this.m_nodeA.prev = null;
    this.m_nodeA.next = null;
    this.m_nodeA.other = null;
    this.m_nodeB.contact = null;
    this.m_nodeB.prev = null;
    this.m_nodeB.next = null;
    this.m_nodeB.other = null;
  };

  b2Contact.prototype.Update = function (listener) {
    var tManifold = this.m_oldManifold;
    this.m_oldManifold = this.m_manifold;
    this.m_manifold = tManifold;
    this.m_flags |= b2Contact.e_enabledFlag;
    var touching = false;
    var wasTouching = (this.m_flags & b2Contact.e_touchingFlag) == b2Contact.e_touchingFlag;
    var bodyA = this.m_fixtureA.m_body;
    var bodyB = this.m_fixtureB.m_body;
    var aabbOverlap = this.m_fixtureA.m_aabb.TestOverlap(this.m_fixtureB.m_aabb);

    if (this.m_flags & b2Contact.e_sensorFlag) {
      if (aabbOverlap) {
        var shapeA = this.m_fixtureA.GetShape();
        var shapeB = this.m_fixtureB.GetShape();
        var xfA = bodyA.GetTransform();
        var xfB = bodyB.GetTransform();
        touching = b2Shape.TestOverlap(shapeA, xfA, shapeB, xfB);
      }

      this.m_manifold.m_pointCount = 0;
    } else {
      if (bodyA.GetType() != b2Body.b2_dynamicBody || bodyA.IsBullet() || bodyB.GetType() != b2Body.b2_dynamicBody || bodyB.IsBullet()) {
        this.m_flags |= b2Contact.e_continuousFlag;
      } else {
        this.m_flags &= ~b2Contact.e_continuousFlag;
      }

      if (aabbOverlap) {
        this.Evaluate();
        touching = this.m_manifold.m_pointCount > 0;

        for (var i = 0; i < this.m_manifold.m_pointCount; ++i) {
          var mp2 = this.m_manifold.m_points[i];
          mp2.m_normalImpulse = 0.0;
          mp2.m_tangentImpulse = 0.0;
          var id2 = mp2.m_id;

          for (var j = 0; j < this.m_oldManifold.m_pointCount; ++j) {
            var mp1 = this.m_oldManifold.m_points[j];

            if (mp1.m_id.key == id2.key) {
              mp2.m_normalImpulse = mp1.m_normalImpulse;
              mp2.m_tangentImpulse = mp1.m_tangentImpulse;
              break;
            }
          }
        }
      } else {
        this.m_manifold.m_pointCount = 0;
      }

      if (touching != wasTouching) {
        bodyA.SetAwake(true);
        bodyB.SetAwake(true);
      }
    }

    if (touching) {
      this.m_flags |= b2Contact.e_touchingFlag;
    } else {
      this.m_flags &= ~b2Contact.e_touchingFlag;
    }

    if (wasTouching == false && touching == true) {
      listener.BeginContact(this);
    }

    if (wasTouching == true && touching == false) {
      listener.EndContact(this);
    }

    if ((this.m_flags & b2Contact.e_sensorFlag) == 0) {
      listener.PreSolve(this, this.m_oldManifold);
    }
  };

  b2Contact.prototype.Evaluate = function () {};

  b2Contact.prototype.ComputeTOI = function (sweepA, sweepB) {
    b2Contact.s_input.proxyA.Set(this.m_fixtureA.GetShape());
    b2Contact.s_input.proxyB.Set(this.m_fixtureB.GetShape());
    b2Contact.s_input.sweepA = sweepA;
    b2Contact.s_input.sweepB = sweepB;
    b2Contact.s_input.tolerance = b2Settings.b2_linearSlop;
    return b2TimeOfImpact.TimeOfImpact(b2Contact.s_input);
  };

  Box2D.postDefs.push(function () {
    Box2D.Dynamics.Contacts.b2Contact.e_sensorFlag = 0x0001;
    Box2D.Dynamics.Contacts.b2Contact.e_continuousFlag = 0x0002;
    Box2D.Dynamics.Contacts.b2Contact.e_islandFlag = 0x0004;
    Box2D.Dynamics.Contacts.b2Contact.e_toiFlag = 0x0008;
    Box2D.Dynamics.Contacts.b2Contact.e_touchingFlag = 0x0010;
    Box2D.Dynamics.Contacts.b2Contact.e_enabledFlag = 0x0020;
    Box2D.Dynamics.Contacts.b2Contact.e_filterFlag = 0x0040;
    Box2D.Dynamics.Contacts.b2Contact.s_input = new b2TOIInput();
  });

  b2ContactConstraint.b2ContactConstraint = function () {
    this.localPlaneNormal = new b2Vec2();
    this.localPoint = new b2Vec2();
    this.normal = new b2Vec2();
    this.normalMass = new b2Mat22();
    this.K = new b2Mat22();
  };

  b2ContactConstraint.prototype.b2ContactConstraint = function () {
    this.points = new Vector(b2Settings.b2_maxManifoldPoints);

    for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
      this.points[i] = new b2ContactConstraintPoint();
    }
  };

  b2ContactConstraintPoint.b2ContactConstraintPoint = function () {
    this.localPoint = new b2Vec2();
    this.rA = new b2Vec2();
    this.rB = new b2Vec2();
  };

  b2ContactEdge.b2ContactEdge = function () {};

  b2ContactFactory.b2ContactFactory = function () {};

  b2ContactFactory.prototype.b2ContactFactory = function (allocator) {
    this.m_allocator = allocator;
    this.InitializeRegisters();
  };

  b2ContactFactory.prototype.AddType = function (createFcn, destroyFcn, type1, type2) {
    if (type1 === undefined) type1 = 0;
    if (type2 === undefined) type2 = 0;
    this.m_registers[type1][type2].createFcn = createFcn;
    this.m_registers[type1][type2].destroyFcn = destroyFcn;
    this.m_registers[type1][type2].primary = true;

    if (type1 != type2) {
      this.m_registers[type2][type1].createFcn = createFcn;
      this.m_registers[type2][type1].destroyFcn = destroyFcn;
      this.m_registers[type2][type1].primary = false;
    }
  };

  b2ContactFactory.prototype.InitializeRegisters = function () {
    this.m_registers = new Vector(b2Shape.e_shapeTypeCount);

    for (var i = 0; i < b2Shape.e_shapeTypeCount; i++) {
      this.m_registers[i] = new Vector(b2Shape.e_shapeTypeCount);

      for (var j = 0; j < b2Shape.e_shapeTypeCount; j++) {
        this.m_registers[i][j] = new b2ContactRegister();
      }
    }

    this.AddType(b2CircleContact.Create, b2CircleContact.Destroy, b2Shape.e_circleShape, b2Shape.e_circleShape);
    this.AddType(b2PolyAndCircleContact.Create, b2PolyAndCircleContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_circleShape);
    this.AddType(b2PolygonContact.Create, b2PolygonContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_polygonShape);
    this.AddType(b2EdgeAndCircleContact.Create, b2EdgeAndCircleContact.Destroy, b2Shape.e_edgeShape, b2Shape.e_circleShape);
    this.AddType(b2PolyAndEdgeContact.Create, b2PolyAndEdgeContact.Destroy, b2Shape.e_polygonShape, b2Shape.e_edgeShape);
  };

  b2ContactFactory.prototype.Create = function (fixtureA, fixtureB) {
    var type1 = parseInt(fixtureA.GetType());
    var type2 = parseInt(fixtureB.GetType());
    var reg = this.m_registers[type1][type2];
    var c;

    if (reg.pool) {
      c = reg.pool;
      reg.pool = c.m_next;
      reg.poolCount--;
      c.Reset(fixtureA, fixtureB);
      return c;
    }

    var createFcn = reg.createFcn;

    if (createFcn != null) {
      if (reg.primary) {
        c = createFcn(this.m_allocator);
        c.Reset(fixtureA, fixtureB);
        return c;
      } else {
        c = createFcn(this.m_allocator);
        c.Reset(fixtureB, fixtureA);
        return c;
      }
    } else {
      return null;
    }
  };

  b2ContactFactory.prototype.Destroy = function (contact) {
    if (contact.m_manifold.m_pointCount > 0) {
      contact.m_fixtureA.m_body.SetAwake(true);
      contact.m_fixtureB.m_body.SetAwake(true);
    }

    var type1 = parseInt(contact.m_fixtureA.GetType());
    var type2 = parseInt(contact.m_fixtureB.GetType());
    var reg = this.m_registers[type1][type2];

    if (true) {
      reg.poolCount++;
      contact.m_next = reg.pool;
      reg.pool = contact;
    }

    var destroyFcn = reg.destroyFcn;
    destroyFcn(contact, this.m_allocator);
  };

  b2ContactRegister.b2ContactRegister = function () {};

  b2ContactResult.b2ContactResult = function () {
    this.position = new b2Vec2();
    this.normal = new b2Vec2();
    this.id = new b2ContactID();
  };

  b2ContactSolver.b2ContactSolver = function () {
    this.m_step = new b2TimeStep();
    this.m_constraints = new Vector();
  };

  b2ContactSolver.prototype.b2ContactSolver = function () {};

  b2ContactSolver.prototype.Initialize = function (step, contacts, contactCount, allocator) {
    if (contactCount === undefined) contactCount = 0;
    var contact;
    this.m_step.Set(step);
    this.m_allocator = allocator;
    var i = 0;
    var tVec;
    var tMat;
    this.m_constraintCount = contactCount;

    while (this.m_constraints.length < this.m_constraintCount) {
      this.m_constraints[this.m_constraints.length] = new b2ContactConstraint();
    }

    for (i = 0; i < contactCount; ++i) {
      contact = contacts[i];
      var fixtureA = contact.m_fixtureA;
      var fixtureB = contact.m_fixtureB;
      var shapeA = fixtureA.m_shape;
      var shapeB = fixtureB.m_shape;
      var radiusA = shapeA.m_radius;
      var radiusB = shapeB.m_radius;
      var bodyA = fixtureA.m_body;
      var bodyB = fixtureB.m_body;
      var manifold = contact.GetManifold();
      var friction = b2Settings.b2MixFriction(fixtureA.GetFriction(), fixtureB.GetFriction());
      var restitution = b2Settings.b2MixRestitution(fixtureA.GetRestitution(), fixtureB.GetRestitution());
      var vAX = bodyA.m_linearVelocity.x;
      var vAY = bodyA.m_linearVelocity.y;
      var vBX = bodyB.m_linearVelocity.x;
      var vBY = bodyB.m_linearVelocity.y;
      var wA = bodyA.m_angularVelocity;
      var wB = bodyB.m_angularVelocity;
      b2Settings.b2Assert(manifold.m_pointCount > 0);
      b2ContactSolver.s_worldManifold.Initialize(manifold, bodyA.m_xf, radiusA, bodyB.m_xf, radiusB);
      var normalX = b2ContactSolver.s_worldManifold.m_normal.x;
      var normalY = b2ContactSolver.s_worldManifold.m_normal.y;
      var cc = this.m_constraints[i];
      cc.bodyA = bodyA;
      cc.bodyB = bodyB;
      cc.manifold = manifold;
      cc.normal.x = normalX;
      cc.normal.y = normalY;
      cc.pointCount = manifold.m_pointCount;
      cc.friction = friction;
      cc.restitution = restitution;
      cc.localPlaneNormal.x = manifold.m_localPlaneNormal.x;
      cc.localPlaneNormal.y = manifold.m_localPlaneNormal.y;
      cc.localPoint.x = manifold.m_localPoint.x;
      cc.localPoint.y = manifold.m_localPoint.y;
      cc.radius = radiusA + radiusB;
      cc.type = manifold.m_type;

      for (var k = 0; k < cc.pointCount; ++k) {
        var cp = manifold.m_points[k];
        var ccp = cc.points[k];
        ccp.normalImpulse = cp.m_normalImpulse;
        ccp.tangentImpulse = cp.m_tangentImpulse;
        ccp.localPoint.SetV(cp.m_localPoint);
        var rAX = ccp.rA.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyA.m_sweep.c.x;
        var rAY = ccp.rA.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyA.m_sweep.c.y;
        var rBX = ccp.rB.x = b2ContactSolver.s_worldManifold.m_points[k].x - bodyB.m_sweep.c.x;
        var rBY = ccp.rB.y = b2ContactSolver.s_worldManifold.m_points[k].y - bodyB.m_sweep.c.y;
        var rnA = rAX * normalY - rAY * normalX;
        var rnB = rBX * normalY - rBY * normalX;
        rnA *= rnA;
        rnB *= rnB;
        var kNormal = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rnA + bodyB.m_invI * rnB;
        ccp.normalMass = 1.0 / kNormal;
        var kEqualized = bodyA.m_mass * bodyA.m_invMass + bodyB.m_mass * bodyB.m_invMass;
        kEqualized += bodyA.m_mass * bodyA.m_invI * rnA + bodyB.m_mass * bodyB.m_invI * rnB;
        ccp.equalizedMass = 1.0 / kEqualized;
        var tangentX = normalY;
        var tangentY = -normalX;
        var rtA = rAX * tangentY - rAY * tangentX;
        var rtB = rBX * tangentY - rBY * tangentX;
        rtA *= rtA;
        rtB *= rtB;
        var kTangent = bodyA.m_invMass + bodyB.m_invMass + bodyA.m_invI * rtA + bodyB.m_invI * rtB;
        ccp.tangentMass = 1.0 / kTangent;
        ccp.velocityBias = 0.0;
        var tX = vBX + -wB * rBY - vAX - -wA * rAY;
        var tY = vBY + wB * rBX - vAY - wA * rAX;
        var vRel = cc.normal.x * tX + cc.normal.y * tY;

        if (vRel < -b2Settings.b2_velocityThreshold) {
          ccp.velocityBias += -cc.restitution * vRel;
        }
      }

      if (cc.pointCount == 2) {
        var ccp1 = cc.points[0];
        var ccp2 = cc.points[1];
        var invMassA = bodyA.m_invMass;
        var invIA = bodyA.m_invI;
        var invMassB = bodyB.m_invMass;
        var invIB = bodyB.m_invI;
        var rn1A = ccp1.rA.x * normalY - ccp1.rA.y * normalX;
        var rn1B = ccp1.rB.x * normalY - ccp1.rB.y * normalX;
        var rn2A = ccp2.rA.x * normalY - ccp2.rA.y * normalX;
        var rn2B = ccp2.rB.x * normalY - ccp2.rB.y * normalX;
        var k11 = invMassA + invMassB + invIA * rn1A * rn1A + invIB * rn1B * rn1B;
        var k22 = invMassA + invMassB + invIA * rn2A * rn2A + invIB * rn2B * rn2B;
        var k12 = invMassA + invMassB + invIA * rn1A * rn2A + invIB * rn1B * rn2B;
        var k_maxConditionNumber = 100.0;

        if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
          cc.K.col1.Set(k11, k12);
          cc.K.col2.Set(k12, k22);
          cc.K.GetInverse(cc.normalMass);
        } else {
          cc.pointCount = 1;
        }
      }
    }
  };

  b2ContactSolver.prototype.InitVelocityConstraints = function (step) {
    var tVec;
    var tVec2;
    var tMat;

    for (var i = 0; i < this.m_constraintCount; ++i) {
      var c = this.m_constraints[i];
      var bodyA = c.bodyA;
      var bodyB = c.bodyB;
      var invMassA = bodyA.m_invMass;
      var invIA = bodyA.m_invI;
      var invMassB = bodyB.m_invMass;
      var invIB = bodyB.m_invI;
      var normalX = c.normal.x;
      var normalY = c.normal.y;
      var tangentX = normalY;
      var tangentY = -normalX;
      var tX = 0;
      var j = 0;
      var tCount = 0;

      if (step.warmStarting) {
        tCount = c.pointCount;

        for (j = 0; j < tCount; ++j) {
          var ccp = c.points[j];
          ccp.normalImpulse *= step.dtRatio;
          ccp.tangentImpulse *= step.dtRatio;
          var PX = ccp.normalImpulse * normalX + ccp.tangentImpulse * tangentX;
          var PY = ccp.normalImpulse * normalY + ccp.tangentImpulse * tangentY;
          bodyA.m_angularVelocity -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
          bodyA.m_linearVelocity.x -= invMassA * PX;
          bodyA.m_linearVelocity.y -= invMassA * PY;
          bodyB.m_angularVelocity += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
          bodyB.m_linearVelocity.x += invMassB * PX;
          bodyB.m_linearVelocity.y += invMassB * PY;
        }
      } else {
        tCount = c.pointCount;

        for (j = 0; j < tCount; ++j) {
          var ccp2 = c.points[j];
          ccp2.normalImpulse = 0.0;
          ccp2.tangentImpulse = 0.0;
        }
      }
    }
  };

  b2ContactSolver.prototype.SolveVelocityConstraints = function () {
    var j = 0;
    var ccp;
    var rAX = 0;
    var rAY = 0;
    var rBX = 0;
    var rBY = 0;
    var dvX = 0;
    var dvY = 0;
    var vn = 0;
    var vt = 0;
    var lambda = 0;
    var maxFriction = 0;
    var newImpulse = 0;
    var PX = 0;
    var PY = 0;
    var dX = 0;
    var dY = 0;
    var P1X = 0;
    var P1Y = 0;
    var P2X = 0;
    var P2Y = 0;
    var tMat;
    var tVec;

    for (var i = 0; i < this.m_constraintCount; ++i) {
      var c = this.m_constraints[i];
      var bodyA = c.bodyA;
      var bodyB = c.bodyB;
      var wA = bodyA.m_angularVelocity;
      var wB = bodyB.m_angularVelocity;
      var vA = bodyA.m_linearVelocity;
      var vB = bodyB.m_linearVelocity;
      var invMassA = bodyA.m_invMass;
      var invIA = bodyA.m_invI;
      var invMassB = bodyB.m_invMass;
      var invIB = bodyB.m_invI;
      var normalX = c.normal.x;
      var normalY = c.normal.y;
      var tangentX = normalY;
      var tangentY = -normalX;
      var friction = c.friction;
      var tX = 0;

      for (j = 0; j < c.pointCount; j++) {
        ccp = c.points[j];
        dvX = vB.x - wB * ccp.rB.y - vA.x + wA * ccp.rA.y;
        dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
        vt = dvX * tangentX + dvY * tangentY;
        lambda = ccp.tangentMass * -vt;
        maxFriction = friction * ccp.normalImpulse;
        newImpulse = b2Math.Clamp(ccp.tangentImpulse + lambda, -maxFriction, maxFriction);
        lambda = newImpulse - ccp.tangentImpulse;
        PX = lambda * tangentX;
        PY = lambda * tangentY;
        vA.x -= invMassA * PX;
        vA.y -= invMassA * PY;
        wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
        vB.x += invMassB * PX;
        vB.y += invMassB * PY;
        wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
        ccp.tangentImpulse = newImpulse;
      }

      var tCount = parseInt(c.pointCount);

      if (c.pointCount == 1) {
        ccp = c.points[0];
        dvX = vB.x + -wB * ccp.rB.y - vA.x - -wA * ccp.rA.y;
        dvY = vB.y + wB * ccp.rB.x - vA.y - wA * ccp.rA.x;
        vn = dvX * normalX + dvY * normalY;
        lambda = -ccp.normalMass * (vn - ccp.velocityBias);
        newImpulse = ccp.normalImpulse + lambda;
        newImpulse = newImpulse > 0 ? newImpulse : 0.0;
        lambda = newImpulse - ccp.normalImpulse;
        PX = lambda * normalX;
        PY = lambda * normalY;
        vA.x -= invMassA * PX;
        vA.y -= invMassA * PY;
        wA -= invIA * (ccp.rA.x * PY - ccp.rA.y * PX);
        vB.x += invMassB * PX;
        vB.y += invMassB * PY;
        wB += invIB * (ccp.rB.x * PY - ccp.rB.y * PX);
        ccp.normalImpulse = newImpulse;
      } else {
        var cp1 = c.points[0];
        var cp2 = c.points[1];
        var aX = cp1.normalImpulse;
        var aY = cp2.normalImpulse;
        var dv1X = vB.x - wB * cp1.rB.y - vA.x + wA * cp1.rA.y;
        var dv1Y = vB.y + wB * cp1.rB.x - vA.y - wA * cp1.rA.x;
        var dv2X = vB.x - wB * cp2.rB.y - vA.x + wA * cp2.rA.y;
        var dv2Y = vB.y + wB * cp2.rB.x - vA.y - wA * cp2.rA.x;
        var vn1 = dv1X * normalX + dv1Y * normalY;
        var vn2 = dv2X * normalX + dv2Y * normalY;
        var bX = vn1 - cp1.velocityBias;
        var bY = vn2 - cp2.velocityBias;
        tMat = c.K;
        bX -= tMat.col1.x * aX + tMat.col2.x * aY;
        bY -= tMat.col1.y * aX + tMat.col2.y * aY;
        var k_errorTol = 0.001;

        for (;;) {
          tMat = c.normalMass;
          var xX = -(tMat.col1.x * bX + tMat.col2.x * bY);
          var xY = -(tMat.col1.y * bX + tMat.col2.y * bY);

          if (xX >= 0.0 && xY >= 0.0) {
            dX = xX - aX;
            dY = xY - aY;
            P1X = dX * normalX;
            P1Y = dX * normalY;
            P2X = dY * normalX;
            P2Y = dY * normalY;
            vA.x -= invMassA * (P1X + P2X);
            vA.y -= invMassA * (P1Y + P2Y);
            wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
            vB.x += invMassB * (P1X + P2X);
            vB.y += invMassB * (P1Y + P2Y);
            wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
            cp1.normalImpulse = xX;
            cp2.normalImpulse = xY;
            break;
          }

          xX = -cp1.normalMass * bX;
          xY = 0.0;
          vn1 = 0.0;
          vn2 = c.K.col1.y * xX + bY;

          if (xX >= 0.0 && vn2 >= 0.0) {
            dX = xX - aX;
            dY = xY - aY;
            P1X = dX * normalX;
            P1Y = dX * normalY;
            P2X = dY * normalX;
            P2Y = dY * normalY;
            vA.x -= invMassA * (P1X + P2X);
            vA.y -= invMassA * (P1Y + P2Y);
            wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
            vB.x += invMassB * (P1X + P2X);
            vB.y += invMassB * (P1Y + P2Y);
            wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
            cp1.normalImpulse = xX;
            cp2.normalImpulse = xY;
            break;
          }

          xX = 0.0;
          xY = -cp2.normalMass * bY;
          vn1 = c.K.col2.x * xY + bX;
          vn2 = 0.0;

          if (xY >= 0.0 && vn1 >= 0.0) {
            dX = xX - aX;
            dY = xY - aY;
            P1X = dX * normalX;
            P1Y = dX * normalY;
            P2X = dY * normalX;
            P2Y = dY * normalY;
            vA.x -= invMassA * (P1X + P2X);
            vA.y -= invMassA * (P1Y + P2Y);
            wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
            vB.x += invMassB * (P1X + P2X);
            vB.y += invMassB * (P1Y + P2Y);
            wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
            cp1.normalImpulse = xX;
            cp2.normalImpulse = xY;
            break;
          }

          xX = 0.0;
          xY = 0.0;
          vn1 = bX;
          vn2 = bY;

          if (vn1 >= 0.0 && vn2 >= 0.0) {
            dX = xX - aX;
            dY = xY - aY;
            P1X = dX * normalX;
            P1Y = dX * normalY;
            P2X = dY * normalX;
            P2Y = dY * normalY;
            vA.x -= invMassA * (P1X + P2X);
            vA.y -= invMassA * (P1Y + P2Y);
            wA -= invIA * (cp1.rA.x * P1Y - cp1.rA.y * P1X + cp2.rA.x * P2Y - cp2.rA.y * P2X);
            vB.x += invMassB * (P1X + P2X);
            vB.y += invMassB * (P1Y + P2Y);
            wB += invIB * (cp1.rB.x * P1Y - cp1.rB.y * P1X + cp2.rB.x * P2Y - cp2.rB.y * P2X);
            cp1.normalImpulse = xX;
            cp2.normalImpulse = xY;
            break;
          }

          break;
        }
      }

      bodyA.m_angularVelocity = wA;
      bodyB.m_angularVelocity = wB;
    }
  };

  b2ContactSolver.prototype.FinalizeVelocityConstraints = function () {
    for (var i = 0; i < this.m_constraintCount; ++i) {
      var c = this.m_constraints[i];
      var m = c.manifold;

      for (var j = 0; j < c.pointCount; ++j) {
        var point1 = m.m_points[j];
        var point2 = c.points[j];
        point1.m_normalImpulse = point2.normalImpulse;
        point1.m_tangentImpulse = point2.tangentImpulse;
      }
    }
  };

  b2ContactSolver.prototype.SolvePositionConstraints = function (baumgarte) {
    if (baumgarte === undefined) baumgarte = 0;
    var minSeparation = 0.0;

    for (var i = 0; i < this.m_constraintCount; i++) {
      var c = this.m_constraints[i];
      var bodyA = c.bodyA;
      var bodyB = c.bodyB;
      var invMassA = bodyA.m_mass * bodyA.m_invMass;
      var invIA = bodyA.m_mass * bodyA.m_invI;
      var invMassB = bodyB.m_mass * bodyB.m_invMass;
      var invIB = bodyB.m_mass * bodyB.m_invI;
      b2ContactSolver.s_psm.Initialize(c);
      var normal = b2ContactSolver.s_psm.m_normal;

      for (var j = 0; j < c.pointCount; j++) {
        var ccp = c.points[j];
        var point = b2ContactSolver.s_psm.m_points[j];
        var separation = b2ContactSolver.s_psm.m_separations[j];
        var rAX = point.x - bodyA.m_sweep.c.x;
        var rAY = point.y - bodyA.m_sweep.c.y;
        var rBX = point.x - bodyB.m_sweep.c.x;
        var rBY = point.y - bodyB.m_sweep.c.y;
        minSeparation = minSeparation < separation ? minSeparation : separation;
        var C = b2Math.Clamp(baumgarte * (separation + b2Settings.b2_linearSlop), -b2Settings.b2_maxLinearCorrection, 0.0);
        var impulse = -ccp.equalizedMass * C;
        var PX = impulse * normal.x;
        var PY = impulse * normal.y;
        bodyA.m_sweep.c.x -= invMassA * PX;
        bodyA.m_sweep.c.y -= invMassA * PY;
        bodyA.m_sweep.a -= invIA * (rAX * PY - rAY * PX);
        bodyA.SynchronizeTransform();
        bodyB.m_sweep.c.x += invMassB * PX;
        bodyB.m_sweep.c.y += invMassB * PY;
        bodyB.m_sweep.a += invIB * (rBX * PY - rBY * PX);
        bodyB.SynchronizeTransform();
      }
    }

    return minSeparation > -1.5 * b2Settings.b2_linearSlop;
  };

  Box2D.postDefs.push(function () {
    Box2D.Dynamics.Contacts.b2ContactSolver.s_worldManifold = new b2WorldManifold();
    Box2D.Dynamics.Contacts.b2ContactSolver.s_psm = new b2PositionSolverManifold();
  });
  Box2D.inherit(b2EdgeAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
  b2EdgeAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;

  b2EdgeAndCircleContact.b2EdgeAndCircleContact = function () {
    Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
  };

  b2EdgeAndCircleContact.Create = function (allocator) {
    return new b2EdgeAndCircleContact();
  };

  b2EdgeAndCircleContact.Destroy = function (contact, allocator) {};

  b2EdgeAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
    this.__super.Reset.call(this, fixtureA, fixtureB);
  };

  b2EdgeAndCircleContact.prototype.Evaluate = function () {
    var bA = this.m_fixtureA.GetBody();
    var bB = this.m_fixtureB.GetBody();
    this.b2CollideEdgeAndCircle(this.m_manifold, this.m_fixtureA.GetShape() instanceof b2EdgeShape ? this.m_fixtureA.GetShape() : null, bA.m_xf, this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null, bB.m_xf);
  };

  b2EdgeAndCircleContact.prototype.b2CollideEdgeAndCircle = function (manifold, edge, xf1, circle, xf2) {};

  Box2D.inherit(b2NullContact, Box2D.Dynamics.Contacts.b2Contact);
  b2NullContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;

  b2NullContact.b2NullContact = function () {
    Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
  };

  b2NullContact.prototype.b2NullContact = function () {
    this.__super.b2Contact.call(this);
  };

  b2NullContact.prototype.Evaluate = function () {};

  Box2D.inherit(b2PolyAndCircleContact, Box2D.Dynamics.Contacts.b2Contact);
  b2PolyAndCircleContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;

  b2PolyAndCircleContact.b2PolyAndCircleContact = function () {
    Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
  };

  b2PolyAndCircleContact.Create = function (allocator) {
    return new b2PolyAndCircleContact();
  };

  b2PolyAndCircleContact.Destroy = function (contact, allocator) {};

  b2PolyAndCircleContact.prototype.Reset = function (fixtureA, fixtureB) {
    this.__super.Reset.call(this, fixtureA, fixtureB);

    b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
    b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_circleShape);
  };

  b2PolyAndCircleContact.prototype.Evaluate = function () {
    var bA = this.m_fixtureA.m_body;
    var bB = this.m_fixtureB.m_body;
    b2Collision.CollidePolygonAndCircle(this.m_manifold, this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null, bA.m_xf, this.m_fixtureB.GetShape() instanceof b2CircleShape ? this.m_fixtureB.GetShape() : null, bB.m_xf);
  };

  Box2D.inherit(b2PolyAndEdgeContact, Box2D.Dynamics.Contacts.b2Contact);
  b2PolyAndEdgeContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;

  b2PolyAndEdgeContact.b2PolyAndEdgeContact = function () {
    Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
  };

  b2PolyAndEdgeContact.Create = function (allocator) {
    return new b2PolyAndEdgeContact();
  };

  b2PolyAndEdgeContact.Destroy = function (contact, allocator) {};

  b2PolyAndEdgeContact.prototype.Reset = function (fixtureA, fixtureB) {
    this.__super.Reset.call(this, fixtureA, fixtureB);

    b2Settings.b2Assert(fixtureA.GetType() == b2Shape.e_polygonShape);
    b2Settings.b2Assert(fixtureB.GetType() == b2Shape.e_edgeShape);
  };

  b2PolyAndEdgeContact.prototype.Evaluate = function () {
    var bA = this.m_fixtureA.GetBody();
    var bB = this.m_fixtureB.GetBody();
    this.b2CollidePolyAndEdge(this.m_manifold, this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null, bA.m_xf, this.m_fixtureB.GetShape() instanceof b2EdgeShape ? this.m_fixtureB.GetShape() : null, bB.m_xf);
  };

  b2PolyAndEdgeContact.prototype.b2CollidePolyAndEdge = function (manifold, polygon, xf1, edge, xf2) {};

  Box2D.inherit(b2PolygonContact, Box2D.Dynamics.Contacts.b2Contact);
  b2PolygonContact.prototype.__super = Box2D.Dynamics.Contacts.b2Contact.prototype;

  b2PolygonContact.b2PolygonContact = function () {
    Box2D.Dynamics.Contacts.b2Contact.b2Contact.apply(this, arguments);
  };

  b2PolygonContact.Create = function (allocator) {
    return new b2PolygonContact();
  };

  b2PolygonContact.Destroy = function (contact, allocator) {};

  b2PolygonContact.prototype.Reset = function (fixtureA, fixtureB) {
    this.__super.Reset.call(this, fixtureA, fixtureB);
  };

  b2PolygonContact.prototype.Evaluate = function () {
    var bA = this.m_fixtureA.GetBody();
    var bB = this.m_fixtureB.GetBody();
    b2Collision.CollidePolygons(this.m_manifold, this.m_fixtureA.GetShape() instanceof b2PolygonShape ? this.m_fixtureA.GetShape() : null, bA.m_xf, this.m_fixtureB.GetShape() instanceof b2PolygonShape ? this.m_fixtureB.GetShape() : null, bB.m_xf);
  };

  b2PositionSolverManifold.b2PositionSolverManifold = function () {};

  b2PositionSolverManifold.prototype.b2PositionSolverManifold = function () {
    this.m_normal = new b2Vec2();
    this.m_separations = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints);
    this.m_points = new Vector(b2Settings.b2_maxManifoldPoints);

    for (var i = 0; i < b2Settings.b2_maxManifoldPoints; i++) {
      this.m_points[i] = new b2Vec2();
    }
  };

  b2PositionSolverManifold.prototype.Initialize = function (cc) {
    b2Settings.b2Assert(cc.pointCount > 0);
    var i = 0;
    var clipPointX = 0;
    var clipPointY = 0;
    var tMat;
    var tVec;
    var planePointX = 0;
    var planePointY = 0;

    switch (cc.type) {
      case b2Manifold.e_circles:
        {
          tMat = cc.bodyA.m_xf.R;
          tVec = cc.localPoint;
          var pointAX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          var pointAY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          tMat = cc.bodyB.m_xf.R;
          tVec = cc.points[0].localPoint;
          var pointBX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          var pointBY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          var dX = pointBX - pointAX;
          var dY = pointBY - pointAY;
          var d2 = dX * dX + dY * dY;

          if (d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
            var d = Math.sqrt(d2);
            this.m_normal.x = dX / d;
            this.m_normal.y = dY / d;
          } else {
            this.m_normal.x = 1.0;
            this.m_normal.y = 0.0;
          }

          this.m_points[0].x = 0.5 * (pointAX + pointBX);
          this.m_points[0].y = 0.5 * (pointAY + pointBY);
          this.m_separations[0] = dX * this.m_normal.x + dY * this.m_normal.y - cc.radius;
        }
        break;

      case b2Manifold.e_faceA:
        {
          tMat = cc.bodyA.m_xf.R;
          tVec = cc.localPlaneNormal;
          this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
          this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
          tMat = cc.bodyA.m_xf.R;
          tVec = cc.localPoint;
          planePointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          planePointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          tMat = cc.bodyB.m_xf.R;

          for (i = 0; i < cc.pointCount; ++i) {
            tVec = cc.points[i].localPoint;
            clipPointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            clipPointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
            this.m_points[i].x = clipPointX;
            this.m_points[i].y = clipPointY;
          }
        }
        break;

      case b2Manifold.e_faceB:
        {
          tMat = cc.bodyB.m_xf.R;
          tVec = cc.localPlaneNormal;
          this.m_normal.x = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
          this.m_normal.y = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
          tMat = cc.bodyB.m_xf.R;
          tVec = cc.localPoint;
          planePointX = cc.bodyB.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
          planePointY = cc.bodyB.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
          tMat = cc.bodyA.m_xf.R;

          for (i = 0; i < cc.pointCount; ++i) {
            tVec = cc.points[i].localPoint;
            clipPointX = cc.bodyA.m_xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
            clipPointY = cc.bodyA.m_xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
            this.m_separations[i] = (clipPointX - planePointX) * this.m_normal.x + (clipPointY - planePointY) * this.m_normal.y - cc.radius;
            this.m_points[i].Set(clipPointX, clipPointY);
          }

          this.m_normal.x *= -1;
          this.m_normal.y *= -1;
        }
        break;
    }
  };

  Box2D.postDefs.push(function () {
    Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointA = new b2Vec2();
    Box2D.Dynamics.Contacts.b2PositionSolverManifold.circlePointB = new b2Vec2();
  });
})();

(function () {
  var b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2CircleShape = Box2D.Collision.Shapes.b2CircleShape,
      b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef,
      b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape,
      b2MassData = Box2D.Collision.Shapes.b2MassData,
      b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape,
      b2Shape = Box2D.Collision.Shapes.b2Shape,
      b2BuoyancyController = Box2D.Dynamics.Controllers.b2BuoyancyController,
      b2ConstantAccelController = Box2D.Dynamics.Controllers.b2ConstantAccelController,
      b2ConstantForceController = Box2D.Dynamics.Controllers.b2ConstantForceController,
      b2Controller = Box2D.Dynamics.Controllers.b2Controller,
      b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge,
      b2GravityController = Box2D.Dynamics.Controllers.b2GravityController,
      b2TensorDampingController = Box2D.Dynamics.Controllers.b2TensorDampingController;
  Box2D.inherit(b2BuoyancyController, Box2D.Dynamics.Controllers.b2Controller);
  b2BuoyancyController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;

  b2BuoyancyController.b2BuoyancyController = function () {
    Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
    this.normal = new b2Vec2(0, -1);
    this.offset = 0;
    this.density = 0;
    this.velocity = new b2Vec2(0, 0);
    this.linearDrag = 2;
    this.angularDrag = 1;
    this.useDensity = false;
    this.useWorldGravity = true;
    this.gravity = null;
  };

  b2BuoyancyController.prototype.Step = function (step) {
    if (!this.m_bodyList) return;

    if (this.useWorldGravity) {
      this.gravity = this.GetWorld().GetGravity().Copy();
    }

    for (var i = this.m_bodyList; i; i = i.nextBody) {
      var body = i.body;

      if (body.IsAwake() == false) {
        continue;
      }

      var areac = new b2Vec2();
      var massc = new b2Vec2();
      var area = 0.0;
      var mass = 0.0;

      for (var fixture = body.GetFixtureList(); fixture; fixture = fixture.GetNext()) {
        var sc = new b2Vec2();
        var sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);
        area += sarea;
        areac.x += sarea * sc.x;
        areac.y += sarea * sc.y;
        var shapeDensity = 0;

        if (this.useDensity) {
          shapeDensity = 1;
        } else {
          shapeDensity = 1;
        }

        mass += sarea * shapeDensity;
        massc.x += sarea * sc.x * shapeDensity;
        massc.y += sarea * sc.y * shapeDensity;
      }

      areac.x /= area;
      areac.y /= area;
      massc.x /= mass;
      massc.y /= mass;
      if (area < Number.MIN_VALUE) continue;
      var buoyancyForce = this.gravity.GetNegative();
      buoyancyForce.Multiply(this.density * area);
      body.ApplyForce(buoyancyForce, massc);
      var dragForce = body.GetLinearVelocityFromWorldPoint(areac);
      dragForce.Subtract(this.velocity);
      dragForce.Multiply(-this.linearDrag * area);
      body.ApplyForce(dragForce, areac);
      body.ApplyTorque(-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag);
    }
  };

  b2BuoyancyController.prototype.Draw = function (debugDraw) {
    var r = 1000;
    var p1 = new b2Vec2();
    var p2 = new b2Vec2();
    p1.x = this.normal.x * this.offset + this.normal.y * r;
    p1.y = this.normal.y * this.offset - this.normal.x * r;
    p2.x = this.normal.x * this.offset - this.normal.y * r;
    p2.y = this.normal.y * this.offset + this.normal.x * r;
    var color = new b2Color(0, 0, 1);
    debugDraw.DrawSegment(p1, p2, color);
  };

  Box2D.inherit(b2ConstantAccelController, Box2D.Dynamics.Controllers.b2Controller);
  b2ConstantAccelController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;

  b2ConstantAccelController.b2ConstantAccelController = function () {
    Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
    this.A = new b2Vec2(0, 0);
  };

  b2ConstantAccelController.prototype.Step = function (step) {
    var smallA = new b2Vec2(this.A.x * step.dt, this.A.y * step.dt);

    for (var i = this.m_bodyList; i; i = i.nextBody) {
      var body = i.body;
      if (!body.IsAwake()) continue;
      body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + smallA.x, body.GetLinearVelocity().y + smallA.y));
    }
  };

  Box2D.inherit(b2ConstantForceController, Box2D.Dynamics.Controllers.b2Controller);
  b2ConstantForceController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;

  b2ConstantForceController.b2ConstantForceController = function () {
    Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
    this.F = new b2Vec2(0, 0);
  };

  b2ConstantForceController.prototype.Step = function (step) {
    for (var i = this.m_bodyList; i; i = i.nextBody) {
      var body = i.body;
      if (!body.IsAwake()) continue;
      body.ApplyForce(this.F, body.GetWorldCenter());
    }
  };

  b2Controller.b2Controller = function () {};

  b2Controller.prototype.Step = function (step) {};

  b2Controller.prototype.Draw = function (debugDraw) {};

  b2Controller.prototype.AddBody = function (body) {
    var edge = new b2ControllerEdge();
    edge.controller = this;
    edge.body = body;
    edge.nextBody = this.m_bodyList;
    edge.prevBody = null;
    this.m_bodyList = edge;
    if (edge.nextBody) edge.nextBody.prevBody = edge;
    this.m_bodyCount++;
    edge.nextController = body.m_controllerList;
    edge.prevController = null;
    body.m_controllerList = edge;
    if (edge.nextController) edge.nextController.prevController = edge;
    body.m_controllerCount++;
  };

  b2Controller.prototype.RemoveBody = function (body) {
    var edge = body.m_controllerList;

    while (edge && edge.controller != this) edge = edge.nextController;

    if (edge.prevBody) edge.prevBody.nextBody = edge.nextBody;
    if (edge.nextBody) edge.nextBody.prevBody = edge.prevBody;
    if (edge.nextController) edge.nextController.prevController = edge.prevController;
    if (edge.prevController) edge.prevController.nextController = edge.nextController;
    if (this.m_bodyList == edge) this.m_bodyList = edge.nextBody;
    if (body.m_controllerList == edge) body.m_controllerList = edge.nextController;
    body.m_controllerCount--;
    this.m_bodyCount--;
  };

  b2Controller.prototype.Clear = function () {
    while (this.m_bodyList) this.RemoveBody(this.m_bodyList.body);
  };

  b2Controller.prototype.GetNext = function () {
    return this.m_next;
  };

  b2Controller.prototype.GetWorld = function () {
    return this.m_world;
  };

  b2Controller.prototype.GetBodyList = function () {
    return this.m_bodyList;
  };

  b2ControllerEdge.b2ControllerEdge = function () {};

  Box2D.inherit(b2GravityController, Box2D.Dynamics.Controllers.b2Controller);
  b2GravityController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;

  b2GravityController.b2GravityController = function () {
    Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
    this.G = 1;
    this.invSqr = true;
  };

  b2GravityController.prototype.Step = function (step) {
    var i = null;
    var body1 = null;
    var p1 = null;
    var mass1 = 0;
    var j = null;
    var body2 = null;
    var p2 = null;
    var dx = 0;
    var dy = 0;
    var r2 = 0;
    var f = null;

    if (this.invSqr) {
      for (i = this.m_bodyList; i; i = i.nextBody) {
        body1 = i.body;
        p1 = body1.GetWorldCenter();
        mass1 = body1.GetMass();

        for (j = this.m_bodyList; j != i; j = j.nextBody) {
          body2 = j.body;
          p2 = body2.GetWorldCenter();
          dx = p2.x - p1.x;
          dy = p2.y - p1.y;
          r2 = dx * dx + dy * dy;
          if (r2 < Number.MIN_VALUE) continue;
          f = new b2Vec2(dx, dy);
          f.Multiply(this.G / r2 / Math.sqrt(r2) * mass1 * body2.GetMass());
          if (body1.IsAwake()) body1.ApplyForce(f, p1);
          f.Multiply(-1);
          if (body2.IsAwake()) body2.ApplyForce(f, p2);
        }
      }
    } else {
      for (i = this.m_bodyList; i; i = i.nextBody) {
        body1 = i.body;
        p1 = body1.GetWorldCenter();
        mass1 = body1.GetMass();

        for (j = this.m_bodyList; j != i; j = j.nextBody) {
          body2 = j.body;
          p2 = body2.GetWorldCenter();
          dx = p2.x - p1.x;
          dy = p2.y - p1.y;
          r2 = dx * dx + dy * dy;
          if (r2 < Number.MIN_VALUE) continue;
          f = new b2Vec2(dx, dy);
          f.Multiply(this.G / r2 * mass1 * body2.GetMass());
          if (body1.IsAwake()) body1.ApplyForce(f, p1);
          f.Multiply(-1);
          if (body2.IsAwake()) body2.ApplyForce(f, p2);
        }
      }
    }
  };

  Box2D.inherit(b2TensorDampingController, Box2D.Dynamics.Controllers.b2Controller);
  b2TensorDampingController.prototype.__super = Box2D.Dynamics.Controllers.b2Controller.prototype;

  b2TensorDampingController.b2TensorDampingController = function () {
    Box2D.Dynamics.Controllers.b2Controller.b2Controller.apply(this, arguments);
    this.T = new b2Mat22();
    this.maxTimestep = 0;
  };

  b2TensorDampingController.prototype.SetAxisAligned = function (xDamping, yDamping) {
    if (xDamping === undefined) xDamping = 0;
    if (yDamping === undefined) yDamping = 0;
    this.T.col1.x = -xDamping;
    this.T.col1.y = 0;
    this.T.col2.x = 0;
    this.T.col2.y = -yDamping;

    if (xDamping > 0 || yDamping > 0) {
      this.maxTimestep = 1 / Math.max(xDamping, yDamping);
    } else {
      this.maxTimestep = 0;
    }
  };

  b2TensorDampingController.prototype.Step = function (step) {
    var timestep = step.dt;
    if (timestep <= Number.MIN_VALUE) return;
    if (timestep > this.maxTimestep && this.maxTimestep > 0) timestep = this.maxTimestep;

    for (var i = this.m_bodyList; i; i = i.nextBody) {
      var body = i.body;

      if (!body.IsAwake()) {
        continue;
      }

      var damping = body.GetWorldVector(b2Math.MulMV(this.T, body.GetLocalVector(body.GetLinearVelocity())));
      body.SetLinearVelocity(new b2Vec2(body.GetLinearVelocity().x + damping.x * timestep, body.GetLinearVelocity().y + damping.y * timestep));
    }
  };
})();

(function () {
  var b2Color = Box2D.Common.b2Color,
      b2internal = Box2D.Common.b2internal,
      b2Settings = Box2D.Common.b2Settings,
      b2Mat22 = Box2D.Common.Math.b2Mat22,
      b2Mat33 = Box2D.Common.Math.b2Mat33,
      b2Math = Box2D.Common.Math.b2Math,
      b2Sweep = Box2D.Common.Math.b2Sweep,
      b2Transform = Box2D.Common.Math.b2Transform,
      b2Vec2 = Box2D.Common.Math.b2Vec2,
      b2Vec3 = Box2D.Common.Math.b2Vec3,
      b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint,
      b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef,
      b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint,
      b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef,
      b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint,
      b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef,
      b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian,
      b2Joint = Box2D.Dynamics.Joints.b2Joint,
      b2JointDef = Box2D.Dynamics.Joints.b2JointDef,
      b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge,
      b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint,
      b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef,
      b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint,
      b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef,
      b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint,
      b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef,
      b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint,
      b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef,
      b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint,
      b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef,
      b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint,
      b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef,
      b2Body = Box2D.Dynamics.b2Body,
      b2BodyDef = Box2D.Dynamics.b2BodyDef,
      b2ContactFilter = Box2D.Dynamics.b2ContactFilter,
      b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse,
      b2ContactListener = Box2D.Dynamics.b2ContactListener,
      b2ContactManager = Box2D.Dynamics.b2ContactManager,
      b2DebugDraw = Box2D.Dynamics.b2DebugDraw,
      b2DestructionListener = Box2D.Dynamics.b2DestructionListener,
      b2FilterData = Box2D.Dynamics.b2FilterData,
      b2Fixture = Box2D.Dynamics.b2Fixture,
      b2FixtureDef = Box2D.Dynamics.b2FixtureDef,
      b2Island = Box2D.Dynamics.b2Island,
      b2TimeStep = Box2D.Dynamics.b2TimeStep,
      b2World = Box2D.Dynamics.b2World;
  Box2D.inherit(b2DistanceJoint, Box2D.Dynamics.Joints.b2Joint);
  b2DistanceJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;

  b2DistanceJoint.b2DistanceJoint = function () {
    Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
    this.m_localAnchor1 = new b2Vec2();
    this.m_localAnchor2 = new b2Vec2();
    this.m_u = new b2Vec2();
  };

  b2DistanceJoint.prototype.GetAnchorA = function () {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
  };

  b2DistanceJoint.prototype.GetAnchorB = function () {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
  };

  b2DistanceJoint.prototype.GetReactionForce = function (inv_dt) {
    if (inv_dt === undefined) inv_dt = 0;
    return new b2Vec2(inv_dt * this.m_impulse * this.m_u.x, inv_dt * this.m_impulse * this.m_u.y);
  };

  b2DistanceJoint.prototype.GetReactionTorque = function (inv_dt) {
    if (inv_dt === undefined) inv_dt = 0;
    return 0.0;
  };

  b2DistanceJoint.prototype.GetLength = function () {
    return this.m_length;
  };

  b2DistanceJoint.prototype.SetLength = function (length) {
    if (length === undefined) length = 0;
    this.m_length = length;
  };

  b2DistanceJoint.prototype.GetFrequency = function () {
    return this.m_frequencyHz;
  };

  b2DistanceJoint.prototype.SetFrequency = function (hz) {
    if (hz === undefined) hz = 0;
    this.m_frequencyHz = hz;
  };

  b2DistanceJoint.prototype.GetDampingRatio = function () {
    return this.m_dampingRatio;
  };

  b2DistanceJoint.prototype.SetDampingRatio = function (ratio) {
    if (ratio === undefined) ratio = 0;
    this.m_dampingRatio = ratio;
  };

  b2DistanceJoint.prototype.b2DistanceJoint = function (def) {
    this.__super.b2Joint.call(this, def);

    var tMat;
    var tX = 0;
    var tY = 0;
    this.m_localAnchor1.SetV(def.localAnchorA);
    this.m_localAnchor2.SetV(def.localAnchorB);
    this.m_length = def.length;
    this.m_frequencyHz = def.frequencyHz;
    this.m_dampingRatio = def.dampingRatio;
    this.m_impulse = 0.0;
    this.m_gamma = 0.0;
    this.m_bias = 0.0;
  };

  b2DistanceJoint.prototype.InitVelocityConstraints = function (step) {
    var tMat;
    var tX = 0;
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    tMat = bA.m_xf.R;
    var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    this.m_u.x = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
    this.m_u.y = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
    var length = Math.sqrt(this.m_u.x * this.m_u.x + this.m_u.y * this.m_u.y);

    if (length > b2Settings.b2_linearSlop) {
      this.m_u.Multiply(1.0 / length);
    } else {
      this.m_u.SetZero();
    }

    var cr1u = r1X * this.m_u.y - r1Y * this.m_u.x;
    var cr2u = r2X * this.m_u.y - r2Y * this.m_u.x;
    var invMass = bA.m_invMass + bA.m_invI * cr1u * cr1u + bB.m_invMass + bB.m_invI * cr2u * cr2u;
    this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;

    if (this.m_frequencyHz > 0.0) {
      var C = length - this.m_length;
      var omega = 2.0 * Math.PI * this.m_frequencyHz;
      var d = 2.0 * this.m_mass * this.m_dampingRatio * omega;
      var k = this.m_mass * omega * omega;
      this.m_gamma = step.dt * (d + step.dt * k);
      this.m_gamma = this.m_gamma != 0.0 ? 1 / this.m_gamma : 0.0;
      this.m_bias = C * step.dt * k * this.m_gamma;
      this.m_mass = invMass + this.m_gamma;
      this.m_mass = this.m_mass != 0.0 ? 1.0 / this.m_mass : 0.0;
    }

    if (step.warmStarting) {
      this.m_impulse *= step.dtRatio;
      var PX = this.m_impulse * this.m_u.x;
      var PY = this.m_impulse * this.m_u.y;
      bA.m_linearVelocity.x -= bA.m_invMass * PX;
      bA.m_linearVelocity.y -= bA.m_invMass * PY;
      bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
      bB.m_linearVelocity.x += bB.m_invMass * PX;
      bB.m_linearVelocity.y += bB.m_invMass * PY;
      bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
    } else {
      this.m_impulse = 0.0;
    }
  };

  b2DistanceJoint.prototype.SolveVelocityConstraints = function (step) {
    var tMat;
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    tMat = bA.m_xf.R;
    var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    var v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
    var v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
    var v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
    var v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
    var Cdot = this.m_u.x * (v2X - v1X) + this.m_u.y * (v2Y - v1Y);
    var impulse = -this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);
    this.m_impulse += impulse;
    var PX = impulse * this.m_u.x;
    var PY = impulse * this.m_u.y;
    bA.m_linearVelocity.x -= bA.m_invMass * PX;
    bA.m_linearVelocity.y -= bA.m_invMass * PY;
    bA.m_angularVelocity -= bA.m_invI * (r1X * PY - r1Y * PX);
    bB.m_linearVelocity.x += bB.m_invMass * PX;
    bB.m_linearVelocity.y += bB.m_invMass * PY;
    bB.m_angularVelocity += bB.m_invI * (r2X * PY - r2Y * PX);
  };

  b2DistanceJoint.prototype.SolvePositionConstraints = function (baumgarte) {
    if (baumgarte === undefined) baumgarte = 0;
    var tMat;

    if (this.m_frequencyHz > 0.0) {
      return true;
    }

    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    tMat = bA.m_xf.R;
    var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
    var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
    var length = Math.sqrt(dX * dX + dY * dY);
    dX /= length;
    dY /= length;
    var C = length - this.m_length;
    C = b2Math.Clamp(C, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
    var impulse = -this.m_mass * C;
    this.m_u.Set(dX, dY);
    var PX = impulse * this.m_u.x;
    var PY = impulse * this.m_u.y;
    bA.m_sweep.c.x -= bA.m_invMass * PX;
    bA.m_sweep.c.y -= bA.m_invMass * PY;
    bA.m_sweep.a -= bA.m_invI * (r1X * PY - r1Y * PX);
    bB.m_sweep.c.x += bB.m_invMass * PX;
    bB.m_sweep.c.y += bB.m_invMass * PY;
    bB.m_sweep.a += bB.m_invI * (r2X * PY - r2Y * PX);
    bA.SynchronizeTransform();
    bB.SynchronizeTransform();
    return b2Math.Abs(C) < b2Settings.b2_linearSlop;
  };

  Box2D.inherit(b2DistanceJointDef, Box2D.Dynamics.Joints.b2JointDef);
  b2DistanceJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;

  b2DistanceJointDef.b2DistanceJointDef = function () {
    Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
    this.localAnchorA = new b2Vec2();
    this.localAnchorB = new b2Vec2();
  };

  b2DistanceJointDef.prototype.b2DistanceJointDef = function () {
    this.__super.b2JointDef.call(this);

    this.type = b2Joint.e_distanceJoint;
    this.length = 1.0;
    this.frequencyHz = 0.0;
    this.dampingRatio = 0.0;
  };

  b2DistanceJointDef.prototype.Initialize = function (bA, bB, anchorA, anchorB) {
    this.bodyA = bA;
    this.bodyB = bB;
    this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchorA));
    this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchorB));
    var dX = anchorB.x - anchorA.x;
    var dY = anchorB.y - anchorA.y;
    this.length = Math.sqrt(dX * dX + dY * dY);
    this.frequencyHz = 0.0;
    this.dampingRatio = 0.0;
  };

  Box2D.inherit(b2FrictionJoint, Box2D.Dynamics.Joints.b2Joint);
  b2FrictionJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;

  b2FrictionJoint.b2FrictionJoint = function () {
    Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
    this.m_localAnchorA = new b2Vec2();
    this.m_localAnchorB = new b2Vec2();
    this.m_linearMass = new b2Mat22();
    this.m_linearImpulse = new b2Vec2();
  };

  b2FrictionJoint.prototype.GetAnchorA = function () {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
  };

  b2FrictionJoint.prototype.GetAnchorB = function () {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
  };

  b2FrictionJoint.prototype.GetReactionForce = function (inv_dt) {
    if (inv_dt === undefined) inv_dt = 0;
    return new b2Vec2(inv_dt * this.m_linearImpulse.x, inv_dt * this.m_linearImpulse.y);
  };

  b2FrictionJoint.prototype.GetReactionTorque = function (inv_dt) {
    if (inv_dt === undefined) inv_dt = 0;
    return inv_dt * this.m_angularImpulse;
  };

  b2FrictionJoint.prototype.SetMaxForce = function (force) {
    if (force === undefined) force = 0;
    this.m_maxForce = force;
  };

  b2FrictionJoint.prototype.GetMaxForce = function () {
    return this.m_maxForce;
  };

  b2FrictionJoint.prototype.SetMaxTorque = function (torque) {
    if (torque === undefined) torque = 0;
    this.m_maxTorque = torque;
  };

  b2FrictionJoint.prototype.GetMaxTorque = function () {
    return this.m_maxTorque;
  };

  b2FrictionJoint.prototype.b2FrictionJoint = function (def) {
    this.__super.b2Joint.call(this, def);

    this.m_localAnchorA.SetV(def.localAnchorA);
    this.m_localAnchorB.SetV(def.localAnchorB);
    this.m_linearMass.SetZero();
    this.m_angularMass = 0.0;
    this.m_linearImpulse.SetZero();
    this.m_angularImpulse = 0.0;
    this.m_maxForce = def.maxForce;
    this.m_maxTorque = def.maxTorque;
  };

  b2FrictionJoint.prototype.InitVelocityConstraints = function (step) {
    var tMat;
    var tX = 0;
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    tMat = bA.m_xf.R;
    var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
    var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
    rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
    rAX = tX;
    tMat = bB.m_xf.R;
    var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
    var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
    rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
    rBX = tX;
    var mA = bA.m_invMass;
    var mB = bB.m_invMass;
    var iA = bA.m_invI;
    var iB = bB.m_invI;
    var K = new b2Mat22();
    K.col1.x = mA + mB;
    K.col2.x = 0.0;
    K.col1.y = 0.0;
    K.col2.y = mA + mB;
    K.col1.x += iA * rAY * rAY;
    K.col2.x += -iA * rAX * rAY;
    K.col1.y += -iA * rAX * rAY;
    K.col2.y += iA * rAX * rAX;
    K.col1.x += iB * rBY * rBY;
    K.col2.x += -iB * rBX * rBY;
    K.col1.y += -iB * rBX * rBY;
    K.col2.y += iB * rBX * rBX;
    K.GetInverse(this.m_linearMass);
    this.m_angularMass = iA + iB;

    if (this.m_angularMass > 0.0) {
      this.m_angularMass = 1.0 / this.m_angularMass;
    }

    if (step.warmStarting) {
      this.m_linearImpulse.x *= step.dtRatio;
      this.m_linearImpulse.y *= step.dtRatio;
      this.m_angularImpulse *= step.dtRatio;
      var P = this.m_linearImpulse;
      bA.m_linearVelocity.x -= mA * P.x;
      bA.m_linearVelocity.y -= mA * P.y;
      bA.m_angularVelocity -= iA * (rAX * P.y - rAY * P.x + this.m_angularImpulse);
      bB.m_linearVelocity.x += mB * P.x;
      bB.m_linearVelocity.y += mB * P.y;
      bB.m_angularVelocity += iB * (rBX * P.y - rBY * P.x + this.m_angularImpulse);
    } else {
      this.m_linearImpulse.SetZero();
      this.m_angularImpulse = 0.0;
    }
  };

  b2FrictionJoint.prototype.SolveVelocityConstraints = function (step) {
    var tMat;
    var tX = 0;
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    var vA = bA.m_linearVelocity;
    var wA = bA.m_angularVelocity;
    var vB = bB.m_linearVelocity;
    var wB = bB.m_angularVelocity;
    var mA = bA.m_invMass;
    var mB = bB.m_invMass;
    var iA = bA.m_invI;
    var iB = bB.m_invI;
    tMat = bA.m_xf.R;
    var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
    var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
    rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
    rAX = tX;
    tMat = bB.m_xf.R;
    var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
    var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
    rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
    rBX = tX;
    var maxImpulse = 0;
    {
      var Cdot = wB - wA;
      var impulse = -this.m_angularMass * Cdot;
      var oldImpulse = this.m_angularImpulse;
      maxImpulse = step.dt * this.m_maxTorque;
      this.m_angularImpulse = b2Math.Clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);
      impulse = this.m_angularImpulse - oldImpulse;
      wA -= iA * impulse;
      wB += iB * impulse;
    }
    {
      var CdotX = vB.x - wB * rBY - vA.x + wA * rAY;
      var CdotY = vB.y + wB * rBX - vA.y - wA * rAX;
      var impulseV = b2Math.MulMV(this.m_linearMass, new b2Vec2(-CdotX, -CdotY));
      var oldImpulseV = this.m_linearImpulse.Copy();
      this.m_linearImpulse.Add(impulseV);
      maxImpulse = step.dt * this.m_maxForce;

      if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {
        this.m_linearImpulse.Normalize();
        this.m_linearImpulse.Multiply(maxImpulse);
      }

      impulseV = b2Math.SubtractVV(this.m_linearImpulse, oldImpulseV);
      vA.x -= mA * impulseV.x;
      vA.y -= mA * impulseV.y;
      wA -= iA * (rAX * impulseV.y - rAY * impulseV.x);
      vB.x += mB * impulseV.x;
      vB.y += mB * impulseV.y;
      wB += iB * (rBX * impulseV.y - rBY * impulseV.x);
    }
    bA.m_angularVelocity = wA;
    bB.m_angularVelocity = wB;
  };

  b2FrictionJoint.prototype.SolvePositionConstraints = function (baumgarte) {
    if (baumgarte === undefined) baumgarte = 0;
    return true;
  };

  Box2D.inherit(b2FrictionJointDef, Box2D.Dynamics.Joints.b2JointDef);
  b2FrictionJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;

  b2FrictionJointDef.b2FrictionJointDef = function () {
    Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
    this.localAnchorA = new b2Vec2();
    this.localAnchorB = new b2Vec2();
  };

  b2FrictionJointDef.prototype.b2FrictionJointDef = function () {
    this.__super.b2JointDef.call(this);

    this.type = b2Joint.e_frictionJoint;
    this.maxForce = 0.0;
    this.maxTorque = 0.0;
  };

  b2FrictionJointDef.prototype.Initialize = function (bA, bB, anchor) {
    this.bodyA = bA;
    this.bodyB = bB;
    this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
    this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
  };

  Box2D.inherit(b2GearJoint, Box2D.Dynamics.Joints.b2Joint);
  b2GearJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;

  b2GearJoint.b2GearJoint = function () {
    Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
    this.m_groundAnchor1 = new b2Vec2();
    this.m_groundAnchor2 = new b2Vec2();
    this.m_localAnchor1 = new b2Vec2();
    this.m_localAnchor2 = new b2Vec2();
    this.m_J = new b2Jacobian();
  };

  b2GearJoint.prototype.GetAnchorA = function () {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
  };

  b2GearJoint.prototype.GetAnchorB = function () {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
  };

  b2GearJoint.prototype.GetReactionForce = function (inv_dt) {
    if (inv_dt === undefined) inv_dt = 0;
    return new b2Vec2(inv_dt * this.m_impulse * this.m_J.linearB.x, inv_dt * this.m_impulse * this.m_J.linearB.y);
  };

  b2GearJoint.prototype.GetReactionTorque = function (inv_dt) {
    if (inv_dt === undefined) inv_dt = 0;
    var tMat = this.m_bodyB.m_xf.R;
    var rX = this.m_localAnchor1.x - this.m_bodyB.m_sweep.localCenter.x;
    var rY = this.m_localAnchor1.y - this.m_bodyB.m_sweep.localCenter.y;
    var tX = tMat.col1.x * rX + tMat.col2.x * rY;
    rY = tMat.col1.y * rX + tMat.col2.y * rY;
    rX = tX;
    var PX = this.m_impulse * this.m_J.linearB.x;
    var PY = this.m_impulse * this.m_J.linearB.y;
    return inv_dt * (this.m_impulse * this.m_J.angularB - rX * PY + rY * PX);
  };

  b2GearJoint.prototype.GetRatio = function () {
    return this.m_ratio;
  };

  b2GearJoint.prototype.SetRatio = function (ratio) {
    if (ratio === undefined) ratio = 0;
    this.m_ratio = ratio;
  };

  b2GearJoint.prototype.b2GearJoint = function (def) {
    this.__super.b2Joint.call(this, def);

    var type1 = parseInt(def.joint1.m_type);
    var type2 = parseInt(def.joint2.m_type);
    this.m_revolute1 = null;
    this.m_prismatic1 = null;
    this.m_revolute2 = null;
    this.m_prismatic2 = null;
    var coordinate1 = 0;
    var coordinate2 = 0;
    this.m_ground1 = def.joint1.GetBodyA();
    this.m_bodyA = def.joint1.GetBodyB();

    if (type1 == b2Joint.e_revoluteJoint) {
      this.m_revolute1 = def.joint1 instanceof b2RevoluteJoint ? def.joint1 : null;
      this.m_groundAnchor1.SetV(this.m_revolute1.m_localAnchor1);
      this.m_localAnchor1.SetV(this.m_revolute1.m_localAnchor2);
      coordinate1 = this.m_revolute1.GetJointAngle();
    } else {
      this.m_prismatic1 = def.joint1 instanceof b2PrismaticJoint ? def.joint1 : null;
      this.m_groundAnchor1.SetV(this.m_prismatic1.m_localAnchor1);
      this.m_localAnchor1.SetV(this.m_prismatic1.m_localAnchor2);
      coordinate1 = this.m_prismatic1.GetJointTranslation();
    }

    this.m_ground2 = def.joint2.GetBodyA();
    this.m_bodyB = def.joint2.GetBodyB();

    if (type2 == b2Joint.e_revoluteJoint) {
      this.m_revolute2 = def.joint2 instanceof b2RevoluteJoint ? def.joint2 : null;
      this.m_groundAnchor2.SetV(this.m_revolute2.m_localAnchor1);
      this.m_localAnchor2.SetV(this.m_revolute2.m_localAnchor2);
      coordinate2 = this.m_revolute2.GetJointAngle();
    } else {
      this.m_prismatic2 = def.joint2 instanceof b2PrismaticJoint ? def.joint2 : null;
      this.m_groundAnchor2.SetV(this.m_prismatic2.m_localAnchor1);
      this.m_localAnchor2.SetV(this.m_prismatic2.m_localAnchor2);
      coordinate2 = this.m_prismatic2.GetJointTranslation();
    }

    this.m_ratio = def.ratio;
    this.m_constant = coordinate1 + this.m_ratio * coordinate2;
    this.m_impulse = 0.0;
  };

  b2GearJoint.prototype.InitVelocityConstraints = function (step) {
    var g1 = this.m_ground1;
    var g2 = this.m_ground2;
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    var ugX = 0;
    var ugY = 0;
    var rX = 0;
    var rY = 0;
    var tMat;
    var tVec;
    var crug = 0;
    var tX = 0;
    var K = 0.0;
    this.m_J.SetZero();

    if (this.m_revolute1) {
      this.m_J.angularA = -1.0;
      K += bA.m_invI;
    } else {
      tMat = g1.m_xf.R;
      tVec = this.m_prismatic1.m_localXAxis1;
      ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = bA.m_xf.R;
      rX = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      rY = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      tX = tMat.col1.x * rX + tMat.col2.x * rY;
      rY = tMat.col1.y * rX + tMat.col2.y * rY;
      rX = tX;
      crug = rX * ugY - rY * ugX;
      this.m_J.linearA.Set(-ugX, -ugY);
      this.m_J.angularA = -crug;
      K += bA.m_invMass + bA.m_invI * crug * crug;
    }

    if (this.m_revolute2) {
      this.m_J.angularB = -this.m_ratio;
      K += this.m_ratio * this.m_ratio * bB.m_invI;
    } else {
      tMat = g2.m_xf.R;
      tVec = this.m_prismatic2.m_localXAxis1;
      ugX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      ugY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = bB.m_xf.R;
      rX = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      rY = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = tMat.col1.x * rX + tMat.col2.x * rY;
      rY = tMat.col1.y * rX + tMat.col2.y * rY;
      rX = tX;
      crug = rX * ugY - rY * ugX;
      this.m_J.linearB.Set(-this.m_ratio * ugX, -this.m_ratio * ugY);
      this.m_J.angularB = -this.m_ratio * crug;
      K += this.m_ratio * this.m_ratio * (bB.m_invMass + bB.m_invI * crug * crug);
    }

    this.m_mass = K > 0.0 ? 1.0 / K : 0.0;

    if (step.warmStarting) {
      bA.m_linearVelocity.x += bA.m_invMass * this.m_impulse * this.m_J.linearA.x;
      bA.m_linearVelocity.y += bA.m_invMass * this.m_impulse * this.m_J.linearA.y;
      bA.m_angularVelocity += bA.m_invI * this.m_impulse * this.m_J.angularA;
      bB.m_linearVelocity.x += bB.m_invMass * this.m_impulse * this.m_J.linearB.x;
      bB.m_linearVelocity.y += bB.m_invMass * this.m_impulse * this.m_J.linearB.y;
      bB.m_angularVelocity += bB.m_invI * this.m_impulse * this.m_J.angularB;
    } else {
      this.m_impulse = 0.0;
    }
  };

  b2GearJoint.prototype.SolveVelocityConstraints = function (step) {
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    var Cdot = this.m_J.Compute(bA.m_linearVelocity, bA.m_angularVelocity, bB.m_linearVelocity, bB.m_angularVelocity);
    var impulse = -this.m_mass * Cdot;
    this.m_impulse += impulse;
    bA.m_linearVelocity.x += bA.m_invMass * impulse * this.m_J.linearA.x;
    bA.m_linearVelocity.y += bA.m_invMass * impulse * this.m_J.linearA.y;
    bA.m_angularVelocity += bA.m_invI * impulse * this.m_J.angularA;
    bB.m_linearVelocity.x += bB.m_invMass * impulse * this.m_J.linearB.x;
    bB.m_linearVelocity.y += bB.m_invMass * impulse * this.m_J.linearB.y;
    bB.m_angularVelocity += bB.m_invI * impulse * this.m_J.angularB;
  };

  b2GearJoint.prototype.SolvePositionConstraints = function (baumgarte) {
    if (baumgarte === undefined) baumgarte = 0;
    var linearError = 0.0;
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    var coordinate1 = 0;
    var coordinate2 = 0;

    if (this.m_revolute1) {
      coordinate1 = this.m_revolute1.GetJointAngle();
    } else {
      coordinate1 = this.m_prismatic1.GetJointTranslation();
    }

    if (this.m_revolute2) {
      coordinate2 = this.m_revolute2.GetJointAngle();
    } else {
      coordinate2 = this.m_prismatic2.GetJointTranslation();
    }

    var C = this.m_constant - (coordinate1 + this.m_ratio * coordinate2);
    var impulse = -this.m_mass * C;
    bA.m_sweep.c.x += bA.m_invMass * impulse * this.m_J.linearA.x;
    bA.m_sweep.c.y += bA.m_invMass * impulse * this.m_J.linearA.y;
    bA.m_sweep.a += bA.m_invI * impulse * this.m_J.angularA;
    bB.m_sweep.c.x += bB.m_invMass * impulse * this.m_J.linearB.x;
    bB.m_sweep.c.y += bB.m_invMass * impulse * this.m_J.linearB.y;
    bB.m_sweep.a += bB.m_invI * impulse * this.m_J.angularB;
    bA.SynchronizeTransform();
    bB.SynchronizeTransform();
    return linearError < b2Settings.b2_linearSlop;
  };

  Box2D.inherit(b2GearJointDef, Box2D.Dynamics.Joints.b2JointDef);
  b2GearJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;

  b2GearJointDef.b2GearJointDef = function () {
    Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
  };

  b2GearJointDef.prototype.b2GearJointDef = function () {
    this.__super.b2JointDef.call(this);

    this.type = b2Joint.e_gearJoint;
    this.joint1 = null;
    this.joint2 = null;
    this.ratio = 1.0;
  };

  b2Jacobian.b2Jacobian = function () {
    this.linearA = new b2Vec2();
    this.linearB = new b2Vec2();
  };

  b2Jacobian.prototype.SetZero = function () {
    this.linearA.SetZero();
    this.angularA = 0.0;
    this.linearB.SetZero();
    this.angularB = 0.0;
  };

  b2Jacobian.prototype.Set = function (x1, a1, x2, a2) {
    if (a1 === undefined) a1 = 0;
    if (a2 === undefined) a2 = 0;
    this.linearA.SetV(x1);
    this.angularA = a1;
    this.linearB.SetV(x2);
    this.angularB = a2;
  };

  b2Jacobian.prototype.Compute = function (x1, a1, x2, a2) {
    if (a1 === undefined) a1 = 0;
    if (a2 === undefined) a2 = 0;
    return this.linearA.x * x1.x + this.linearA.y * x1.y + this.angularA * a1 + (this.linearB.x * x2.x + this.linearB.y * x2.y) + this.angularB * a2;
  };

  b2Joint.b2Joint = function () {
    this.m_edgeA = new b2JointEdge();
    this.m_edgeB = new b2JointEdge();
    this.m_localCenterA = new b2Vec2();
    this.m_localCenterB = new b2Vec2();
  };

  b2Joint.prototype.GetType = function () {
    return this.m_type;
  };

  b2Joint.prototype.GetAnchorA = function () {
    return null;
  };

  b2Joint.prototype.GetAnchorB = function () {
    return null;
  };

  b2Joint.prototype.GetReactionForce = function (inv_dt) {
    if (inv_dt === undefined) inv_dt = 0;
    return null;
  };

  b2Joint.prototype.GetReactionTorque = function (inv_dt) {
    if (inv_dt === undefined) inv_dt = 0;
    return 0.0;
  };

  b2Joint.prototype.GetBodyA = function () {
    return this.m_bodyA;
  };

  b2Joint.prototype.GetBodyB = function () {
    return this.m_bodyB;
  };

  b2Joint.prototype.GetNext = function () {
    return this.m_next;
  };

  b2Joint.prototype.GetUserData = function () {
    return this.m_userData;
  };

  b2Joint.prototype.SetUserData = function (data) {
    this.m_userData = data;
  };

  b2Joint.prototype.IsActive = function () {
    return this.m_bodyA.IsActive() && this.m_bodyB.IsActive();
  };

  b2Joint.Create = function (def, allocator) {
    var joint = null;

    switch (def.type) {
      case b2Joint.e_distanceJoint:
        {
          joint = new b2DistanceJoint(def instanceof b2DistanceJointDef ? def : null);
        }
        break;

      case b2Joint.e_mouseJoint:
        {
          joint = new b2MouseJoint(def instanceof b2MouseJointDef ? def : null);
        }
        break;

      case b2Joint.e_prismaticJoint:
        {
          joint = new b2PrismaticJoint(def instanceof b2PrismaticJointDef ? def : null);
        }
        break;

      case b2Joint.e_revoluteJoint:
        {
          joint = new b2RevoluteJoint(def instanceof b2RevoluteJointDef ? def : null);
        }
        break;

      case b2Joint.e_pulleyJoint:
        {
          joint = new b2PulleyJoint(def instanceof b2PulleyJointDef ? def : null);
        }
        break;

      case b2Joint.e_gearJoint:
        {
          joint = new b2GearJoint(def instanceof b2GearJointDef ? def : null);
        }
        break;

      case b2Joint.e_lineJoint:
        {
          joint = new b2LineJoint(def instanceof b2LineJointDef ? def : null);
        }
        break;

      case b2Joint.e_weldJoint:
        {
          joint = new b2WeldJoint(def instanceof b2WeldJointDef ? def : null);
        }
        break;

      case b2Joint.e_frictionJoint:
        {
          joint = new b2FrictionJoint(def instanceof b2FrictionJointDef ? def : null);
        }
        break;

      default:
        break;
    }

    return joint;
  };

  b2Joint.Destroy = function (joint, allocator) {};

  b2Joint.prototype.b2Joint = function (def) {
    b2Settings.b2Assert(def.bodyA != def.bodyB);
    this.m_type = def.type;
    this.m_prev = null;
    this.m_next = null;
    this.m_bodyA = def.bodyA;
    this.m_bodyB = def.bodyB;
    this.m_collideConnected = def.collideConnected;
    this.m_islandFlag = false;
    this.m_userData = def.userData;
  };

  b2Joint.prototype.InitVelocityConstraints = function (step) {};

  b2Joint.prototype.SolveVelocityConstraints = function (step) {};

  b2Joint.prototype.FinalizeVelocityConstraints = function () {};

  b2Joint.prototype.SolvePositionConstraints = function (baumgarte) {
    if (baumgarte === undefined) baumgarte = 0;
    return false;
  };

  Box2D.postDefs.push(function () {
    Box2D.Dynamics.Joints.b2Joint.e_unknownJoint = 0;
    Box2D.Dynamics.Joints.b2Joint.e_revoluteJoint = 1;
    Box2D.Dynamics.Joints.b2Joint.e_prismaticJoint = 2;
    Box2D.Dynamics.Joints.b2Joint.e_distanceJoint = 3;
    Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint = 4;
    Box2D.Dynamics.Joints.b2Joint.e_mouseJoint = 5;
    Box2D.Dynamics.Joints.b2Joint.e_gearJoint = 6;
    Box2D.Dynamics.Joints.b2Joint.e_lineJoint = 7;
    Box2D.Dynamics.Joints.b2Joint.e_weldJoint = 8;
    Box2D.Dynamics.Joints.b2Joint.e_frictionJoint = 9;
    Box2D.Dynamics.Joints.b2Joint.e_inactiveLimit = 0;
    Box2D.Dynamics.Joints.b2Joint.e_atLowerLimit = 1;
    Box2D.Dynamics.Joints.b2Joint.e_atUpperLimit = 2;
    Box2D.Dynamics.Joints.b2Joint.e_equalLimits = 3;
  });

  b2JointDef.b2JointDef = function () {};

  b2JointDef.prototype.b2JointDef = function () {
    this.type = b2Joint.e_unknownJoint;
    this.userData = null;
    this.bodyA = null;
    this.bodyB = null;
    this.collideConnected = false;
  };

  b2JointEdge.b2JointEdge = function () {};

  Box2D.inherit(b2LineJoint, Box2D.Dynamics.Joints.b2Joint);
  b2LineJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;

  b2LineJoint.b2LineJoint = function () {
    Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
    this.m_localAnchor1 = new b2Vec2();
    this.m_localAnchor2 = new b2Vec2();
    this.m_localXAxis1 = new b2Vec2();
    this.m_localYAxis1 = new b2Vec2();
    this.m_axis = new b2Vec2();
    this.m_perp = new b2Vec2();
    this.m_K = new b2Mat22();
    this.m_impulse = new b2Vec2();
  };

  b2LineJoint.prototype.GetAnchorA = function () {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
  };

  b2LineJoint.prototype.GetAnchorB = function () {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
  };

  b2LineJoint.prototype.GetReactionForce = function (inv_dt) {
    if (inv_dt === undefined) inv_dt = 0;
    return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y));
  };

  b2LineJoint.prototype.GetReactionTorque = function (inv_dt) {
    if (inv_dt === undefined) inv_dt = 0;
    return inv_dt * this.m_impulse.y;
  };

  b2LineJoint.prototype.GetJointTranslation = function () {
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    var tMat;
    var p1 = bA.GetWorldPoint(this.m_localAnchor1);
    var p2 = bB.GetWorldPoint(this.m_localAnchor2);
    var dX = p2.x - p1.x;
    var dY = p2.y - p1.y;
    var axis = bA.GetWorldVector(this.m_localXAxis1);
    var translation = axis.x * dX + axis.y * dY;
    return translation;
  };

  b2LineJoint.prototype.GetJointSpeed = function () {
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    var tMat;
    tMat = bA.m_xf.R;
    var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    var p1X = bA.m_sweep.c.x + r1X;
    var p1Y = bA.m_sweep.c.y + r1Y;
    var p2X = bB.m_sweep.c.x + r2X;
    var p2Y = bB.m_sweep.c.y + r2Y;
    var dX = p2X - p1X;
    var dY = p2Y - p1Y;
    var axis = bA.GetWorldVector(this.m_localXAxis1);
    var v1 = bA.m_linearVelocity;
    var v2 = bB.m_linearVelocity;
    var w1 = bA.m_angularVelocity;
    var w2 = bB.m_angularVelocity;
    var speed = dX * (-w1 * axis.y) + dY * (w1 * axis.x) + (axis.x * (v2.x + -w2 * r2Y - v1.x - -w1 * r1Y) + axis.y * (v2.y + w2 * r2X - v1.y - w1 * r1X));
    return speed;
  };

  b2LineJoint.prototype.IsLimitEnabled = function () {
    return this.m_enableLimit;
  };

  b2LineJoint.prototype.EnableLimit = function (flag) {
    this.m_bodyA.SetAwake(true);
    this.m_bodyB.SetAwake(true);
    this.m_enableLimit = flag;
  };

  b2LineJoint.prototype.GetLowerLimit = function () {
    return this.m_lowerTranslation;
  };

  b2LineJoint.prototype.GetUpperLimit = function () {
    return this.m_upperTranslation;
  };

  b2LineJoint.prototype.SetLimits = function (lower, upper) {
    if (lower === undefined) lower = 0;
    if (upper === undefined) upper = 0;
    this.m_bodyA.SetAwake(true);
    this.m_bodyB.SetAwake(true);
    this.m_lowerTranslation = lower;
    this.m_upperTranslation = upper;
  };

  b2LineJoint.prototype.IsMotorEnabled = function () {
    return this.m_enableMotor;
  };

  b2LineJoint.prototype.EnableMotor = function (flag) {
    this.m_bodyA.SetAwake(true);
    this.m_bodyB.SetAwake(true);
    this.m_enableMotor = flag;
  };

  b2LineJoint.prototype.SetMotorSpeed = function (speed) {
    if (speed === undefined) speed = 0;
    this.m_bodyA.SetAwake(true);
    this.m_bodyB.SetAwake(true);
    this.m_motorSpeed = speed;
  };

  b2LineJoint.prototype.GetMotorSpeed = function () {
    return this.m_motorSpeed;
  };

  b2LineJoint.prototype.SetMaxMotorForce = function (force) {
    if (force === undefined) force = 0;
    this.m_bodyA.SetAwake(true);
    this.m_bodyB.SetAwake(true);
    this.m_maxMotorForce = force;
  };

  b2LineJoint.prototype.GetMaxMotorForce = function () {
    return this.m_maxMotorForce;
  };

  b2LineJoint.prototype.GetMotorForce = function () {
    return this.m_motorImpulse;
  };

  b2LineJoint.prototype.b2LineJoint = function (def) {
    this.__super.b2Joint.call(this, def);

    var tMat;
    var tX = 0;
    var tY = 0;
    this.m_localAnchor1.SetV(def.localAnchorA);
    this.m_localAnchor2.SetV(def.localAnchorB);
    this.m_localXAxis1.SetV(def.localAxisA);
    this.m_localYAxis1.x = -this.m_localXAxis1.y;
    this.m_localYAxis1.y = this.m_localXAxis1.x;
    this.m_impulse.SetZero();
    this.m_motorMass = 0.0;
    this.m_motorImpulse = 0.0;
    this.m_lowerTranslation = def.lowerTranslation;
    this.m_upperTranslation = def.upperTranslation;
    this.m_maxMotorForce = def.maxMotorForce;
    this.m_motorSpeed = def.motorSpeed;
    this.m_enableLimit = def.enableLimit;
    this.m_enableMotor = def.enableMotor;
    this.m_limitState = b2Joint.e_inactiveLimit;
    this.m_axis.SetZero();
    this.m_perp.SetZero();
  };

  b2LineJoint.prototype.InitVelocityConstraints = function (step) {
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    var tMat;
    var tX = 0;
    this.m_localCenterA.SetV(bA.GetLocalCenter());
    this.m_localCenterB.SetV(bB.GetLocalCenter());
    var xf1 = bA.GetTransform();
    var xf2 = bB.GetTransform();
    tMat = bA.m_xf.R;
    var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
    var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
    var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
    var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
    this.m_invMassA = bA.m_invMass;
    this.m_invMassB = bB.m_invMass;
    this.m_invIA = bA.m_invI;
    this.m_invIB = bB.m_invI;
    {
      this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
      this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
      this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
      this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
      this.m_motorMass = this.m_motorMass > Number.MIN_VALUE ? 1.0 / this.m_motorMass : 0.0;
    }
    {
      this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
      this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
      this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
      var m1 = this.m_invMassA;
      var m2 = this.m_invMassB;
      var i1 = this.m_invIA;
      var i2 = this.m_invIB;
      this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
      this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
      this.m_K.col2.x = this.m_K.col1.y;
      this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
    }

    if (this.m_enableLimit) {
      var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;

      if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
        this.m_limitState = b2Joint.e_equalLimits;
      } else if (jointTransition <= this.m_lowerTranslation) {
        if (this.m_limitState != b2Joint.e_atLowerLimit) {
          this.m_limitState = b2Joint.e_atLowerLimit;
          this.m_impulse.y = 0.0;
        }
      } else if (jointTransition >= this.m_upperTranslation) {
        if (this.m_limitState != b2Joint.e_atUpperLimit) {
          this.m_limitState = b2Joint.e_atUpperLimit;
          this.m_impulse.y = 0.0;
        }
      } else {
        this.m_limitState = b2Joint.e_inactiveLimit;
        this.m_impulse.y = 0.0;
      }
    } else {
      this.m_limitState = b2Joint.e_inactiveLimit;
    }

    if (this.m_enableMotor == false) {
      this.m_motorImpulse = 0.0;
    }

    if (step.warmStarting) {
      this.m_impulse.x *= step.dtRatio;
      this.m_impulse.y *= step.dtRatio;
      this.m_motorImpulse *= step.dtRatio;
      var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.x;
      var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.y) * this.m_axis.y;
      var L1 = this.m_impulse.x * this.m_s1 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a1;
      var L2 = this.m_impulse.x * this.m_s2 + (this.m_motorImpulse + this.m_impulse.y) * this.m_a2;
      bA.m_linearVelocity.x -= this.m_invMassA * PX;
      bA.m_linearVelocity.y -= this.m_invMassA * PY;
      bA.m_angularVelocity -= this.m_invIA * L1;
      bB.m_linearVelocity.x += this.m_invMassB * PX;
      bB.m_linearVelocity.y += this.m_invMassB * PY;
      bB.m_angularVelocity += this.m_invIB * L2;
    } else {
      this.m_impulse.SetZero();
      this.m_motorImpulse = 0.0;
    }
  };

  b2LineJoint.prototype.SolveVelocityConstraints = function (step) {
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    var v1 = bA.m_linearVelocity;
    var w1 = bA.m_angularVelocity;
    var v2 = bB.m_linearVelocity;
    var w2 = bB.m_angularVelocity;
    var PX = 0;
    var PY = 0;
    var L1 = 0;
    var L2 = 0;

    if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
      var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
      var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
      var oldImpulse = this.m_motorImpulse;
      var maxImpulse = step.dt * this.m_maxMotorForce;
      this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
      impulse = this.m_motorImpulse - oldImpulse;
      PX = impulse * this.m_axis.x;
      PY = impulse * this.m_axis.y;
      L1 = impulse * this.m_a1;
      L2 = impulse * this.m_a2;
      v1.x -= this.m_invMassA * PX;
      v1.y -= this.m_invMassA * PY;
      w1 -= this.m_invIA * L1;
      v2.x += this.m_invMassB * PX;
      v2.y += this.m_invMassB * PY;
      w2 += this.m_invIB * L2;
    }

    var Cdot1 = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;

    if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
      var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
      var f1 = this.m_impulse.Copy();
      var df = this.m_K.Solve(new b2Vec2(), -Cdot1, -Cdot2);
      this.m_impulse.Add(df);

      if (this.m_limitState == b2Joint.e_atLowerLimit) {
        this.m_impulse.y = b2Math.Max(this.m_impulse.y, 0.0);
      } else if (this.m_limitState == b2Joint.e_atUpperLimit) {
        this.m_impulse.y = b2Math.Min(this.m_impulse.y, 0.0);
      }

      var b = -Cdot1 - (this.m_impulse.y - f1.y) * this.m_K.col2.x;
      var f2r = 0;

      if (this.m_K.col1.x != 0.0) {
        f2r = b / this.m_K.col1.x + f1.x;
      } else {
        f2r = f1.x;
      }

      this.m_impulse.x = f2r;
      df.x = this.m_impulse.x - f1.x;
      df.y = this.m_impulse.y - f1.y;
      PX = df.x * this.m_perp.x + df.y * this.m_axis.x;
      PY = df.x * this.m_perp.y + df.y * this.m_axis.y;
      L1 = df.x * this.m_s1 + df.y * this.m_a1;
      L2 = df.x * this.m_s2 + df.y * this.m_a2;
      v1.x -= this.m_invMassA * PX;
      v1.y -= this.m_invMassA * PY;
      w1 -= this.m_invIA * L1;
      v2.x += this.m_invMassB * PX;
      v2.y += this.m_invMassB * PY;
      w2 += this.m_invIB * L2;
    } else {
      var df2 = 0;

      if (this.m_K.col1.x != 0.0) {
        df2 = -Cdot1 / this.m_K.col1.x;
      } else {
        df2 = 0.0;
      }

      this.m_impulse.x += df2;
      PX = df2 * this.m_perp.x;
      PY = df2 * this.m_perp.y;
      L1 = df2 * this.m_s1;
      L2 = df2 * this.m_s2;
      v1.x -= this.m_invMassA * PX;
      v1.y -= this.m_invMassA * PY;
      w1 -= this.m_invIA * L1;
      v2.x += this.m_invMassB * PX;
      v2.y += this.m_invMassB * PY;
      w2 += this.m_invIB * L2;
    }

    bA.m_linearVelocity.SetV(v1);
    bA.m_angularVelocity = w1;
    bB.m_linearVelocity.SetV(v2);
    bB.m_angularVelocity = w2;
  };

  b2LineJoint.prototype.SolvePositionConstraints = function (baumgarte) {
    if (baumgarte === undefined) baumgarte = 0;
    var limitC = 0;
    var oldLimitImpulse = 0;
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    var c1 = bA.m_sweep.c;
    var a1 = bA.m_sweep.a;
    var c2 = bB.m_sweep.c;
    var a2 = bB.m_sweep.a;
    var tMat;
    var tX = 0;
    var m1 = 0;
    var m2 = 0;
    var i1 = 0;
    var i2 = 0;
    var linearError = 0.0;
    var angularError = 0.0;
    var active = false;
    var C2 = 0.0;
    var R1 = b2Mat22.FromAngle(a1);
    var R2 = b2Mat22.FromAngle(a2);
    tMat = R1;
    var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
    var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = R2;
    var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
    var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    var dX = c2.x + r2X - c1.x - r1X;
    var dY = c2.y + r2Y - c1.y - r1Y;

    if (this.m_enableLimit) {
      this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
      this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
      this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
      var translation = this.m_axis.x * dX + this.m_axis.y * dY;

      if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
        C2 = b2Math.Clamp(translation, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
        linearError = b2Math.Abs(translation);
        active = true;
      } else if (translation <= this.m_lowerTranslation) {
        C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0.0);
        linearError = this.m_lowerTranslation - translation;
        active = true;
      } else if (translation >= this.m_upperTranslation) {
        C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
        linearError = translation - this.m_upperTranslation;
        active = true;
      }
    }

    this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
    this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
    this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
    var impulse = new b2Vec2();
    var C1 = this.m_perp.x * dX + this.m_perp.y * dY;
    linearError = b2Math.Max(linearError, b2Math.Abs(C1));
    angularError = 0.0;

    if (active) {
      m1 = this.m_invMassA;
      m2 = this.m_invMassB;
      i1 = this.m_invIA;
      i2 = this.m_invIB;
      this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
      this.m_K.col1.y = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
      this.m_K.col2.x = this.m_K.col1.y;
      this.m_K.col2.y = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
      this.m_K.Solve(impulse, -C1, -C2);
    } else {
      m1 = this.m_invMassA;
      m2 = this.m_invMassB;
      i1 = this.m_invIA;
      i2 = this.m_invIB;
      var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
      var impulse1 = 0;

      if (k11 != 0.0) {
        impulse1 = -C1 / k11;
      } else {
        impulse1 = 0.0;
      }

      impulse.x = impulse1;
      impulse.y = 0.0;
    }

    var PX = impulse.x * this.m_perp.x + impulse.y * this.m_axis.x;
    var PY = impulse.x * this.m_perp.y + impulse.y * this.m_axis.y;
    var L1 = impulse.x * this.m_s1 + impulse.y * this.m_a1;
    var L2 = impulse.x * this.m_s2 + impulse.y * this.m_a2;
    c1.x -= this.m_invMassA * PX;
    c1.y -= this.m_invMassA * PY;
    a1 -= this.m_invIA * L1;
    c2.x += this.m_invMassB * PX;
    c2.y += this.m_invMassB * PY;
    a2 += this.m_invIB * L2;
    bA.m_sweep.a = a1;
    bB.m_sweep.a = a2;
    bA.SynchronizeTransform();
    bB.SynchronizeTransform();
    return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
  };

  Box2D.inherit(b2LineJointDef, Box2D.Dynamics.Joints.b2JointDef);
  b2LineJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;

  b2LineJointDef.b2LineJointDef = function () {
    Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
    this.localAnchorA = new b2Vec2();
    this.localAnchorB = new b2Vec2();
    this.localAxisA = new b2Vec2();
  };

  b2LineJointDef.prototype.b2LineJointDef = function () {
    this.__super.b2JointDef.call(this);

    this.type = b2Joint.e_lineJoint;
    this.localAxisA.Set(1.0, 0.0);
    this.enableLimit = false;
    this.lowerTranslation = 0.0;
    this.upperTranslation = 0.0;
    this.enableMotor = false;
    this.maxMotorForce = 0.0;
    this.motorSpeed = 0.0;
  };

  b2LineJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
    this.bodyA = bA;
    this.bodyB = bB;
    this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
    this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
    this.localAxisA = this.bodyA.GetLocalVector(axis);
  };

  Box2D.inherit(b2MouseJoint, Box2D.Dynamics.Joints.b2Joint);
  b2MouseJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;

  b2MouseJoint.b2MouseJoint = function () {
    Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
    this.K = new b2Mat22();
    this.K1 = new b2Mat22();
    this.K2 = new b2Mat22();
    this.m_localAnchor = new b2Vec2();
    this.m_target = new b2Vec2();
    this.m_impulse = new b2Vec2();
    this.m_mass = new b2Mat22();
    this.m_C = new b2Vec2();
  };

  b2MouseJoint.prototype.GetAnchorA = function () {
    return this.m_target;
  };

  b2MouseJoint.prototype.GetAnchorB = function () {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchor);
  };

  b2MouseJoint.prototype.GetReactionForce = function (inv_dt) {
    if (inv_dt === undefined) inv_dt = 0;
    return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
  };

  b2MouseJoint.prototype.GetReactionTorque = function (inv_dt) {
    if (inv_dt === undefined) inv_dt = 0;
    return 0.0;
  };

  b2MouseJoint.prototype.GetTarget = function () {
    return this.m_target;
  };

  b2MouseJoint.prototype.SetTarget = function (target) {
    if (this.m_bodyB.IsAwake() == false) {
      this.m_bodyB.SetAwake(true);
    }

    this.m_target = target;
  };

  b2MouseJoint.prototype.GetMaxForce = function () {
    return this.m_maxForce;
  };

  b2MouseJoint.prototype.SetMaxForce = function (maxForce) {
    if (maxForce === undefined) maxForce = 0;
    this.m_maxForce = maxForce;
  };

  b2MouseJoint.prototype.GetFrequency = function () {
    return this.m_frequencyHz;
  };

  b2MouseJoint.prototype.SetFrequency = function (hz) {
    if (hz === undefined) hz = 0;
    this.m_frequencyHz = hz;
  };

  b2MouseJoint.prototype.GetDampingRatio = function () {
    return this.m_dampingRatio;
  };

  b2MouseJoint.prototype.SetDampingRatio = function (ratio) {
    if (ratio === undefined) ratio = 0;
    this.m_dampingRatio = ratio;
  };

  b2MouseJoint.prototype.b2MouseJoint = function (def) {
    this.__super.b2Joint.call(this, def);

    this.m_target.SetV(def.target);
    var tX = this.m_target.x - this.m_bodyB.m_xf.position.x;
    var tY = this.m_target.y - this.m_bodyB.m_xf.position.y;
    var tMat = this.m_bodyB.m_xf.R;
    this.m_localAnchor.x = tX * tMat.col1.x + tY * tMat.col1.y;
    this.m_localAnchor.y = tX * tMat.col2.x + tY * tMat.col2.y;
    this.m_maxForce = def.maxForce;
    this.m_impulse.SetZero();
    this.m_frequencyHz = def.frequencyHz;
    this.m_dampingRatio = def.dampingRatio;
    this.m_beta = 0.0;
    this.m_gamma = 0.0;
  };

  b2MouseJoint.prototype.InitVelocityConstraints = function (step) {
    var b = this.m_bodyB;
    var mass = b.GetMass();
    var omega = 2.0 * Math.PI * this.m_frequencyHz;
    var d = 2.0 * mass * this.m_dampingRatio * omega;
    var k = mass * omega * omega;
    this.m_gamma = step.dt * (d + step.dt * k);
    this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0.0;
    this.m_beta = step.dt * k * this.m_gamma;
    var tMat;
    tMat = b.m_xf.R;
    var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
    var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
    var tX = tMat.col1.x * rX + tMat.col2.x * rY;
    rY = tMat.col1.y * rX + tMat.col2.y * rY;
    rX = tX;
    var invMass = b.m_invMass;
    var invI = b.m_invI;
    this.K1.col1.x = invMass;
    this.K1.col2.x = 0.0;
    this.K1.col1.y = 0.0;
    this.K1.col2.y = invMass;
    this.K2.col1.x = invI * rY * rY;
    this.K2.col2.x = -invI * rX * rY;
    this.K2.col1.y = -invI * rX * rY;
    this.K2.col2.y = invI * rX * rX;
    this.K.SetM(this.K1);
    this.K.AddM(this.K2);
    this.K.col1.x += this.m_gamma;
    this.K.col2.y += this.m_gamma;
    this.K.GetInverse(this.m_mass);
    this.m_C.x = b.m_sweep.c.x + rX - this.m_target.x;
    this.m_C.y = b.m_sweep.c.y + rY - this.m_target.y;
    b.m_angularVelocity *= 0.98;
    this.m_impulse.x *= step.dtRatio;
    this.m_impulse.y *= step.dtRatio;
    b.m_linearVelocity.x += invMass * this.m_impulse.x;
    b.m_linearVelocity.y += invMass * this.m_impulse.y;
    b.m_angularVelocity += invI * (rX * this.m_impulse.y - rY * this.m_impulse.x);
  };

  b2MouseJoint.prototype.SolveVelocityConstraints = function (step) {
    var b = this.m_bodyB;
    var tMat;
    var tX = 0;
    var tY = 0;
    tMat = b.m_xf.R;
    var rX = this.m_localAnchor.x - b.m_sweep.localCenter.x;
    var rY = this.m_localAnchor.y - b.m_sweep.localCenter.y;
    tX = tMat.col1.x * rX + tMat.col2.x * rY;
    rY = tMat.col1.y * rX + tMat.col2.y * rY;
    rX = tX;
    var CdotX = b.m_linearVelocity.x + -b.m_angularVelocity * rY;
    var CdotY = b.m_linearVelocity.y + b.m_angularVelocity * rX;
    tMat = this.m_mass;
    tX = CdotX + this.m_beta * this.m_C.x + this.m_gamma * this.m_impulse.x;
    tY = CdotY + this.m_beta * this.m_C.y + this.m_gamma * this.m_impulse.y;
    var impulseX = -(tMat.col1.x * tX + tMat.col2.x * tY);
    var impulseY = -(tMat.col1.y * tX + tMat.col2.y * tY);
    var oldImpulseX = this.m_impulse.x;
    var oldImpulseY = this.m_impulse.y;
    this.m_impulse.x += impulseX;
    this.m_impulse.y += impulseY;
    var maxImpulse = step.dt * this.m_maxForce;

    if (this.m_impulse.LengthSquared() > maxImpulse * maxImpulse) {
      this.m_impulse.Multiply(maxImpulse / this.m_impulse.Length());
    }

    impulseX = this.m_impulse.x - oldImpulseX;
    impulseY = this.m_impulse.y - oldImpulseY;
    b.m_linearVelocity.x += b.m_invMass * impulseX;
    b.m_linearVelocity.y += b.m_invMass * impulseY;
    b.m_angularVelocity += b.m_invI * (rX * impulseY - rY * impulseX);
  };

  b2MouseJoint.prototype.SolvePositionConstraints = function (baumgarte) {
    if (baumgarte === undefined) baumgarte = 0;
    return true;
  };

  Box2D.inherit(b2MouseJointDef, Box2D.Dynamics.Joints.b2JointDef);
  b2MouseJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;

  b2MouseJointDef.b2MouseJointDef = function () {
    Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
    this.target = new b2Vec2();
  };

  b2MouseJointDef.prototype.b2MouseJointDef = function () {
    this.__super.b2JointDef.call(this);

    this.type = b2Joint.e_mouseJoint;
    this.maxForce = 0.0;
    this.frequencyHz = 5.0;
    this.dampingRatio = 0.7;
  };

  Box2D.inherit(b2PrismaticJoint, Box2D.Dynamics.Joints.b2Joint);
  b2PrismaticJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;

  b2PrismaticJoint.b2PrismaticJoint = function () {
    Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
    this.m_localAnchor1 = new b2Vec2();
    this.m_localAnchor2 = new b2Vec2();
    this.m_localXAxis1 = new b2Vec2();
    this.m_localYAxis1 = new b2Vec2();
    this.m_axis = new b2Vec2();
    this.m_perp = new b2Vec2();
    this.m_K = new b2Mat33();
    this.m_impulse = new b2Vec3();
  };

  b2PrismaticJoint.prototype.GetAnchorA = function () {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
  };

  b2PrismaticJoint.prototype.GetAnchorB = function () {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
  };

  b2PrismaticJoint.prototype.GetReactionForce = function (inv_dt) {
    if (inv_dt === undefined) inv_dt = 0;
    return new b2Vec2(inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y));
  };

  b2PrismaticJoint.prototype.GetReactionTorque = function (inv_dt) {
    if (inv_dt === undefined) inv_dt = 0;
    return inv_dt * this.m_impulse.y;
  };

  b2PrismaticJoint.prototype.GetJointTranslation = function () {
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    var tMat;
    var p1 = bA.GetWorldPoint(this.m_localAnchor1);
    var p2 = bB.GetWorldPoint(this.m_localAnchor2);
    var dX = p2.x - p1.x;
    var dY = p2.y - p1.y;
    var axis = bA.GetWorldVector(this.m_localXAxis1);
    var translation = axis.x * dX + axis.y * dY;
    return translation;
  };

  b2PrismaticJoint.prototype.GetJointSpeed = function () {
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    var tMat;
    tMat = bA.m_xf.R;
    var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    var p1X = bA.m_sweep.c.x + r1X;
    var p1Y = bA.m_sweep.c.y + r1Y;
    var p2X = bB.m_sweep.c.x + r2X;
    var p2Y = bB.m_sweep.c.y + r2Y;
    var dX = p2X - p1X;
    var dY = p2Y - p1Y;
    var axis = bA.GetWorldVector(this.m_localXAxis1);
    var v1 = bA.m_linearVelocity;
    var v2 = bB.m_linearVelocity;
    var w1 = bA.m_angularVelocity;
    var w2 = bB.m_angularVelocity;
    var speed = dX * (-w1 * axis.y) + dY * (w1 * axis.x) + (axis.x * (v2.x + -w2 * r2Y - v1.x - -w1 * r1Y) + axis.y * (v2.y + w2 * r2X - v1.y - w1 * r1X));
    return speed;
  };

  b2PrismaticJoint.prototype.IsLimitEnabled = function () {
    return this.m_enableLimit;
  };

  b2PrismaticJoint.prototype.EnableLimit = function (flag) {
    this.m_bodyA.SetAwake(true);
    this.m_bodyB.SetAwake(true);
    this.m_enableLimit = flag;
  };

  b2PrismaticJoint.prototype.GetLowerLimit = function () {
    return this.m_lowerTranslation;
  };

  b2PrismaticJoint.prototype.GetUpperLimit = function () {
    return this.m_upperTranslation;
  };

  b2PrismaticJoint.prototype.SetLimits = function (lower, upper) {
    if (lower === undefined) lower = 0;
    if (upper === undefined) upper = 0;
    this.m_bodyA.SetAwake(true);
    this.m_bodyB.SetAwake(true);
    this.m_lowerTranslation = lower;
    this.m_upperTranslation = upper;
  };

  b2PrismaticJoint.prototype.IsMotorEnabled = function () {
    return this.m_enableMotor;
  };

  b2PrismaticJoint.prototype.EnableMotor = function (flag) {
    this.m_bodyA.SetAwake(true);
    this.m_bodyB.SetAwake(true);
    this.m_enableMotor = flag;
  };

  b2PrismaticJoint.prototype.SetMotorSpeed = function (speed) {
    if (speed === undefined) speed = 0;
    this.m_bodyA.SetAwake(true);
    this.m_bodyB.SetAwake(true);
    this.m_motorSpeed = speed;
  };

  b2PrismaticJoint.prototype.GetMotorSpeed = function () {
    return this.m_motorSpeed;
  };

  b2PrismaticJoint.prototype.SetMaxMotorForce = function (force) {
    if (force === undefined) force = 0;
    this.m_bodyA.SetAwake(true);
    this.m_bodyB.SetAwake(true);
    this.m_maxMotorForce = force;
  };

  b2PrismaticJoint.prototype.GetMotorForce = function () {
    return this.m_motorImpulse;
  };

  b2PrismaticJoint.prototype.b2PrismaticJoint = function (def) {
    this.__super.b2Joint.call(this, def);

    var tMat;
    var tX = 0;
    var tY = 0;
    this.m_localAnchor1.SetV(def.localAnchorA);
    this.m_localAnchor2.SetV(def.localAnchorB);
    this.m_localXAxis1.SetV(def.localAxisA);
    this.m_localYAxis1.x = -this.m_localXAxis1.y;
    this.m_localYAxis1.y = this.m_localXAxis1.x;
    this.m_refAngle = def.referenceAngle;
    this.m_impulse.SetZero();
    this.m_motorMass = 0.0;
    this.m_motorImpulse = 0.0;
    this.m_lowerTranslation = def.lowerTranslation;
    this.m_upperTranslation = def.upperTranslation;
    this.m_maxMotorForce = def.maxMotorForce;
    this.m_motorSpeed = def.motorSpeed;
    this.m_enableLimit = def.enableLimit;
    this.m_enableMotor = def.enableMotor;
    this.m_limitState = b2Joint.e_inactiveLimit;
    this.m_axis.SetZero();
    this.m_perp.SetZero();
  };

  b2PrismaticJoint.prototype.InitVelocityConstraints = function (step) {
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    var tMat;
    var tX = 0;
    this.m_localCenterA.SetV(bA.GetLocalCenter());
    this.m_localCenterB.SetV(bB.GetLocalCenter());
    var xf1 = bA.GetTransform();
    var xf2 = bB.GetTransform();
    tMat = bA.m_xf.R;
    var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
    var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
    var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    var dX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
    var dY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
    this.m_invMassA = bA.m_invMass;
    this.m_invMassB = bB.m_invMass;
    this.m_invIA = bA.m_invI;
    this.m_invIB = bB.m_invI;
    {
      this.m_axis.SetV(b2Math.MulMV(xf1.R, this.m_localXAxis1));
      this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
      this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
      this.m_motorMass = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_a1 * this.m_a1 + this.m_invIB * this.m_a2 * this.m_a2;
      if (this.m_motorMass > Number.MIN_VALUE) this.m_motorMass = 1.0 / this.m_motorMass;
    }
    {
      this.m_perp.SetV(b2Math.MulMV(xf1.R, this.m_localYAxis1));
      this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
      this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
      var m1 = this.m_invMassA;
      var m2 = this.m_invMassB;
      var i1 = this.m_invIA;
      var i2 = this.m_invIB;
      this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
      this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
      this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
      this.m_K.col2.x = this.m_K.col1.y;
      this.m_K.col2.y = i1 + i2;
      this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
      this.m_K.col3.x = this.m_K.col1.z;
      this.m_K.col3.y = this.m_K.col2.z;
      this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
    }

    if (this.m_enableLimit) {
      var jointTransition = this.m_axis.x * dX + this.m_axis.y * dY;

      if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
        this.m_limitState = b2Joint.e_equalLimits;
      } else if (jointTransition <= this.m_lowerTranslation) {
        if (this.m_limitState != b2Joint.e_atLowerLimit) {
          this.m_limitState = b2Joint.e_atLowerLimit;
          this.m_impulse.z = 0.0;
        }
      } else if (jointTransition >= this.m_upperTranslation) {
        if (this.m_limitState != b2Joint.e_atUpperLimit) {
          this.m_limitState = b2Joint.e_atUpperLimit;
          this.m_impulse.z = 0.0;
        }
      } else {
        this.m_limitState = b2Joint.e_inactiveLimit;
        this.m_impulse.z = 0.0;
      }
    } else {
      this.m_limitState = b2Joint.e_inactiveLimit;
    }

    if (this.m_enableMotor == false) {
      this.m_motorImpulse = 0.0;
    }

    if (step.warmStarting) {
      this.m_impulse.x *= step.dtRatio;
      this.m_impulse.y *= step.dtRatio;
      this.m_motorImpulse *= step.dtRatio;
      var PX = this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x;
      var PY = this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y;
      var L1 = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
      var L2 = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
      bA.m_linearVelocity.x -= this.m_invMassA * PX;
      bA.m_linearVelocity.y -= this.m_invMassA * PY;
      bA.m_angularVelocity -= this.m_invIA * L1;
      bB.m_linearVelocity.x += this.m_invMassB * PX;
      bB.m_linearVelocity.y += this.m_invMassB * PY;
      bB.m_angularVelocity += this.m_invIB * L2;
    } else {
      this.m_impulse.SetZero();
      this.m_motorImpulse = 0.0;
    }
  };

  b2PrismaticJoint.prototype.SolveVelocityConstraints = function (step) {
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    var v1 = bA.m_linearVelocity;
    var w1 = bA.m_angularVelocity;
    var v2 = bB.m_linearVelocity;
    var w2 = bB.m_angularVelocity;
    var PX = 0;
    var PY = 0;
    var L1 = 0;
    var L2 = 0;

    if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
      var Cdot = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
      var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
      var oldImpulse = this.m_motorImpulse;
      var maxImpulse = step.dt * this.m_maxMotorForce;
      this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
      impulse = this.m_motorImpulse - oldImpulse;
      PX = impulse * this.m_axis.x;
      PY = impulse * this.m_axis.y;
      L1 = impulse * this.m_a1;
      L2 = impulse * this.m_a2;
      v1.x -= this.m_invMassA * PX;
      v1.y -= this.m_invMassA * PY;
      w1 -= this.m_invIA * L1;
      v2.x += this.m_invMassB * PX;
      v2.y += this.m_invMassB * PY;
      w2 += this.m_invIB * L2;
    }

    var Cdot1X = this.m_perp.x * (v2.x - v1.x) + this.m_perp.y * (v2.y - v1.y) + this.m_s2 * w2 - this.m_s1 * w1;
    var Cdot1Y = w2 - w1;

    if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
      var Cdot2 = this.m_axis.x * (v2.x - v1.x) + this.m_axis.y * (v2.y - v1.y) + this.m_a2 * w2 - this.m_a1 * w1;
      var f1 = this.m_impulse.Copy();
      var df = this.m_K.Solve33(new b2Vec3(), -Cdot1X, -Cdot1Y, -Cdot2);
      this.m_impulse.Add(df);

      if (this.m_limitState == b2Joint.e_atLowerLimit) {
        this.m_impulse.z = b2Math.Max(this.m_impulse.z, 0.0);
      } else if (this.m_limitState == b2Joint.e_atUpperLimit) {
        this.m_impulse.z = b2Math.Min(this.m_impulse.z, 0.0);
      }

      var bX = -Cdot1X - (this.m_impulse.z - f1.z) * this.m_K.col3.x;
      var bY = -Cdot1Y - (this.m_impulse.z - f1.z) * this.m_K.col3.y;
      var f2r = this.m_K.Solve22(new b2Vec2(), bX, bY);
      f2r.x += f1.x;
      f2r.y += f1.y;
      this.m_impulse.x = f2r.x;
      this.m_impulse.y = f2r.y;
      df.x = this.m_impulse.x - f1.x;
      df.y = this.m_impulse.y - f1.y;
      df.z = this.m_impulse.z - f1.z;
      PX = df.x * this.m_perp.x + df.z * this.m_axis.x;
      PY = df.x * this.m_perp.y + df.z * this.m_axis.y;
      L1 = df.x * this.m_s1 + df.y + df.z * this.m_a1;
      L2 = df.x * this.m_s2 + df.y + df.z * this.m_a2;
      v1.x -= this.m_invMassA * PX;
      v1.y -= this.m_invMassA * PY;
      w1 -= this.m_invIA * L1;
      v2.x += this.m_invMassB * PX;
      v2.y += this.m_invMassB * PY;
      w2 += this.m_invIB * L2;
    } else {
      var df2 = this.m_K.Solve22(new b2Vec2(), -Cdot1X, -Cdot1Y);
      this.m_impulse.x += df2.x;
      this.m_impulse.y += df2.y;
      PX = df2.x * this.m_perp.x;
      PY = df2.x * this.m_perp.y;
      L1 = df2.x * this.m_s1 + df2.y;
      L2 = df2.x * this.m_s2 + df2.y;
      v1.x -= this.m_invMassA * PX;
      v1.y -= this.m_invMassA * PY;
      w1 -= this.m_invIA * L1;
      v2.x += this.m_invMassB * PX;
      v2.y += this.m_invMassB * PY;
      w2 += this.m_invIB * L2;
    }

    bA.m_linearVelocity.SetV(v1);
    bA.m_angularVelocity = w1;
    bB.m_linearVelocity.SetV(v2);
    bB.m_angularVelocity = w2;
  };

  b2PrismaticJoint.prototype.SolvePositionConstraints = function (baumgarte) {
    if (baumgarte === undefined) baumgarte = 0;
    var limitC = 0;
    var oldLimitImpulse = 0;
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    var c1 = bA.m_sweep.c;
    var a1 = bA.m_sweep.a;
    var c2 = bB.m_sweep.c;
    var a2 = bB.m_sweep.a;
    var tMat;
    var tX = 0;
    var m1 = 0;
    var m2 = 0;
    var i1 = 0;
    var i2 = 0;
    var linearError = 0.0;
    var angularError = 0.0;
    var active = false;
    var C2 = 0.0;
    var R1 = b2Mat22.FromAngle(a1);
    var R2 = b2Mat22.FromAngle(a2);
    tMat = R1;
    var r1X = this.m_localAnchor1.x - this.m_localCenterA.x;
    var r1Y = this.m_localAnchor1.y - this.m_localCenterA.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = R2;
    var r2X = this.m_localAnchor2.x - this.m_localCenterB.x;
    var r2Y = this.m_localAnchor2.y - this.m_localCenterB.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    var dX = c2.x + r2X - c1.x - r1X;
    var dY = c2.y + r2Y - c1.y - r1Y;

    if (this.m_enableLimit) {
      this.m_axis = b2Math.MulMV(R1, this.m_localXAxis1);
      this.m_a1 = (dX + r1X) * this.m_axis.y - (dY + r1Y) * this.m_axis.x;
      this.m_a2 = r2X * this.m_axis.y - r2Y * this.m_axis.x;
      var translation = this.m_axis.x * dX + this.m_axis.y * dY;

      if (b2Math.Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * b2Settings.b2_linearSlop) {
        C2 = b2Math.Clamp(translation, -b2Settings.b2_maxLinearCorrection, b2Settings.b2_maxLinearCorrection);
        linearError = b2Math.Abs(translation);
        active = true;
      } else if (translation <= this.m_lowerTranslation) {
        C2 = b2Math.Clamp(translation - this.m_lowerTranslation + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0.0);
        linearError = this.m_lowerTranslation - translation;
        active = true;
      } else if (translation >= this.m_upperTranslation) {
        C2 = b2Math.Clamp(translation - this.m_upperTranslation + b2Settings.b2_linearSlop, 0.0, b2Settings.b2_maxLinearCorrection);
        linearError = translation - this.m_upperTranslation;
        active = true;
      }
    }

    this.m_perp = b2Math.MulMV(R1, this.m_localYAxis1);
    this.m_s1 = (dX + r1X) * this.m_perp.y - (dY + r1Y) * this.m_perp.x;
    this.m_s2 = r2X * this.m_perp.y - r2Y * this.m_perp.x;
    var impulse = new b2Vec3();
    var C1X = this.m_perp.x * dX + this.m_perp.y * dY;
    var C1Y = a2 - a1 - this.m_refAngle;
    linearError = b2Math.Max(linearError, b2Math.Abs(C1X));
    angularError = b2Math.Abs(C1Y);

    if (active) {
      m1 = this.m_invMassA;
      m2 = this.m_invMassB;
      i1 = this.m_invIA;
      i2 = this.m_invIB;
      this.m_K.col1.x = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
      this.m_K.col1.y = i1 * this.m_s1 + i2 * this.m_s2;
      this.m_K.col1.z = i1 * this.m_s1 * this.m_a1 + i2 * this.m_s2 * this.m_a2;
      this.m_K.col2.x = this.m_K.col1.y;
      this.m_K.col2.y = i1 + i2;
      this.m_K.col2.z = i1 * this.m_a1 + i2 * this.m_a2;
      this.m_K.col3.x = this.m_K.col1.z;
      this.m_K.col3.y = this.m_K.col2.z;
      this.m_K.col3.z = m1 + m2 + i1 * this.m_a1 * this.m_a1 + i2 * this.m_a2 * this.m_a2;
      this.m_K.Solve33(impulse, -C1X, -C1Y, -C2);
    } else {
      m1 = this.m_invMassA;
      m2 = this.m_invMassB;
      i1 = this.m_invIA;
      i2 = this.m_invIB;
      var k11 = m1 + m2 + i1 * this.m_s1 * this.m_s1 + i2 * this.m_s2 * this.m_s2;
      var k12 = i1 * this.m_s1 + i2 * this.m_s2;
      var k22 = i1 + i2;
      this.m_K.col1.Set(k11, k12, 0.0);
      this.m_K.col2.Set(k12, k22, 0.0);
      var impulse1 = this.m_K.Solve22(new b2Vec2(), -C1X, -C1Y);
      impulse.x = impulse1.x;
      impulse.y = impulse1.y;
      impulse.z = 0.0;
    }

    var PX = impulse.x * this.m_perp.x + impulse.z * this.m_axis.x;
    var PY = impulse.x * this.m_perp.y + impulse.z * this.m_axis.y;
    var L1 = impulse.x * this.m_s1 + impulse.y + impulse.z * this.m_a1;
    var L2 = impulse.x * this.m_s2 + impulse.y + impulse.z * this.m_a2;
    c1.x -= this.m_invMassA * PX;
    c1.y -= this.m_invMassA * PY;
    a1 -= this.m_invIA * L1;
    c2.x += this.m_invMassB * PX;
    c2.y += this.m_invMassB * PY;
    a2 += this.m_invIB * L2;
    bA.m_sweep.a = a1;
    bB.m_sweep.a = a2;
    bA.SynchronizeTransform();
    bB.SynchronizeTransform();
    return linearError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
  };

  Box2D.inherit(b2PrismaticJointDef, Box2D.Dynamics.Joints.b2JointDef);
  b2PrismaticJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;

  b2PrismaticJointDef.b2PrismaticJointDef = function () {
    Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
    this.localAnchorA = new b2Vec2();
    this.localAnchorB = new b2Vec2();
    this.localAxisA = new b2Vec2();
  };

  b2PrismaticJointDef.prototype.b2PrismaticJointDef = function () {
    this.__super.b2JointDef.call(this);

    this.type = b2Joint.e_prismaticJoint;
    this.localAxisA.Set(1.0, 0.0);
    this.referenceAngle = 0.0;
    this.enableLimit = false;
    this.lowerTranslation = 0.0;
    this.upperTranslation = 0.0;
    this.enableMotor = false;
    this.maxMotorForce = 0.0;
    this.motorSpeed = 0.0;
  };

  b2PrismaticJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {
    this.bodyA = bA;
    this.bodyB = bB;
    this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
    this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
    this.localAxisA = this.bodyA.GetLocalVector(axis);
    this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
  };

  Box2D.inherit(b2PulleyJoint, Box2D.Dynamics.Joints.b2Joint);
  b2PulleyJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;

  b2PulleyJoint.b2PulleyJoint = function () {
    Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
    this.m_groundAnchor1 = new b2Vec2();
    this.m_groundAnchor2 = new b2Vec2();
    this.m_localAnchor1 = new b2Vec2();
    this.m_localAnchor2 = new b2Vec2();
    this.m_u1 = new b2Vec2();
    this.m_u2 = new b2Vec2();
  };

  b2PulleyJoint.prototype.GetAnchorA = function () {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
  };

  b2PulleyJoint.prototype.GetAnchorB = function () {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
  };

  b2PulleyJoint.prototype.GetReactionForce = function (inv_dt) {
    if (inv_dt === undefined) inv_dt = 0;
    return new b2Vec2(inv_dt * this.m_impulse * this.m_u2.x, inv_dt * this.m_impulse * this.m_u2.y);
  };

  b2PulleyJoint.prototype.GetReactionTorque = function (inv_dt) {
    if (inv_dt === undefined) inv_dt = 0;
    return 0.0;
  };

  b2PulleyJoint.prototype.GetGroundAnchorA = function () {
    var a = this.m_ground.m_xf.position.Copy();
    a.Add(this.m_groundAnchor1);
    return a;
  };

  b2PulleyJoint.prototype.GetGroundAnchorB = function () {
    var a = this.m_ground.m_xf.position.Copy();
    a.Add(this.m_groundAnchor2);
    return a;
  };

  b2PulleyJoint.prototype.GetLength1 = function () {
    var p = this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
    var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
    var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
    var dX = p.x - sX;
    var dY = p.y - sY;
    return Math.sqrt(dX * dX + dY * dY);
  };

  b2PulleyJoint.prototype.GetLength2 = function () {
    var p = this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
    var sX = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
    var sY = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
    var dX = p.x - sX;
    var dY = p.y - sY;
    return Math.sqrt(dX * dX + dY * dY);
  };

  b2PulleyJoint.prototype.GetRatio = function () {
    return this.m_ratio;
  };

  b2PulleyJoint.prototype.b2PulleyJoint = function (def) {
    this.__super.b2Joint.call(this, def);

    var tMat;
    var tX = 0;
    var tY = 0;
    this.m_ground = this.m_bodyA.m_world.m_groundBody;
    this.m_groundAnchor1.x = def.groundAnchorA.x - this.m_ground.m_xf.position.x;
    this.m_groundAnchor1.y = def.groundAnchorA.y - this.m_ground.m_xf.position.y;
    this.m_groundAnchor2.x = def.groundAnchorB.x - this.m_ground.m_xf.position.x;
    this.m_groundAnchor2.y = def.groundAnchorB.y - this.m_ground.m_xf.position.y;
    this.m_localAnchor1.SetV(def.localAnchorA);
    this.m_localAnchor2.SetV(def.localAnchorB);
    this.m_ratio = def.ratio;
    this.m_constant = def.lengthA + this.m_ratio * def.lengthB;
    this.m_maxLength1 = b2Math.Min(def.maxLengthA, this.m_constant - this.m_ratio * b2PulleyJoint.b2_minPulleyLength);
    this.m_maxLength2 = b2Math.Min(def.maxLengthB, (this.m_constant - b2PulleyJoint.b2_minPulleyLength) / this.m_ratio);
    this.m_impulse = 0.0;
    this.m_limitImpulse1 = 0.0;
    this.m_limitImpulse2 = 0.0;
  };

  b2PulleyJoint.prototype.InitVelocityConstraints = function (step) {
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    var tMat;
    tMat = bA.m_xf.R;
    var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    var p1X = bA.m_sweep.c.x + r1X;
    var p1Y = bA.m_sweep.c.y + r1Y;
    var p2X = bB.m_sweep.c.x + r2X;
    var p2Y = bB.m_sweep.c.y + r2Y;
    var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
    var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
    var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
    var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
    this.m_u1.Set(p1X - s1X, p1Y - s1Y);
    this.m_u2.Set(p2X - s2X, p2Y - s2Y);
    var length1 = this.m_u1.Length();
    var length2 = this.m_u2.Length();

    if (length1 > b2Settings.b2_linearSlop) {
      this.m_u1.Multiply(1.0 / length1);
    } else {
      this.m_u1.SetZero();
    }

    if (length2 > b2Settings.b2_linearSlop) {
      this.m_u2.Multiply(1.0 / length2);
    } else {
      this.m_u2.SetZero();
    }

    var C = this.m_constant - length1 - this.m_ratio * length2;

    if (C > 0.0) {
      this.m_state = b2Joint.e_inactiveLimit;
      this.m_impulse = 0.0;
    } else {
      this.m_state = b2Joint.e_atUpperLimit;
    }

    if (length1 < this.m_maxLength1) {
      this.m_limitState1 = b2Joint.e_inactiveLimit;
      this.m_limitImpulse1 = 0.0;
    } else {
      this.m_limitState1 = b2Joint.e_atUpperLimit;
    }

    if (length2 < this.m_maxLength2) {
      this.m_limitState2 = b2Joint.e_inactiveLimit;
      this.m_limitImpulse2 = 0.0;
    } else {
      this.m_limitState2 = b2Joint.e_atUpperLimit;
    }

    var cr1u1 = r1X * this.m_u1.y - r1Y * this.m_u1.x;
    var cr2u2 = r2X * this.m_u2.y - r2Y * this.m_u2.x;
    this.m_limitMass1 = bA.m_invMass + bA.m_invI * cr1u1 * cr1u1;
    this.m_limitMass2 = bB.m_invMass + bB.m_invI * cr2u2 * cr2u2;
    this.m_pulleyMass = this.m_limitMass1 + this.m_ratio * this.m_ratio * this.m_limitMass2;
    this.m_limitMass1 = 1.0 / this.m_limitMass1;
    this.m_limitMass2 = 1.0 / this.m_limitMass2;
    this.m_pulleyMass = 1.0 / this.m_pulleyMass;

    if (step.warmStarting) {
      this.m_impulse *= step.dtRatio;
      this.m_limitImpulse1 *= step.dtRatio;
      this.m_limitImpulse2 *= step.dtRatio;
      var P1X = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.x;
      var P1Y = (-this.m_impulse - this.m_limitImpulse1) * this.m_u1.y;
      var P2X = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.x;
      var P2Y = (-this.m_ratio * this.m_impulse - this.m_limitImpulse2) * this.m_u2.y;
      bA.m_linearVelocity.x += bA.m_invMass * P1X;
      bA.m_linearVelocity.y += bA.m_invMass * P1Y;
      bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
      bB.m_linearVelocity.x += bB.m_invMass * P2X;
      bB.m_linearVelocity.y += bB.m_invMass * P2Y;
      bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
    } else {
      this.m_impulse = 0.0;
      this.m_limitImpulse1 = 0.0;
      this.m_limitImpulse2 = 0.0;
    }
  };

  b2PulleyJoint.prototype.SolveVelocityConstraints = function (step) {
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    var tMat;
    tMat = bA.m_xf.R;
    var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    var tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    var v1X = 0;
    var v1Y = 0;
    var v2X = 0;
    var v2Y = 0;
    var P1X = 0;
    var P1Y = 0;
    var P2X = 0;
    var P2Y = 0;
    var Cdot = 0;
    var impulse = 0;
    var oldImpulse = 0;

    if (this.m_state == b2Joint.e_atUpperLimit) {
      v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
      v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
      v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
      v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
      Cdot = -(this.m_u1.x * v1X + this.m_u1.y * v1Y) - this.m_ratio * (this.m_u2.x * v2X + this.m_u2.y * v2Y);
      impulse = this.m_pulleyMass * -Cdot;
      oldImpulse = this.m_impulse;
      this.m_impulse = b2Math.Max(0.0, this.m_impulse + impulse);
      impulse = this.m_impulse - oldImpulse;
      P1X = -impulse * this.m_u1.x;
      P1Y = -impulse * this.m_u1.y;
      P2X = -this.m_ratio * impulse * this.m_u2.x;
      P2Y = -this.m_ratio * impulse * this.m_u2.y;
      bA.m_linearVelocity.x += bA.m_invMass * P1X;
      bA.m_linearVelocity.y += bA.m_invMass * P1Y;
      bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
      bB.m_linearVelocity.x += bB.m_invMass * P2X;
      bB.m_linearVelocity.y += bB.m_invMass * P2Y;
      bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
    }

    if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
      v1X = bA.m_linearVelocity.x + -bA.m_angularVelocity * r1Y;
      v1Y = bA.m_linearVelocity.y + bA.m_angularVelocity * r1X;
      Cdot = -(this.m_u1.x * v1X + this.m_u1.y * v1Y);
      impulse = -this.m_limitMass1 * Cdot;
      oldImpulse = this.m_limitImpulse1;
      this.m_limitImpulse1 = b2Math.Max(0.0, this.m_limitImpulse1 + impulse);
      impulse = this.m_limitImpulse1 - oldImpulse;
      P1X = -impulse * this.m_u1.x;
      P1Y = -impulse * this.m_u1.y;
      bA.m_linearVelocity.x += bA.m_invMass * P1X;
      bA.m_linearVelocity.y += bA.m_invMass * P1Y;
      bA.m_angularVelocity += bA.m_invI * (r1X * P1Y - r1Y * P1X);
    }

    if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
      v2X = bB.m_linearVelocity.x + -bB.m_angularVelocity * r2Y;
      v2Y = bB.m_linearVelocity.y + bB.m_angularVelocity * r2X;
      Cdot = -(this.m_u2.x * v2X + this.m_u2.y * v2Y);
      impulse = -this.m_limitMass2 * Cdot;
      oldImpulse = this.m_limitImpulse2;
      this.m_limitImpulse2 = b2Math.Max(0.0, this.m_limitImpulse2 + impulse);
      impulse = this.m_limitImpulse2 - oldImpulse;
      P2X = -impulse * this.m_u2.x;
      P2Y = -impulse * this.m_u2.y;
      bB.m_linearVelocity.x += bB.m_invMass * P2X;
      bB.m_linearVelocity.y += bB.m_invMass * P2Y;
      bB.m_angularVelocity += bB.m_invI * (r2X * P2Y - r2Y * P2X);
    }
  };

  b2PulleyJoint.prototype.SolvePositionConstraints = function (baumgarte) {
    if (baumgarte === undefined) baumgarte = 0;
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    var tMat;
    var s1X = this.m_ground.m_xf.position.x + this.m_groundAnchor1.x;
    var s1Y = this.m_ground.m_xf.position.y + this.m_groundAnchor1.y;
    var s2X = this.m_ground.m_xf.position.x + this.m_groundAnchor2.x;
    var s2Y = this.m_ground.m_xf.position.y + this.m_groundAnchor2.y;
    var r1X = 0;
    var r1Y = 0;
    var r2X = 0;
    var r2Y = 0;
    var p1X = 0;
    var p1Y = 0;
    var p2X = 0;
    var p2Y = 0;
    var length1 = 0;
    var length2 = 0;
    var C = 0;
    var impulse = 0;
    var oldImpulse = 0;
    var oldLimitPositionImpulse = 0;
    var tX = 0;
    var linearError = 0.0;

    if (this.m_state == b2Joint.e_atUpperLimit) {
      tMat = bA.m_xf.R;
      r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
      r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
      r1X = tX;
      tMat = bB.m_xf.R;
      r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
      r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
      r2X = tX;
      p1X = bA.m_sweep.c.x + r1X;
      p1Y = bA.m_sweep.c.y + r1Y;
      p2X = bB.m_sweep.c.x + r2X;
      p2Y = bB.m_sweep.c.y + r2Y;
      this.m_u1.Set(p1X - s1X, p1Y - s1Y);
      this.m_u2.Set(p2X - s2X, p2Y - s2Y);
      length1 = this.m_u1.Length();
      length2 = this.m_u2.Length();

      if (length1 > b2Settings.b2_linearSlop) {
        this.m_u1.Multiply(1.0 / length1);
      } else {
        this.m_u1.SetZero();
      }

      if (length2 > b2Settings.b2_linearSlop) {
        this.m_u2.Multiply(1.0 / length2);
      } else {
        this.m_u2.SetZero();
      }

      C = this.m_constant - length1 - this.m_ratio * length2;
      linearError = b2Math.Max(linearError, -C);
      C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0.0);
      impulse = -this.m_pulleyMass * C;
      p1X = -impulse * this.m_u1.x;
      p1Y = -impulse * this.m_u1.y;
      p2X = -this.m_ratio * impulse * this.m_u2.x;
      p2Y = -this.m_ratio * impulse * this.m_u2.y;
      bA.m_sweep.c.x += bA.m_invMass * p1X;
      bA.m_sweep.c.y += bA.m_invMass * p1Y;
      bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
      bB.m_sweep.c.x += bB.m_invMass * p2X;
      bB.m_sweep.c.y += bB.m_invMass * p2Y;
      bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
    }

    if (this.m_limitState1 == b2Joint.e_atUpperLimit) {
      tMat = bA.m_xf.R;
      r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
      r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
      r1X = tX;
      p1X = bA.m_sweep.c.x + r1X;
      p1Y = bA.m_sweep.c.y + r1Y;
      this.m_u1.Set(p1X - s1X, p1Y - s1Y);
      length1 = this.m_u1.Length();

      if (length1 > b2Settings.b2_linearSlop) {
        this.m_u1.x *= 1.0 / length1;
        this.m_u1.y *= 1.0 / length1;
      } else {
        this.m_u1.SetZero();
      }

      C = this.m_maxLength1 - length1;
      linearError = b2Math.Max(linearError, -C);
      C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0.0);
      impulse = -this.m_limitMass1 * C;
      p1X = -impulse * this.m_u1.x;
      p1Y = -impulse * this.m_u1.y;
      bA.m_sweep.c.x += bA.m_invMass * p1X;
      bA.m_sweep.c.y += bA.m_invMass * p1Y;
      bA.m_sweep.a += bA.m_invI * (r1X * p1Y - r1Y * p1X);
      bA.SynchronizeTransform();
    }

    if (this.m_limitState2 == b2Joint.e_atUpperLimit) {
      tMat = bB.m_xf.R;
      r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
      r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
      r2X = tX;
      p2X = bB.m_sweep.c.x + r2X;
      p2Y = bB.m_sweep.c.y + r2Y;
      this.m_u2.Set(p2X - s2X, p2Y - s2Y);
      length2 = this.m_u2.Length();

      if (length2 > b2Settings.b2_linearSlop) {
        this.m_u2.x *= 1.0 / length2;
        this.m_u2.y *= 1.0 / length2;
      } else {
        this.m_u2.SetZero();
      }

      C = this.m_maxLength2 - length2;
      linearError = b2Math.Max(linearError, -C);
      C = b2Math.Clamp(C + b2Settings.b2_linearSlop, -b2Settings.b2_maxLinearCorrection, 0.0);
      impulse = -this.m_limitMass2 * C;
      p2X = -impulse * this.m_u2.x;
      p2Y = -impulse * this.m_u2.y;
      bB.m_sweep.c.x += bB.m_invMass * p2X;
      bB.m_sweep.c.y += bB.m_invMass * p2Y;
      bB.m_sweep.a += bB.m_invI * (r2X * p2Y - r2Y * p2X);
      bB.SynchronizeTransform();
    }

    return linearError < b2Settings.b2_linearSlop;
  };

  Box2D.postDefs.push(function () {
    Box2D.Dynamics.Joints.b2PulleyJoint.b2_minPulleyLength = 2.0;
  });
  Box2D.inherit(b2PulleyJointDef, Box2D.Dynamics.Joints.b2JointDef);
  b2PulleyJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;

  b2PulleyJointDef.b2PulleyJointDef = function () {
    Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
    this.groundAnchorA = new b2Vec2();
    this.groundAnchorB = new b2Vec2();
    this.localAnchorA = new b2Vec2();
    this.localAnchorB = new b2Vec2();
  };

  b2PulleyJointDef.prototype.b2PulleyJointDef = function () {
    this.__super.b2JointDef.call(this);

    this.type = b2Joint.e_pulleyJoint;
    this.groundAnchorA.Set(-1.0, 1.0);
    this.groundAnchorB.Set(1.0, 1.0);
    this.localAnchorA.Set(-1.0, 0.0);
    this.localAnchorB.Set(1.0, 0.0);
    this.lengthA = 0.0;
    this.maxLengthA = 0.0;
    this.lengthB = 0.0;
    this.maxLengthB = 0.0;
    this.ratio = 1.0;
    this.collideConnected = true;
  };

  b2PulleyJointDef.prototype.Initialize = function (bA, bB, gaA, gaB, anchorA, anchorB, r) {
    if (r === undefined) r = 0;
    this.bodyA = bA;
    this.bodyB = bB;
    this.groundAnchorA.SetV(gaA);
    this.groundAnchorB.SetV(gaB);
    this.localAnchorA = this.bodyA.GetLocalPoint(anchorA);
    this.localAnchorB = this.bodyB.GetLocalPoint(anchorB);
    var d1X = anchorA.x - gaA.x;
    var d1Y = anchorA.y - gaA.y;
    this.lengthA = Math.sqrt(d1X * d1X + d1Y * d1Y);
    var d2X = anchorB.x - gaB.x;
    var d2Y = anchorB.y - gaB.y;
    this.lengthB = Math.sqrt(d2X * d2X + d2Y * d2Y);
    this.ratio = r;
    var C = this.lengthA + this.ratio * this.lengthB;
    this.maxLengthA = C - this.ratio * b2PulleyJoint.b2_minPulleyLength;
    this.maxLengthB = (C - b2PulleyJoint.b2_minPulleyLength) / this.ratio;
  };

  Box2D.inherit(b2RevoluteJoint, Box2D.Dynamics.Joints.b2Joint);
  b2RevoluteJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;

  b2RevoluteJoint.b2RevoluteJoint = function () {
    Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
    this.K = new b2Mat22();
    this.K1 = new b2Mat22();
    this.K2 = new b2Mat22();
    this.K3 = new b2Mat22();
    this.impulse3 = new b2Vec3();
    this.impulse2 = new b2Vec2();
    this.reduced = new b2Vec2();
    this.m_localAnchor1 = new b2Vec2();
    this.m_localAnchor2 = new b2Vec2();
    this.m_impulse = new b2Vec3();
    this.m_mass = new b2Mat33();
  };

  b2RevoluteJoint.prototype.GetAnchorA = function () {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchor1);
  };

  b2RevoluteJoint.prototype.GetAnchorB = function () {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchor2);
  };

  b2RevoluteJoint.prototype.GetReactionForce = function (inv_dt) {
    if (inv_dt === undefined) inv_dt = 0;
    return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
  };

  b2RevoluteJoint.prototype.GetReactionTorque = function (inv_dt) {
    if (inv_dt === undefined) inv_dt = 0;
    return inv_dt * this.m_impulse.z;
  };

  b2RevoluteJoint.prototype.GetJointAngle = function () {
    return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle;
  };

  b2RevoluteJoint.prototype.GetJointSpeed = function () {
    return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity;
  };

  b2RevoluteJoint.prototype.IsLimitEnabled = function () {
    return this.m_enableLimit;
  };

  b2RevoluteJoint.prototype.EnableLimit = function (flag) {
    this.m_enableLimit = flag;
  };

  b2RevoluteJoint.prototype.GetLowerLimit = function () {
    return this.m_lowerAngle;
  };

  b2RevoluteJoint.prototype.GetUpperLimit = function () {
    return this.m_upperAngle;
  };

  b2RevoluteJoint.prototype.SetLimits = function (lower, upper) {
    if (lower === undefined) lower = 0;
    if (upper === undefined) upper = 0;
    this.m_lowerAngle = lower;
    this.m_upperAngle = upper;
  };

  b2RevoluteJoint.prototype.IsMotorEnabled = function () {
    this.m_bodyA.SetAwake(true);
    this.m_bodyB.SetAwake(true);
    return this.m_enableMotor;
  };

  b2RevoluteJoint.prototype.EnableMotor = function (flag) {
    this.m_enableMotor = flag;
  };

  b2RevoluteJoint.prototype.SetMotorSpeed = function (speed) {
    if (speed === undefined) speed = 0;
    this.m_bodyA.SetAwake(true);
    this.m_bodyB.SetAwake(true);
    this.m_motorSpeed = speed;
  };

  b2RevoluteJoint.prototype.GetMotorSpeed = function () {
    return this.m_motorSpeed;
  };

  b2RevoluteJoint.prototype.SetMaxMotorTorque = function (torque) {
    if (torque === undefined) torque = 0;
    this.m_maxMotorTorque = torque;
  };

  b2RevoluteJoint.prototype.GetMotorTorque = function () {
    return this.m_maxMotorTorque;
  };

  b2RevoluteJoint.prototype.b2RevoluteJoint = function (def) {
    this.__super.b2Joint.call(this, def);

    this.m_localAnchor1.SetV(def.localAnchorA);
    this.m_localAnchor2.SetV(def.localAnchorB);
    this.m_referenceAngle = def.referenceAngle;
    this.m_impulse.SetZero();
    this.m_motorImpulse = 0.0;
    this.m_lowerAngle = def.lowerAngle;
    this.m_upperAngle = def.upperAngle;
    this.m_maxMotorTorque = def.maxMotorTorque;
    this.m_motorSpeed = def.motorSpeed;
    this.m_enableLimit = def.enableLimit;
    this.m_enableMotor = def.enableMotor;
    this.m_limitState = b2Joint.e_inactiveLimit;
  };

  b2RevoluteJoint.prototype.InitVelocityConstraints = function (step) {
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    var tMat;
    var tX = 0;

    if (this.m_enableMotor || this.m_enableLimit) {}

    tMat = bA.m_xf.R;
    var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
    var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
    r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
    r1X = tX;
    tMat = bB.m_xf.R;
    var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
    var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
    r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
    r2X = tX;
    var m1 = bA.m_invMass;
    var m2 = bB.m_invMass;
    var i1 = bA.m_invI;
    var i2 = bB.m_invI;
    this.m_mass.col1.x = m1 + m2 + r1Y * r1Y * i1 + r2Y * r2Y * i2;
    this.m_mass.col2.x = -r1Y * r1X * i1 - r2Y * r2X * i2;
    this.m_mass.col3.x = -r1Y * i1 - r2Y * i2;
    this.m_mass.col1.y = this.m_mass.col2.x;
    this.m_mass.col2.y = m1 + m2 + r1X * r1X * i1 + r2X * r2X * i2;
    this.m_mass.col3.y = r1X * i1 + r2X * i2;
    this.m_mass.col1.z = this.m_mass.col3.x;
    this.m_mass.col2.z = this.m_mass.col3.y;
    this.m_mass.col3.z = i1 + i2;
    this.m_motorMass = 1.0 / (i1 + i2);

    if (this.m_enableMotor == false) {
      this.m_motorImpulse = 0.0;
    }

    if (this.m_enableLimit) {
      var jointAngle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;

      if (b2Math.Abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * b2Settings.b2_angularSlop) {
        this.m_limitState = b2Joint.e_equalLimits;
      } else if (jointAngle <= this.m_lowerAngle) {
        if (this.m_limitState != b2Joint.e_atLowerLimit) {
          this.m_impulse.z = 0.0;
        }

        this.m_limitState = b2Joint.e_atLowerLimit;
      } else if (jointAngle >= this.m_upperAngle) {
        if (this.m_limitState != b2Joint.e_atUpperLimit) {
          this.m_impulse.z = 0.0;
        }

        this.m_limitState = b2Joint.e_atUpperLimit;
      } else {
        this.m_limitState = b2Joint.e_inactiveLimit;
        this.m_impulse.z = 0.0;
      }
    } else {
      this.m_limitState = b2Joint.e_inactiveLimit;
    }

    if (step.warmStarting) {
      this.m_impulse.x *= step.dtRatio;
      this.m_impulse.y *= step.dtRatio;
      this.m_motorImpulse *= step.dtRatio;
      var PX = this.m_impulse.x;
      var PY = this.m_impulse.y;
      bA.m_linearVelocity.x -= m1 * PX;
      bA.m_linearVelocity.y -= m1 * PY;
      bA.m_angularVelocity -= i1 * (r1X * PY - r1Y * PX + this.m_motorImpulse + this.m_impulse.z);
      bB.m_linearVelocity.x += m2 * PX;
      bB.m_linearVelocity.y += m2 * PY;
      bB.m_angularVelocity += i2 * (r2X * PY - r2Y * PX + this.m_motorImpulse + this.m_impulse.z);
    } else {
      this.m_impulse.SetZero();
      this.m_motorImpulse = 0.0;
    }
  };

  b2RevoluteJoint.prototype.SolveVelocityConstraints = function (step) {
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    var tMat;
    var tX = 0;
    var newImpulse = 0;
    var r1X = 0;
    var r1Y = 0;
    var r2X = 0;
    var r2Y = 0;
    var v1 = bA.m_linearVelocity;
    var w1 = bA.m_angularVelocity;
    var v2 = bB.m_linearVelocity;
    var w2 = bB.m_angularVelocity;
    var m1 = bA.m_invMass;
    var m2 = bB.m_invMass;
    var i1 = bA.m_invI;
    var i2 = bB.m_invI;

    if (this.m_enableMotor && this.m_limitState != b2Joint.e_equalLimits) {
      var Cdot = w2 - w1 - this.m_motorSpeed;
      var impulse = this.m_motorMass * -Cdot;
      var oldImpulse = this.m_motorImpulse;
      var maxImpulse = step.dt * this.m_maxMotorTorque;
      this.m_motorImpulse = b2Math.Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);
      impulse = this.m_motorImpulse - oldImpulse;
      w1 -= i1 * impulse;
      w2 += i2 * impulse;
    }

    if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
      tMat = bA.m_xf.R;
      r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
      r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
      r1X = tX;
      tMat = bB.m_xf.R;
      r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
      r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
      r2X = tX;
      var Cdot1X = v2.x + -w2 * r2Y - v1.x - -w1 * r1Y;
      var Cdot1Y = v2.y + w2 * r2X - v1.y - w1 * r1X;
      var Cdot2 = w2 - w1;
      this.m_mass.Solve33(this.impulse3, -Cdot1X, -Cdot1Y, -Cdot2);

      if (this.m_limitState == b2Joint.e_equalLimits) {
        this.m_impulse.Add(this.impulse3);
      } else if (this.m_limitState == b2Joint.e_atLowerLimit) {
        newImpulse = this.m_impulse.z + this.impulse3.z;

        if (newImpulse < 0.0) {
          this.m_mass.Solve22(this.reduced, -Cdot1X, -Cdot1Y);
          this.impulse3.x = this.reduced.x;
          this.impulse3.y = this.reduced.y;
          this.impulse3.z = -this.m_impulse.z;
          this.m_impulse.x += this.reduced.x;
          this.m_impulse.y += this.reduced.y;
          this.m_impulse.z = 0.0;
        }
      } else if (this.m_limitState == b2Joint.e_atUpperLimit) {
        newImpulse = this.m_impulse.z + this.impulse3.z;

        if (newImpulse > 0.0) {
          this.m_mass.Solve22(this.reduced, -Cdot1X, -Cdot1Y);
          this.impulse3.x = this.reduced.x;
          this.impulse3.y = this.reduced.y;
          this.impulse3.z = -this.m_impulse.z;
          this.m_impulse.x += this.reduced.x;
          this.m_impulse.y += this.reduced.y;
          this.m_impulse.z = 0.0;
        }
      }

      v1.x -= m1 * this.impulse3.x;
      v1.y -= m1 * this.impulse3.y;
      w1 -= i1 * (r1X * this.impulse3.y - r1Y * this.impulse3.x + this.impulse3.z);
      v2.x += m2 * this.impulse3.x;
      v2.y += m2 * this.impulse3.y;
      w2 += i2 * (r2X * this.impulse3.y - r2Y * this.impulse3.x + this.impulse3.z);
    } else {
      tMat = bA.m_xf.R;
      r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
      r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
      r1X = tX;
      tMat = bB.m_xf.R;
      r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
      r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
      r2X = tX;
      var CdotX = v2.x + -w2 * r2Y - v1.x - -w1 * r1Y;
      var CdotY = v2.y + w2 * r2X - v1.y - w1 * r1X;
      this.m_mass.Solve22(this.impulse2, -CdotX, -CdotY);
      this.m_impulse.x += this.impulse2.x;
      this.m_impulse.y += this.impulse2.y;
      v1.x -= m1 * this.impulse2.x;
      v1.y -= m1 * this.impulse2.y;
      w1 -= i1 * (r1X * this.impulse2.y - r1Y * this.impulse2.x);
      v2.x += m2 * this.impulse2.x;
      v2.y += m2 * this.impulse2.y;
      w2 += i2 * (r2X * this.impulse2.y - r2Y * this.impulse2.x);
    }

    bA.m_linearVelocity.SetV(v1);
    bA.m_angularVelocity = w1;
    bB.m_linearVelocity.SetV(v2);
    bB.m_angularVelocity = w2;
  };

  b2RevoluteJoint.prototype.SolvePositionConstraints = function (baumgarte) {
    if (baumgarte === undefined) baumgarte = 0;
    var oldLimitImpulse = 0;
    var C = 0;
    var tMat;
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    var angularError = 0.0;
    var positionError = 0.0;
    var tX = 0;
    var impulseX = 0;
    var impulseY = 0;

    if (this.m_enableLimit && this.m_limitState != b2Joint.e_inactiveLimit) {
      var angle = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
      var limitImpulse = 0.0;

      if (this.m_limitState == b2Joint.e_equalLimits) {
        C = b2Math.Clamp(angle - this.m_lowerAngle, -b2Settings.b2_maxAngularCorrection, b2Settings.b2_maxAngularCorrection);
        limitImpulse = -this.m_motorMass * C;
        angularError = b2Math.Abs(C);
      } else if (this.m_limitState == b2Joint.e_atLowerLimit) {
        C = angle - this.m_lowerAngle;
        angularError = -C;
        C = b2Math.Clamp(C + b2Settings.b2_angularSlop, -b2Settings.b2_maxAngularCorrection, 0.0);
        limitImpulse = -this.m_motorMass * C;
      } else if (this.m_limitState == b2Joint.e_atUpperLimit) {
        C = angle - this.m_upperAngle;
        angularError = C;
        C = b2Math.Clamp(C - b2Settings.b2_angularSlop, 0.0, b2Settings.b2_maxAngularCorrection);
        limitImpulse = -this.m_motorMass * C;
      }

      bA.m_sweep.a -= bA.m_invI * limitImpulse;
      bB.m_sweep.a += bB.m_invI * limitImpulse;
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
    }

    {
      tMat = bA.m_xf.R;
      var r1X = this.m_localAnchor1.x - bA.m_sweep.localCenter.x;
      var r1Y = this.m_localAnchor1.y - bA.m_sweep.localCenter.y;
      tX = tMat.col1.x * r1X + tMat.col2.x * r1Y;
      r1Y = tMat.col1.y * r1X + tMat.col2.y * r1Y;
      r1X = tX;
      tMat = bB.m_xf.R;
      var r2X = this.m_localAnchor2.x - bB.m_sweep.localCenter.x;
      var r2Y = this.m_localAnchor2.y - bB.m_sweep.localCenter.y;
      tX = tMat.col1.x * r2X + tMat.col2.x * r2Y;
      r2Y = tMat.col1.y * r2X + tMat.col2.y * r2Y;
      r2X = tX;
      var CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
      var CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      var CLengthSquared = CX * CX + CY * CY;
      var CLength = Math.sqrt(CLengthSquared);
      positionError = CLength;
      var invMass1 = bA.m_invMass;
      var invMass2 = bB.m_invMass;
      var invI1 = bA.m_invI;
      var invI2 = bB.m_invI;
      var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;

      if (CLengthSquared > k_allowedStretch * k_allowedStretch) {
        var uX = CX / CLength;
        var uY = CY / CLength;
        var k = invMass1 + invMass2;
        var m = 1.0 / k;
        impulseX = m * -CX;
        impulseY = m * -CY;
        var k_beta = 0.5;
        bA.m_sweep.c.x -= k_beta * invMass1 * impulseX;
        bA.m_sweep.c.y -= k_beta * invMass1 * impulseY;
        bB.m_sweep.c.x += k_beta * invMass2 * impulseX;
        bB.m_sweep.c.y += k_beta * invMass2 * impulseY;
        CX = bB.m_sweep.c.x + r2X - bA.m_sweep.c.x - r1X;
        CY = bB.m_sweep.c.y + r2Y - bA.m_sweep.c.y - r1Y;
      }

      this.K1.col1.x = invMass1 + invMass2;
      this.K1.col2.x = 0.0;
      this.K1.col1.y = 0.0;
      this.K1.col2.y = invMass1 + invMass2;
      this.K2.col1.x = invI1 * r1Y * r1Y;
      this.K2.col2.x = -invI1 * r1X * r1Y;
      this.K2.col1.y = -invI1 * r1X * r1Y;
      this.K2.col2.y = invI1 * r1X * r1X;
      this.K3.col1.x = invI2 * r2Y * r2Y;
      this.K3.col2.x = -invI2 * r2X * r2Y;
      this.K3.col1.y = -invI2 * r2X * r2Y;
      this.K3.col2.y = invI2 * r2X * r2X;
      this.K.SetM(this.K1);
      this.K.AddM(this.K2);
      this.K.AddM(this.K3);
      this.K.Solve(b2RevoluteJoint.tImpulse, -CX, -CY);
      impulseX = b2RevoluteJoint.tImpulse.x;
      impulseY = b2RevoluteJoint.tImpulse.y;
      bA.m_sweep.c.x -= bA.m_invMass * impulseX;
      bA.m_sweep.c.y -= bA.m_invMass * impulseY;
      bA.m_sweep.a -= bA.m_invI * (r1X * impulseY - r1Y * impulseX);
      bB.m_sweep.c.x += bB.m_invMass * impulseX;
      bB.m_sweep.c.y += bB.m_invMass * impulseY;
      bB.m_sweep.a += bB.m_invI * (r2X * impulseY - r2Y * impulseX);
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
    }
    return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
  };

  Box2D.postDefs.push(function () {
    Box2D.Dynamics.Joints.b2RevoluteJoint.tImpulse = new b2Vec2();
  });
  Box2D.inherit(b2RevoluteJointDef, Box2D.Dynamics.Joints.b2JointDef);
  b2RevoluteJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;

  b2RevoluteJointDef.b2RevoluteJointDef = function () {
    Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
    this.localAnchorA = new b2Vec2();
    this.localAnchorB = new b2Vec2();
  };

  b2RevoluteJointDef.prototype.b2RevoluteJointDef = function () {
    this.__super.b2JointDef.call(this);

    this.type = b2Joint.e_revoluteJoint;
    this.localAnchorA.Set(0.0, 0.0);
    this.localAnchorB.Set(0.0, 0.0);
    this.referenceAngle = 0.0;
    this.lowerAngle = 0.0;
    this.upperAngle = 0.0;
    this.maxMotorTorque = 0.0;
    this.motorSpeed = 0.0;
    this.enableLimit = false;
    this.enableMotor = false;
  };

  b2RevoluteJointDef.prototype.Initialize = function (bA, bB, anchor) {
    this.bodyA = bA;
    this.bodyB = bB;
    this.localAnchorA = this.bodyA.GetLocalPoint(anchor);
    this.localAnchorB = this.bodyB.GetLocalPoint(anchor);
    this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
  };

  Box2D.inherit(b2WeldJoint, Box2D.Dynamics.Joints.b2Joint);
  b2WeldJoint.prototype.__super = Box2D.Dynamics.Joints.b2Joint.prototype;

  b2WeldJoint.b2WeldJoint = function () {
    Box2D.Dynamics.Joints.b2Joint.b2Joint.apply(this, arguments);
    this.m_localAnchorA = new b2Vec2();
    this.m_localAnchorB = new b2Vec2();
    this.m_impulse = new b2Vec3();
    this.m_mass = new b2Mat33();
  };

  b2WeldJoint.prototype.GetAnchorA = function () {
    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA);
  };

  b2WeldJoint.prototype.GetAnchorB = function () {
    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB);
  };

  b2WeldJoint.prototype.GetReactionForce = function (inv_dt) {
    if (inv_dt === undefined) inv_dt = 0;
    return new b2Vec2(inv_dt * this.m_impulse.x, inv_dt * this.m_impulse.y);
  };

  b2WeldJoint.prototype.GetReactionTorque = function (inv_dt) {
    if (inv_dt === undefined) inv_dt = 0;
    return inv_dt * this.m_impulse.z;
  };

  b2WeldJoint.prototype.b2WeldJoint = function (def) {
    this.__super.b2Joint.call(this, def);

    this.m_localAnchorA.SetV(def.localAnchorA);
    this.m_localAnchorB.SetV(def.localAnchorB);
    this.m_referenceAngle = def.referenceAngle;
    this.m_impulse.SetZero();
    this.m_mass = new b2Mat33();
  };

  b2WeldJoint.prototype.InitVelocityConstraints = function (step) {
    var tMat;
    var tX = 0;
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    tMat = bA.m_xf.R;
    var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
    var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
    rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
    rAX = tX;
    tMat = bB.m_xf.R;
    var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
    var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
    rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
    rBX = tX;
    var mA = bA.m_invMass;
    var mB = bB.m_invMass;
    var iA = bA.m_invI;
    var iB = bB.m_invI;
    this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
    this.m_mass.col2.x = -rAY * rAX * iA - rBY * rBX * iB;
    this.m_mass.col3.x = -rAY * iA - rBY * iB;
    this.m_mass.col1.y = this.m_mass.col2.x;
    this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
    this.m_mass.col3.y = rAX * iA + rBX * iB;
    this.m_mass.col1.z = this.m_mass.col3.x;
    this.m_mass.col2.z = this.m_mass.col3.y;
    this.m_mass.col3.z = iA + iB;

    if (step.warmStarting) {
      this.m_impulse.x *= step.dtRatio;
      this.m_impulse.y *= step.dtRatio;
      this.m_impulse.z *= step.dtRatio;
      bA.m_linearVelocity.x -= mA * this.m_impulse.x;
      bA.m_linearVelocity.y -= mA * this.m_impulse.y;
      bA.m_angularVelocity -= iA * (rAX * this.m_impulse.y - rAY * this.m_impulse.x + this.m_impulse.z);
      bB.m_linearVelocity.x += mB * this.m_impulse.x;
      bB.m_linearVelocity.y += mB * this.m_impulse.y;
      bB.m_angularVelocity += iB * (rBX * this.m_impulse.y - rBY * this.m_impulse.x + this.m_impulse.z);
    } else {
      this.m_impulse.SetZero();
    }
  };

  b2WeldJoint.prototype.SolveVelocityConstraints = function (step) {
    var tMat;
    var tX = 0;
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    var vA = bA.m_linearVelocity;
    var wA = bA.m_angularVelocity;
    var vB = bB.m_linearVelocity;
    var wB = bB.m_angularVelocity;
    var mA = bA.m_invMass;
    var mB = bB.m_invMass;
    var iA = bA.m_invI;
    var iB = bB.m_invI;
    tMat = bA.m_xf.R;
    var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
    var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
    rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
    rAX = tX;
    tMat = bB.m_xf.R;
    var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
    var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
    rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
    rBX = tX;
    var Cdot1X = vB.x - wB * rBY - vA.x + wA * rAY;
    var Cdot1Y = vB.y + wB * rBX - vA.y - wA * rAX;
    var Cdot2 = wB - wA;
    var impulse = new b2Vec3();
    this.m_mass.Solve33(impulse, -Cdot1X, -Cdot1Y, -Cdot2);
    this.m_impulse.Add(impulse);
    vA.x -= mA * impulse.x;
    vA.y -= mA * impulse.y;
    wA -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
    vB.x += mB * impulse.x;
    vB.y += mB * impulse.y;
    wB += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
    bA.m_angularVelocity = wA;
    bB.m_angularVelocity = wB;
  };

  b2WeldJoint.prototype.SolvePositionConstraints = function (baumgarte) {
    if (baumgarte === undefined) baumgarte = 0;
    var tMat;
    var tX = 0;
    var bA = this.m_bodyA;
    var bB = this.m_bodyB;
    tMat = bA.m_xf.R;
    var rAX = this.m_localAnchorA.x - bA.m_sweep.localCenter.x;
    var rAY = this.m_localAnchorA.y - bA.m_sweep.localCenter.y;
    tX = tMat.col1.x * rAX + tMat.col2.x * rAY;
    rAY = tMat.col1.y * rAX + tMat.col2.y * rAY;
    rAX = tX;
    tMat = bB.m_xf.R;
    var rBX = this.m_localAnchorB.x - bB.m_sweep.localCenter.x;
    var rBY = this.m_localAnchorB.y - bB.m_sweep.localCenter.y;
    tX = tMat.col1.x * rBX + tMat.col2.x * rBY;
    rBY = tMat.col1.y * rBX + tMat.col2.y * rBY;
    rBX = tX;
    var mA = bA.m_invMass;
    var mB = bB.m_invMass;
    var iA = bA.m_invI;
    var iB = bB.m_invI;
    var C1X = bB.m_sweep.c.x + rBX - bA.m_sweep.c.x - rAX;
    var C1Y = bB.m_sweep.c.y + rBY - bA.m_sweep.c.y - rAY;
    var C2 = bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
    var k_allowedStretch = 10.0 * b2Settings.b2_linearSlop;
    var positionError = Math.sqrt(C1X * C1X + C1Y * C1Y);
    var angularError = b2Math.Abs(C2);

    if (positionError > k_allowedStretch) {
      iA *= 1.0;
      iB *= 1.0;
    }

    this.m_mass.col1.x = mA + mB + rAY * rAY * iA + rBY * rBY * iB;
    this.m_mass.col2.x = -rAY * rAX * iA - rBY * rBX * iB;
    this.m_mass.col3.x = -rAY * iA - rBY * iB;
    this.m_mass.col1.y = this.m_mass.col2.x;
    this.m_mass.col2.y = mA + mB + rAX * rAX * iA + rBX * rBX * iB;
    this.m_mass.col3.y = rAX * iA + rBX * iB;
    this.m_mass.col1.z = this.m_mass.col3.x;
    this.m_mass.col2.z = this.m_mass.col3.y;
    this.m_mass.col3.z = iA + iB;
    var impulse = new b2Vec3();
    this.m_mass.Solve33(impulse, -C1X, -C1Y, -C2);
    bA.m_sweep.c.x -= mA * impulse.x;
    bA.m_sweep.c.y -= mA * impulse.y;
    bA.m_sweep.a -= iA * (rAX * impulse.y - rAY * impulse.x + impulse.z);
    bB.m_sweep.c.x += mB * impulse.x;
    bB.m_sweep.c.y += mB * impulse.y;
    bB.m_sweep.a += iB * (rBX * impulse.y - rBY * impulse.x + impulse.z);
    bA.SynchronizeTransform();
    bB.SynchronizeTransform();
    return positionError <= b2Settings.b2_linearSlop && angularError <= b2Settings.b2_angularSlop;
  };

  Box2D.inherit(b2WeldJointDef, Box2D.Dynamics.Joints.b2JointDef);
  b2WeldJointDef.prototype.__super = Box2D.Dynamics.Joints.b2JointDef.prototype;

  b2WeldJointDef.b2WeldJointDef = function () {
    Box2D.Dynamics.Joints.b2JointDef.b2JointDef.apply(this, arguments);
    this.localAnchorA = new b2Vec2();
    this.localAnchorB = new b2Vec2();
  };

  b2WeldJointDef.prototype.b2WeldJointDef = function () {
    this.__super.b2JointDef.call(this);

    this.type = b2Joint.e_weldJoint;
    this.referenceAngle = 0.0;
  };

  b2WeldJointDef.prototype.Initialize = function (bA, bB, anchor) {
    this.bodyA = bA;
    this.bodyB = bB;
    this.localAnchorA.SetV(this.bodyA.GetLocalPoint(anchor));
    this.localAnchorB.SetV(this.bodyB.GetLocalPoint(anchor));
    this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();
  };
})();

(function () {
  var b2DebugDraw = Box2D.Dynamics.b2DebugDraw;

  b2DebugDraw.b2DebugDraw = function () {
    this.m_drawScale = 1.0;
    this.m_lineThickness = 1.0;
    this.m_alpha = 1.0;
    this.m_fillAlpha = 1.0;
    this.m_xformScale = 1.0;

    var __this = this; //#WORKAROUND


    this.m_sprite = {
      graphics: {
        clear: function clear() {
          __this.m_ctx.clearRect(0, 0, __this.m_ctx.canvas.width, __this.m_ctx.canvas.height);
        }
      }
    };
  };

  b2DebugDraw.prototype._color = function (color, alpha) {
    return "rgba(" + ((color & 0xFF0000) >> 16) + "," + ((color & 0xFF00) >> 8) + "," + (color & 0xFF) + "," + alpha + ")";
  };

  b2DebugDraw.prototype.b2DebugDraw = function () {
    this.m_drawFlags = 0;
  };

  b2DebugDraw.prototype.SetFlags = function (flags) {
    if (flags === undefined) flags = 0;
    this.m_drawFlags = flags;
  };

  b2DebugDraw.prototype.GetFlags = function () {
    return this.m_drawFlags;
  };

  b2DebugDraw.prototype.AppendFlags = function (flags) {
    if (flags === undefined) flags = 0;
    this.m_drawFlags |= flags;
  };

  b2DebugDraw.prototype.ClearFlags = function (flags) {
    if (flags === undefined) flags = 0;
    this.m_drawFlags &= ~flags;
  };

  b2DebugDraw.prototype.SetSprite = function (sprite) {
    this.m_ctx = sprite;
  };

  b2DebugDraw.prototype.GetSprite = function () {
    return this.m_ctx;
  };

  b2DebugDraw.prototype.SetDrawScale = function (drawScale) {
    if (drawScale === undefined) drawScale = 0;
    this.m_drawScale = drawScale;
  };

  b2DebugDraw.prototype.GetDrawScale = function () {
    return this.m_drawScale;
  };

  b2DebugDraw.prototype.SetLineThickness = function (lineThickness) {
    if (lineThickness === undefined) lineThickness = 0;
    this.m_lineThickness = lineThickness;
    this.m_ctx.strokeWidth = lineThickness;
  };

  b2DebugDraw.prototype.GetLineThickness = function () {
    return this.m_lineThickness;
  };

  b2DebugDraw.prototype.SetAlpha = function (alpha) {
    if (alpha === undefined) alpha = 0;
    this.m_alpha = alpha;
  };

  b2DebugDraw.prototype.GetAlpha = function () {
    return this.m_alpha;
  };

  b2DebugDraw.prototype.SetFillAlpha = function (alpha) {
    if (alpha === undefined) alpha = 0;
    this.m_fillAlpha = alpha;
  };

  b2DebugDraw.prototype.GetFillAlpha = function () {
    return this.m_fillAlpha;
  };

  b2DebugDraw.prototype.SetXFormScale = function (xformScale) {
    if (xformScale === undefined) xformScale = 0;
    this.m_xformScale = xformScale;
  };

  b2DebugDraw.prototype.GetXFormScale = function () {
    return this.m_xformScale;
  };

  b2DebugDraw.prototype.DrawPolygon = function (vertices, vertexCount, color) {
    if (!vertexCount) return;
    var s = this.m_ctx;
    var drawScale = this.m_drawScale;
    s.beginPath();
    s.strokeStyle = this._color(color.color, this.m_alpha);
    s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);

    for (var i = 1; i < vertexCount; i++) {
      s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
    }

    s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
    s.closePath();
    s.stroke();
  };

  b2DebugDraw.prototype.DrawSolidPolygon = function (vertices, vertexCount, color) {
    if (!vertexCount) return;
    var s = this.m_ctx;
    var drawScale = this.m_drawScale;
    s.beginPath();
    s.strokeStyle = this._color(color.color, this.m_alpha);
    s.fillStyle = this._color(color.color, this.m_fillAlpha);
    s.moveTo(vertices[0].x * drawScale, vertices[0].y * drawScale);

    for (var i = 1; i < vertexCount; i++) {
      s.lineTo(vertices[i].x * drawScale, vertices[i].y * drawScale);
    }

    s.lineTo(vertices[0].x * drawScale, vertices[0].y * drawScale);
    s.closePath();
    s.fill();
    s.stroke();
  };

  b2DebugDraw.prototype.DrawCircle = function (center, radius, color) {
    if (!radius) return;
    var s = this.m_ctx;
    var drawScale = this.m_drawScale;
    s.beginPath();
    s.strokeStyle = this._color(color.color, this.m_alpha);
    s.arc(center.x * drawScale, center.y * drawScale, radius * drawScale, 0, Math.PI * 2, true);
    s.closePath();
    s.stroke();
  };

  b2DebugDraw.prototype.DrawSolidCircle = function (center, radius, axis, color) {
    if (!radius) return;
    var s = this.m_ctx,
        drawScale = this.m_drawScale,
        cx = center.x * drawScale,
        cy = center.y * drawScale;
    s.moveTo(0, 0);
    s.beginPath();
    s.strokeStyle = this._color(color.color, this.m_alpha);
    s.fillStyle = this._color(color.color, this.m_fillAlpha);
    s.arc(cx, cy, radius * drawScale, 0, Math.PI * 2, true);
    s.moveTo(cx, cy);
    s.lineTo((center.x + axis.x * radius) * drawScale, (center.y + axis.y * radius) * drawScale);
    s.closePath();
    s.fill();
    s.stroke();
  };

  b2DebugDraw.prototype.DrawSegment = function (p1, p2, color) {
    var s = this.m_ctx,
        drawScale = this.m_drawScale;
    s.strokeStyle = this._color(color.color, this.m_alpha);
    s.beginPath();
    s.moveTo(p1.x * drawScale, p1.y * drawScale);
    s.lineTo(p2.x * drawScale, p2.y * drawScale);
    s.closePath();
    s.stroke();
  };

  b2DebugDraw.prototype.DrawTransform = function (xf) {
    var s = this.m_ctx,
        drawScale = this.m_drawScale;
    s.beginPath();
    s.strokeStyle = this._color(0xff0000, this.m_alpha);
    s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
    s.lineTo((xf.position.x + this.m_xformScale * xf.R.col1.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col1.y) * drawScale);
    s.strokeStyle = this._color(0xff00, this.m_alpha);
    s.moveTo(xf.position.x * drawScale, xf.position.y * drawScale);
    s.lineTo((xf.position.x + this.m_xformScale * xf.R.col2.x) * drawScale, (xf.position.y + this.m_xformScale * xf.R.col2.y) * drawScale);
    s.closePath();
    s.stroke();
  };
})();

var i;

for (i = 0; i < Box2D.postDefs.length; ++i) Box2D.postDefs[i]();

module.exports = Box2D;

/***/ }),

/***/ "./src/extensions/griffpatch_box2d/index.js":
/*!**************************************************!*\
  !*** ./src/extensions/griffpatch_box2d/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://cdn.jsdelivr.net/gh/griffpatch/griffpatch.github.io/testExtension.js
const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js"); // const MathUtil = require('../../util/math-util');
// const Clone = require('../../util/clone');


const Cast = __webpack_require__(/*! ../../util/cast */ "./src/util/cast.js");

const Runtime = __webpack_require__(/*! ../../engine/runtime */ "./src/engine/runtime.js");

const RenderedTarget = __webpack_require__(/*! ../../sprites/rendered-target */ "./src/sprites/rendered-target.js");

const formatMessage = __webpack_require__(/*! format-message */ "format-message"); // const MathUtil = require('../../util/math-util');
// const Timer = require('../../util/timer');
// const Matter = require('matterJs/matter');
// const Matter = require('matter-js');
// const Box2D = require('./Box2d.min').box2d;


const Box2D = __webpack_require__(/*! ./box2d_es6 */ "./src/extensions/griffpatch_box2d/box2d_es6.js"); // window.decomp = require('poly-decomp');


const b2World = Box2D.Dynamics.b2World;
const b2Vec2 = Box2D.Common.Math.b2Vec2;
const b2AABB = Box2D.Collision.b2AABB;
const b2BodyDef = Box2D.Dynamics.b2BodyDef;
const b2Body = Box2D.Dynamics.b2Body;
const b2FixtureDef = Box2D.Dynamics.b2FixtureDef; // const b2Fixture = Box2D.Dynamics.b2Fixture;
// const b2Fixture = Box2D.Dynamics.b2Fixture;

const b2Contact = Box2D.Dynamics.Contacts.b2Contact; // const b2MassData = Box2D.Collision.Shapes.b2MassData;

const b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;
const b2CircleShape = Box2D.Collision.Shapes.b2CircleShape; // const b2DebugDraw = Box2D.Dynamics.b2DebugDraw;

const b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef;
const b2Math = Box2D.Common.Math.b2Math;
let world;
let zoom;
const fixDef = new b2FixtureDef();
const bodyDef = new b2BodyDef(); // const uid_seq = 0;
// let ujidSeq = 0;

const prevPos = {};
/**
 * Active b2Body/s in the world.
 * @type {Object.<string,*>}
 */

const bodies = {}; // const joints = {};

const pinned = {}; // Map of IDs to pinned joints

/**
 * The runtime instantiating this block package.
 * @type {Array}
 */

const stageBodies = []; // const categorySeq = 1;
// const categories = {default: 1};

const bodyCategoryBits = 1;
const bodyMaskBits = 1; // const noCollideSeq = 0;

const toRad = Math.PI / 180; // Used to record the scroll position of all sprites

const _scroll = new b2Vec2(0, 0);

const STAGE_TYPE_OPTIONS = {
  BOXED: 'boxed',
  FLOOR: 'floor',
  OPEN: 'open'
};
const SPACE_TYPE_OPTIONS = {
  WORLD: 'world',
  STAGE: 'stage',
  RELATIVE: 'relative'
};
const WHERE_TYPE_OPTIONS = {
  ANY: 'any',
  FEET: 'feet'
};
const SHAPE_TYPE_OPTIONS = {
  COSTUME: 'costume',
  CIRCLE: 'circle',
  SVG_POLYGON: 'svg',
  ALL: 'all'
};

const _definePolyFromHull = function _definePolyFromHull(hullPoints) {
  fixDef.shape = new b2PolygonShape();
  const vertices = [];
  let prev = null;

  for (let i = hullPoints.length - 1; i >= 0; i--) {
    // for (let i = 0; i < hullPoints.length; i++) {
    const b2Vec = new b2Vec2(hullPoints[i].x / zoom, hullPoints[i].y / zoom);

    if (prev !== null && b2Math.SubtractVV(b2Vec, prev).LengthSquared() > Number.MIN_VALUE) {
      vertices.push(b2Vec);
    }

    prev = b2Vec;
  }

  fixDef.shape.SetAsArray(vertices);
};

const _placeBody = function _placeBody(id, x, y, dir) {
  if (bodies[id]) {
    world.DestroyBody(bodies[id]);
  }

  fixDef.filter.categoryBits = bodyCategoryBits;
  fixDef.filter.maskBits = bodyMaskBits;
  bodyDef.position.x = (x + _scroll.x) / zoom;
  bodyDef.position.y = (y + _scroll.y) / zoom;
  bodyDef.angle = (90 - dir) * toRad;
  const body = world.CreateBody(bodyDef);
  body.uid = id;
  body.CreateFixture(fixDef);
  bodies[id] = body;
  return body;
};

const _applyForce = function _applyForce(id, ftype, x, y, dir, pow) {
  const body = bodies[id];

  if (!body) {
    return;
  }

  dir = (90 - dir) * toRad;

  if (ftype === 'Impulse') {
    const center = body.GetLocalCenter(); // get the mass data from you body

    body.ApplyImpulse({
      x: pow * Math.cos(dir),
      y: pow * Math.sin(dir)
    }, body.GetWorldPoint({
      x: x / zoom + center.x,
      y: y / zoom + center.y
    }));
  } else if (ftype === 'World Impulse') {
    body.ApplyForce({
      x: pow * Math.cos(dir),
      y: pow * Math.sin(dir)
    }, {
      x: x / zoom,
      y: y / zoom
    });
  }
}; // ['', 'Define Spring Length: %n Damping: %n  Freq: %n', '_defineSpring', 100, 0.5, 8],


const defSpring = {
  len: 100,
  damp: 0.7,
  freq: 5
};

const _defineSpring = function _defineSpring(len, damp, freq) {
  defSpring.len = len < 0.1 ? 0.1 : len / zoom;
  defSpring.damp = damp < 0 ? 0.7 : damp;
  defSpring.freq = freq > 0 ? freq : 5;
};

const _createJointOfType = function _createJointOfType(jName, typ, bodyID, x, y, bodyID2, x2, y2) {
  // if (jName.length > 0) ext.destroyJoint(jName);
  if (!bodyID) bodyID = null;
  if (!bodyID2) bodyID2 = null;

  if (!bodyID && !bodyID2) {
    return null;
  }

  const body = bodyID ? bodies[bodyID] : world.GetGroundBody();
  const body2 = bodyID2 ? bodies[bodyID2] : world.GetGroundBody();
  if (!body || !body2) return null;
  let md;

  switch (typ) {
    case 'Spring':
      md = new Box2D.Dynamics.Joints.b2DistanceJointDef();
      md.length = defSpring.len;
      md.dampingRatio = defSpring.damp;
      md.frequencyHz = defSpring.freq;
      md.bodyA = body;
      md.bodyB = body2;
      md.localAnchorA = {
        x: x / zoom,
        y: y / zoom
      };
      md.localAnchorB = {
        x: x2 / zoom,
        y: y2 / zoom
      };
      break;

    case 'Rotating':
      md = new Box2D.Dynamics.Joints.b2RevoluteJointDef();
      md.bodyA = body;
      md.bodyB = body2;
      md.localAnchorA = {
        x: x / zoom,
        y: y / zoom
      };

      if (x2 === null) {
        if (body2) {
          md.localAnchorB = body2.GetLocalPoint(body.GetPosition()); // Wheel Type Joint...
        } else {
          md.localAnchorB = body.GetWorldPoint({
            x: x / zoom,
            y: y / zoom
          });
        }
      } else {
        md.localAnchorB = {
          x: x2 / zoom,
          y: y2 / zoom
        };
      }

      break;

    case 'Mouse':
      md = new b2MouseJointDef();

      if (bodyID) {
        md.bodyB = body;
        md.target.Set(x / zoom, y / zoom);
      } else {
        md.bodyB = body2;
        md.target.Set(x2 / zoom, y2 / zoom);
      }

      md.bodyA = world.GetGroundBody();
      md.collideConnected = true;
      md.maxForce = 300.0 * body.GetMass();
      break;
  } // md.collideConnected = true;
  // md.maxForce = 300.0 * body.GetMass();


  const joint = world.CreateJoint(md);

  if (bodyID) {
    body.SetAwake(true);
  }

  if (bodyID2) {
    body2.SetAwake(true);
  } // if (!jName) {
  //     ujidSeq++;
  //     jName = `_${ujidSeq}`;
  // }
  // joints[jName] = joint;


  return joint;
};
/**
 * Set the X and Y coordinates (No Fencing)
 * @param {!RenderedTarget} rt the renderedTarget.
 * @param {!number} x New X coordinate, in Scratch coordinates.
 * @param {!number} y New Y coordinate, in Scratch coordinates.
 * @param {?boolean} force Force setting X/Y, in case of dragging
 */


const _setXY = function _setXY(rt, x, y, force) {
  if (rt.isStage) return;
  if (rt.dragging && !force) return;
  const oldX = rt.x;
  const oldY = rt.y;

  if (rt.renderer) {
    // const position = rt.renderer.getFencedPositionOfDrawable(rt.drawableID, [x, y]);
    rt.x = x; // position[0];

    rt.y = y; // position[1];

    rt.renderer.updateDrawableProperties(rt.drawableID, {
      position: [x, y]
    });

    if (rt.visible) {
      rt.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, rt);
      rt.runtime.requestRedraw();
    }
  } else {
    rt.x = x;
    rt.y = y;
  }

  rt.emit(RenderedTarget.EVENT_TARGET_MOVED, rt, oldX, oldY, force);
  rt.runtime.requestTargetsUpdate(rt);
};

const createStageBody = function createStageBody() {
  const body = world.CreateBody(bodyDef);
  body.CreateFixture(fixDef);
  stageBodies.push(body);
};

const _setStageType = function _setStageType(type) {
  // Clear down previous stage
  if (stageBodies.length > 0) {
    for (const stageBodyID in stageBodies) {
      world.DestroyBody(stageBodies[stageBodyID]);
      delete stageBodies[stageBodyID];
    }
  } // Build up new stage


  bodyDef.type = b2Body.b2_staticBody;
  fixDef.shape = new b2PolygonShape();
  bodyDef.angle = 0;

  if (type === STAGE_TYPE_OPTIONS.BOXED) {
    fixDef.shape.SetAsBox(250 / zoom, 10 / zoom);
    bodyDef.position.Set(0, -190 / zoom);
    createStageBody();
    bodyDef.position.Set(0, 1000 / zoom);
    createStageBody();
    fixDef.shape.SetAsBox(10 / zoom, 800 / zoom);
    bodyDef.position.Set(-250 / zoom, 540 / zoom);
    createStageBody();
    bodyDef.position.Set(250 / zoom, 540 / zoom);
    createStageBody();
  } else if (type === STAGE_TYPE_OPTIONS.FLOOR) {
    fixDef.shape.SetAsBox(5000 / zoom, 100 / zoom);
    bodyDef.position.Set(0, -280 / zoom);
    createStageBody();
    bodyDef.position.Set(-10000, -280 / zoom);
    createStageBody();
    bodyDef.position.Set(10000, -280 / zoom);
    createStageBody();
    bodyDef.position.Set(-20000, -280 / zoom);
    createStageBody();
    bodyDef.position.Set(20000, -280 / zoom);
    createStageBody();
  }

  bodyDef.type = b2Body.b2_dynamicBody;

  for (const bodyID in bodies) {
    bodies[bodyID].SetAwake(true);
  }
};
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const blockIconURI = 'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiDQoJIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbG5zOmE9Imh0dHA6Ly9ucy5hZG9iZS5jb20vQWRvYmVTVkdWaWV3ZXJFeHRlbnNpb25zLzMuMC8iDQoJIHg9IjBweCIgeT0iMHB4IiB3aWR0aD0iNDBweCIgaGVpZ2h0PSI0MHB4IiB2aWV3Qm94PSItMy43IC0zLjcgNDAgNDAiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgLTMuNyAtMy43IDQwIDQwIg0KCSB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxkZWZzPg0KPC9kZWZzPg0KPHJlY3QgeD0iOC45IiB5PSIxLjUiIGZpbGw9IiNGRkZGRkYiIHN0cm9rZT0iIzE2OUZCMCIgc3Ryb2tlLXdpZHRoPSIzIiB3aWR0aD0iMTQuOCIgaGVpZ2h0PSIxNC44Ii8+DQo8cmVjdCB4PSIxLjUiIHk9IjE2LjMiIGZpbGw9IiNGRkZGRkYiIHN0cm9rZT0iIzE2OUZCMCIgc3Ryb2tlLXdpZHRoPSIzIiB3aWR0aD0iMTQuOCIgaGVpZ2h0PSIxNC44Ii8+DQo8cmVjdCB4PSIxNi4zIiB5PSIxNi4zIiBmaWxsPSIjRkZGRkZGIiBzdHJva2U9IiMxNjlGQjAiIHN0cm9rZS13aWR0aD0iMyIgd2lkdGg9IjE0LjgiIGhlaWdodD0iMTQuOCIvPg0KPC9zdmc+';
/**
 * Icon svg to be displayed in the category menu, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len

const menuIconURI = 'data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiDQoJIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHhtbG5zOmE9Imh0dHA6Ly9ucy5hZG9iZS5jb20vQWRvYmVTVkdWaWV3ZXJFeHRlbnNpb25zLzMuMC8iDQoJIHg9IjBweCIgeT0iMHB4IiB3aWR0aD0iNDBweCIgaGVpZ2h0PSI0MHB4IiB2aWV3Qm94PSItMy43IC0zLjcgNDAgNDAiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgLTMuNyAtMy43IDQwIDQwIg0KCSB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxkZWZzPg0KPC9kZWZzPg0KPHJlY3QgeD0iOC45IiB5PSIxLjUiIGZpbGw9IiNGRkZGRkYiIHN0cm9rZT0iIzE2OUZCMCIgc3Ryb2tlLXdpZHRoPSIzIiB3aWR0aD0iMTQuOCIgaGVpZ2h0PSIxNC44Ii8+DQo8cmVjdCB4PSIxLjUiIHk9IjE2LjMiIGZpbGw9IiNGRkZGRkYiIHN0cm9rZT0iIzE2OUZCMCIgc3Ryb2tlLXdpZHRoPSIzIiB3aWR0aD0iMTQuOCIgaGVpZ2h0PSIxNC44Ii8+DQo8cmVjdCB4PSIxNi4zIiB5PSIxNi4zIiBmaWxsPSIjRkZGRkZGIiBzdHJva2U9IiMxNjlGQjAiIHN0cm9rZS13aWR0aD0iMyIgd2lkdGg9IjE0LjgiIGhlaWdodD0iMTQuOCIvPg0KPC9zdmc+';
/**
 * Class for the music-related blocks in Scratch 3.0
 * @param {Runtime} runtime - the runtime instantiating this block package.
 * @constructor
 */

class Scratch3Griffpatch {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime; // Clear target motion state values when the project starts.

    this.runtime.on(Runtime.PROJECT_START, this.reset.bind(this));
    world = new b2World(new b2Vec2(0, -10), // gravity (10)
    true // allow sleep
    );
    zoom = 50; // scale;

    this.map = {};
    fixDef.density = 1.0; // 1.0

    fixDef.friction = 0.5; // 0.5

    fixDef.restitution = 0.2; // 0.2

    _setStageType(STAGE_TYPE_OPTIONS.BOXED);
  }

  reset() {
    for (const body in bodies) {
      if (pinned[body.uid]) {
        world.DestroyJoint(pinned[body.uid]);
        delete pinned[body.uid];
      }

      world.DestroyBody(bodies[body]);
      delete bodies[body];
      delete prevPos[body];
    } // todo: delete joins?

  }
  /**
   * The key to load & store a target's music-related state.
   * @type {string}
   */


  static get STATE_KEY() {
    return 'Scratch.Griffpatch';
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: 'griffpatch',
      name: formatMessage({
        id: 'griffpatch.categoryName',
        default: 'Physics',
        description: 'Label for the Griffpatch extension category'
      }),
      menuIconURI: menuIconURI,
      blockIconURI: blockIconURI,
      blocks: [// Global Setup ------------------
      {
        opcode: 'setStage',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'griffpatch.setStage',
          default: 'setup stage [stageType]',
          description: 'Set the stage type'
        }),
        arguments: {
          stageType: {
            type: ArgumentType.STRING,
            menu: 'StageTypes',
            defaultValue: STAGE_TYPE_OPTIONS.BOXED
          }
        }
      }, {
        opcode: 'setGravity',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'griffpatch.setGravity',
          default: 'set gravity to x: [gx] y: [gy]',
          description: 'Set the gravity'
        }),
        arguments: {
          gx: {
            type: ArgumentType.NUMBER,
            defaultValue: 0
          },
          gy: {
            type: ArgumentType.NUMBER,
            defaultValue: -10
          }
        }
      }, '---', {
        opcode: 'setPhysics',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'griffpatch.setPhysics',
          default: 'enable for [shape] mode [mode]',
          description: 'Enable Physics for this Sprite'
        }),
        arguments: {
          shape: {
            type: ArgumentType.STRING,
            menu: 'ShapeTypes',
            defaultValue: 'costume'
          },
          mode: {
            type: ArgumentType.STRING,
            menu: 'EnableModeTypes',
            defaultValue: 'normal'
          }
        }
      }, // {
      //     opcode: 'setPhysics',
      //     blockType: BlockType.COMMAND,
      //     text: formatMessage({
      //         id: 'griffpatch.setPhysics',
      //         default: 'enable physics for sprite [shape]',
      //         description: 'Enable Physics for this Sprite'
      //     }),
      //     arguments: {
      //         shape: {
      //             type: ArgumentType.STRING,
      //             menu: 'ShapeTypes',
      //             defaultValue: 'costume'
      //         }
      //     }
      // },
      // {
      //     opcode: 'setPhysicsAll',
      //     blockType: BlockType.COMMAND,
      //     text: formatMessage({
      //         id: 'griffpatch.setPhysicsAll',
      //         default: 'enable physics for all sprites',
      //         description: 'Enable Physics For All Sprites'
      //     })
      // },
      //
      '---', {
        opcode: 'doTick',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'griffpatch.doTick',
          default: 'step simulation',
          description: 'Run a single tick of the physics simulation'
        })
      }, '---', {
        opcode: 'setPosition',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'griffpatch.setPosition',
          default: 'go to x: [x] y: [y] [space]',
          description: 'Position Sprite'
        }),
        arguments: {
          x: {
            type: ArgumentType.NUMBER,
            defaultValue: 0
          },
          y: {
            type: ArgumentType.NUMBER,
            defaultValue: 0
          },
          space: {
            type: ArgumentType.STRING,
            menu: 'SpaceTypes',
            defaultValue: 'world'
          }
        }
      }, '---', // applyForce (target, ftype, x, y, dir, pow) {
      // applyAngForce (target, pow) {
      {
        opcode: 'setVelocity',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'griffpatch.setVelocity',
          default: 'set velocity to sx: [sx] sy: [sy]',
          description: 'Set Velocity'
        }),
        arguments: {
          sx: {
            type: ArgumentType.NUMBER,
            defaultValue: 0
          },
          sy: {
            type: ArgumentType.NUMBER,
            defaultValue: 0
          }
        }
      }, {
        opcode: 'changeVelocity',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'griffpatch.changeVelocity',
          default: 'change velocity by sx: [sx] sy: [sy]',
          description: 'Change Velocity'
        }),
        arguments: {
          sx: {
            type: ArgumentType.NUMBER,
            defaultValue: 0
          },
          sy: {
            type: ArgumentType.NUMBER,
            defaultValue: 0
          }
        }
      }, {
        opcode: 'getVelocityX',
        text: formatMessage({
          id: 'griffpatch.getVelocityX',
          default: 'x velocity',
          description: 'get the x velocity'
        }),
        blockType: BlockType.REPORTER
      }, {
        opcode: 'getVelocityY',
        text: formatMessage({
          id: 'griffpatch.getVelocityY',
          default: 'y velocity',
          description: 'get the y velocity'
        }),
        blockType: BlockType.REPORTER
      }, '---', {
        opcode: 'applyForce',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'griffpatch.applyForce',
          default: 'push with force [force] in direction [dir]',
          description: 'Push this object in a given direction'
        }),
        arguments: {
          force: {
            type: ArgumentType.NUMBER,
            defaultValue: 25
          },
          dir: {
            type: ArgumentType.NUMBER,
            defaultValue: 0
          }
        }
      }, {
        opcode: 'applyAngForce',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'griffpatch.applyAngForce',
          default: 'spin with force [force]',
          description: 'Push this object in a given direction'
        }),
        arguments: {
          force: {
            type: ArgumentType.NUMBER,
            defaultValue: 500
          }
        }
      }, '---', {
        opcode: 'setStatic',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'griffpatch.setStatic',
          default: 'set fixed [static]',
          description: 'Sets whether this block is static or dynamic'
        }),
        arguments: {
          static: {
            type: ArgumentType.STRING,
            menu: 'StaticTypes',
            defaultValue: 'static'
          }
        }
      }, // {
      //     opcode: 'setDensity',
      //     blockType: BlockType.COMMAND,
      //     text: formatMessage({
      //         id: 'griffpatch.setDensity',
      //         default: 'set density [density]',
      //         description: 'Set the density of the object'
      //     }),
      //     arguments: {
      //         density: {
      //             type: ArgumentType.NUMBER,
      //             defaultValue: 1
      //         }
      //     }
      // },
      {
        opcode: 'setProperties',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'griffpatch.setProperties',
          default: 'set density [density] roughness [friction] bounce [restitution]',
          description: 'Set the density of the object'
        }),
        arguments: {
          density: {
            type: ArgumentType.NUMBER,
            menu: 'DensityTypes',
            defaultValue: 100
          },
          friction: {
            type: ArgumentType.NUMBER,
            menu: 'FrictionTypes',
            defaultValue: 50
          },
          restitution: {
            type: ArgumentType.NUMBER,
            menu: 'RestitutionTypes',
            defaultValue: 20
          }
        }
      }, // {
      //     opcode: 'pinSprite',
      //     blockType: BlockType.COMMAND,
      //     text: formatMessage({
      //         id: 'griffpatch.pinSprite',
      //         default: 'pin to world at sprite\'s x: [x] y: [y]',
      //         description: 'Pin the sprite'
      //     }),
      //     arguments: {
      //         x: {
      //             type: ArgumentType.NUMBER,
      //             defaultValue: 0
      //         },
      //         y: {
      //             type: ArgumentType.NUMBER,
      //             defaultValue: 0
      //         }
      //     }
      // },
      '---', {
        opcode: 'getTouching',
        text: formatMessage({
          id: 'griffpatch.getTouching',
          default: 'touching [where]',
          description: 'get the name of any sprites we are touching'
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          where: {
            type: ArgumentType.STRING,
            menu: 'WhereTypes',
            defaultValue: 'any'
          }
        }
      }, // Scene Scrolling -------------------
      '---', {
        opcode: 'setScroll',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'griffpatch.setScroll',
          default: 'set scroll x: [ox] y: [oy]',
          description: 'Sets whether this block is static or dynamic'
        }),
        arguments: {
          ox: {
            type: ArgumentType.NUMBER,
            defaultValue: 0
          },
          oy: {
            type: ArgumentType.NUMBER,
            defaultValue: 0
          }
        }
      }, {
        opcode: 'changeScroll',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'griffpatch.changeScroll',
          default: 'change scroll by x: [ox] y: [oy]',
          description: 'Sets whether this block is static or dynamic'
        }),
        arguments: {
          ox: {
            type: ArgumentType.NUMBER,
            defaultValue: 0
          },
          oy: {
            type: ArgumentType.NUMBER,
            defaultValue: 0
          }
        }
      }, {
        opcode: 'getScrollX',
        text: formatMessage({
          id: 'griffpatch.getScrollX',
          default: 'x scroll',
          description: 'get the x scroll'
        }),
        blockType: BlockType.REPORTER
      }, {
        opcode: 'getScrollY',
        text: formatMessage({
          id: 'griffpatch.getScrollY',
          default: 'y scroll',
          description: 'get the y scroll'
        }),
        blockType: BlockType.REPORTER
      } // {
      //     opcode: 'getStatic',
      //     text: formatMessage({
      //         id: 'griffpatch.getStatic',
      //         default: 'Static?',
      //         description: 'get whether this sprite is static'
      //     }),
      //     blockType: BlockType.BOOLEAN
      // }
      ],
      menus: {
        StageTypes: this.STAGE_TYPE_MENU,
        SpaceTypes: this.SPACE_TYPE_MENU,
        WhereTypes: this.WHERE_TYPE_MENU,
        ShapeTypes: this.SHAPE_TYPE_MENU,
        EnableModeTypes: this.ENABLE_TYPES_TYPE_MENU,
        StaticTypes: this.STATIC_TYPE_MENU,
        FrictionTypes: this.FRICTION_TYPE_MENU,
        RestitutionTypes: this.RESTITUTION_TYPE_MENU,
        DensityTypes: this.DENSITY_TYPE_MENU
      }
    };
  }

  get STAGE_TYPE_MENU() {
    return [{
      text: 'boxed stage',
      value: STAGE_TYPE_OPTIONS.BOXED
    }, {
      text: 'open (with floor)',
      value: STAGE_TYPE_OPTIONS.FLOOR
    }, {
      text: 'open (no floor)',
      value: STAGE_TYPE_OPTIONS.OPEN
    }];
  }

  get SPACE_TYPE_MENU() {
    return [{
      text: 'in world',
      value: SPACE_TYPE_OPTIONS.WORLD
    }, {
      text: 'on stage',
      value: SPACE_TYPE_OPTIONS.STAGE
    }, {
      text: 'relative',
      value: SPACE_TYPE_OPTIONS.RELATIVE
    }];
  }

  get WHERE_TYPE_MENU() {
    return [{
      text: 'any',
      value: WHERE_TYPE_OPTIONS.ANY
    }, {
      text: 'feet',
      value: WHERE_TYPE_OPTIONS.FEET
    }];
  }

  get SHAPE_TYPE_MENU() {
    return [{
      text: 'this costume',
      value: SHAPE_TYPE_OPTIONS.COSTUME
    }, {
      text: 'this circle',
      value: SHAPE_TYPE_OPTIONS.CIRCLE
    }, {
      text: 'this polygon',
      value: SHAPE_TYPE_OPTIONS.SVG_POLYGON
    }, {
      text: 'all sprites',
      value: SHAPE_TYPE_OPTIONS.ALL
    }];
  }

  get ENABLE_TYPES_TYPE_MENU() {
    return [{
      text: 'normal',
      value: 'normal'
    }, {
      text: 'precision',
      value: 'bullet'
    }];
  }

  get STATIC_TYPE_MENU() {
    return [{
      text: 'free',
      value: 'dynamic'
    }, {
      text: 'fixed in place',
      value: 'static'
    }, {
      text: 'fixed (but can rotate)',
      value: 'pinned'
    }];
  }

  get DENSITY_TYPE_MENU() {
    return [{
      text: 'very light',
      value: '25'
    }, {
      text: 'light',
      value: '50'
    }, {
      text: 'normal',
      value: '100'
    }, {
      text: 'heavy',
      value: '200'
    }, {
      text: 'very heavy',
      value: '400'
    }];
  }

  get FRICTION_TYPE_MENU() {
    return [{
      text: 'none',
      value: '0'
    }, {
      text: 'smooth',
      value: '20'
    }, {
      text: 'normal',
      value: '50'
    }, {
      text: 'rough',
      value: '75'
    }, {
      text: 'extremely rough',
      value: '100'
    }];
  }

  get RESTITUTION_TYPE_MENU() {
    return [{
      text: 'none',
      value: '0'
    }, {
      text: 'little',
      value: '10'
    }, {
      text: 'normal',
      value: '20'
    }, {
      text: 'quite bouncy',
      value: '40'
    }, {
      text: 'very bouncy',
      value: '70'
    }, {
      text: 'unstable',
      value: '100'
    }];
  }
  /**
   * Play a drum sound for some number of beats.
   * @property {number} x - x offset.
   * @property {number} y - y offset.
   */


  doTick() {
    // args, util) {
    // this._playDrumForBeats(args.DRUM, args.BEATS, util);
    // if (util.runtime.audioEngine === null) return;
    // if (util.target.sprite.soundBank === null) return;
    // const dx = Cast.toNumber(args.x);
    // const dy = Cast.toNumber(args.y);
    // const allTargets = this.runtime.targets;
    // if (allTargets === null) return;
    // for (let i = 0; i < allTargets.length; i++) {
    //     const target = allTargets[i];
    //     if (!target.isStage) {
    //         target.setXY(target.x + dx, target.y + dy);
    //     }
    // }
    // util.target.setXY(util.target.x + dx, util.target.y + dy);
    // Matter.Engine.update(this.engine, 1000 / 30);
    this._checkMoved(); // world.Step(1 / 30, 10, 10);


    world.Step(1 / 30, 10, 10);
    world.ClearForces();

    for (const targetID in bodies) {
      const body = bodies[targetID];
      const target = this.runtime.getTargetById(targetID);

      if (!target) {
        // Drop target from simulation
        world.DestroyBody(body);
        delete bodies[targetID];
        delete prevPos[targetID];
        continue;
      }

      const position = body.GetPosition();

      _setXY(target, position.x * zoom - _scroll.x, position.y * zoom - _scroll.y);

      if (target.rotationStyle === RenderedTarget.ROTATION_STYLE_ALL_AROUND) {
        target.setDirection(90 - body.GetAngle() / toRad);
      }

      prevPos[targetID] = {
        x: target.x,
        y: target.y,
        dir: target.direction
      };
    }
  }

  _checkMoved() {
    for (const targetID in bodies) {
      const body = bodies[targetID];
      const target = this.runtime.getTargetById(targetID);

      if (!target) {
        // Drop target from simulation
        world.DestroyBody(body);
        delete bodies[targetID];
        delete prevPos[targetID];
        continue;
      }

      const prev = prevPos[targetID];
      const fixedRotation = target.rotationStyle !== RenderedTarget.ROTATION_STYLE_ALL_AROUND;

      if (prev && (prev.x !== target.x || prev.y !== target.y)) {
        const pos = new b2Vec2((target.x + _scroll.x) / zoom, (target.y + _scroll.y) / zoom);

        this._setPosition(body, pos);

        if (!fixedRotation) {
          body.SetAngle((90 - target.direction) * toRad);
        }

        body.SetAwake(true);
      } else if (!fixedRotation && prev && prev.dir !== target.direction) {
        body.SetAngle((90 - target.direction) * toRad);
        body.SetAwake(true);
      }
    }
  }
  /**
   * Play a drum sound for some number of beats.
   * @property {number} x - x offset.
   * @property {number} y - y offset.
   */


  setPhysicsAll() {
    const allTargets = this.runtime.targets;
    if (allTargets === null) return;

    for (let i = 0; i < allTargets.length; i++) {
      const target = allTargets[i];

      if (!target.isStage && !bodies[target.id]) {
        this.setPhysicsFor(target);
      }
    }
  }
  /**
   * Play a drum sound for some number of beats.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {string} shape - the shape
   */


  setPhysics(args, util) {
    // this._playDrumForBeats(args.DRUM, args.BEATS, util);
    // if (util.runtime.audioEngine === null) return;
    // if (util.target.sprite.soundBank === null) return;
    // const dx = Cast.toNumber(args.x);
    // const dy = Cast.toNumber(args.y);
    if (args.shape === SHAPE_TYPE_OPTIONS.ALL) {
      this.setPhysicsAll();
      return;
    }

    const target = util.target;
    const body = this.setPhysicsFor(target, args.shape);

    if (body) {
      body.SetBullet(args.mode === 'bullet');
    }
  }

  setPhysicsFor(target, shape) {
    const r = this.runtime.renderer;
    const drawable = r._allDrawables[target.drawableID]; // Tell the Drawable about its updated convex hullPoints, if necessary.

    if (drawable.needsConvexHullPoints()) {
      const points = r._getConvexHullPointsForDrawable(target.drawableID);

      drawable.setConvexHullPoints(points);
    } // if (drawable._transformDirty) {
    //     drawable._calculateTransform();
    // }
    // const points = drawable._getTransformedHullPoints();
    //
    // const hullPoints = [];
    // for (const i in points) {
    //     hullPoints.push({x: points[i][0] - target.x, y: points[i][1] - target.y});
    // }


    const points = drawable._convexHullPoints;
    const scaleX = drawable.scale[0] / 100;
    const scaleY = drawable.scale[1] / -100; // Flip Y for hulls

    const offset = drawable.skin.rotationCenter;
    let allHulls = null;

    if (shape === SHAPE_TYPE_OPTIONS.CIRCLE) {
      fixDef.shape = new b2CircleShape();
      const size = drawable.skin.size;
      fixDef.shape.SetRadius((size[0] * Math.abs(scaleX) + size[1] * Math.abs(scaleY)) / 4.0 / zoom); // fixDef.shape.SetRadius((drawable.getBounds().width / 2) / zoom);
    } else if (shape === SHAPE_TYPE_OPTIONS.SVG_POLYGON) {
      const svg = drawable._skin._svgRenderer._svgTag; // recurse through childNodes of type 'g', looking for type 'path'

      const hullPoints = [];

      if (svg) {
        this._fetchPolygonPointsFromSVG(svg, hullPoints, offset[0], offset[1], scaleX, scaleY);
      }

      _definePolyFromHull(hullPoints[0]);

      allHulls = hullPoints;
    } else {
      const hullPoints = [];

      for (const i in points) {
        hullPoints.push({
          x: (points[i][0] - offset[0]) * scaleX,
          y: (points[i][1] - offset[1]) * scaleY
        });
      }

      _definePolyFromHull(hullPoints);
    }

    const fixedRotation = target.rotationStyle !== RenderedTarget.ROTATION_STYLE_ALL_AROUND;

    const body = _placeBody(target.id, target.x, target.y, fixedRotation ? 90 : target.direction);

    if (target.rotationStyle !== RenderedTarget.ROTATION_STYLE_ALL_AROUND) {
      body.SetFixedRotation(true);
    }

    if (allHulls) {
      for (let i = 1; i < allHulls.length; i++) {
        _definePolyFromHull(allHulls[i]);

        body.CreateFixture(fixDef);
      }
    }

    return body;
  }
  /**
   *
   * @param svg the svg element
   * @param {Array} hullPointsList array of points
   * @private
   */


  _fetchPolygonPointsFromSVG(svg, hullPointsList, ox, oy, scaleX, scaleY) {
    if (svg.tagName === 'g' || svg.tagName === 'svg') {
      if (svg.hasChildNodes()) {
        for (const node of svg.childNodes) {
          this._fetchPolygonPointsFromSVG(node, hullPointsList, ox, oy, scaleX, scaleY);
        }
      }

      return;
    }

    if (svg.tagName !== 'path') {
      return;
    } // This is it boys! Get that svg data :)
    // <path xmlns="http://www.w3.org/2000/svg" d="M 1 109.7118 L 1 1.8097 L 60.3049 38.0516 L 117.9625 1.8097 L 117.9625 109.7118 L 59.8931 73.8817 Z "
    //  data-paper-data="{&quot;origPos&quot;:null}" stroke-width="2" fill="#9966ff"/>


    let fx;
    let fy;
    const hullPoints = [];
    hullPointsList.push(hullPoints);
    const tokens = svg.getAttribute('d').split(' ');

    for (let i = 0; i < tokens.length;) {
      const token = tokens[i++];

      if (token === 'M' || token === 'L') {
        const x = Cast.toNumber(tokens[i++]);
        const y = Cast.toNumber(tokens[i++]);
        hullPoints.push({
          x: (x - ox) * scaleX,
          y: (y - oy) * scaleY
        });

        if (token === 'M') {
          fx = x;
          fy = y;
        }
      }

      if (token === 'Z') {
        hullPoints.push({
          x: (fx - ox) * scaleX,
          y: (fy - oy) * scaleY
        });
      }
    }
  }

  applyForce(args, util) {
    _applyForce(util.target.id, 'Impulse', 0, 0, Cast.toNumber(args.dir), Cast.toNumber(args.force));
  }

  applyAngForce(args, util) {
    let body = bodies[util.target.id];

    if (!body) {
      body = this.setPhysicsFor(util.target);
    }

    body.ApplyTorque(-Cast.toNumber(args.force));
  }

  setDensity(args, util) {
    let body = bodies[util.target.id];

    if (!body) {
      body = this.setPhysicsFor(util.target);
    }

    body.GetFixtureList().SetDensity(Cast.toNumber(args.density));
    body.ResetMassData();
  }

  setProperties(args, util) {
    let body = bodies[util.target.id];

    if (!body) {
      body = this.setPhysicsFor(util.target);
    }

    body.GetFixtureList().SetDensity(Cast.toNumber(args.density) / 100.0);
    body.GetFixtureList().SetFriction(Cast.toNumber(args.friction) / 100.0);
    body.GetFixtureList().SetRestitution(Cast.toNumber(args.restitution) / 100.0);
    body.ResetMassData();
  }

  pinSprite(args, util) {
    if (!bodies[util.target.id]) {
      this.setPhysicsFor(util.target);
    }

    const x = Cast.toNumber(args.x);
    const y = Cast.toNumber(args.y);

    _createJointOfType(null, 'Rotating', util.target.id, x, y, null, null, null);
  }
  /**
   * Set's the sprites position.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {number} x - x offset.
   * @property {number} y - y offset.
   * @property {string} space - Space type (SPACE_TYPE_OPTIONS)
   */


  setPosition(args, util) {
    const x = Cast.toNumber(args.x);
    const y = Cast.toNumber(args.y);
    const body = bodies[util.target.id];

    switch (args.space) {
      case SPACE_TYPE_OPTIONS.STAGE:
        _setXY(util.target, x, y); // Position on stage (after scroll)


        if (body) {
          this._setPosition(body, new b2Vec2((x + _scroll.x) / zoom, (y + _scroll.y) / zoom));
        }

        break;

      case SPACE_TYPE_OPTIONS.RELATIVE:
        {
          _setXY(util.target, util.target.x + x, util.target.x + y);

          if (body) {
            const pos = body.GetPosition();
            const pos2 = new b2Vec2(pos.x + x / zoom, pos.y + y / zoom);

            this._setPosition(body, pos2);
          }

          break;
        }

      default:
        _setXY(util.target, x - _scroll.x, y - _scroll.y);

        if (body) {
          this._setPosition(body, new b2Vec2(x / zoom, y / zoom));
        }

    }
  }

  _setPosition(body, pos2) {
    const md = pinned[body.uid];

    if (md) {
      world.DestroyJoint(md);
      pinned[body.uid] = _createJointOfType(null, 'Rotating', body.uid, 0, 0, null, pos2.x * zoom, pos2.y * zoom);
    }

    body.SetPosition(pos2); // if (md) {
    //     pinned[body.uid] = _createJointOfType(null, 'Rotating', body.uid, 0, 0, null, null, null);
    // }
  }
  /**
   * Set the sprites velocity.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {number} sx - speed x.
   * @property {number} sy - speed y.
   */


  setVelocity(args, util) {
    let body = bodies[util.target.id];

    if (!body) {
      body = this.setPhysicsFor(util.target);
    }

    body.SetAwake(true);
    const x = Cast.toNumber(args.sx);
    const y = Cast.toNumber(args.sy);
    const force = new b2Vec2(x, y);
    force.Multiply(30 / zoom);
    body.SetLinearVelocity(force);
  }
  /**
   * Change the sprites velocity.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {number} sx - speed x.
   * @property {number} sy - speed y.
   */


  changeVelocity(args, util) {
    let body = bodies[util.target.id];

    if (!body) {
      body = this.setPhysicsFor(util.target);
    }

    body.SetAwake(true);
    const x = Cast.toNumber(args.sx);
    const y = Cast.toNumber(args.sy);
    const force = new b2Vec2(x, y);
    force.Multiply(30 / zoom);
    force.Add(body.GetLinearVelocity());
    body.SetLinearVelocity(force);
  }
  /**
   * Get the current tempo.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @return {boolean} - the current tempo, in beats per minute.
   */


  getStatic(args, util) {
    const body = bodies[util.target.id];

    if (!body) {
      return false;
    }

    const type = body.GetType();
    return type === b2Body.b2_staticBody;
  }
  /**
   * Get the current tempo.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @return {number} - the current x velocity.
   */


  getVelocityX(args, util) {
    const body = bodies[util.target.id];

    if (!body) {
      return 0;
    }

    const x = body.GetLinearVelocity().x;
    return x * zoom / 30;
  }
  /**
   * Get the current tempo.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @return {boolean} - the current y velocity.
   */


  getVelocityY(args, util) {
    const body = bodies[util.target.id];

    if (!body) {
      return 0;
    }

    const y = body.GetLinearVelocity().y;
    return y * zoom / 30;
  }
  /**
   * Sets the static property
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {string} static - static or not
   */


  setStatic(args, util) {
    const target = util.target;
    let body = bodies[util.target.id];

    if (!body) {
      body = this.setPhysicsFor(target);
    }

    body.SetType(args.static === 'static' ? b2Body.b2_staticBody : b2Body.b2_dynamicBody);
    const pos = new b2Vec2((target.x + _scroll.x) / zoom, (target.y + _scroll.y) / zoom);
    const fixedRotation = target.rotationStyle !== RenderedTarget.ROTATION_STYLE_ALL_AROUND;
    body.SetPositionAndAngle(pos, fixedRotation ? 0 : (90 - target.direction) * toRad);

    if (args.static === 'pinned') {
      // Find what's behind the sprite (pin to that)
      const point = new b2AABB();
      point.lowerBound.SetV(pos);
      point.upperBound.SetV(pos);
      let body2ID = null;
      world.QueryAABB(fixture => {
        const body2 = fixture.GetBody();

        if (body2 !== body && fixture.TestPoint(pos.x, pos.y)) {
          body2ID = body2.uid;
          return false;
        }

        return true;
      }, point);
      pinned[target.id] = _createJointOfType(null, 'Rotating', target.id, 0, 0, body2ID, null, null);
    } else {
      const pin = pinned[target.id];

      if (pin) {
        world.DestroyJoint(pin); // delete joints[pin.I];

        delete pinned[target.id];
      }
    }
  }
  /**
   * Sets the sprite offset
   * @param {object} args - the block arguments.
   * @property {number} ox - x offset.
   * @property {number} oy - y offset.
   */


  setScroll(args) {
    this._checkMoved();

    _scroll.x = Cast.toNumber(args.ox);
    _scroll.y = Cast.toNumber(args.oy);

    this._repositionBodies();
  }
  /**
   * Sets the sprite offset
   * @param {object} args - the block arguments.
   * @property {number} ox - x offset.
   * @property {number} oy - y offset.
   */


  changeScroll(args) {
    this._checkMoved();

    _scroll.x += Cast.toNumber(args.ox);
    _scroll.y += Cast.toNumber(args.oy);

    this._repositionBodies();
  }
  /**
   * Get the scroll x.
   * @return {number} - the current x velocity.
   */


  getScrollX() {
    return _scroll.x;
  }
  /**
   * Get the scroll x.
   * @return {number} - the current x velocity.
   */


  getScrollY() {
    return _scroll.y;
  }

  _repositionBodies() {
    for (const targetID in bodies) {
      const body = bodies[targetID];
      const target = this.runtime.getTargetById(targetID);

      if (target) {
        const position = body.GetPosition();

        _setXY(target, position.x * zoom - _scroll.x, position.y * zoom - _scroll.y);

        prevPos[targetID] = {
          x: target.x,
          y: target.y,
          dir: target.direction
        };
      }
    }
  }

  getTouching(args, util) {
    const target = util.target;
    const body = bodies[target.id];

    if (!body) {
      return '';
    }

    const where = args.where;
    let touching = '';
    const contacts = body.GetContactList();

    for (let ce = contacts; ce; ce = ce.next) {
      // noinspection JSBitwiseOperatorUsage
      if (ce.contact.m_flags & b2Contact.e_islandFlag) {
        continue;
      }

      if (ce.contact.IsSensor() === true || ce.contact.IsEnabled() === false || ce.contact.IsTouching() === false) {
        continue;
      }

      const contact = ce.contact;
      const fixtureA = contact.GetFixtureA();
      const fixtureB = contact.GetFixtureB();
      const bodyA = fixtureA.GetBody();
      const bodyB = fixtureB.GetBody(); // const myFix = touchingB ? fixtureA : fixtureB;

      const touchingB = bodyA === body;

      if (where !== 'any') {
        const man = new Box2D.Collision.b2WorldManifold();
        contact.GetWorldManifold(man); // man.m_points
        // const mx = man.m_normal.x;
        // const my = man.m_normal.y;

        if (where === 'feet') {
          // if (my > -0.6) {
          //     continue;
          // }
          const fixture = body.GetFixtureList();
          const y = man.m_points[0].y;

          if (y > fixture.m_aabb.lowerBound.y * 0.75 + fixture.m_aabb.upperBound.y * 0.25) {
            continue;
          } // const lp = body.GetLocalPoint(man.m_points[0]).Normalize();
          // if (lp.y)

        }
      }

      const other = touchingB ? bodyB : bodyA;
      const uid = other.uid;
      const target2 = uid ? this.runtime.getTargetById(uid) : this.runtime.getTargetForStage();

      if (target2) {
        const name = target2.sprite.name;

        if (touching.length === 0) {
          touching = name;
        } else {
          touching += ",".concat(name);
        }
      }
    }

    return touching;
  }
  /**
   * Sets the stage
   * @param {object} args - the block arguments.
   * @property {number} stageType - Stage Type.
   */


  setStage(args) {
    _setStageType(args.stageType);
  }
  /**
   * Sets the gravity
   * @param {object} args - the block arguments.
   * @property {number} gx - Gravity x.
   * @property {number} gy - Gravity y.
   */


  setGravity(args) {
    world.SetGravity(new b2Vec2(Cast.toNumber(args.gx), Cast.toNumber(args.gy)));

    for (const bodyID in bodies) {
      bodies[bodyID].SetAwake(true);
    }
  }

}

module.exports = Scratch3Griffpatch;

/***/ }),

/***/ "./src/extensions/jg_files/index.js":
/*!******************************************!*\
  !*** ./src/extensions/jg_files/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const formatMessage = __webpack_require__(/*! format-message */ "format-message");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js"); // const Cast = require('../../util/cast');

/**
 * Class for File blocks
 * @constructor
 */


class JgFilesBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: 'jgFiles',
      name: 'Files',
      color1: '#ffbb00',
      color2: '#ffaa00',
      // docsURI: 'https://docs.turbowarp.org/blocks',
      blocks: [{
        opcode: 'isFileReaderSupported',
        text: formatMessage({
          id: 'jgFiles.blocks.canFilesBeUsed',
          default: 'can files be used?',
          description: 'Block that returns whether the user\'s machine allows for Scratch to read their files'
        }),
        disableMonitor: false,
        blockType: BlockType.BOOLEAN
      }, {
        opcode: 'askUserForFile',
        text: formatMessage({
          id: 'jgFiles.blocks.askUserForFile',
          default: 'ask user for a file',
          description: 'Block that returns the contents of a file the user provides. The block will return no text if it was rejected.'
        }),
        disableMonitor: true,
        blockType: BlockType.REPORTER
      }, {
        opcode: 'askUserForFileOfType',
        text: formatMessage({
          id: 'jgFiles.blocks.askUserForFileOfType',
          default: 'ask user for a file of type [FILE_TYPE]',
          description: 'Block that returns the contents of a file the user provides. The file picker will only allow the file types specified. The block will return no text if it was rejected.'
        }),
        disableMonitor: true,
        blockType: BlockType.REPORTER,
        arguments: {
          FILE_TYPE: {
            type: ArgumentType.STRING,
            defaultValue: formatMessage({
              id: 'jgFiles.file_type_accept_area',
              default: 'txt savefile',
              description: 'Default file types accepted for the file picker on the ask user for file block'
            })
          }
        }
      }, {
        opcode: 'downloadFile',
        text: formatMessage({
          id: 'jgFiles.blocks.downloadFile',
          default: 'download content [FILE_CONTENT] as file name [FILE_NAME]',
          description: 'Block that downloads a file. The content is what the file has inside, and the file name is what the file will save as on the user\'s computer.'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          FILE_CONTENT: {
            type: ArgumentType.STRING,
            defaultValue: formatMessage({
              id: 'jgFiles.file_content_name_area',
              default: 'Hello!',
              description: 'Default text for the file\'s content'
            })
          },
          FILE_NAME: {
            type: ArgumentType.STRING,
            defaultValue: formatMessage({
              id: 'jgFiles.file_name_name_area',
              default: 'text.txt',
              description: 'Default text for the file\'s name'
            })
          }
        }
      }] // menus: {
      // mouseButton: {
      // items: [
      // {
      // text: formatMessage({
      // id: 'tw.blocks.mouseButton.primary',
      // default: '(0) primary',
      // description: 'Dropdown item to select primary (usually left) mouse button'
      // }),
      // value: '0'
      // },
      // {
      // text: formatMessage({
      // id: 'tw.blocks.mouseButton.middle',
      // default: '(1) middle',
      // description: 'Dropdown item to select middle mouse button'
      // }),
      // value: '1'
      // },
      // {
      // text: formatMessage({
      // id: 'tw.blocks.mouseButton.secondary',
      // default: '(2) secondary',
      // description: 'Dropdown item to select secondary (usually right) mouse button'
      // }),
      // value: '2'
      // }
      // ],
      // acceptReporters: true
      // }
      // }

    };
  }

  isFileReaderSupported()
  /*args, util*/
  {
    return window.FileReader != null && window.document != null;
  }

  __askUserForFile(acceptTypes) {
    return new Promise((resolve, _) => {
      const fileReader = new FileReader();

      fileReader.onload = e => {
        resolve(e.target.result);
      };

      const input = document.createElement("input");
      input.type = "file";

      if (acceptTypes != null) {
        input.accept = acceptTypes;
      }

      input.style.display = "none";
      document.body.append(input);

      input.onchange = () => {
        const file = input.files[0];

        if (!file) {
          resolve("");
          return;
        } else {
          fileReader.readAsText(file);
        }

        input.remove();
      };

      input.onblur = () => {
        input.onchange();
      };

      input.focus();
      input.click();
    });
  }

  askUserForFile(args, util) {
    return this.__askUserForFile(null);
  }

  askUserForFileOfType(args, util) {
    const fileTypesAllowed = [];
    const input = String(args.FILE_TYPE).toLowerCase().replace(/.,/gmi, "");
    if (input == "any") return this.__askUserForFile(null);
    input.split(" ").forEach(type => {
      fileTypesAllowed.push("." + type);
    });
    return this.__askUserForFile(fileTypesAllowed.join(","));
  }

  downloadFile(args, util) {
    let content = "";
    let fileName = "text.txt";
    content = String(args.FILE_CONTENT);
    fileName = String(args.FILE_NAME);
    const blob = new Blob([content]);
    const a = document.createElement("a");
    a.style.display = "none";
    document.body.append(a);
    const url = window.URL.createObjectURL(blob);
    a.href = url;
    a.download = fileName;
    a.click();
    window.URL.revokeObjectURL(url);
    a.remove();
  }

}

module.exports = JgFilesBlocks;

/***/ }),

/***/ "./src/extensions/jg_json/index.js":
/*!*****************************************!*\
  !*** ./src/extensions/jg_json/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const formatMessage = __webpack_require__(/*! format-message */ "format-message");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js"); // const Cast = require('../../util/cast');

/**
 * Class for JSON blocks
 * @constructor
 */


class JgJSONBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: 'jgJSON',
      name: 'JSON',
      color1: '#0FBD8C',
      color2: '#0EAF82',
      blocks: [{
        opcode: 'getValueFromJSON',
        text: formatMessage({
          id: 'jgJSON.blocks.getValueFromJSON',
          default: 'get [VALUE] from [JSON]',
          description: 'Gets a value from a JSON object.'
        }),
        disableMonitor: true,
        blockType: BlockType.REPORTER,
        arguments: {
          VALUE: {
            type: ArgumentType.STRING,
            defaultValue: formatMessage({
              id: 'jgJSON.getValueFromJSON_value',
              default: 'key',
              description: 'The name of the item you want to get from the JSON.'
            })
          },
          JSON: {
            type: ArgumentType.STRING,
            defaultValue: '{"key": "value"}'
          }
        }
      }, {
        opcode: 'setValueToKeyInJSON',
        text: formatMessage({
          id: 'jgJSON.blocks.setValueToKeyInJSON',
          default: 'set [VALUE] to [KEY] in [JSON]',
          description: 'Returns the JSON with the key set to the value.'
        }),
        disableMonitor: true,
        blockType: BlockType.REPORTER,
        arguments: {
          VALUE: {
            type: ArgumentType.STRING,
            defaultValue: formatMessage({
              id: 'jgJSON.setValueToKeyInJSON_value',
              default: 'value',
              description: 'The value of the key you are setting.'
            })
          },
          KEY: {
            type: ArgumentType.STRING,
            defaultValue: formatMessage({
              id: 'jgJSON.setValueToKeyInJSON_key',
              default: 'key',
              description: 'The key you are setting in the JSON.'
            })
          },
          JSON: {
            type: ArgumentType.STRING,
            defaultValue: "{}"
          }
        }
      }]
    };
  }

  getValueFromJSON(args) {
    const jsonString = String(args.JSON);
    const key = String(args.VALUE);
    let canParseJSON = true;

    try {
      JSON.parse(jsonString);
    } catch (_unused) {
      canParseJSON = false;
    }

    if (!canParseJSON) return "";
    const json = JSON.parse(jsonString);
    const checking = json[key];
    return Number(checking) ? Number(checking) : checking == null ? "null" : typeof checking == "object" || Array.isArray(checking) ? JSON.stringify(checking) : String(checking);
  }

  setValueToKeyInJSON(args) {
    const jsonString = String(args.JSON);
    const key = String(args.KEY);
    const value = String(args.VALUE);
    let canParseJSON = true;

    try {
      JSON.parse(jsonString);
    } catch (_unused2) {
      canParseJSON = false;
    }

    if (!canParseJSON) return "";
    const json = JSON.parse(jsonString);
    canParseJSON = true;

    try {
      JSON.parse(value);
    } catch (_unused3) {
      canParseJSON = false;
    }

    const checking = String(value);
    json[key] = checking == "true" ? true : checking == "false" ? false : Number(checking) ? Number(checking) : checking == "null" ? null : canParseJSON ? JSON.parse(checking) : checking;
    return JSON.stringify(json);
  }

}

module.exports = JgJSONBlocks;

/***/ }),

/***/ "./src/extensions/jg_prism/index.js":
/*!******************************************!*\
  !*** ./src/extensions/jg_prism/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const formatMessage = __webpack_require__(/*! format-message */ "format-message");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js"); // const Cast = require('../../util/cast');

/**
 * Class for Prism blocks
 * @constructor
 */


class JgPrismBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    this.audioPlayer = new Audio();
    this.isJSPermissionGranted = false;
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: 'jgPrism',
      name: 'Prism',
      color1: '#BC7FFF',
      color2: '#AD66FF',
      blocks: [{
        opcode: 'playAudioFromUrl',
        text: formatMessage({
          id: 'jgPrism.blocks.playAudioFromUrl',
          default: 'play audio from [URL]',
          description: 'Plays sound from a URL.'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          URL: {
            type: ArgumentType.STRING,
            defaultValue: 'https://synthesis-service.scratch.mit.edu/synth?locale=en-US&gender=female&text=hello'
          }
        }
      }, {
        opcode: 'setAudioToLooping',
        text: formatMessage({
          id: 'jgPrism.blocks.setAudioToLooping',
          default: 'set audio to loop',
          description: 'Sets the audio to be looping.'
        }),
        blockType: BlockType.COMMAND
      }, {
        opcode: 'setAudioToNotLooping',
        text: formatMessage({
          id: 'jgPrism.blocks.setAudioToNotLooping',
          default: 'set audio to not loop',
          description: 'Sets the audio to not be looping.'
        }),
        blockType: BlockType.COMMAND
      }, {
        opcode: 'pauseAudio',
        text: formatMessage({
          id: 'jgPrism.blocks.pauseAudio',
          default: 'pause audio',
          description: 'Pauses the audio player.'
        }),
        blockType: BlockType.COMMAND
      }, {
        opcode: 'playAudio',
        text: formatMessage({
          id: 'jgPrism.blocks.playAudio',
          default: 'resume audio',
          description: 'Resumes the audio player.'
        }),
        blockType: BlockType.COMMAND
      }, {
        opcode: 'setAudioPlaybackSpeed',
        text: formatMessage({
          id: 'jgPrism.blocks.setAudioPlaybackSpeed',
          default: 'set audio speed to [SPEED]%',
          description: 'Sets the speed of the audio player.'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          SPEED: {
            type: ArgumentType.NUMBER,
            defaultValue: 100
          }
        }
      }, {
        opcode: 'getAudioPlaybackSpeed',
        text: formatMessage({
          id: 'jgRuntime.blocks.getAudioPlaybackSpeed',
          default: 'audio speed',
          description: 'Block that returns the playback speed of the audio player.'
        }),
        disableMonitor: false,
        blockType: BlockType.REPORTER
      }, {
        opcode: 'setAudioPosition',
        text: formatMessage({
          id: 'jgPrism.blocks.setAudioPosition',
          default: 'set audio position to [POSITION] seconds',
          description: 'Sets the position of the current audio in the audio player.'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          POSITION: {
            type: ArgumentType.NUMBER,
            defaultValue: 5
          }
        }
      }, {
        opcode: 'getAudioPosition',
        text: formatMessage({
          id: 'jgRuntime.blocks.getAudioPosition',
          default: 'audio position',
          description: 'Block that returns the position of the audio player in the currently playing audio.'
        }),
        disableMonitor: false,
        blockType: BlockType.REPORTER
      }, {
        opcode: 'setAudioVolume',
        text: formatMessage({
          id: 'jgPrism.blocks.setAudioVolume',
          default: 'set audio volume to [VOLUME]%',
          description: 'Sets the volume of the current audio in the audio player.'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          VOLUME: {
            type: ArgumentType.NUMBER,
            defaultValue: 100
          }
        }
      }, {
        opcode: 'getAudioVolume',
        text: formatMessage({
          id: 'jgRuntime.blocks.getAudioVolume',
          default: 'audio volume',
          description: 'Block that returns the volume of the audio player.'
        }),
        disableMonitor: false,
        blockType: BlockType.REPORTER
      }, {
        opcode: 'evaluate',
        text: formatMessage({
          id: 'jgRuntime.blocks.evaluate',
          default: 'eval [JAVASCRIPT]',
          description: 'Block that runs JavaScript code.'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          JAVASCRIPT: {
            type: ArgumentType.STRING,
            defaultValue: "console.log('Hello!')"
          }
        }
      }, {
        opcode: 'evaluate2',
        text: formatMessage({
          id: 'jgRuntime.blocks.evaluate2',
          default: 'eval [JAVASCRIPT]',
          description: 'Block that runs JavaScript code and returns the result of it.'
        }),
        blockType: BlockType.REPORTER,
        disableMonitor: true,
        arguments: {
          JAVASCRIPT: {
            type: ArgumentType.STRING,
            defaultValue: "Math.random()"
          }
        }
      }, {
        opcode: 'screenshotStage',
        text: formatMessage({
          id: 'jgRuntime.blocks.screenshotStage',
          default: 'screenshot the stage',
          description: 'Block that screenshots the stage and returns a Data URI of it.'
        }),
        blockType: BlockType.REPORTER,
        disableMonitor: true
      }]
    };
  }

  playAudioFromUrl(args) {
    this.audioPlayer.pause();
    this.audioPlayer.src = "https://api.allorigins.win/raw?url=" + encodeURIComponent(String(args.URL));
    this.audioPlayer.currentTime = 0;
    this.audioPlayer.play();
  }

  setAudioToLooping() {
    this.audioPlayer.loop = true;
  }

  setAudioToNotLooping() {
    this.audioPlayer.loop = false;
  }

  pauseAudio() {
    this.audioPlayer.pause();
  }

  playAudio() {
    this.audioPlayer.play();
  }

  setAudioPlaybackSpeed(args) {
    this.audioPlayer.playbackRate = (isNaN(Number(args.SPEED)) ? 100 : Number(args.SPEED)) / 100;
  }

  getAudioPlaybackSpeed() {
    return this.audioPlayer.playbackRate * 100;
  }

  setAudioPosition(args) {
    this.audioPlayer.currentTime = isNaN(Number(args.POSITION)) ? 0 : Number(args.POSITION);
  }

  getAudioPosition() {
    return this.audioPlayer.currentTime;
  }

  setAudioVolume(args) {
    this.audioPlayer.volume = (isNaN(Number(args.VOLUME)) ? 100 : Number(args.VOLUME)) / 100;
  }

  getAudioVolume() {
    return this.audioPlayer.volume * 100;
  }

  evaluate(args) {
    if (!this.isJSPermissionGranted) {
      this.isJSPermissionGranted = confirm("Allow this project to run custom unsafe code?");
    }

    if (this.isJSPermissionGranted) {
      try {
        eval(String(args.JAVASCRIPT));
      } catch (e) {
        alert(e);
      }
    }
  }

  evaluate2(args) {
    if (!this.isJSPermissionGranted) {
      this.isJSPermissionGranted = confirm("Allow this project to run custom unsafe code?");
    }

    if (this.isJSPermissionGranted) {
      let result = "";

      try {
        result = eval(String(args.JAVASCRIPT));
      } catch (e) {
        result = e;
      }

      let canJsonParse = true;

      try {
        JSON.parse(result);
      } catch (_unused) {
        canJsonParse = false;
      }

      if (canJsonParse) return JSON.parse(result);else return result;
    } else {
      return "";
    }
  }

  screenshotStage() {
    return new Promise((resolve, _) => {
      vm.renderer.requestSnapshot(uri => {
        resolve(uri);
      });
    });
  }

}

module.exports = JgPrismBlocks;

/***/ }),

/***/ "./src/extensions/jg_runtime/index.js":
/*!********************************************!*\
  !*** ./src/extensions/jg_runtime/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const formatMessage = __webpack_require__(/*! format-message */ "format-message");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js"); // const Cast = require('../../util/cast');

/**
 * Class for Runtime blocks
 * @constructor
 */


class JgRuntimeBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    this.md5HashApi = "https://api.hashify.net/hash/md5/hex?value="; // costumes want MD5 hashes for asset IDs and just in general ig

    this.getImageSizeApi = "https://pm-bapi.vercel.app/api/getSize?url="; // costumes want their image size so they dont break lol

    this.generateMd5Hash = hashing => {
      return new Promise((resolve, _) => {
        fetch(this.md5HashApi + String(hashing)).then(res => {
          res.json().then(json => {
            if (!json.Digest) {
              console.warn("MD5 hash could not be generated. Fallback is resolving with random number.");
              resolve(Math.round(Math.random() * 99999999999)); // fallback to generating random numbers incase it is deemed good enough

              return;
            }

            resolve(String(json.Digest));
          }).catch(() => {
            console.warn("MD5 hash could not be generated. Fallback is resolving with random number.");
            resolve(Math.round(Math.random() * 99999999999)); // fallback to generating random numbers incase it is deemed good enough
          });
        }).catch(() => {
          console.warn("MD5 hash could not be generated. Fallback is resolving with random number.");
          resolve(Math.round(Math.random() * 99999999999)); // fallback to generating random numbers incase it is deemed good enough
        });
      });
    };

    this.getImageSize = imageUrl => {
      return new Promise((resolve, _) => {
        fetch(this.getImageSizeApi + encodeURIComponent(String(imageUrl))).then(res => {
          res.json().then(json => {
            resolve(json);
          }).catch(() => {
            resolve({
              width: 480,
              height: 360
            });
          });
        }).catch(() => {
          resolve({
            width: 480,
            height: 360
          });
        });
      });
    };
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: 'jgRuntime',
      name: 'Runtime',
      color1: '#777777',
      color2: '#555555',
      blocks: [{
        opcode: 'addCostumeUrl',
        text: formatMessage({
          id: 'jgRuntime.blocks.addCostumeUrl',
          default: 'add costume from [URL]',
          description: 'Adds a costume to the current sprite using the image at the URL. Returns the costume name.'
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          URL: {
            type: ArgumentType.STRING,
            defaultValue: 'https://en.scratch-wiki.info/w/images/thumb/ScratchCat-Small.png/200px-ScratchCat-Small.png'
          }
        }
      }, {
        opcode: 'deleteCostume',
        text: formatMessage({
          id: 'jgRuntime.blocks.deleteCostume',
          default: 'delete costume at index [COSTUME]',
          description: 'Deletes a costume at the specified index.'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          COSTUME: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        }
      }, {
        opcode: 'setStageSize',
        text: formatMessage({
          id: 'jgRuntime.blocks.setStageSize',
          default: 'set stage width: [WIDTH] height: [HEIGHT]',
          description: 'Sets the width and height of the stage.'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          WIDTH: {
            type: ArgumentType.NUMBER,
            defaultValue: 480
          },
          HEIGHT: {
            type: ArgumentType.NUMBER,
            defaultValue: 360
          }
        }
      }, {
        opcode: 'turboModeEnabled',
        text: formatMessage({
          id: 'jgRuntime.blocks.turboModeEnabled',
          default: 'turbo mode enabled?',
          description: 'Block that returns whether Turbo Mode is enabled on the project or not.'
        }),
        disableMonitor: false,
        blockType: BlockType.BOOLEAN
      }, {
        opcode: 'amountOfClones',
        text: formatMessage({
          id: 'jgRuntime.blocks.amountOfClones',
          default: 'clone count',
          description: 'Block that returns the amount of clones that currently exist.'
        }),
        disableMonitor: false,
        blockType: BlockType.REPORTER
      }, {
        opcode: 'getStageWidth',
        text: formatMessage({
          id: 'jgRuntime.blocks.getStageWidth',
          default: 'stage width',
          description: 'Block that returns the width of the stage.'
        }),
        disableMonitor: false,
        blockType: BlockType.REPORTER
      }, {
        opcode: 'getStageHeight',
        text: formatMessage({
          id: 'jgRuntime.blocks.getStageHeight',
          default: 'stage height',
          description: 'Block that returns the height of the stage.'
        }),
        disableMonitor: false,
        blockType: BlockType.REPORTER
      }, {
        opcode: 'setMaxFrameRate',
        text: formatMessage({
          id: 'jgRuntime.blocks.setMaxFrameRate',
          default: 'set max framerate to: [FRAMERATE]',
          description: 'Sets the max allowed framerate.'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          FRAMERATE: {
            type: ArgumentType.NUMBER,
            defaultValue: 30
          }
        }
      }, {
        opcode: 'getMaxFrameRate',
        text: formatMessage({
          id: 'jgRuntime.blocks.getMaxFrameRate',
          default: 'max framerate',
          description: 'Block that returns the amount of FPS allowed.'
        }),
        disableMonitor: false,
        blockType: BlockType.REPORTER
      }]
    };
  }

  addCostumeUrl(args, util) {
    return new Promise((resolve, reject) => {
      // console.warn('Runtime Block "add costume" is currently broken. Please avoid using it until the block is updated.');
      const Asset = vm.runtime.storage.Asset;
      const AssetType = vm.runtime.storage.AssetType;
      const URL = String(args.URL); // const COSTUME_SIZE_X = 480; // this will be changed in the future to the ACTUAL image size
      // const COSTUME_SIZE_Y = 360; // this will be changed in the future to the ACTUAL image size

      try {
        if (util.target.isSprite) {
          const sprite = util.target.sprite;
          const COSTUMES_CURRENTLY_IN_THE_SPRITE = sprite.costumes.length;
          const LAST_SKIN_ID = sprite.costumes[sprite.costumes.length - 1].skinId;
          const COSTUME_NAME = "runtime_" + String(encodeURIComponent(URL)).replace(/[^A-Za-z0-9]/gmi, "_").substring(0, 600) + String(10000 + Math.random() * 99999) + String((COSTUMES_CURRENTLY_IN_THE_SPRITE + LAST_SKIN_ID) * 3 + 11); // this.generateMd5Hash(COSTUME_NAME).then(GENERATED_MD5 => {

          const fetchedImageUrl = String(URL).startsWith("data:image/") ? String(URL) : "https://api.allorigins.win/raw?url=" + encodeURIComponent(URL);
          fetch(fetchedImageUrl).then(req => {
            if (req.headers.get("Content-Type") != "image/png" && req.headers.get("Content-Type") != "image/jpeg") return console.warn('Format', req.headers.get("Content-Type"), 'is not supported for costumes');

            if (req.status == 200) {
              this.getImageSize(fetchedImageUrl).then(IMAGE_SIZE => {
                const COSTUME_SIZE_X = IMAGE_SIZE.width;
                const COSTUME_SIZE_Y = IMAGE_SIZE.height;
                req.blob().then(blob => {
                  blob.arrayBuffer().then(arrayBuffer => {
                    const UINT8ARRAY_COSTUME_DATA = new Uint8Array(arrayBuffer, 0, arrayBuffer.byteLength);
                    const CONTENT_TYPE = req.headers.get("Content-Type");
                    const IMAGE_CONTENT_TYPE =
                    /*CONTENT_TYPE == "image/png" ? */
                    "ImageBitmap"; // : "ImageVector";

                    const FILE_EXTENSION = CONTENT_TYPE == "image/png" ? "png" : "jpg";
                    const ASSET = vm.runtime.storage.createAsset(AssetType[IMAGE_CONTENT_TYPE], FILE_EXTENSION, UINT8ARRAY_COSTUME_DATA, null, true);
                    const GENERATED_MD5 = ASSET.assetId;
                    const ROTATION_CENTER = {
                      x: Math.round(COSTUME_SIZE_X) / 2,
                      y: Math.round(COSTUME_SIZE_Y) / 2
                    };
                    const SKIN_ID = vm.renderer.createBitmapSkin(UINT8ARRAY_COSTUME_DATA, 1, [ROTATION_CENTER.x, ROTATION_CENTER.y]);
                    const costumeObject = {
                      asset: ASSET,
                      assetId: ASSET.assetId,
                      bitmapResolution: 1,
                      dataFormat: FILE_EXTENSION,
                      md5: GENERATED_MD5 + "." + FILE_EXTENSION,
                      name: COSTUME_NAME,
                      rotationCenterX: ROTATION_CENTER.x,
                      rotationCenterY: ROTATION_CENTER.y,
                      size: [COSTUME_SIZE_X, COSTUME_SIZE_Y],
                      skinId: SKIN_ID
                    };
                    sprite.addCostumeAt(costumeObject, COSTUMES_CURRENTLY_IN_THE_SPRITE);
                    resolve(COSTUME_NAME);
                  });
                });
              });
            } else {
              console.warn("Failed to fetch costume");
            }
          }); // })
        }
      } catch (e) {
        console.warn(e);
      }
    });
  }

  deleteCostume(args, util) {
    const index = (Number(args.COSTUME) ? Number(args.COSTUME) : 1) - 1;
    if (index < 0) return;
    vm.deleteCostume(index);
  }

  setStageSize(args, util) {
    let width = Number(args.WIDTH) || 480;
    let height = Number(args.HEIGHT) || 360;
    if (width <= 0) width = 1;
    if (height <= 0) height = 1;
    if (vm) vm.setStageSize(width, height);
  }

  turboModeEnabled() {
    return vm.runtime.turboMode;
  }

  amountOfClones() {
    return vm.runtime._cloneCounter;
  }

  getStageWidth() {
    return vm.runtime.stageWidth;
  }

  getStageHeight() {
    return vm.runtime.stageHeight;
  }

  getMaxFrameRate() {
    return vm.runtime.frameLoop.framerate;
  }

  setMaxFrameRate(args, util) {
    let frameRate = Number(args.FRAMERATE) || 1;
    if (frameRate <= 0) frameRate = 1;
    if (vm) vm.runtime.frameLoop.setFramerate(frameRate);
  }

}

module.exports = JgRuntimeBlocks;

/***/ }),

/***/ "./src/extensions/jg_websiteRequests/index.js":
/*!****************************************************!*\
  !*** ./src/extensions/jg_websiteRequests/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const formatMessage = __webpack_require__(/*! format-message */ "format-message");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js"); // const Cast = require('../../util/cast');

/**
 * Class for Website Request blocks
 * @constructor
 */


class JgWebsiteRequestBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: 'jgWebsiteRequests',
      name: 'Website Requests',
      color1: '#004299',
      color2: '#003478',
      blocks: [{
        opcode: 'encodeTextForURL',
        text: formatMessage({
          id: 'jgWebsiteRequests.blocks.encodeTextForURL',
          default: 'encode [TEXT] for URL',
          description: 'Encodes text to be usable in a URL.'
        }),
        disableMonitor: true,
        blockType: BlockType.REPORTER,
        arguments: {
          TEXT: {
            type: ArgumentType.STRING,
            defaultValue: formatMessage({
              id: 'jgWebsiteRequests.text_encode_for_url',
              default: 'Text here',
              description: 'The text to encode.'
            })
          }
        }
      }, {
        opcode: 'getWebsiteContent',
        text: formatMessage({
          id: 'jgWebsiteRequests.blocks.getWebsiteContent',
          default: 'get [WEBSITE]\'s content',
          description: 'Gets the contents of the specified website. Includes HTML if it\'s a normal website.'
        }),
        disableMonitor: true,
        blockType: BlockType.REPORTER,
        arguments: {
          WEBSITE: {
            type: ArgumentType.STRING,
            defaultValue: formatMessage({
              id: 'jgWebsiteRequests.website_fetch_content',
              default: 'https://www.google.com',
              description: 'The website to get the content of.'
            })
          }
        }
      }, {
        opcode: 'postWithContentToWebsite',
        text: formatMessage({
          id: 'jgWebsiteRequests.blocks.postWithContentToWebsite',
          default: 'post [CONTENT] as [KEY] to [WEBSITE]',
          description: 'Posts to a website using a JSON body with the key text set to the content.'
        }),
        disableMonitor: true,
        blockType: BlockType.REPORTER,
        arguments: {
          CONTENT: {
            type: ArgumentType.STRING,
            defaultValue: formatMessage({
              id: 'jgWebsiteRequests.website_post_content',
              default: 'value',
              description: 'The content of the key to post.'
            })
          },
          KEY: {
            type: ArgumentType.STRING,
            defaultValue: formatMessage({
              id: 'jgWebsiteRequests.website_post_key',
              default: 'key',
              description: 'The key in the request body to post.'
            })
          },
          WEBSITE: {
            type: ArgumentType.STRING,
            defaultValue: formatMessage({
              id: 'jgWebsiteRequests.website_post_website',
              default: 'https://httpbin.org/post',
              description: 'The website to post the key and content to.'
            })
          }
        }
      }]
    };
  }

  encodeTextForURL(args, util) {
    return encodeURIComponent(String(args.TEXT));
  }

  getWebsiteContent(args, util) {
    return new Promise((resolve, reject) => {
      if (window && !window.fetch) return resolve("");
      fetch("https://api.allorigins.win/raw?url=" + encodeURIComponent(String(args.WEBSITE))).then(r => {
        r.text().then(text => {
          resolve(String(text));
        }).catch(err => {
          resolve("");
        });
      }).catch(err => {
        resolve("");
      });
    });
  }

  postWithContentToWebsite(args, util) {
    return new Promise((resolve, reject) => {
      if (window && !window.fetch) return resolve("");
      const body = {};
      const checking = String(args.CONTENT);
      let canJSONParse = true;

      try {
        JSON.parse(checking);
      } catch (_unused) {
        canJSONParse = false;
      }

      body[String(args.KEY)] = checking == "true" ? true : checking == "false" ? false : Number(checking) ? Number(checking) : checking == "null" ? null : canJSONParse ? JSON.parse(checking) : checking;
      fetch(String(args.WEBSITE), {
        method: "POST",
        headers: {
          "Content-Type": "application-json"
        },
        body: JSON.stringify(body)
      }).then(r => {
        r.text().then(text => {
          resolve(String(text));
        }).catch(err => {
          resolve("");
        });
      }).catch(err => {
        resolve("");
      });
    });
  }

}

module.exports = JgWebsiteRequestBlocks;

/***/ }),

/***/ "./src/extensions/jw_unite/index.js":
/*!******************************************!*\
  !*** ./src/extensions/jw_unite/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const formatMessage = __webpack_require__(/*! format-message */ "format-message");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js"); // const Cast = require('../../util/cast');


const blockIconURI = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUAAAAFACAMAAAD6TlWYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAPUExURQAAAP+xNQDiGgCU/wAAAJEQGGoAAAAFdFJOU/////8A+7YOUwAAAAlwSFlzAAAOwwAADsMBx2+oZAAABA5JREFUeF7t0EtuW0EUA9F8vP81Z8JRAwzbLuk5COoMBb1LdP34EGJAyICQASEDQgaEDAgZEDIgZEDIgJABIQNCBoQMCBkQMiBkQMiAkAEhA0IGhAwIGRAyIGRAyICQASEDQgaEDAgZEHos4M+HZfbtDAgZEDIgZEDIgJABIQNCBoQMCBkQMiBkQMiAkAEhA0IGhAwIGRAyIGRAyICQASEDQgaEDAgZEDIgZEDIgJABIQNCBoQMCBkQMiBkQMiAkAEhA0IGhAwIGRAyIGRAyICQASEDQgaEDAgZEDIgZEDIgJABIQNCBoQMCBkQMiBkQMiAkAEhA0IGhAwIGRAyIGRAyICQASEDQgaEDAgZEDIgZEDIgJABIQNCBoQMCBkQMiBkQMiAkAEhA0IGhAwIGRAyIGRAyICQASEDQgaEDAgZEDIgZEDIgJABIQNCBoQMCBkQMiBkQMiAkAEhA0KPBfxfGRAyIGRAyICQASEDQgaEDAgZEDIgZEDIgJABIQNCBoQMCBkQMiBkQMiAkAEhA0IGhAwIGRAyIGRAyICQASEDQgaEZsBfh/z8z/r9SfnsywwIGRAyIGRAyICQASEDQp8OeMrfvk06vEzOXjPgIWevGfCQs9cMeMjZawY85Ow1Ax5y9poBDzl7zYCHnL2GA57y2dvlvW+TmcmARWYmAxaZmQxYZGYyYJGZyYBFZiYDFpmZDFhkZnp5wFPOvFze+TaZmQxYZGYyYJGZyYBFZiYDFpmZDFhkZjJgkZnJgEVmprcHPOXsl+V9j8lsZcAhs5UBh8xWBhwyWxlwyGxlwCGzlQGHzFYGHDJbPR7wlJlreddjMlsZcMhsZcAhs5UBh8xWBhwyWxlwyGxlwCGzlQGHzFbfHvCU2SrvekxmKwMOma0MOGS2MuCQ2cqAQ2YrAw6ZrQw4ZLYy4JDZyoBDZisDDpmtDDhktjLgkNnKgENmKwMOma0MOGS2MuCQ2erbA2bmWt71mMxWBhwyWxlwyGxlwCGzlQGHzFYGHDJbGXDIbGXAIbPV4wFz9svyrsdktjLgkNnKgENmKwMOma0MOGS2MuCQ2cqAQ2YrAw6Zrd4eMGdeLu97m8xMBiwyMxmwyMxkwCIzkwGLzEwGLDIzGbDIzGTAIjPTywPms7fLO98mM5MBi8xMBiwyMxmwyMxkwCIzkwGLzEwGLDIzGbDIzIQD5m/fJu99mZy9ZsBDzl4z4CFnrxnwkLPXDHjI2WsGPOTsNQMecvaaAQ85e+3TAfPzPysdruWzLzMgZEDIgJABIQNCBoQMCM2A+jsDQgaEDAgZEDIgZEDIgJABIQNCBoQMCBkQMiBkQMiAkAEhA0IGhAwIGRAyIGRAyICQASEDQgaEDAgZEDIgZEDIgMjHxx+IPExM0h8siAAAAABJRU5ErkJggg==";
/**
 * Class for Unite blocks
 * @constructor
 */

class jwUnite {
  constructor(runtime) {
    _defineProperty(this, "replacers", {});

    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: 'jwUnite',
      name: 'Unite',
      blockIconURI: blockIconURI,
      color1: '#7ddcff',
      color2: '#4a98ff',
      blocks: [{
        opcode: 'whenanything',
        text: formatMessage({
          id: 'jwUnite.blocks.whenanything',
          default: 'when [ANYTHING]',
          description: 'Runs blocks when set boolean is true'
        }),
        disableMonitor: true,
        blockType: BlockType.HAT,
        arguments: {
          ANYTHING: {
            type: ArgumentType.BOOLEAN
          }
        }
      }, "---", {
        opcode: 'backToGreenFlag',
        text: formatMessage({
          id: 'jwUnite.blocks.backToGreenFlag',
          default: 'run [FLAG]',
          description: 'Acts like a click on the flag has been done.'
        }),
        terminal: true,
        blockType: BlockType.COMMAND,
        arguments: {
          FLAG: {
            type: ArgumentType.IMAGE,
            dataURI: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QA/wD/AP+gvaeTAAACJ0lEQVRIid2Uy09TQRSHv2kv1VR5hhQQqwlYGtqCmtbHokhDTNQtEVz4B/gfmBCDXoyGmLj3kbBwY2LY6MpHWJDUoBukKsTKQ6I2paWGBipCo73jBii30BpI78ZfMpkzMznznTOPAwZLbFgt/ZWY011k9gzysSdZLICStdJXkPRjSns41hcH2Y7EjmAVmESKFyjyCaPqr50AzBtWbeAsEKDE0oy7w4rnfAXNbWU0nlY40CQwmX0kY73UBr4QGw5vu5vndg31Zy6wv3OGhecZfQbrajk3Rp2zXRdCqe0Irg5o8k8w+uwWR9VLmE13eaeNgarRqtoQ4jKKdpUy+wLy+3Hg2vaAQlIsbk51ZUjNJ/n8egBv5CBan2Bf5TL1nlkafGkWYz8YeVy94bIjwHpOpTY/vs7Nc1WAHQCNr5sXTLsA/EOaNBagabph8QEyYzAA3QkZkYGeUOAVyTlWUt/I/M5gLa/GpDjYXFryuumPaCsgMWsl+ilEfLoOSQTBClBBuW2GExcXsVi9hQFSF8RWQGT8MNCLwzXAYHc2nNabbQzdu4/TH6ThpBMhbDmef1iKhRgf8iHFo/wAeEpIfUgoZ/bD9SAB1Us42MPUiJOaxhBVh5YwKYKfib3MhZtYXS5B0sl79VUhQH4Nq6vADbzqHaJTbUQn3QjKECKOlG8Iqblh7apUsFayX661gjLgH/zPgPm1PlFMQPaSHa4HTIcnSFW8LSbAcP0F3uGqEimnx6MAAAAASUVORK5CYII=',
            alt: 'Blue Flag'
          }
        }
      }, "---", {
        opcode: 'trueBoolean',
        text: formatMessage({
          id: 'jwUnite.blocks.trueBoolean',
          default: 'true',
          description: 'Returns true'
        }),
        disableMonitor: true,
        blockType: BlockType.BOOLEAN
      }, {
        opcode: 'falseBoolean',
        text: formatMessage({
          id: 'jwUnite.blocks.falseBoolean',
          default: 'false',
          description: 'Returns false'
        }),
        disableMonitor: true,
        blockType: BlockType.BOOLEAN
      }, {
        opcode: 'randomBoolean',
        text: formatMessage({
          id: 'jwUnite.blocks.randomBoolean',
          default: 'random',
          description: 'Returns true or false'
        }),
        disableMonitor: true,
        blockType: BlockType.BOOLEAN
      }, "---", {
        opcode: 'indexOfTextInText',
        text: formatMessage({
          id: 'jwUnite.blocks.indexOfTextInText',
          default: 'index of [TEXT1] in [TEXT2]',
          description: 'Finds the position of some text in another piece of text.'
        }),
        disableMonitor: true,
        blockType: BlockType.REPORTER,
        arguments: {
          TEXT1: {
            type: ArgumentType.STRING,
            defaultValue: formatMessage({
              id: 'jwUnite.indexof_textToFind',
              default: 'world',
              description: 'The text to look for.'
            })
          },
          TEXT2: {
            type: ArgumentType.STRING,
            defaultValue: formatMessage({
              id: 'jwUnite.indexof_textToSearch',
              default: 'Hello world!',
              description: 'The text to search in.'
            })
          }
        }
      }, {
        opcode: 'getLettersFromIndexToIndexInText',
        text: formatMessage({
          id: 'jwUnite.blocks.getLettersFromIndexToIndexInText',
          default: 'letters from [INDEX1] to [INDEX2] in [TEXT]',
          description: 'Gets a part of text using the indexes specified.'
        }),
        disableMonitor: true,
        blockType: BlockType.REPORTER,
        arguments: {
          INDEX1: {
            type: ArgumentType.NUMBER,
            defaultValue: 2
          },
          INDEX2: {
            type: ArgumentType.NUMBER,
            defaultValue: 3
          },
          TEXT: {
            type: ArgumentType.STRING,
            defaultValue: formatMessage({
              id: 'jwUnite.getLettersFromIndexToIndexInText_text',
              default: 'Hello!',
              description: 'The text to get a substring from.'
            })
          }
        }
      }, {
        opcode: 'readLineInMultilineText',
        text: formatMessage({
          id: 'jwUnite.blocks.readLineInMultilineText',
          default: 'read line [LINE] in [TEXT]',
          description: 'Reads a certain line in text with multiple lines.'
        }),
        disableMonitor: true,
        blockType: BlockType.REPORTER,
        arguments: {
          LINE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          },
          TEXT: {
            type: ArgumentType.STRING,
            defaultValue: formatMessage({
              id: 'jwUnite.readLineInMultilineText_text',
              default: 'Text with multiple lines here',
              description: 'The text to read lines from.'
            })
          }
        }
      }, {
        opcode: 'newLine',
        text: formatMessage({
          id: 'jwUnite.blocks.newLine',
          default: 'newline',
          description: 'Represents a new line character.'
        }),
        disableMonitor: true,
        blockType: BlockType.REPORTER
      }, "---", {
        opcode: 'lerpFunc',
        text: formatMessage({
          id: 'jwUnite.blocks.lerpFunc',
          default: 'interpolate [ONE] to [TWO] by [AMOUNT]',
          description: 'Linearly interpolates the first number to the second by the amount.'
        }),
        disableMonitor: true,
        blockType: BlockType.REPORTER,
        arguments: {
          ONE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          },
          TWO: {
            type: ArgumentType.NUMBER,
            defaultValue: 3
          },
          AMOUNT: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.5
          }
        }
      }, {
        opcode: 'advMath',
        text: formatMessage({
          id: 'jwUnite.blocks.advMath',
          default: '[ONE] [OPTION] [TWO]',
          description: 'Operators advanced math function but with 2 variables'
        }),
        disableMonitor: true,
        blockType: BlockType.REPORTER,
        arguments: {
          ONE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          },
          OPTION: {
            type: ArgumentType.NUMBER,
            defaultValue: "^",
            menu: 'advMath'
          },
          TWO: {
            type: ArgumentType.NUMBER,
            defaultValue: 2
          }
        }
      }, "---", {
        opcode: 'setReplacer',
        text: formatMessage({
          id: 'jwUnite.blocks.setReplacer',
          default: 'replacer [REPLACER] to [VALUE]',
          description: 'Sets a replacer to a value'
        }),
        arguments: {
          REPLACER: {
            type: ArgumentType.STRING,
            defaultValue: "foo"
          },
          VALUE: {
            type: ArgumentType.STRING,
            defaultValue: "bar"
          }
        },
        disableMonitor: true,
        blockType: BlockType.COMMAND
      }, {
        opcode: 'replaceWithReplacers',
        text: formatMessage({
          id: 'jwUnite.blocks.replaceWithReplacers',
          default: 'replace [STRING] with replacers',
          description: 'Replaces all replacer names with their respective value'
        }),
        arguments: {
          STRING: {
            type: ArgumentType.STRING,
            defaultValue: "Hello {foo}!"
          }
        },
        disableMonitor: true,
        blockType: BlockType.REPORTER
      }],
      menus: {
        advMath: ['^', 'root', 'log']
      }
    };
  }

  whenanything(args, util) {
    return Boolean(args.ANYTHING || false);
  }

  backToGreenFlag(args, util) {
    if (vm) vm.greenFlag();
  }

  trueBoolean() {
    return true;
  }

  falseBoolean() {
    return false;
  }

  randomBoolean() {
    return Boolean(Math.round(Math.random()));
  }

  indexOfTextInText(args, util) {
    const lookfor = String(args.TEXT1);
    const searchin = String(args.TEXT2);
    let index = 0;

    if (searchin.includes(lookfor)) {
      index = searchin.indexOf(lookfor) + 1;
    }

    return index;
  }

  getLettersFromIndexToIndexInText(args, util) {
    const index1 = (Number(args.INDEX1) ? Number(args.INDEX1) : 1) - 1;
    const index2 = (Number(args.INDEX2) ? Number(args.INDEX2) : 1) - 1;
    const string = String(args.TEXT);
    const substring = string.substring(index1, index2);
    return substring;
  }

  readLineInMultilineText(args, util) {
    const line = (Number(args.LINE) ? Number(args.LINE) : 1) - 1;
    const text = String(args.TEXT);
    const readline = text.split("\n")[line] || "";
    return readline;
  }

  newLine() {
    return "\n";
  }

  lerpFunc(args, util) {
    const one = isNaN(Number(args.ONE)) ? 0 : Number(args.ONE);
    const two = isNaN(Number(args.TWO)) ? 0 : Number(args.TWO);
    const amount = isNaN(Number(args.AMOUNT)) ? 0 : Number(args.AMOUNT);
    let lerped = one;
    lerped += (two - one) / (amount / (amount * amount));
    return lerped;
  }

  advMath(args, util) {
    const one = isNaN(Number(args.ONE)) ? 0 : Number(args.ONE);
    const two = isNaN(Number(args.TWO)) ? 0 : Number(args.TWO);
    const operator = String(args.OPTION);

    switch (operator) {
      case "^":
        return one ** two;

      case "root":
        return one ** 1 / two;

      case "log":
        return Math.log(two) / Math.log(one);

      default:
        return 0;
    }
  }

  setReplacer(args, util) {
    this.replacers["{" + String(args.REPLACER) + "}"] = String(args.VALUE || "");
  }

  replaceWithReplacers(args, util) {
    let string = String(args.STRING || "");

    for (const replacer of Object.keys(this.replacers)) {
      string = string.replaceAll(replacer, this.replacers[replacer]);
    }

    return string;
  }

}

module.exports = jwUnite;

/***/ }),

/***/ "./src/extensions/scratch3_boost/index.js":
/*!************************************************!*\
  !*** ./src/extensions/scratch3_boost/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const Cast = __webpack_require__(/*! ../../util/cast */ "./src/util/cast.js");

const formatMessage = __webpack_require__(/*! format-message */ "format-message");

const color = __webpack_require__(/*! ../../util/color */ "./src/util/color.js");

const BLE = __webpack_require__(/*! ../../io/ble */ "./src/io/ble.js");

const Base64Util = __webpack_require__(/*! ../../util/base64-util */ "./src/util/base64-util.js");

const MathUtil = __webpack_require__(/*! ../../util/math-util */ "./src/util/math-util.js");

const RateLimiter = __webpack_require__(/*! ../../util/rateLimiter.js */ "./src/util/rateLimiter.js");

const log = __webpack_require__(/*! ../../util/log */ "./src/util/log.js");
/**
 * The LEGO Wireless Protocol documentation used to create this extension can be found at:
 * https://lego.github.io/lego-ble-wireless-protocol-docs/index.html
 */

/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const iconURI = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAMAAAC5zwKfAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACpQTFRF////fIel5ufolZ62/2YavsPS+YZOkJmy9/j53+Hk6+zs6N/b6dfO////tDhMHAAAAA50Uk5T/////////////////wBFwNzIAAAA6ElEQVR42uzX2w6DIBAEUGDVtlr//3dLaLwgiwUd2z7MJPJg5EQWiGhGcAxBggQJEiT436CIfqXJPTn3MKNYYMSDFpoAmp24OaYgvwKnFgL2zvVTCwHrMoMi+nUQLFthaNCCa0iwclLkDgYVsQp0mzxuqXgK1MRzoCLWgkPXNN2wI/q6Kvt7u/cX0HtejN8x2sXpnpb8J8D3b0Keuhh3X975M+i0xNVbg3s1TIasgK21bQyGO+s2PykaGMYbge8KrNrssvkOWDXkErB8UuBHETjoYLkKBA8ZfuDkbwVBggQJEiR4MC8BBgDTtMZLx2nFCQAAAABJRU5ErkJggg==';
/**
 * Boost BLE UUIDs.
 * @enum {string}
 */

const BoostBLE = {
  service: '00001623-1212-efde-1623-785feabcd123',
  characteristic: '00001624-1212-efde-1623-785feabcd123',
  sendInterval: 100,
  sendRateMax: 20
};
/**
 * Boost Motor Max Power Add. Defines how much more power than the target speed
 * the motors may supply to reach the target speed faster.
 * Lower number == softer, slower reached target speed.
 * Higher number == harder, faster reached target speed.
 * @constant {number}
 */

const BoostMotorMaxPowerAdd = 10;
/**
 * A time interval to wait (in milliseconds) in between battery check calls.
 * @type {number}
 */

const BoostPingInterval = 5000;
/**
 * The number of continuous samples the color-sensor will evaluate color from.
 * @type {number}
 */

const BoostColorSampleSize = 5;
/**
 * Enum for Boost sensor and actuator types.
 * @readonly
 * @enum {number}
 */

const BoostIO = {
  MOTOR_WEDO: 0x01,
  MOTOR_SYSTEM: 0x02,
  BUTTON: 0x05,
  LIGHT: 0x08,
  VOLTAGE: 0x14,
  CURRENT: 0x15,
  PIEZO: 0x16,
  LED: 0x17,
  TILT_EXTERNAL: 0x22,
  MOTION_SENSOR: 0x23,
  COLOR: 0x25,
  MOTOREXT: 0x26,
  MOTORINT: 0x27,
  TILT: 0x28
};
/**
 * Enum for ids for various output command feedback types on the Boost.
 * @readonly
 * @enum {number}
 */

const BoostPortFeedback = {
  IN_PROGRESS: 0x01,
  COMPLETED: 0x02,
  DISCARDED: 0x04,
  IDLE: 0x08,
  BUSY_OR_FULL: 0x10
};
/**
 * Enum for physical Boost Ports
 * @readonly
 * @enum {number}
 */

const BoostPort10000223OrOlder = {
  A: 55,
  B: 56,
  C: 1,
  D: 2
};
const BoostPort10000224OrNewer = {
  A: 0,
  B: 1,
  C: 2,
  D: 3
}; // Set default port mapping to support the newer firmware

let BoostPort = BoostPort10000224OrNewer;
/**
 * Ids for each color sensor value used by the extension.
 * @readonly
 * @enum {string}
 */

const BoostColor = {
  ANY: 'any',
  NONE: 'none',
  RED: 'red',
  BLUE: 'blue',
  GREEN: 'green',
  YELLOW: 'yellow',
  WHITE: 'white',
  BLACK: 'black'
};
/**
 * Enum for indices for each color sensed by the Boost vision sensor.
 * @readonly
 * @enum {number}
 */

const BoostColorIndex = {
  [BoostColor.NONE]: 255,
  [BoostColor.RED]: 9,
  [BoostColor.BLUE]: 3,
  [BoostColor.GREEN]: 5,
  [BoostColor.YELLOW]: 7,
  [BoostColor.WHITE]: 10,
  [BoostColor.BLACK]: 0
};
/**
 * Enum for Message Types
 * @readonly
 * @enum {number}
 */

const BoostMessage = {
  HUB_PROPERTIES: 0x01,
  HUB_ACTIONS: 0x02,
  HUB_ALERTS: 0x03,
  HUB_ATTACHED_IO: 0x04,
  ERROR: 0x05,
  PORT_INPUT_FORMAT_SETUP_SINGLE: 0x41,
  PORT_INPUT_FORMAT_SETUP_COMBINED: 0x42,
  PORT_INFORMATION: 0x43,
  PORT_MODEINFORMATION: 0x44,
  PORT_VALUE: 0x45,
  PORT_VALUE_COMBINED: 0x46,
  PORT_INPUT_FORMAT: 0x47,
  PORT_INPUT_FORMAT_COMBINED: 0x48,
  OUTPUT: 0x81,
  PORT_FEEDBACK: 0x82
};
/**
 * Enum for Hub Property Types
 * @readonly
 * @enum {number}
 */

const BoostHubProperty = {
  ADVERTISEMENT_NAME: 0x01,
  BUTTON: 0x02,
  FW_VERSION: 0x03,
  HW_VERSION: 0x04,
  RSSI: 0x05,
  BATTERY_VOLTAGE: 0x06,
  BATTERY_TYPE: 0x07,
  MANUFACTURER_NAME: 0x08,
  RADIO_FW_VERSION: 0x09,
  LEGO_WP_VERSION: 0x0A,
  SYSTEM_TYPE_ID: 0x0B,
  HW_NETWORK_ID: 0x0C,
  PRIMARY_MAC: 0x0D,
  SECONDARY_MAC: 0x0E,
  HW_NETWORK_FAMILY: 0x0F
};
/**
 * Enum for Hub Property Operations
 * @readonly
 * @enum {number}
 */

const BoostHubPropertyOperation = {
  SET: 0x01,
  ENABLE_UPDATES: 0x02,
  DISABLE_UPDATES: 0x03,
  RESET: 0x04,
  REQUEST_UPDATE: 0x05,
  UPDATE: 0x06
};
/**
 * Enum for Motor Subcommands (for 0x81)
 * @readonly
 * @enum {number}
 */

const BoostOutputSubCommand = {
  START_POWER: 0x01,
  START_POWER_PAIR: 0x02,
  SET_ACC_TIME: 0x05,
  SET_DEC_TIME: 0x06,
  START_SPEED: 0x07,
  START_SPEED_PAIR: 0x08,
  START_SPEED_FOR_TIME: 0x09,
  START_SPEED_FOR_TIME_PAIR: 0x0A,
  START_SPEED_FOR_DEGREES: 0x0B,
  START_SPEED_FOR_DEGREES_PAIR: 0x0C,
  GO_TO_ABS_POSITION: 0x0D,
  GO_TO_ABS_POSITION_PAIR: 0x0E,
  PRESET_ENCODER: 0x14,
  WRITE_DIRECT_MODE_DATA: 0x51
};
/**
 * Enum for Startup/Completion information for an output command.
 * Startup and completion bytes must be OR'ed to be combined to a single byte.
 * @readonly
 * @enum {number}
 */

const BoostOutputExecution = {
  // Startup information
  BUFFER_IF_NECESSARY: 0x00,
  EXECUTE_IMMEDIATELY: 0x10,
  // Completion information
  NO_ACTION: 0x00,
  COMMAND_FEEDBACK: 0x01
};
/**
 * Enum for Boost Motor end states
 * @readonly
 * @enum {number}
 */

const BoostMotorEndState = {
  FLOAT: 0,
  HOLD: 126,
  BRAKE: 127
};
/**
 * Enum for Boost Motor acceleration/deceleration profiles
 * @readyonly
 * @enum {number}
 */

const BoostMotorProfile = {
  DO_NOT_USE: 0x00,
  ACCELERATION: 0x01,
  DECELERATION: 0x02
};
/**
 * Enum for when Boost IO's are attached/detached
 * @readonly
 * @enum {number}
 */

const BoostIOEvent = {
  ATTACHED: 0x01,
  DETACHED: 0x00,
  ATTACHED_VIRTUAL: 0x02
};
/**
 * Enum for selected sensor modes.
 * @enum {number}
 */

const BoostMode = {
  TILT: 0,
  // angle (pitch/yaw)
  LED: 1,
  // Set LED to accept RGB values
  COLOR: 0,
  // Read indexed colors from Vision Sensor
  MOTOR_SENSOR: 2,
  // Set motors to report their position
  UNKNOWN: 0 // Anything else will use the default mode (mode 0)

};
/**
 * Enum for Boost motor states.
 * @param {number}
 */

const BoostMotorState = {
  OFF: 0,
  ON_FOREVER: 1,
  ON_FOR_TIME: 2,
  ON_FOR_ROTATION: 3
};
/**
 * Helper function for converting a JavaScript number to an INT32-number
 * @param {number} number - a number
 * @return {array} - a 4-byte array of Int8-values representing an INT32-number
 */

const numberToInt32Array = function numberToInt32Array(number) {
  const buffer = new ArrayBuffer(4);
  const dataview = new DataView(buffer);
  dataview.setInt32(0, number);
  return [dataview.getInt8(3), dataview.getInt8(2), dataview.getInt8(1), dataview.getInt8(0)];
};
/**
 * Helper function for converting a regular array to a Little Endian INT32-value
 * @param {Array} array - an array containing UInt8-values
 * @return {number} - a number
 */


const int32ArrayToNumber = function int32ArrayToNumber(array) {
  const i = Uint8Array.from(array);
  const d = new DataView(i.buffer);
  return d.getInt32(0, true);
};
/**
 * Manage power, direction, position, and timers for one Boost motor.
 */


class BoostMotor {
  /**
   * Construct a Boost Motor instance.
   * @param {Boost} parent - the Boost peripheral which owns this motor.
   * @param {int} index - the zero-based index of this motor on its parent peripheral.
   */
  constructor(parent, index) {
    /**
     * The Boost peripheral which owns this motor.
     * @type {Boost}
     * @private
     */
    this._parent = parent;
    /**
     * The zero-based index of this motor on its parent peripheral.
     * @type {int}
     * @private
     */

    this._index = index;
    /**
     * This motor's current direction: 1 for "this way" or -1 for "that way"
     * @type {number}
     * @private
     */

    this._direction = 1;
    /**
     * This motor's current power level, in the range [0,100].
     * @type {number}
     * @private
     */

    this._power = 50;
    /**
     * This motor's current relative position
     * @type {number}
     * @private
     */

    this._position = 0;
    /**
     * Is this motor currently moving?
     * @type {boolean}
     * @private
     */

    this._status = BoostMotorState.OFF;
    /**
     * If the motor has been turned on or is actively braking for a specific duration, this is the timeout ID for
     * the end-of-action handler. Cancel this when changing plans.
     * @type {Object}
     * @private
     */

    this._pendingDurationTimeoutId = null;
    /**
     * The starting time for the pending duration timeout.
     * @type {number}
     * @private
     */

    this._pendingDurationTimeoutStartTime = null;
    /**
     * The delay/duration of the pending duration timeout.
     * @type {number}
     * @private
     */

    this._pendingDurationTimeoutDelay = null;
    /**
     * The target position of a turn-based command.
     * @type {number}
     * @private
     */

    this._pendingRotationDestination = null;
    /**
     * If the motor has been turned on run for a specific rotation, this is the function
     * that will be called once Scratch VM gets a notification from the Move Hub.
     * @type {Object}
     * @private
     */

    this._pendingRotationPromise = null;
    this.turnOff = this.turnOff.bind(this);
  }
  /**
   * @return {int} - this motor's current direction: 1 for "this way" or -1 for "that way"
   */


  get direction() {
    return this._direction;
  }
  /**
   * @param {int} value - this motor's new direction: 1 for "this way" or -1 for "that way"
   */


  set direction(value) {
    if (value < 0) {
      this._direction = -1;
    } else {
      this._direction = 1;
    }
  }
  /**
   * @return {int} - this motor's current power level, in the range [0,100].
   */


  get power() {
    return this._power;
  }
  /**
   * @param {int} value - this motor's new power level, in the range [10,100].
   */


  set power(value) {
    /**
     * Scale the motor power to a range between 10 and 100,
     * to make sure the motors will run with something built onto them.
     */
    if (value === 0) {
      this._power = 0;
    } else {
      this._power = MathUtil.scale(value, 1, 100, 10, 100);
    }
  }
  /**
   * @return {int} - this motor's current position, in the range of [-MIN_INT32,MAX_INT32]
   */


  get position() {
    return this._position;
  }
  /**
   * @param {int} value - set this motor's current position.
   */


  set position(value) {
    this._position = value;
  }
  /**
   * @return {BoostMotorState} - the motor's current state.
   */


  get status() {
    return this._status;
  }
  /**
   * @param {BoostMotorState} value - set this motor's state.
   */


  set status(value) {
    this._clearRotationState();

    this._clearDurationTimeout();

    this._status = value;
  }
  /**
   * @return {number} - time, in milliseconds, of when the pending duration timeout began.
   */


  get pendingDurationTimeoutStartTime() {
    return this._pendingDurationTimeoutStartTime;
  }
  /**
   * @return {number} - delay, in milliseconds, of the pending duration timeout.
   */


  get pendingDurationTimeoutDelay() {
    return this._pendingDurationTimeoutDelay;
  }
  /**
   * @return {number} - target position, in degrees, of the pending rotation.
   */


  get pendingRotationDestination() {
    return this._pendingRotationDestination;
  }
  /**
   * @return {Promise} - the Promise function for the pending rotation.
   */


  get pendingRotationPromise() {
    return this._pendingRotationPromise;
  }
  /**
   * @param {function} func - function to resolve pending rotation Promise
   */


  set pendingRotationPromise(func) {
    this._pendingRotationPromise = func;
  }
  /**
   * Turn this motor on indefinitely
   * @private
   */


  _turnOn() {
    const cmd = this._parent.generateOutputCommand(this._index, BoostOutputExecution.EXECUTE_IMMEDIATELY, BoostOutputSubCommand.START_SPEED, [this.power * this.direction, MathUtil.clamp(this.power + BoostMotorMaxPowerAdd, 0, 100), BoostMotorProfile.DO_NOT_USE]);

    this._parent.send(BoostBLE.characteristic, cmd);
  }
  /**
   * Turn this motor on indefinitely
   */


  turnOnForever() {
    this.status = BoostMotorState.ON_FOREVER;

    this._turnOn();
  }
  /**
   * Turn this motor on for a specific duration.
   * @param {number} milliseconds - run the motor for this long.
   */


  turnOnFor(milliseconds) {
    milliseconds = Math.max(0, milliseconds);
    this.status = BoostMotorState.ON_FOR_TIME;

    this._turnOn();

    this._setNewDurationTimeout(this.turnOff, milliseconds);
  }
  /**
   * Turn this motor on for a specific rotation in degrees.
   * @param {number} degrees - run the motor for this amount of degrees.
   * @param {number} direction - rotate in this direction
   */


  turnOnForDegrees(degrees, direction) {
    degrees = Math.max(0, degrees);

    const cmd = this._parent.generateOutputCommand(this._index, BoostOutputExecution.EXECUTE_IMMEDIATELY ^ BoostOutputExecution.COMMAND_FEEDBACK, BoostOutputSubCommand.START_SPEED_FOR_DEGREES, [...numberToInt32Array(degrees), this.power * this.direction * direction, MathUtil.clamp(this.power + BoostMotorMaxPowerAdd, 0, 100), BoostMotorEndState.BRAKE, BoostMotorProfile.DO_NOT_USE]);

    this.status = BoostMotorState.ON_FOR_ROTATION;
    this._pendingRotationDestination = this.position + degrees * this.direction * direction;

    this._parent.send(BoostBLE.characteristic, cmd);
  }
  /**
   * Turn this motor off.
   * @param {boolean} [useLimiter=true] - if true, use the rate limiter
   */


  turnOff() {
    let useLimiter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    const cmd = this._parent.generateOutputCommand(this._index, BoostOutputExecution.EXECUTE_IMMEDIATELY, BoostOutputSubCommand.START_POWER, [BoostMotorEndState.FLOAT]);

    this.status = BoostMotorState.OFF;

    this._parent.send(BoostBLE.characteristic, cmd, useLimiter);
  }
  /**
   * Clear the motor action timeout, if any. Safe to call even when there is no pending timeout.
   * @private
   */


  _clearDurationTimeout() {
    if (this._pendingDurationTimeoutId !== null) {
      clearTimeout(this._pendingDurationTimeoutId);
      this._pendingDurationTimeoutId = null;
      this._pendingDurationTimeoutStartTime = null;
      this._pendingDurationTimeoutDelay = null;
    }
  }
  /**
   * Set a new motor action timeout, after clearing an existing one if necessary.
   * @param {Function} callback - to be called at the end of the timeout.
   * @param {int} delay - wait this many milliseconds before calling the callback.
   * @private
   */


  _setNewDurationTimeout(callback, delay) {
    this._clearDurationTimeout();

    const timeoutID = setTimeout(() => {
      if (this._pendingDurationTimeoutId === timeoutID) {
        this._pendingDurationTimeoutId = null;
        this._pendingDurationTimeoutStartTime = null;
        this._pendingDurationTimeoutDelay = null;
      }

      callback();
    }, delay);
    this._pendingDurationTimeoutId = timeoutID;
    this._pendingDurationTimeoutStartTime = Date.now();
    this._pendingDurationTimeoutDelay = delay;
  }
  /**
   * Clear the motor states related to rotation-based commands, if any.
   * Safe to call even when there is no pending promise function.
   * @private
   */


  _clearRotationState() {
    if (this._pendingRotationPromise !== null) {
      this._pendingRotationPromise();

      this._pendingRotationPromise = null;
    }

    this._pendingRotationDestination = null;
  }

}
/**
 * Manage communication with a Boost peripheral over a Bluetooth Low Energy client socket.
 */


class Boost {
  constructor(runtime, extensionId) {
    /**
     * The Scratch 3.0 runtime used to trigger the green flag button.
     * @type {Runtime}
     * @private
     */
    this._runtime = runtime;

    this._runtime.on('PROJECT_STOP_ALL', this.stopAll.bind(this));
    /**
     * The id of the extension this peripheral belongs to.
     */


    this._extensionId = extensionId;
    /**
     * A list of the ids of the physical or virtual sensors.
     * @type {string[]}
     * @private
     */

    this._ports = [];
    /**
     * A list of motors registered by the Boost hardware.
     * @type {BoostMotor[]}
     * @private
     */

    this._motors = [];
    /**
     * The most recently received value for each sensor.
     * @type {Object.<string, number>}
     * @private
     */

    this._sensors = {
      tiltX: 0,
      tiltY: 0,
      color: BoostColor.NONE,
      previousColor: BoostColor.NONE
    };
    /**
     * An array of values from the Boost Vision Sensor.
     * @type {Array}
     * @private
     */

    this._colorSamples = [];
    /**
     * The Bluetooth connection socket for reading/writing peripheral data.
     * @type {BLE}
     * @private
     */

    this._ble = null;

    this._runtime.registerPeripheralExtension(extensionId, this);
    /**
     * A rate limiter utility, to help limit the rate at which we send BLE messages
     * over the socket to Scratch Link to a maximum number of sends per second.
     * @type {RateLimiter}
     * @private
     */


    this._rateLimiter = new RateLimiter(BoostBLE.sendRateMax);
    /**
     * An interval id for the battery check interval.
     * @type {number}
     * @private
     */

    this._pingDeviceId = null;
    this.reset = this.reset.bind(this);
    this._onConnect = this._onConnect.bind(this);
    this._onMessage = this._onMessage.bind(this);
    this._pingDevice = this._pingDevice.bind(this);
  }
  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the X axis.
   */


  get tiltX() {
    return this._sensors.tiltX;
  }
  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the Y axis.
   */


  get tiltY() {
    return this._sensors.tiltY;
  }
  /**
   * @return {number} - the latest color value received from the vision sensor.
   */


  get color() {
    return this._sensors.color;
  }
  /**
   * @return {number} - the previous color value received from the vision sensor.
   */


  get previousColor() {
    return this._sensors.previousColor;
  }
  /**
   * Look up the color id for an index received from the vision sensor.
   * @param {number} index - the color index to look up.
   * @return {BoostColor} the color id for this index.
   */


  boostColorForIndex(index) {
    const colorForIndex = Object.keys(BoostColorIndex).find(key => BoostColorIndex[key] === index);
    return colorForIndex || BoostColor.NONE;
  }
  /**
   * Access a particular motor on this peripheral.
   * @param {int} index - the index of the desired motor.
   * @return {BoostMotor} - the BoostMotor instance, if any, at that index.
   */


  motor(index) {
    return this._motors[index];
  }
  /**
   * Stop all the motors that are currently running.
   */


  stopAllMotors() {
    this._motors.forEach(motor => {
      if (motor) {
        // Send the motor off command without using the rate limiter.
        // This allows the stop button to stop motors even if we are
        // otherwise flooded with commands.
        motor.turnOff(false);
      }
    });
  }
  /**
   * Set the Boost peripheral's LED to a specific color.
   * @param {int} inputRGB - a 24-bit RGB color in 0xRRGGBB format.
   * @return {Promise} - a promise of the completion of the set led send operation.
   */


  setLED(inputRGB) {
    const rgb = [inputRGB >> 16 & 0x000000FF, inputRGB >> 8 & 0x000000FF, inputRGB & 0x000000FF];
    const cmd = this.generateOutputCommand(this._ports.indexOf(BoostIO.LED), BoostOutputExecution.EXECUTE_IMMEDIATELY ^ BoostOutputExecution.COMMAND_FEEDBACK, BoostOutputSubCommand.WRITE_DIRECT_MODE_DATA, [BoostMode.LED, ...rgb]);
    return this.send(BoostBLE.characteristic, cmd);
  }
  /**
   * Sets the input mode of the LED to RGB.
   * @return {Promise} - a promise returned by the send operation.
   */


  setLEDMode() {
    const cmd = this.generateInputCommand(this._ports.indexOf(BoostIO.LED), BoostMode.LED, 0, false);
    return this.send(BoostBLE.characteristic, cmd);
  }
  /**
   * Stop the motors on the Boost peripheral.
   */


  stopAll() {
    if (!this.isConnected()) return;
    this.stopAllMotors();
  }
  /**
   * Called by the runtime when user wants to scan for a Boost peripheral.
   */


  scan() {
    if (this._ble) {
      this._ble.disconnect();
    }

    this._ble = new BLE(this._runtime, this._extensionId, {
      filters: [{
        services: [BoostBLE.service],
        manufacturerData: {
          0x0397: {
            dataPrefix: [0x00, 0x40],
            mask: [0x00, 0xFF]
          }
        }
      }],
      optionalServices: []
    }, this._onConnect, this.reset);
  }
  /**
   * Called by the runtime when user wants to connect to a certain Boost peripheral.
   * @param {number} id - the id of the peripheral to connect to.
   */


  connect(id) {
    if (this._ble) {
      this._ble.connectPeripheral(id);
    }
  }
  /**
   * Disconnects from the current BLE socket and resets state.
   */


  disconnect() {
    if (this._ble) {
      this._ble.disconnect();
    }

    this.reset();
  }
  /**
   * Reset all the state and timeout/interval ids.
   */


  reset() {
    this._ports = [];
    this._motors = [];
    this._sensors = {
      tiltX: 0,
      tiltY: 0,
      color: BoostColor.NONE,
      previousColor: BoostColor.NONE
    };

    if (this._pingDeviceId) {
      window.clearInterval(this._pingDeviceId);
      this._pingDeviceId = null;
    }
  }
  /**
   * Called by the runtime to detect whether the Boost peripheral is connected.
   * @return {boolean} - the connected state.
   */


  isConnected() {
    let connected = false;

    if (this._ble) {
      connected = this._ble.isConnected();
    }

    return connected;
  }
  /**
   * Write a message to the Boost peripheral BLE socket.
   * @param {number} uuid - the UUID of the characteristic to write to
   * @param {Array} message - the message to write.
   * @param {boolean} [useLimiter=true] - if true, use the rate limiter
   * @return {Promise} - a promise result of the write operation
   */


  send(uuid, message) {
    let useLimiter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    if (!this.isConnected()) return Promise.resolve();

    if (useLimiter) {
      if (!this._rateLimiter.okayToSend()) return Promise.resolve();
    }

    return this._ble.write(BoostBLE.service, uuid, Base64Util.uint8ArrayToBase64(message), 'base64');
  }
  /**
   * Generate a Boost 'Output Command' in the byte array format
   * (COMMON HEADER, PORT ID, EXECUTION BYTE, SUBCOMMAND ID, PAYLOAD).
   *
   * Payload is accepted as an array since these vary across different subcommands.
   *
   * @param  {number} portID - the port (Connect ID) to send a command to.
   * @param  {number} execution - Byte containing startup/completion information
   * @param  {number} subCommand - the id of the subcommand byte.
   * @param  {array}  payload    - the list of bytes to send as subcommand payload
   * @return {array}            - a generated output command.
   */


  generateOutputCommand(portID, execution, subCommand, payload) {
    const hubID = 0x00;
    const command = [hubID, BoostMessage.OUTPUT, portID, execution, subCommand, ...payload];
    command.unshift(command.length + 1); // Prepend payload with length byte;

    return command;
  }
  /**
   * Generate a Boost 'Input Command' in the byte array format
   * (COMMAND ID, COMMAND TYPE, CONNECT ID, TYPE ID, MODE, DELTA INTERVAL (4 BYTES),
   * UNIT, NOTIFICATIONS ENABLED).
   *
   * This sends a command to the Boost that sets that input format
   * of the specified inputs and sets value change notifications.
   *
   * @param  {number}  portID           - the port (Connect ID) to send a command to.
   * @param  {number}  mode                - the mode of the input sensor.
   * @param  {number}  delta               - the delta change needed to trigger notification.
   * @param  {boolean} enableNotifications - whether to enable notifications.
   * @return {array}                       - a generated input command.
   */


  generateInputCommand(portID, mode, delta, enableNotifications) {
    const command = [0x00, // Hub ID
    BoostMessage.PORT_INPUT_FORMAT_SETUP_SINGLE, portID, mode].concat(numberToInt32Array(delta)).concat([enableNotifications]);
    command.unshift(command.length + 1); // Prepend payload with length byte;

    return command;
  }
  /**
   * Starts reading data from peripheral after BLE has connected.
   * @private
   */


  _onConnect() {
    this._ble.startNotifications(BoostBLE.service, BoostBLE.characteristic, this._onMessage);

    this._pingDeviceId = window.setInterval(this._pingDevice, BoostPingInterval); // Send a request for firmware version.

    setTimeout(() => {
      const command = [0x00, // Hub ID
      BoostMessage.HUB_PROPERTIES, BoostHubProperty.FW_VERSION, BoostHubPropertyOperation.REQUEST_UPDATE];
      command.unshift(command.length + 1);
      this.send(BoostBLE.characteristic, command, false);
    }, 500);
  }
  /**
   * Process the sensor data from the incoming BLE characteristic.
   * @param {object} base64 - the incoming BLE data.
   * @private
   */


  _onMessage(base64) {
    const data = Base64Util.base64ToUint8Array(base64);
    /**
     * First three bytes are the common header:
     * 0: Length of message
     * 1: Hub ID (always 0x00 at the moment, unused)
     * 2: Message Type
     * 3: Port ID
     * We base our switch-case on Message Type
     */

    const messageType = data[2];
    const portID = data[3];

    switch (messageType) {
      case BoostMessage.HUB_PROPERTIES:
        {
          const property = data[3];

          switch (property) {
            case BoostHubProperty.FW_VERSION:
              {
                // Establish firmware version 1.0.00.0224 as a 32-bit signed integer (little endian)
                const fwVersion10000224 = int32ArrayToNumber([0x24, 0x02, 0x00, 0x10]);
                const fwHub = int32ArrayToNumber(data.slice(5, data.length));

                if (fwHub < fwVersion10000224) {
                  BoostPort = BoostPort10000223OrOlder;
                  log.info('Move Hub firmware older than version 1.0.00.0224 detected. Using old port mapping.');
                } else {
                  BoostPort = BoostPort10000224OrNewer;
                }

                break;
              }
          }

          break;
        }

      case BoostMessage.HUB_ATTACHED_IO:
        {
          // IO Attach/Detach events
          const event = data[4];
          const typeId = data[5];

          switch (event) {
            case BoostIOEvent.ATTACHED:
              this._registerSensorOrMotor(portID, typeId);

              break;

            case BoostIOEvent.DETACHED:
              this._clearPort(portID);

              break;

            case BoostIOEvent.ATTACHED_VIRTUAL:
            default:
          }

          break;
        }

      case BoostMessage.PORT_VALUE:
        {
          const type = this._ports[portID];

          switch (type) {
            case BoostIO.TILT:
              this._sensors.tiltX = data[4];
              this._sensors.tiltY = data[5];
              break;

            case BoostIO.COLOR:
              this._colorSamples.unshift(data[4]);

              if (this._colorSamples.length > BoostColorSampleSize) {
                this._colorSamples.pop();

                if (this._colorSamples.every((v, i, arr) => v === arr[0])) {
                  this._sensors.previousColor = this._sensors.color;
                  this._sensors.color = this.boostColorForIndex(this._colorSamples[0]);
                } else {
                  this._sensors.color = BoostColor.NONE;
                }
              } else {
                this._sensors.color = BoostColor.NONE;
              }

              break;

            case BoostIO.MOTOREXT:
            case BoostIO.MOTORINT:
              this.motor(portID).position = int32ArrayToNumber(data.slice(4, 8));
              break;

            case BoostIO.CURRENT:
            case BoostIO.VOLTAGE:
            case BoostIO.LED:
              break;

            default:
              log.warn("Unknown sensor value! Type: ".concat(type));
          }

          break;
        }

      case BoostMessage.PORT_FEEDBACK:
        {
          const feedback = data[4];
          const motor = this.motor(portID);

          if (motor) {
            // Makes sure that commands resolve both when they actually complete and when they fail
            const isBusy = feedback & BoostPortFeedback.IN_PROGRESS;
            const commandCompleted = feedback & (BoostPortFeedback.COMPLETED ^ BoostPortFeedback.DISCARDED);

            if (!isBusy && commandCompleted) {
              if (motor.status === BoostMotorState.ON_FOR_ROTATION) {
                motor.status = BoostMotorState.OFF;
              }
            }
          }

          break;
        }

      case BoostMessage.ERROR:
        log.warn("Error reported by hub: ".concat(data));
        break;
    }
  }
  /**
   * Ping the Boost hub. If the Boost hub has disconnected
   * for some reason, the BLE socket will get an error back and automatically
   * close the socket.
   * @private
   */


  _pingDevice() {
    this._ble.read(BoostBLE.service, BoostBLE.characteristic, false);
  }
  /**
   * Register a new sensor or motor connected at a port.  Store the type of
   * sensor or motor internally, and then register for notifications on input
   * values if it is a sensor.
   * @param {number} portID - the port to register a sensor or motor on.
   * @param {number} type - the type ID of the sensor or motor
   * @private
   */


  _registerSensorOrMotor(portID, type) {
    // Record which port is connected to what type of device
    this._ports[portID] = type; // Record motor port

    if (type === BoostIO.MOTORINT || type === BoostIO.MOTOREXT) {
      this._motors[portID] = new BoostMotor(this, portID);
    } // Set input format for tilt or distance sensor


    let mode = null;
    let delta = 1;

    switch (type) {
      case BoostIO.MOTORINT:
      case BoostIO.MOTOREXT:
        mode = BoostMode.MOTOR_SENSOR;
        break;

      case BoostIO.COLOR:
        mode = BoostMode.COLOR;
        delta = 0;
        break;

      case BoostIO.LED:
        mode = BoostMode.LED;
        /**
         * Sets the LED to blue to give an indication on the hub
         * that it has connected successfully.
         */

        this.setLEDMode();
        this.setLED(0x0000FF);
        break;

      case BoostIO.TILT:
        mode = BoostMode.TILT;
        break;

      default:
        mode = BoostMode.UNKNOWN;
    }

    const cmd = this.generateInputCommand(portID, mode, delta, true // Receive feedback
    );
    this.send(BoostBLE.characteristic, cmd);
  }
  /**
   * Clear the sensors or motors present on the ports.
   * @param {number} portID - the port to clear.
   * @private
   */


  _clearPort(portID) {
    const type = this._ports[portID];

    if (type === BoostIO.TILT) {
      this._sensors.tiltX = this._sensors.tiltY = 0;
    }

    if (type === BoostIO.COLOR) {
      this._sensors.color = BoostColor.NONE;
    }

    this._ports[portID] = 'none';
    this._motors[portID] = null;
  }

}
/**
 * Enum for motor specification.
 * @readonly
 * @enum {string}
 */


const BoostMotorLabel = {
  A: 'A',
  B: 'B',
  C: 'C',
  D: 'D',
  AB: 'AB',
  ALL: 'ABCD'
};
/**
 * Enum for motor direction specification.
 * @readonly
 * @enum {string}
 */

const BoostMotorDirection = {
  FORWARD: 'this way',
  BACKWARD: 'that way',
  REVERSE: 'reverse'
};
/**
 * Enum for tilt sensor direction.
 * @readonly
 * @enum {string}
 */

const BoostTiltDirection = {
  UP: 'up',
  DOWN: 'down',
  LEFT: 'left',
  RIGHT: 'right',
  ANY: 'any'
};
/**
 * Scratch 3.0 blocks to interact with a LEGO Boost peripheral.
 */

class Scratch3BoostBlocks {
  /**
   * @return {string} - the ID of this extension.
   */
  static get EXTENSION_ID() {
    return 'boost';
  }
  /**
   * @return {number} - the tilt sensor counts as "tilted" if its tilt angle meets or exceeds this threshold.
   */


  static get TILT_THRESHOLD() {
    return 15;
  }
  /**
   * Construct a set of Boost blocks.
   * @param {Runtime} runtime - the Scratch 3.0 runtime.
   */


  constructor(runtime) {
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime; // Create a new Boost peripheral instance

    this._peripheral = new Boost(this.runtime, Scratch3BoostBlocks.EXTENSION_ID);
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: Scratch3BoostBlocks.EXTENSION_ID,
      name: 'BOOST',
      blockIconURI: iconURI,
      showStatusButton: true,
      blocks: [{
        opcode: 'motorOnFor',
        text: formatMessage({
          id: 'boost.motorOnFor',
          default: 'turn motor [MOTOR_ID] for [DURATION] seconds',
          description: 'turn a motor on for some time'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_ID',
            defaultValue: BoostMotorLabel.A
          },
          DURATION: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        }
      }, {
        opcode: 'motorOnForRotation',
        text: formatMessage({
          id: 'boost.motorOnForRotation',
          default: 'turn motor [MOTOR_ID] for [ROTATION] rotations',
          description: 'turn a motor on for rotation'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_ID',
            defaultValue: BoostMotorLabel.A
          },
          ROTATION: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        }
      }, {
        opcode: 'motorOn',
        text: formatMessage({
          id: 'boost.motorOn',
          default: 'turn motor [MOTOR_ID] on',
          description: 'turn a motor on indefinitely'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_ID',
            defaultValue: BoostMotorLabel.A
          }
        }
      }, {
        opcode: 'motorOff',
        text: formatMessage({
          id: 'boost.motorOff',
          default: 'turn motor [MOTOR_ID] off',
          description: 'turn a motor off'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_ID',
            defaultValue: BoostMotorLabel.A
          }
        }
      }, {
        opcode: 'setMotorPower',
        text: formatMessage({
          id: 'boost.setMotorPower',
          default: 'set motor [MOTOR_ID] speed to [POWER] %',
          description: 'set the motor\'s speed without turning it on'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_ID',
            defaultValue: BoostMotorLabel.ALL
          },
          POWER: {
            type: ArgumentType.NUMBER,
            defaultValue: 100
          }
        }
      }, {
        opcode: 'setMotorDirection',
        text: formatMessage({
          id: 'boost.setMotorDirection',
          default: 'set motor [MOTOR_ID] direction [MOTOR_DIRECTION]',
          description: 'set the motor\'s turn direction without turning it on'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_ID',
            defaultValue: BoostMotorLabel.A
          },
          MOTOR_DIRECTION: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_DIRECTION',
            defaultValue: BoostMotorDirection.FORWARD
          }
        }
      }, {
        opcode: 'getMotorPosition',
        text: formatMessage({
          id: 'boost.getMotorPosition',
          default: 'motor [MOTOR_REPORTER_ID] position',
          description: 'the position returned by the motor'
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          MOTOR_REPORTER_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_REPORTER_ID',
            defaultValue: BoostMotorLabel.A
          }
        }
      }, {
        opcode: 'whenColor',
        text: formatMessage({
          id: 'boost.whenColor',
          default: 'when [COLOR] brick seen',
          description: 'check for when color'
        }),
        blockType: BlockType.HAT,
        arguments: {
          COLOR: {
            type: ArgumentType.STRING,
            menu: 'COLOR',
            defaultValue: BoostColor.ANY
          }
        }
      }, {
        opcode: 'seeingColor',
        text: formatMessage({
          id: 'boost.seeingColor',
          default: 'seeing [COLOR] brick?',
          description: 'is the color sensor seeing a certain color?'
        }),
        blockType: BlockType.BOOLEAN,
        arguments: {
          COLOR: {
            type: ArgumentType.STRING,
            menu: 'COLOR',
            defaultValue: BoostColor.ANY
          }
        }
      }, {
        opcode: 'whenTilted',
        text: formatMessage({
          id: 'boost.whenTilted',
          default: 'when tilted [TILT_DIRECTION_ANY]',
          description: 'check when tilted in a certain direction'
        }),
        func: 'isTilted',
        blockType: BlockType.HAT,
        arguments: {
          TILT_DIRECTION_ANY: {
            type: ArgumentType.STRING,
            menu: 'TILT_DIRECTION_ANY',
            defaultValue: BoostTiltDirection.ANY
          }
        }
      }, {
        opcode: 'getTiltAngle',
        text: formatMessage({
          id: 'boost.getTiltAngle',
          default: 'tilt angle [TILT_DIRECTION]',
          description: 'the angle returned by the tilt sensor'
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          TILT_DIRECTION: {
            type: ArgumentType.STRING,
            menu: 'TILT_DIRECTION',
            defaultValue: BoostTiltDirection.UP
          }
        }
      }, {
        opcode: 'setLightHue',
        text: formatMessage({
          id: 'boost.setLightHue',
          default: 'set light color to [HUE]',
          description: 'set the LED color'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          HUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        }
      }],
      menus: {
        MOTOR_ID: {
          acceptReporters: true,
          items: [{
            text: 'A',
            value: BoostMotorLabel.A
          }, {
            text: 'B',
            value: BoostMotorLabel.B
          }, {
            text: 'C',
            value: BoostMotorLabel.C
          }, {
            text: 'D',
            value: BoostMotorLabel.D
          }, {
            text: 'AB',
            value: BoostMotorLabel.AB
          }, {
            text: 'ABCD',
            value: BoostMotorLabel.ALL
          }]
        },
        MOTOR_REPORTER_ID: {
          acceptReporters: true,
          items: [{
            text: 'A',
            value: BoostMotorLabel.A
          }, {
            text: 'B',
            value: BoostMotorLabel.B
          }, {
            text: 'C',
            value: BoostMotorLabel.C
          }, {
            text: 'D',
            value: BoostMotorLabel.D
          }]
        },
        MOTOR_DIRECTION: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: 'boost.motorDirection.forward',
              default: 'this way',
              description: 'label for forward element in motor direction menu for LEGO Boost extension'
            }),
            value: BoostMotorDirection.FORWARD
          }, {
            text: formatMessage({
              id: 'boost.motorDirection.backward',
              default: 'that way',
              description: 'label for backward element in motor direction menu for LEGO Boost extension'
            }),
            value: BoostMotorDirection.BACKWARD
          }, {
            text: formatMessage({
              id: 'boost.motorDirection.reverse',
              default: 'reverse',
              description: 'label for reverse element in motor direction menu for LEGO Boost extension'
            }),
            value: BoostMotorDirection.REVERSE
          }]
        },
        TILT_DIRECTION: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: 'boost.tiltDirection.up',
              default: 'up',
              description: 'label for up element in tilt direction menu for LEGO Boost extension'
            }),
            value: BoostTiltDirection.UP
          }, {
            text: formatMessage({
              id: 'boost.tiltDirection.down',
              default: 'down',
              description: 'label for down element in tilt direction menu for LEGO Boost extension'
            }),
            value: BoostTiltDirection.DOWN
          }, {
            text: formatMessage({
              id: 'boost.tiltDirection.left',
              default: 'left',
              description: 'label for left element in tilt direction menu for LEGO Boost extension'
            }),
            value: BoostTiltDirection.LEFT
          }, {
            text: formatMessage({
              id: 'boost.tiltDirection.right',
              default: 'right',
              description: 'label for right element in tilt direction menu for LEGO Boost extension'
            }),
            value: BoostTiltDirection.RIGHT
          }]
        },
        TILT_DIRECTION_ANY: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: 'boost.tiltDirection.up',
              default: 'up'
            }),
            value: BoostTiltDirection.UP
          }, {
            text: formatMessage({
              id: 'boost.tiltDirection.down',
              default: 'down'
            }),
            value: BoostTiltDirection.DOWN
          }, {
            text: formatMessage({
              id: 'boost.tiltDirection.left',
              default: 'left'
            }),
            value: BoostTiltDirection.LEFT
          }, {
            text: formatMessage({
              id: 'boost.tiltDirection.right',
              default: 'right'
            }),
            value: BoostTiltDirection.RIGHT
          }, {
            text: formatMessage({
              id: 'boost.tiltDirection.any',
              default: 'any',
              description: 'label for any element in tilt direction menu for LEGO Boost extension'
            }),
            value: BoostTiltDirection.ANY
          }]
        },
        COLOR: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: 'boost.color.red',
              default: 'red',
              description: 'the color red'
            }),
            value: BoostColor.RED
          }, {
            text: formatMessage({
              id: 'boost.color.blue',
              default: 'blue',
              description: 'the color blue'
            }),
            value: BoostColor.BLUE
          }, {
            text: formatMessage({
              id: 'boost.color.green',
              default: 'green',
              description: 'the color green'
            }),
            value: BoostColor.GREEN
          }, {
            text: formatMessage({
              id: 'boost.color.yellow',
              default: 'yellow',
              description: 'the color yellow'
            }),
            value: BoostColor.YELLOW
          }, {
            text: formatMessage({
              id: 'boost.color.white',
              default: 'white',
              desription: 'the color white'
            }),
            value: BoostColor.WHITE
          }, {
            text: formatMessage({
              id: 'boost.color.black',
              default: 'black',
              description: 'the color black'
            }),
            value: BoostColor.BLACK
          }, {
            text: formatMessage({
              id: 'boost.color.any',
              default: 'any color',
              description: 'any color'
            }),
            value: BoostColor.ANY
          }]
        }
      }
    };
  }
  /**
   * Turn specified motor(s) on for a specified duration.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to activate.
   * @property {int} DURATION - the amount of time to run the motors.
   * @return {Promise} - a promise which will resolve at the end of the duration.
   */


  motorOnFor(args) {
    // TODO: cast args.MOTOR_ID?
    let durationMS = Cast.toNumber(args.DURATION) * 1000;
    durationMS = MathUtil.clamp(durationMS, 0, 15000);
    return new Promise(resolve => {
      this._forEachMotor(args.MOTOR_ID, motorIndex => {
        const motor = this._peripheral.motor(motorIndex);

        if (motor) motor.turnOnFor(durationMS);
      }); // Run for some time even when no motor is connected


      setTimeout(resolve, durationMS);
    });
  }
  /**
   * Turn specified motor(s) on for a specified rotation in full rotations.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to activate.
   * @property {int} ROTATION - the amount of full rotations to turn the motors.
   * @return {Promise} - a promise which will resolve at the end of the duration.
   */


  motorOnForRotation(args) {
    // TODO: cast args.MOTOR_ID?
    let degrees = Cast.toNumber(args.ROTATION) * 360; // TODO: Clamps to 100 rotations. Consider changing.

    const sign = Math.sign(degrees);
    degrees = Math.abs(MathUtil.clamp(degrees, -360000, 360000));
    const motors = [];

    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      motors.push(motorIndex);
    });
    /**
     * Checks that the motors given in args.MOTOR_ID exist,
     * and maps a promise for each of the motor-commands to an array.
     */


    const promises = motors.map(portID => {
      const motor = this._peripheral.motor(portID);

      if (motor) {
        // to avoid a hanging block if power is 0, return an immediately resolving promise.
        if (motor.power === 0) return Promise.resolve();
        return new Promise(resolve => {
          motor.turnOnForDegrees(degrees, sign);
          motor.pendingRotationPromise = resolve;
        });
      }

      return null;
    });
    /**
     * Make sure all promises are resolved, i.e. all motor-commands have completed.
     * To prevent the block from returning a value, an empty function is added to the .then
     */

    return Promise.all(promises).then(() => {});
  }
  /**
   * Turn specified motor(s) on indefinitely.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to activate.
   * @return {Promise} - a Promise that resolves after some delay.
   */


  motorOn(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) motor.turnOnForever();
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BoostBLE.sendInterval);
    });
  }
  /**
   * Turn specified motor(s) off.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to deactivate.
   * @return {Promise} - a Promise that resolves after some delay.
   */


  motorOff(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) motor.turnOff();
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BoostBLE.sendInterval);
    });
  }
  /**
   * Set the power level of the specified motor(s).
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to be affected.
   * @property {int} POWER - the new power level for the motor(s).
   * @return {Promise} - returns a promise to make sure the block yields.
   */


  setMotorPower(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) {
        motor.power = MathUtil.clamp(Cast.toNumber(args.POWER), 0, 100);

        switch (motor.status) {
          case BoostMotorState.ON_FOREVER:
            motor.turnOnForever();
            break;

          case BoostMotorState.ON_FOR_TIME:
            motor.turnOnFor(motor.pendingDurationTimeoutStartTime + motor.pendingDurationTimeoutDelay - Date.now());
            break;
        }
      }
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BoostBLE.sendInterval);
    });
  }
  /**
   * Set the direction of rotation for specified motor(s).
   * If the direction is 'reverse' the motor(s) will be reversed individually.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to be affected.
   * @property {MotorDirection} MOTOR_DIRECTION - the new direction for the motor(s).
   * @return {Promise} - returns a promise to make sure the block yields.
   */


  setMotorDirection(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) {
        switch (args.MOTOR_DIRECTION) {
          case BoostMotorDirection.FORWARD:
            motor.direction = 1;
            break;

          case BoostMotorDirection.BACKWARD:
            motor.direction = -1;
            break;

          case BoostMotorDirection.REVERSE:
            motor.direction = -motor.direction;
            break;

          default:
            log.warn("Unknown motor direction in setMotorDirection: ".concat(args.DIRECTION));
            break;
        } // keep the motor on if it's running, and update the pending timeout if needed


        if (motor) {
          switch (motor.status) {
            case BoostMotorState.ON_FOREVER:
              motor.turnOnForever();
              break;

            case BoostMotorState.ON_FOR_TIME:
              motor.turnOnFor(motor.pendingDurationTimeoutStartTime + motor.pendingDurationTimeoutDelay - Date.now());
              break;
          }
        }
      }
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BoostBLE.sendInterval);
    });
  }
  /**
   * @param {object} args - the block's arguments.
   * @return {number} - returns the motor's position.
   */


  getMotorPosition(args) {
    let portID = null;

    switch (args.MOTOR_REPORTER_ID) {
      case BoostMotorLabel.A:
        portID = BoostPort.A;
        break;

      case BoostMotorLabel.B:
        portID = BoostPort.B;
        break;

      case BoostMotorLabel.C:
        portID = BoostPort.C;
        break;

      case BoostMotorLabel.D:
        portID = BoostPort.D;
        break;

      default:
        log.warn('Asked for a motor position that doesnt exist!');
        return false;
    }

    if (portID !== null && this._peripheral.motor(portID)) {
      let val = this._peripheral.motor(portID).position; // Boost motor A position direction is reversed by design
      // so we have to reverse the position here


      if (portID === BoostPort.A) {
        val *= -1;
      }

      return MathUtil.wrapClamp(val, 0, 360);
    }

    return 0;
  }
  /**
   * Call a callback for each motor indexed by the provided motor ID.
   * @param {MotorID} motorID - the ID specifier.
   * @param {Function} callback - the function to call with the numeric motor index for each motor.
   * @private
   */


  _forEachMotor(motorID, callback) {
    let motors;

    switch (motorID) {
      case BoostMotorLabel.A:
        motors = [BoostPort.A];
        break;

      case BoostMotorLabel.B:
        motors = [BoostPort.B];
        break;

      case BoostMotorLabel.C:
        motors = [BoostPort.C];
        break;

      case BoostMotorLabel.D:
        motors = [BoostPort.D];
        break;

      case BoostMotorLabel.AB:
        motors = [BoostPort.A, BoostPort.B];
        break;

      case BoostMotorLabel.ALL:
        motors = [BoostPort.A, BoostPort.B, BoostPort.C, BoostPort.D];
        break;

      default:
        log.warn("Invalid motor ID: ".concat(motorID));
        motors = [];
        break;
    }

    for (const index of motors) {
      callback(index);
    }
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */


  whenTilted(args) {
    return this._isTilted(args.TILT_DIRECTION_ANY);
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */


  isTilted(args) {
    return this._isTilted(args.TILT_DIRECTION_ANY);
  }
  /**
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION - the direction (up, down, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).
   */


  getTiltAngle(args) {
    return this._getTiltAngle(args.TILT_DIRECTION);
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {TiltDirection} direction - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   * @private
   */


  _isTilted(direction) {
    switch (direction) {
      case BoostTiltDirection.ANY:
        return Math.abs(this._peripheral.tiltX) >= Scratch3BoostBlocks.TILT_THRESHOLD || Math.abs(this._peripheral.tiltY) >= Scratch3BoostBlocks.TILT_THRESHOLD;

      default:
        return this._getTiltAngle(direction) >= Scratch3BoostBlocks.TILT_THRESHOLD;
    }
  }
  /**
   * @param {TiltDirection} direction - the direction (up, down, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).
   * @private
   */


  _getTiltAngle(direction) {
    switch (direction) {
      case BoostTiltDirection.UP:
        return this._peripheral.tiltY > 90 ? 256 - this._peripheral.tiltY : -this._peripheral.tiltY;

      case BoostTiltDirection.DOWN:
        return this._peripheral.tiltY > 90 ? this._peripheral.tiltY - 256 : this._peripheral.tiltY;

      case BoostTiltDirection.LEFT:
        return this._peripheral.tiltX > 90 ? this._peripheral.tiltX - 256 : this._peripheral.tiltX;

      case BoostTiltDirection.RIGHT:
        return this._peripheral.tiltX > 90 ? 256 - this._peripheral.tiltX : -this._peripheral.tiltX;

      default:
        log.warn("Unknown tilt direction in _getTiltAngle: ".concat(direction));
    }
  }
  /**
   * Edge-triggering hat function, for when the vision sensor is detecting
   * a certain color.
   * @param {object} args - the block's arguments.
   * @return {boolean} - true when the color sensor senses the specified color.
   */


  whenColor(args) {
    if (args.COLOR === BoostColor.ANY) {
      // For "any" color, return true if the color is not "none", and
      // the color is different from the previous color detected. This
      // allows the hat to trigger when the color changes from one color
      // to another.
      return this._peripheral.color !== BoostColor.NONE && this._peripheral.color !== this._peripheral.previousColor;
    }

    return args.COLOR === this._peripheral.color;
  }
  /**
   * A boolean reporter function, for whether the vision sensor is detecting
   * a certain color.
   * @param {object} args - the block's arguments.
   * @return {boolean} - true when the color sensor senses the specified color.
   */


  seeingColor(args) {
    if (args.COLOR === BoostColor.ANY) {
      return this._peripheral.color !== BoostColor.NONE;
    }

    return args.COLOR === this._peripheral.color;
  }
  /**
   * Set the LED's hue.
   * @param {object} args - the block's arguments.
   * @property {number} HUE - the hue to set, in the range [0,100].
   * @return {Promise} - a Promise that resolves after some delay.
   */


  setLightHue(args) {
    // Convert from [0,100] to [0,360]
    let inputHue = Cast.toNumber(args.HUE);
    inputHue = MathUtil.wrapClamp(inputHue, 0, 100);
    const hue = inputHue * 360 / 100;
    const rgbObject = color.hsvToRgb({
      h: hue,
      s: 1,
      v: 1
    });
    const rgbDecimal = color.rgbToDecimal(rgbObject);
    this._peripheral._led = inputHue;

    this._peripheral.setLED(rgbDecimal);

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BoostBLE.sendInterval);
    });
  }

}

module.exports = Scratch3BoostBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_ev3/index.js":
/*!**********************************************!*\
  !*** ./src/extensions/scratch3_ev3/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const Cast = __webpack_require__(/*! ../../util/cast */ "./src/util/cast.js");

const formatMessage = __webpack_require__(/*! format-message */ "format-message");

const uid = __webpack_require__(/*! ../../util/uid */ "./src/util/uid.js");

const BT = __webpack_require__(/*! ../../io/bt */ "./src/io/bt.js");

const Base64Util = __webpack_require__(/*! ../../util/base64-util */ "./src/util/base64-util.js");

const MathUtil = __webpack_require__(/*! ../../util/math-util */ "./src/util/math-util.js");

const RateLimiter = __webpack_require__(/*! ../../util/rateLimiter.js */ "./src/util/rateLimiter.js");

const log = __webpack_require__(/*! ../../util/log */ "./src/util/log.js");
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const blockIconURI = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNDBweCIgaGVpZ2h0PSI0MHB4IiB2aWV3Qm94PSIwIDAgNDAgNDAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDUwLjIgKDU1MDQ3KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5ldjMtYmxvY2staWNvbjwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxkZWZzPjwvZGVmcz4KICAgIDxnIGlkPSJldjMtYmxvY2staWNvbiIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9ImV2MyIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNS41MDAwMDAsIDMuNTAwMDAwKSIgZmlsbC1ydWxlPSJub256ZXJvIj4KICAgICAgICAgICAgPHJlY3QgaWQ9IlJlY3RhbmdsZS1wYXRoIiBzdHJva2U9IiM3Qzg3QTUiIGZpbGw9IiNGRkZGRkYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgeD0iMC41IiB5PSIzLjU5IiB3aWR0aD0iMjgiIGhlaWdodD0iMjUuODEiIHJ4PSIxIj48L3JlY3Q+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtcGF0aCIgc3Ryb2tlPSIjN0M4N0E1IiBmaWxsPSIjRTZFN0U4IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHg9IjIuNSIgeT0iMC41IiB3aWR0aD0iMjQiIGhlaWdodD0iMzIiIHJ4PSIxIj48L3JlY3Q+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtcGF0aCIgc3Ryb2tlPSIjN0M4N0E1IiBmaWxsPSIjRkZGRkZGIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHg9IjIuNSIgeT0iMTQuNSIgd2lkdGg9IjI0IiBoZWlnaHQ9IjEzIj48L3JlY3Q+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0xNC41LDEwLjUgTDE0LjUsMTQuNSIgaWQ9IlNoYXBlIiBzdHJva2U9IiM3Qzg3QTUiIGZpbGw9IiNFNkU3RTgiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCI+PC9wYXRoPgogICAgICAgICAgICA8cmVjdCBpZD0iUmVjdGFuZ2xlLXBhdGgiIGZpbGw9IiM0MTQ3NTciIHg9IjQuNSIgeT0iMi41IiB3aWR0aD0iMjAiIGhlaWdodD0iMTAiIHJ4PSIxIj48L3JlY3Q+CiAgICAgICAgICAgIDxyZWN0IGlkPSJSZWN0YW5nbGUtcGF0aCIgZmlsbD0iIzdDODdBNSIgb3BhY2l0eT0iMC41IiB4PSIxMy41IiB5PSIyMC4xMyIgd2lkdGg9IjIiIGhlaWdodD0iMiIgcng9IjAuNSI+PC9yZWN0PgogICAgICAgICAgICA8cGF0aCBkPSJNOS4wNiwyMC4xMyBMMTAuNTYsMjAuMTMgQzEwLjgzNjE0MjQsMjAuMTMgMTEuMDYsMjAuMzUzODU3NiAxMS4wNiwyMC42MyBMMTEuMDYsMjEuNjMgQzExLjA2LDIxLjkwNjE0MjQgMTAuODM2MTQyNCwyMi4xMyAxMC41NiwyMi4xMyBMOS4wNiwyMi4xMyBDOC41MDc3MTUyNSwyMi4xMyA4LjA2LDIxLjY4MjI4NDcgOC4wNiwyMS4xMyBDOC4wNiwyMC41Nzc3MTUzIDguNTA3NzE1MjUsMjAuMTMgOS4wNiwyMC4xMyBaIiBpZD0iU2hhcGUiIGZpbGw9IiM3Qzg3QTUiIG9wYWNpdHk9IjAuNSI+PC9wYXRoPgogICAgICAgICAgICA8cGF0aCBkPSJNMTguOTEsMjAuMTMgTDIwLjQyLDIwLjEzIEMyMC42OTYxNDI0LDIwLjEzIDIwLjkyLDIwLjM1Mzg1NzYgMjAuOTIsMjAuNjMgTDIwLjkyLDIxLjYzIEMyMC45MiwyMS45MDYxNDI0IDIwLjY5NjE0MjQsMjIuMTMgMjAuNDIsMjIuMTMgTDE4LjkyLDIyLjEzIEMxOC4zNjc3MTUzLDIyLjEzIDE3LjkyLDIxLjY4MjI4NDcgMTcuOTIsMjEuMTMgQzE3LjkxOTk3MjYsMjAuNTgxNTk3IDE4LjM2MTYyNDUsMjAuMTM1NDg0IDE4LjkxLDIwLjEzIFoiIGlkPSJTaGFwZSIgZmlsbD0iIzdDODdBNSIgb3BhY2l0eT0iMC41IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxOS40MjAwMDAsIDIxLjEzMDAwMCkgcm90YXRlKC0xODAuMDAwMDAwKSB0cmFuc2xhdGUoLTE5LjQyMDAwMCwgLTIxLjEzMDAwMCkgIj48L3BhdGg+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik04LjIzLDE3LjUgTDUsMTcuNSBDNC43MjM4NTc2MywxNy41IDQuNSwxNy4yNzYxNDI0IDQuNSwxNyBMNC41LDE0LjUgTDEwLjUsMTQuNSBMOC42NSwxNy4yOCBDOC41NTQ2Njk2MSwxNy40MTc5MDgyIDguMzk3NjUwMDYsMTcuNTAwMTU2NiA4LjIzLDE3LjUgWiIgaWQ9IlNoYXBlIiBmaWxsPSIjN0M4N0E1IiBvcGFjaXR5PSIwLjUiPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggZD0iTTE4LjE1LDE4Ljg1IEwxNy42NSwxOS4zNSBDMTcuNTUyMzQxNiwxOS40NDQwNzU2IDE3LjQ5ODAzMzksMTkuNTc0NDE0MiAxNy41LDE5LjcxIEwxNy41LDIwIEMxNy41LDIwLjI3NjE0MjQgMTcuMjc2MTQyNCwyMC41IDE3LDIwLjUgTDE2LjUsMjAuNSBDMTYuMjIzODU3NiwyMC41IDE2LDIwLjI3NjE0MjQgMTYsMjAgQzE2LDE5LjcyMzg1NzYgMTUuNzc2MTQyNCwxOS41IDE1LjUsMTkuNSBMMTMuNSwxOS41IEMxMy4yMjM4NTc2LDE5LjUgMTMsMTkuNzIzODU3NiAxMywyMCBDMTMsMjAuMjc2MTQyNCAxMi43NzYxNDI0LDIwLjUgMTIuNSwyMC41IEwxMiwyMC41IEMxMS43MjM4NTc2LDIwLjUgMTEuNSwyMC4yNzYxNDI0IDExLjUsMjAgTDExLjUsMTkuNzEgQzExLjUwMTk2NjEsMTkuNTc0NDE0MiAxMS40NDc2NTg0LDE5LjQ0NDA3NTYgMTEuMzUsMTkuMzUgTDEwLjg1LDE4Ljg1IEMxMC42NTgyMTY3LDE4LjY1MjE4NjMgMTAuNjU4MjE2NywxOC4zMzc4MTM3IDEwLjg1LDE4LjE0IEwxMi4zNiwxNi42NSBDMTIuNDUwMjgwMywxNi41NTI4NjE3IDEyLjU3NzM5NjEsMTYuNDk4MzgzNSAxMi43MSwxNi41IEwxNi4yOSwxNi41IEMxNi40MjI2MDM5LDE2LjQ5ODM4MzUgMTYuNTQ5NzE5NywxNi41NTI4NjE3IDE2LjY0LDE2LjY1IEwxOC4xNSwxOC4xNCBDMTguMzQxNzgzMywxOC4zMzc4MTM3IDE4LjM0MTc4MzMsMTguNjUyMTg2MyAxOC4xNSwxOC44NSBaIiBpZD0iU2hhcGUiIGZpbGw9IiM3Qzg3QTUiIG9wYWNpdHk9IjAuNSI+PC9wYXRoPgogICAgICAgICAgICA8cGF0aCBkPSJNMTAuODUsMjMuNDUgTDExLjM1LDIyLjk1IEMxMS40NDc2NTg0LDIyLjg1NTkyNDQgMTEuNTAxOTY2MSwyMi43MjU1ODU4IDExLjUsMjIuNTkgTDExLjUsMjIuMyBDMTEuNSwyMi4wMjM4NTc2IDExLjcyMzg1NzYsMjEuOCAxMiwyMS44IEwxMi41LDIxLjggQzEyLjc3NjE0MjQsMjEuOCAxMywyMi4wMjM4NTc2IDEzLDIyLjMgQzEzLDIyLjU3NjE0MjQgMTMuMjIzODU3NiwyMi44IDEzLjUsMjIuOCBMMTUuNSwyMi44IEMxNS43NzYxNDI0LDIyLjggMTYsMjIuNTc2MTQyNCAxNiwyMi4zIEMxNiwyMi4wMjM4NTc2IDE2LjIyMzg1NzYsMjEuOCAxNi41LDIxLjggTDE3LDIxLjggQzE3LjI3NjE0MjQsMjEuOCAxNy41LDIyLjAyMzg1NzYgMTcuNSwyMi4zIEwxNy41LDIyLjU5IEMxNy40OTgwMzM5LDIyLjcyNTU4NTggMTcuNTUyMzQxNiwyMi44NTU5MjQ0IDE3LjY1LDIyLjk1IEwxOC4xNSwyMy40NSBDMTguMzQwNTcxNCwyMy42NDQ0MjE4IDE4LjM0MDU3MTQsMjMuOTU1NTc4MiAxOC4xNSwyNC4xNSBMMTYuNjQsMjUuNjUgQzE2LjU0OTcxOTcsMjUuNzQ3MTM4MyAxNi40MjI2MDM5LDI1LjgwMTYxNjUgMTYuMjksMjUuOCBMMTIuNzEsMjUuOCBDMTIuNTc3Mzk2MSwyNS44MDE2MTY1IDEyLjQ1MDI4MDMsMjUuNzQ3MTM4MyAxMi4zNiwyNS42NSBMMTAuODUsMjQuMTUgQzEwLjY1OTQyODYsMjMuOTU1NTc4MiAxMC42NTk0Mjg2LDIzLjY0NDQyMTggMTAuODUsMjMuNDUgWiIgaWQ9IlNoYXBlIiBmaWxsPSIjN0M4N0E1IiBvcGFjaXR5PSIwLjUiPjwvcGF0aD4KICAgICAgICAgICAgPHBhdGggZD0iTTIxLjUsMjcuNSBMMjYuNSwyNy41IEwyNi41LDMxLjUgQzI2LjUsMzIuMDUyMjg0NyAyNi4wNTIyODQ3LDMyLjUgMjUuNSwzMi41IEwyMS41LDMyLjUgTDIxLjUsMjcuNSBaIiBpZD0iU2hhcGUiIHN0cm9rZT0iI0NDNEMyMyIgZmlsbD0iI0YxNUEyOSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48L3BhdGg+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4=';
/**
 * String with Ev3 expected pairing pin.
 * @readonly
 */

const Ev3PairingPin = '1234';
/**
 * A maximum number of BT message sends per second, to be enforced by the rate limiter.
 * @type {number}
 */

const BTSendRateMax = 40;
/**
 * Enum for Ev3 parameter encodings of various argument and return values.
 * Found in the 'EV3 Firmware Developer Kit', section4, page 9, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 *
 * The format for these values is:
 * 0xxxxxxx for Short Format
 * 1ttt-bbb for Long Format
 *
 * @readonly
 * @enum {number}
 */

const Ev3Encoding = {
  ONE_BYTE: 0x81,
  // = 0b1000-001, "1 byte to follow"
  TWO_BYTES: 0x82,
  // = 0b1000-010, "2 bytes to follow"
  FOUR_BYTES: 0x83,
  // = 0b1000-011, "4 bytes to follow"
  GLOBAL_VARIABLE_ONE_BYTE: 0xE1,
  // = 0b1110-001, "1 byte to follow"
  GLOBAL_CONSTANT_INDEX_0: 0x20,
  // = 0b00100000
  GLOBAL_VARIABLE_INDEX_0: 0x60 // = 0b01100000

};
/**
 * Enum for Ev3 direct command types.
 * Found in the 'EV3 Communication Developer Kit', section 4, page 24, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 * @readonly
 * @enum {number}
 */

const Ev3Command = {
  DIRECT_COMMAND_REPLY: 0x00,
  DIRECT_COMMAND_NO_REPLY: 0x80,
  DIRECT_REPLY: 0x02
};
/**
 * Enum for Ev3 commands opcodes.
 * Found in the 'EV3 Firmware Developer Kit', section 4, page 10, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 * @readonly
 * @enum {number}
 */

const Ev3Opcode = {
  OPOUTPUT_STEP_SPEED: 0xAE,
  OPOUTPUT_TIME_SPEED: 0xAF,
  OPOUTPUT_STOP: 0xA3,
  OPOUTPUT_RESET: 0xA2,
  OPOUTPUT_STEP_SYNC: 0xB0,
  OPOUTPUT_TIME_SYNC: 0xB1,
  OPOUTPUT_GET_COUNT: 0xB3,
  OPSOUND: 0x94,
  OPSOUND_CMD_TONE: 1,
  OPSOUND_CMD_STOP: 0,
  OPINPUT_DEVICE_LIST: 0x98,
  OPINPUT_READSI: 0x9D
};
/**
 * Enum for Ev3 values used as arguments to various opcodes.
 * Found in the 'EV3 Firmware Developer Kit', section4, page 10-onwards, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 * @readonly
 * @enum {number}
 */

const Ev3Args = {
  LAYER: 0,
  // always 0, chained EV3s not supported
  COAST: 0,
  BRAKE: 1,
  RAMP: 50,
  // time in milliseconds
  DO_NOT_CHANGE_TYPE: 0,
  MAX_DEVICES: 32 // 'Normally 32' from pg. 46

};
/**
 * Enum for Ev3 device type numbers.
 * Found in the 'EV3 Firmware Developer Kit', section 5, page 100, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 * @readonly
 * @enum {string}
 */

const Ev3Device = {
  29: 'color',
  30: 'ultrasonic',
  32: 'gyro',
  16: 'touch',
  8: 'mediumMotor',
  7: 'largeMotor',
  126: 'none',
  125: 'none'
};
/**
 * Enum for Ev3 device modes.
 * Found in the 'EV3 Firmware Developer Kit', section 5, page 100, at
 * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
 * @readonly
 * @enum {number}
 */

const Ev3Mode = {
  touch: 0,
  // touch
  color: 1,
  // ambient
  ultrasonic: 1,
  // inch
  none: 0
};
/**
 * Enum for Ev3 device labels used in the Scratch blocks/UI.
 * @readonly
 * @enum {string}
 */

const Ev3Label = {
  touch: 'button',
  color: 'brightness',
  ultrasonic: 'distance'
};
/**
 * Manage power, direction, and timers for one EV3 motor.
 */

class EV3Motor {
  /**
   * Construct a EV3 Motor instance, which could be of type 'largeMotor' or
   * 'mediumMotor'.
   *
   * @param {EV3} parent - the EV3 peripheral which owns this motor.
   * @param {int} index - the zero-based index of this motor on its parent peripheral.
   * @param {string} type - the type of motor (i.e. 'largeMotor' or 'mediumMotor').
   */
  constructor(parent, index, type) {
    /**
     * The EV3 peripheral which owns this motor.
     * @type {EV3}
     * @private
     */
    this._parent = parent;
    /**
     * The zero-based index of this motor on its parent peripheral.
     * @type {int}
     * @private
     */

    this._index = index;
    /**
     * The type of EV3 motor this could be: 'largeMotor' or 'mediumMotor'.
     * @type {string}
     * @private
     */

    this._type = type;
    /**
     * This motor's current direction: 1 for "clockwise" or -1 for "counterclockwise"
     * @type {number}
     * @private
     */

    this._direction = 1;
    /**
     * This motor's current power level, in the range [0,100].
     * @type {number}
     * @private
     */

    this._power = 50;
    /**
     * This motor's current position, in the range [0,360].
     * @type {number}
     * @private
     */

    this._position = 0;
    /**
     * An ID for the current coast command, to help override multiple coast
     * commands sent in succession.
     * @type {number}
     * @private
     */

    this._commandID = null;
    /**
     * A delay, in milliseconds, to add to coasting, to make sure that a brake
     * first takes effect if one was sent.
     * @type {number}
     * @private
     */

    this._coastDelay = 1000;
  }
  /**
   * @return {string} - this motor's type: 'largeMotor' or 'mediumMotor'
   */


  get type() {
    return this._type;
  }
  /**
   * @param {string} value - this motor's new type: 'largeMotor' or 'mediumMotor'
   */


  set type(value) {
    this._type = value;
  }
  /**
   * @return {int} - this motor's current direction: 1 for "clockwise" or -1 for "counterclockwise"
   */


  get direction() {
    return this._direction;
  }
  /**
   * @param {int} value - this motor's new direction: 1 for "clockwise" or -1 for "counterclockwise"
   */


  set direction(value) {
    if (value < 0) {
      this._direction = -1;
    } else {
      this._direction = 1;
    }
  }
  /**
   * @return {int} - this motor's current power level, in the range [0,100].
   */


  get power() {
    return this._power;
  }
  /**
   * @param {int} value - this motor's new power level, in the range [0,100].
   */


  set power(value) {
    this._power = value;
  }
  /**
   * @return {int} - this motor's current position, in the range [-inf,inf].
   */


  get position() {
    return this._position;
  }
  /**
   * @param {int} array - this motor's new position, in the range [0,360].
   */


  set position(array) {
    // tachoValue from Paula
    let value = array[0] + array[1] * 256 + array[2] * 256 * 256 + array[3] * 256 * 256 * 256;

    if (value > 0x7fffffff) {
      value = value - 0x100000000;
    }

    this._position = value;
  }
  /**
   * Turn this motor on for a specific duration.
   * Found in the 'EV3 Firmware Developer Kit', page 56, at
   * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
   *
   * Opcode arguments:
   * (Data8) LAYER  Specify chain layer number [0 - 3]
   * (Data8) NOS  Output bit field [0x00  0x0F]
   * (Data8) SPEED  Power level, [-100  100]
   * (Data32) STEP1  Time in milliseconds for ramp up
   * (Data32) STEP2  Time in milliseconds for continues run
   * (Data32) STEP3  Time in milliseconds for ramp down
   * (Data8) BRAKE - Specify break level [0: Float, 1: Break]
   *
   * @param {number} milliseconds - run the motor for this long.
   */


  turnOnFor(milliseconds) {
    if (this._power === 0) return;

    const port = this._portMask(this._index);

    let n = milliseconds;
    let speed = this._power * this._direction;
    const ramp = Ev3Args.RAMP;
    let byteCommand = [];
    byteCommand[0] = Ev3Opcode.OPOUTPUT_TIME_SPEED; // If speed is less than zero, make it positive and multiply the input
    // value by -1

    if (speed < 0) {
      speed = -1 * speed;
      n = -1 * n;
    } // If the input value is less than 0


    const dir = n < 0 ? 0x100 - speed : speed; // step negative or positive

    n = Math.abs(n); // Setup motor run duration and ramping behavior

    let rampup = ramp;
    let rampdown = ramp;
    let run = n - ramp * 2;

    if (run < 0) {
      rampup = Math.floor(n / 2);
      run = 0;
      rampdown = n - rampup;
    } // Generate motor command values


    const runcmd = this._runValues(run);

    byteCommand = byteCommand.concat([Ev3Args.LAYER, port, Ev3Encoding.ONE_BYTE, dir & 0xff, Ev3Encoding.ONE_BYTE, rampup]).concat(runcmd.concat([Ev3Encoding.ONE_BYTE, rampdown, Ev3Args.BRAKE]));

    const cmd = this._parent.generateCommand(Ev3Command.DIRECT_COMMAND_NO_REPLY, byteCommand);

    this._parent.send(cmd);

    this.coastAfter(milliseconds);
  }
  /**
   * Set the motor to coast after a specified amount of time.
   * @param {number} time - the time in milliseconds.
   */


  coastAfter(time) {
    if (this._power === 0) return; // Set the motor command id to check before starting coast

    const commandId = uid();
    this._commandID = commandId; // Send coast message

    setTimeout(() => {
      // Do not send coast if another motor command changed the command id.
      if (this._commandID === commandId) {
        this.coast();
        this._commandID = null;
      }
    }, time + this._coastDelay); // add a delay so the brake takes effect
  }
  /**
   * Set the motor to coast.
   */


  coast() {
    if (this._power === 0) return;

    const cmd = this._parent.generateCommand(Ev3Command.DIRECT_COMMAND_NO_REPLY, [Ev3Opcode.OPOUTPUT_STOP, Ev3Args.LAYER, this._portMask(this._index), // port output bit field
    Ev3Args.COAST]);

    this._parent.send(cmd, false); // don't use rate limiter to ensure motor stops

  }
  /**
   * Generate motor run values for a given input.
   * @param  {number} run - run input.
   * @return {array} - run values as a byte array.
   */


  _runValues(run) {
    // If run duration is less than max 16-bit integer
    if (run < 0x7fff) {
      return [Ev3Encoding.TWO_BYTES, run & 0xff, run >> 8 & 0xff];
    } // Run forever


    return [Ev3Encoding.FOUR_BYTES, run & 0xff, run >> 8 & 0xff, run >> 16 & 0xff, run >> 24 & 0xff];
  }
  /**
   * Return a port value for the EV3 that is in the format for 'output bit field'
   * as 1/2/4/8, generally needed for motor ports, instead of the typical 0/1/2/3.
   * The documentation in the 'EV3 Firmware Developer Kit' for motor port arguments
   * is sometimes mistaken, but we believe motor ports are mostly addressed this way.
   * @param {number} port - the port number to convert to an 'output bit field'.
   * @return {number} - the converted port number.
   */


  _portMask(port) {
    return Math.pow(2, port);
  }

}

class EV3 {
  constructor(runtime, extensionId) {
    /**
     * The Scratch 3.0 runtime used to trigger the green flag button.
     * @type {Runtime}
     * @private
     */
    this._runtime = runtime;

    this._runtime.on('PROJECT_STOP_ALL', this.stopAll.bind(this));
    /**
     * The id of the extension this peripheral belongs to.
     */


    this._extensionId = extensionId;
    /**
     * A list of the names of the sensors connected in ports 1,2,3,4.
     * @type {string[]}
     * @private
     */

    this._sensorPorts = [];
    /**
     * A list of the names of the motors connected in ports A,B,C,D.
     * @type {string[]}
     * @private
     */

    this._motorPorts = [];
    /**
     * The state of all sensor values.
     * @type {string[]}
     * @private
     */

    this._sensors = {
      distance: 0,
      brightness: 0,
      buttons: [0, 0, 0, 0]
    };
    /**
     * The motors which this EV3 could possibly have connected.
     * @type {string[]}
     * @private
     */

    this._motors = [null, null, null, null];
    /**
     * The polling interval, in milliseconds.
     * @type {number}
     * @private
     */

    this._pollingInterval = 150;
    /**
     * The polling interval ID.
     * @type {number}
     * @private
     */

    this._pollingIntervalID = null;
    /**
     * The counter keeping track of polling cycles.
     * @type {string[]}
     * @private
     */

    this._pollingCounter = 0;
    /**
     * The Bluetooth socket connection for reading/writing peripheral data.
     * @type {BT}
     * @private
     */

    this._bt = null;

    this._runtime.registerPeripheralExtension(extensionId, this);
    /**
     * A rate limiter utility, to help limit the rate at which we send BT messages
     * over the socket to Scratch Link to a maximum number of sends per second.
     * @type {RateLimiter}
     * @private
     */


    this._rateLimiter = new RateLimiter(BTSendRateMax);
    this.reset = this.reset.bind(this);
    this._onConnect = this._onConnect.bind(this);
    this._onMessage = this._onMessage.bind(this);
    this._pollValues = this._pollValues.bind(this);
  }

  get distance() {
    let value = this._sensors.distance > 100 ? 100 : this._sensors.distance;
    value = value < 0 ? 0 : value;
    value = Math.round(100 * value) / 100;
    return value;
  }

  get brightness() {
    return this._sensors.brightness;
  }
  /**
   * Access a particular motor on this peripheral.
   * @param {int} index - the zero-based index of the desired motor.
   * @return {EV3Motor} - the EV3Motor instance, if any, at that index.
   */


  motor(index) {
    return this._motors[index];
  }

  isButtonPressed(port) {
    return this._sensors.buttons[port] === 1;
  }

  beep(freq, time) {
    const cmd = this.generateCommand(Ev3Command.DIRECT_COMMAND_NO_REPLY, [Ev3Opcode.OPSOUND, Ev3Opcode.OPSOUND_CMD_TONE, Ev3Encoding.ONE_BYTE, 2, Ev3Encoding.TWO_BYTES, freq, freq >> 8, Ev3Encoding.TWO_BYTES, time, time >> 8]);
    this.send(cmd);
  }

  stopAll() {
    this.stopAllMotors();
    this.stopSound();
  }

  stopSound() {
    const cmd = this.generateCommand(Ev3Command.DIRECT_COMMAND_NO_REPLY, [Ev3Opcode.OPSOUND, Ev3Opcode.OPSOUND_CMD_STOP]);
    this.send(cmd, false); // don't use rate limiter to ensure sound stops
  }

  stopAllMotors() {
    this._motors.forEach(motor => {
      if (motor) {
        motor.coast();
      }
    });
  }
  /**
   * Called by the runtime when user wants to scan for an EV3 peripheral.
   */


  scan() {
    if (this._bt) {
      this._bt.disconnect();
    }

    this._bt = new BT(this._runtime, this._extensionId, {
      majorDeviceClass: 8,
      minorDeviceClass: 1
    }, this._onConnect, this.reset, this._onMessage);
  }
  /**
   * Called by the runtime when user wants to connect to a certain EV3 peripheral.
   * @param {number} id - the id of the peripheral to connect to.
   */


  connect(id) {
    if (this._bt) {
      this._bt.connectPeripheral(id, Ev3PairingPin);
    }
  }
  /**
   * Called by the runtime when user wants to disconnect from the EV3 peripheral.
   */


  disconnect() {
    if (this._bt) {
      this._bt.disconnect();
    }

    this.reset();
  }
  /**
   * Reset all the state and timeout/interval ids.
   */


  reset() {
    this._sensorPorts = [];
    this._motorPorts = [];
    this._sensors = {
      distance: 0,
      brightness: 0,
      buttons: [0, 0, 0, 0]
    };
    this._motors = [null, null, null, null];

    if (this._pollingIntervalID) {
      window.clearInterval(this._pollingIntervalID);
      this._pollingIntervalID = null;
    }
  }
  /**
   * Called by the runtime to detect whether the EV3 peripheral is connected.
   * @return {boolean} - the connected state.
   */


  isConnected() {
    let connected = false;

    if (this._bt) {
      connected = this._bt.isConnected();
    }

    return connected;
  }
  /**
   * Send a message to the peripheral BT socket.
   * @param {Uint8Array} message - the message to send.
   * @param {boolean} [useLimiter=true] - if true, use the rate limiter
   * @return {Promise} - a promise result of the send operation.
   */


  send(message) {
    let useLimiter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    if (!this.isConnected()) return Promise.resolve();

    if (useLimiter) {
      if (!this._rateLimiter.okayToSend()) return Promise.resolve();
    }

    return this._bt.sendMessage({
      message: Base64Util.uint8ArrayToBase64(message),
      encoding: 'base64'
    });
  }
  /**
   * Genrates direct commands that are sent to the EV3 as a single or compounded byte arrays.
   * See 'EV3 Communication Developer Kit', section 4, page 24 at
   * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits.
   *
   * Direct commands are one of two types:
   * DIRECT_COMMAND_NO_REPLY = a direct command where no reply is expected
   * DIRECT_COMMAND_REPLY = a direct command where a reply is expected, and the
   * number and length of returned values needs to be specified.
   *
   * The direct command byte array sent takes the following format:
   * Byte 0 - 1: Command size, Little Endian. Command size not including these 2 bytes
   * Byte 2 - 3: Message counter, Little Endian. Forth running counter
   * Byte 4:     Command type. Either DIRECT_COMMAND_REPLY or DIRECT_COMMAND_NO_REPLY
   * Byte 5 - 6: Reservation (allocation) of global and local variables using a compressed format
   *             (globals reserved in byte 5 and the 2 lsb of byte 6, locals reserved in the upper
   *             6 bits of byte 6)  see documentation for more details.
   * Byte 7 - n: Byte codes as a single command or compound commands (I.e. more commands composed
   *             as a small program)
   *
   * @param {number} type - the direct command type.
   * @param {string} byteCommands - a compound array of EV3 Opcode + arguments.
   * @param {number} allocation - the allocation of global and local vars needed for replies.
   * @return {array} - generated complete command byte array, with header and compounded commands.
   */


  generateCommand(type, byteCommands) {
    let allocation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    // Header (Bytes 0 - 6)
    let command = [];
    command[2] = 0; // Message counter unused for now

    command[3] = 0; // Message counter unused for now

    command[4] = type;
    command[5] = allocation & 0xFF;
    command[6] = allocation >> 8 && 0xFF; // Bytecodes (Bytes 7 - n)

    command = command.concat(byteCommands); // Calculate command length minus first two header bytes

    const len = command.length - 2;
    command[0] = len & 0xFF;
    command[1] = len >> 8 && 0xFF;
    return command;
  }
  /**
   * When the EV3 peripheral connects, start polling for sensor and motor values.
   * @private
   */


  _onConnect() {
    this._pollingIntervalID = window.setInterval(this._pollValues, this._pollingInterval);
  }
  /**
   * Poll the EV3 for sensor and motor input values, based on the list of
   * known connected sensors and motors. This is sent as many compound commands
   * in a direct command, with a reply expected.
   *
   * See 'EV3 Firmware Developer Kit', section 4.8, page 46, at
   * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits
   * for a list of polling/input device commands and their arguments.
   *
   * @private
   */


  _pollValues() {
    if (!this.isConnected()) {
      window.clearInterval(this._pollingIntervalID);
      return;
    }

    const cmds = []; // compound command

    let allocation = 0;
    let sensorCount = 0; // Reset the list of devices every 20 counts

    if (this._pollingCounter % 20 === 0) {
      // GET DEVICE LIST
      cmds[0] = Ev3Opcode.OPINPUT_DEVICE_LIST;
      cmds[1] = Ev3Encoding.ONE_BYTE;
      cmds[2] = Ev3Args.MAX_DEVICES;
      cmds[3] = Ev3Encoding.GLOBAL_VARIABLE_INDEX_0;
      cmds[4] = Ev3Encoding.GLOBAL_VARIABLE_ONE_BYTE;
      cmds[5] = Ev3Encoding.GLOBAL_CONSTANT_INDEX_0; // Command and payload lengths

      allocation = 33;
      this._updateDevices = true;
    } else {
      // GET SENSOR VALUES FOR CONNECTED SENSORS
      let index = 0;

      for (let i = 0; i < 4; i++) {
        if (this._sensorPorts[i] !== 'none') {
          cmds[index + 0] = Ev3Opcode.OPINPUT_READSI;
          cmds[index + 1] = Ev3Args.LAYER;
          cmds[index + 2] = i; // PORT

          cmds[index + 3] = Ev3Args.DO_NOT_CHANGE_TYPE;
          cmds[index + 4] = Ev3Mode[this._sensorPorts[i]];
          cmds[index + 5] = Ev3Encoding.GLOBAL_VARIABLE_ONE_BYTE;
          cmds[index + 6] = sensorCount * 4; // GLOBAL INDEX

          index += 7;
        }

        sensorCount++;
      } // GET MOTOR POSITION VALUES, EVEN IF NO MOTOR PRESENT


      for (let i = 0; i < 4; i++) {
        cmds[index + 0] = Ev3Opcode.OPOUTPUT_GET_COUNT;
        cmds[index + 1] = Ev3Args.LAYER;
        cmds[index + 2] = i; // PORT (incorrectly specified as 'Output bit field' in LEGO docs)

        cmds[index + 3] = Ev3Encoding.GLOBAL_VARIABLE_ONE_BYTE;
        cmds[index + 4] = sensorCount * 4; // GLOBAL INDEX

        index += 5;
        sensorCount++;
      } // Command and payload lengths


      allocation = sensorCount * 4;
    }

    const cmd = this.generateCommand(Ev3Command.DIRECT_COMMAND_REPLY, cmds, allocation);
    this.send(cmd);
    this._pollingCounter++;
  }
  /**
   * Message handler for incoming EV3 reply messages, either a list of connected
   * devices (sensors and motors) or the values of the connected sensors and motors.
   *
   * See 'EV3 Communication Developer Kit', section 4.1, page 24 at
   * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits
   * for more details on direct reply formats.
   *
   * The direct reply byte array sent takes the following format:
   * Byte 0  1: Reply size, Little Endian. Reply size not including these 2 bytes
   * Byte 2  3: Message counter, Little Endian. Equals the Direct Command
   * Byte 4:     Reply type. Either DIRECT_REPLY or DIRECT_REPLY_ERROR
   * Byte 5 - n: Resonse buffer. I.e. the content of the by the Command reserved global variables.
   *             I.e. if the command reserved 64 bytes, these bytes will be placed in the reply
   *             packet as the bytes 5 to 68.
   *
   * See 'EV3 Firmware Developer Kit', section 4.8, page 56 at
   * https://education.lego.com/en-us/support/mindstorms-ev3/developer-kits
   * for direct response buffer formats for various commands.
   *
   * @param {object} params - incoming message parameters
   * @private
   */


  _onMessage(params) {
    const message = params.message;
    const data = Base64Util.base64ToUint8Array(message);

    if (data[4] !== Ev3Command.DIRECT_REPLY) {
      return;
    }

    if (this._updateDevices) {
      // PARSE DEVICE LIST
      for (let i = 0; i < 4; i++) {
        const deviceType = Ev3Device[data[i + 5]]; // if returned device type is null, use 'none'

        this._sensorPorts[i] = deviceType ? deviceType : 'none';
      }

      for (let i = 0; i < 4; i++) {
        const deviceType = Ev3Device[data[i + 21]]; // if returned device type is null, use 'none'

        this._motorPorts[i] = deviceType ? deviceType : 'none';
      }

      for (let m = 0; m < 4; m++) {
        const type = this._motorPorts[m];

        if (type !== 'none' && !this._motors[m]) {
          // add new motor if don't already have one
          this._motors[m] = new EV3Motor(this, m, type);
        }

        if (type === 'none' && this._motors[m]) {
          // clear old motor
          this._motors[m] = null;
        }
      }

      this._updateDevices = false; // eslint-disable-next-line no-undefined
    } else if (!this._sensorPorts.includes(undefined) && !this._motorPorts.includes(undefined)) {
      // PARSE SENSOR VALUES
      let offset = 5; // start reading sensor values at byte 5

      for (let i = 0; i < 4; i++) {
        // array 2 float
        const buffer = new Uint8Array([data[offset], data[offset + 1], data[offset + 2], data[offset + 3]]).buffer;
        const view = new DataView(buffer);
        const value = view.getFloat32(0, true);

        if (Ev3Label[this._sensorPorts[i]] === 'button') {
          // Read a button value per port
          this._sensors.buttons[i] = value ? value : 0;
        } else if (Ev3Label[this._sensorPorts[i]]) {
          // if valid
          // Read brightness / distance values and set to 0 if null
          this._sensors[Ev3Label[this._sensorPorts[i]]] = value ? value : 0;
        }

        offset += 4;
      } // PARSE MOTOR POSITION VALUES, EVEN IF NO MOTOR PRESENT


      for (let i = 0; i < 4; i++) {
        const positionArray = [data[offset], data[offset + 1], data[offset + 2], data[offset + 3]];

        if (this._motors[i]) {
          this._motors[i].position = positionArray;
        }

        offset += 4;
      }
    }
  }

}
/**
 * Enum for motor port names.
 * Note: if changed, will break compatibility with previously saved projects.
 * @readonly
 * @enum {string}
 */


const Ev3MotorMenu = ['A', 'B', 'C', 'D'];
/**
 * Enum for sensor port names.
 * Note: if changed, will break compatibility with previously saved projects.
 * @readonly
 * @enum {string}
 */

const Ev3SensorMenu = ['1', '2', '3', '4'];

class Scratch3Ev3Blocks {
  /**
   * The ID of the extension.
   * @return {string} the id
   */
  static get EXTENSION_ID() {
    return 'ev3';
  }
  /**
   * Creates a new instance of the EV3 extension.
   * @param  {object} runtime VM runtime
   * @constructor
   */


  constructor(runtime) {
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime; // Create a new EV3 peripheral instance

    this._peripheral = new EV3(this.runtime, Scratch3Ev3Blocks.EXTENSION_ID);
    this._playNoteForPicker = this._playNoteForPicker.bind(this);
    this.runtime.on('PLAY_NOTE', this._playNoteForPicker);
  }
  /**
   * Define the EV3 extension.
   * @return {object} Extension description.
   */


  getInfo() {
    return {
      id: Scratch3Ev3Blocks.EXTENSION_ID,
      name: 'LEGO EV3',
      blockIconURI: blockIconURI,
      showStatusButton: true,
      blocks: [{
        opcode: 'motorTurnClockwise',
        text: formatMessage({
          id: 'ev3.motorTurnClockwise',
          default: 'motor [PORT] turn this way for [TIME] seconds',
          description: 'turn a motor clockwise for some time'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: 'motorPorts',
            defaultValue: 0
          },
          TIME: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        }
      }, {
        opcode: 'motorTurnCounterClockwise',
        text: formatMessage({
          id: 'ev3.motorTurnCounterClockwise',
          default: 'motor [PORT] turn that way for [TIME] seconds',
          description: 'turn a motor counter-clockwise for some time'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: 'motorPorts',
            defaultValue: 0
          },
          TIME: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        }
      }, {
        opcode: 'motorSetPower',
        text: formatMessage({
          id: 'ev3.motorSetPower',
          default: 'motor [PORT] set power [POWER] %',
          description: 'set a motor\'s power to some value'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: 'motorPorts',
            defaultValue: 0
          },
          POWER: {
            type: ArgumentType.NUMBER,
            defaultValue: 100
          }
        }
      }, {
        opcode: 'getMotorPosition',
        text: formatMessage({
          id: 'ev3.getMotorPosition',
          default: 'motor [PORT] position',
          description: 'get the measured degrees a motor has turned'
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: 'motorPorts',
            defaultValue: 0
          }
        }
      }, {
        opcode: 'whenButtonPressed',
        text: formatMessage({
          id: 'ev3.whenButtonPressed',
          default: 'when button [PORT] pressed',
          description: 'when a button connected to a port is pressed'
        }),
        blockType: BlockType.HAT,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: 'sensorPorts',
            defaultValue: 0
          }
        }
      }, {
        opcode: 'whenDistanceLessThan',
        text: formatMessage({
          id: 'ev3.whenDistanceLessThan',
          default: 'when distance < [DISTANCE]',
          description: 'when the value measured by the distance sensor is less than some value'
        }),
        blockType: BlockType.HAT,
        arguments: {
          DISTANCE: {
            type: ArgumentType.NUMBER,
            defaultValue: 5
          }
        }
      }, {
        opcode: 'whenBrightnessLessThan',
        text: formatMessage({
          id: 'ev3.whenBrightnessLessThan',
          default: 'when brightness < [DISTANCE]',
          description: 'when value measured by brightness sensor is less than some value'
        }),
        blockType: BlockType.HAT,
        arguments: {
          DISTANCE: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        }
      }, {
        opcode: 'buttonPressed',
        text: formatMessage({
          id: 'ev3.buttonPressed',
          default: 'button [PORT] pressed?',
          description: 'is a button on some port pressed?'
        }),
        blockType: BlockType.BOOLEAN,
        arguments: {
          PORT: {
            type: ArgumentType.STRING,
            menu: 'sensorPorts',
            defaultValue: 0
          }
        }
      }, {
        opcode: 'getDistance',
        text: formatMessage({
          id: 'ev3.getDistance',
          default: 'distance',
          description: 'gets measured distance'
        }),
        blockType: BlockType.REPORTER
      }, {
        opcode: 'getBrightness',
        text: formatMessage({
          id: 'ev3.getBrightness',
          default: 'brightness',
          description: 'gets measured brightness'
        }),
        blockType: BlockType.REPORTER
      }, {
        opcode: 'beep',
        text: formatMessage({
          id: 'ev3.beepNote',
          default: 'beep note [NOTE] for [TIME] secs',
          description: 'play some note on EV3 for some time'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          NOTE: {
            type: ArgumentType.NOTE,
            defaultValue: 60
          },
          TIME: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.5
          }
        }
      }],
      menus: {
        motorPorts: {
          acceptReporters: true,
          items: this._formatMenu(Ev3MotorMenu)
        },
        sensorPorts: {
          acceptReporters: true,
          items: this._formatMenu(Ev3SensorMenu)
        }
      }
    };
  }

  motorTurnClockwise(args) {
    const port = Cast.toNumber(args.PORT);
    let time = Cast.toNumber(args.TIME) * 1000;
    time = MathUtil.clamp(time, 0, 15000);
    return new Promise(resolve => {
      this._forEachMotor(port, motorIndex => {
        const motor = this._peripheral.motor(motorIndex);

        if (motor) {
          motor.direction = 1;
          motor.turnOnFor(time);
        }
      }); // Run for some time even when no motor is connected


      setTimeout(resolve, time);
    });
  }

  motorTurnCounterClockwise(args) {
    const port = Cast.toNumber(args.PORT);
    let time = Cast.toNumber(args.TIME) * 1000;
    time = MathUtil.clamp(time, 0, 15000);
    return new Promise(resolve => {
      this._forEachMotor(port, motorIndex => {
        const motor = this._peripheral.motor(motorIndex);

        if (motor) {
          motor.direction = -1;
          motor.turnOnFor(time);
        }
      }); // Run for some time even when no motor is connected


      setTimeout(resolve, time);
    });
  }

  motorSetPower(args) {
    const port = Cast.toNumber(args.PORT);
    const power = MathUtil.clamp(Cast.toNumber(args.POWER), 0, 100);

    this._forEachMotor(port, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) {
        motor.power = power;
      }
    });
  }

  getMotorPosition(args) {
    const port = Cast.toNumber(args.PORT);

    if (![0, 1, 2, 3].includes(port)) {
      return;
    }

    const motor = this._peripheral.motor(port);

    let position = 0;

    if (motor) {
      position = MathUtil.wrapClamp(motor.position, 0, 360);
    }

    return position;
  }

  whenButtonPressed(args) {
    const port = Cast.toNumber(args.PORT);

    if (![0, 1, 2, 3].includes(port)) {
      return;
    }

    return this._peripheral.isButtonPressed(port);
  }

  whenDistanceLessThan(args) {
    const distance = MathUtil.clamp(Cast.toNumber(args.DISTANCE), 0, 100);
    return this._peripheral.distance < distance;
  }

  whenBrightnessLessThan(args) {
    const brightness = MathUtil.clamp(Cast.toNumber(args.DISTANCE), 0, 100);
    return this._peripheral.brightness < brightness;
  }

  buttonPressed(args) {
    const port = Cast.toNumber(args.PORT);

    if (![0, 1, 2, 3].includes(port)) {
      return;
    }

    return this._peripheral.isButtonPressed(port);
  }

  getDistance() {
    return this._peripheral.distance;
  }

  getBrightness() {
    return this._peripheral.brightness;
  }

  _playNoteForPicker(note, category) {
    if (category !== this.getInfo().name) return;
    this.beep({
      NOTE: note,
      TIME: 0.25
    });
  }

  beep(args) {
    const note = MathUtil.clamp(Cast.toNumber(args.NOTE), 47, 99); // valid EV3 sounds

    let time = Cast.toNumber(args.TIME) * 1000;
    time = MathUtil.clamp(time, 0, 3000);

    if (time === 0) {
      return; // don't send a beep time of 0
    }

    return new Promise(resolve => {
      // https://en.wikipedia.org/wiki/MIDI_tuning_standard#Frequency_values
      const freq = Math.pow(2, (note - 69 + 12) / 12) * 440;

      this._peripheral.beep(freq, time); // Run for some time even when no piezo is connected.


      setTimeout(resolve, time);
    });
  }
  /**
   * Call a callback for each motor indexed by the provided motor ID.
   *
   * Note: This way of looping through motors is currently unnecessary, but could be
   * useful if an 'all motors' option is added in the future (see WeDo2 extension).
   *
   * @param {MotorID} motorID - the ID specifier.
   * @param {Function} callback - the function to call with the numeric motor index for each motor.
   * @private
   */


  _forEachMotor(motorID, callback) {
    let motors;

    switch (motorID) {
      case 0:
        motors = [0];
        break;

      case 1:
        motors = [1];
        break;

      case 2:
        motors = [2];
        break;

      case 3:
        motors = [3];
        break;

      default:
        log.warn("Invalid motor ID: ".concat(motorID));
        motors = [];
        break;
    }

    for (const index of motors) {
      callback(index);
    }
  }
  /**
   * Formats menus into a format suitable for block menus, and loading previously
   * saved projects:
   * [
   *   {
   *    text: label,
   *    value: index
   *   },
   *   {
   *    text: label,
   *    value: index
   *   },
   *   etc...
   * ]
   *
   * @param {array} menu - a menu to format.
   * @return {object} - a formatted menu as an object.
   * @private
   */


  _formatMenu(menu) {
    const m = [];

    for (let i = 0; i < menu.length; i++) {
      const obj = {};
      obj.text = menu[i];
      obj.value = i.toString();
      m.push(obj);
    }

    return m;
  }

}

module.exports = Scratch3Ev3Blocks;

/***/ }),

/***/ "./src/extensions/scratch3_gdx_for/index.js":
/*!**************************************************!*\
  !*** ./src/extensions/scratch3_gdx_for/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const log = __webpack_require__(/*! ../../util/log */ "./src/util/log.js");

const formatMessage = __webpack_require__(/*! format-message */ "format-message");

const MathUtil = __webpack_require__(/*! ../../util/math-util */ "./src/util/math-util.js");

const BLE = __webpack_require__(/*! ../../io/ble */ "./src/io/ble.js");

const godirect = __webpack_require__(/*! @vernier/godirect/dist/godirect.min.umd.js */ "./node_modules/@vernier/godirect/dist/godirect.min.umd.js");

const ScratchLinkDeviceAdapter = __webpack_require__(/*! ./scratch-link-device-adapter */ "./src/extensions/scratch3_gdx_for/scratch-link-device-adapter.js");
/**
 * Icon png to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const blockIconURI = 'data:image/png;base64,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';
/**
 * Icon png to be displayed in the blocks category menu, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len

const menuIconURI = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAABGdBTUEAALGPC/xhBQAAA9dJREFUWAnNmE2IFEcUgF/9dE/v7LoaM9kkK4JBRA0EFBIPRm85hBAvEXHXwyo5eFE87GFcReMkObgJiQnkkJzEg9n8HIJixKNe1IMKihgiCbviwV11V3d0d3pmuqsqr5ppcEnb3TNVggVFVVe9eu+r97qqq4tASqp8/fsboQgmU0TMugi571K29bPy9ovPU8Sf16HbpQj3EkYFBcJcr5Am2nZfs94AIWVfqMQeHNwhICUBZ4ypUIA/X2sbIm2AW8AJK0lkEP6TJpfqwXgg4QxmF/fB7Gtvxk1G5ZKHU1CqTgPJoSUXYJYeohSUJu+qrqdVUGh2/pVX4VFffx77WaqBZkrkEFj271+qWH0sXcU3FBzyQe/Mg7B//LbKMTRTxNiDbsMHHjTJlyM7HEJIBHXs2KXFj+oTNSdoQOCYLS5jD9IwBMm5H8NplwwPb/QV4yEIcycaAza9IuA76B38fuz1OF5RXUkmHCdu6rg0BpSMgV/sAe7DdzGFrvvdi0D3mSZjQA0wt7REQsY+iWF0XbfFzyal8SLRxuteD+Du4h4Z/flbqaBHibAQtZmQtcZaAZSMwtTylaR/4vaw1ju5YhWG10pwwAqghmp2FeHO2+t11WqyM80W0m7vAOhsM1kD7CGz8L57Jsq6bitZC/GcWgLf1H6KuHT92cTDAFy/BgXMXm0OCpgV50Bo9kK3BqiBboabQMMU/WoL5im4jToeq/AIgXsiRx5KKCjcwPEsiAv/BQMu9EwyDHXd/3kqCOSzDk6t5/YglQKKeJwq+PNRmJI8kwSTaj1HZy5AhSHqnXkIvU9mMUwEw4Q5wTM57LUtkg8QPw/cdcBJ+PhvKJ0Gj80nGq6JXrg6/XFiX97GXIBpyqTieKpKViOl+WEhWXMaUavvvdIZ8Giy5+Lh3bwKm/t+Be3JazMfxc1tldY26rastiHcsQevTG9pw0znovkAcRWHzSDKnZtaOJLSfMFLB5RqtRBS4LbCurqLCy0YPkU3C0IIPEimMqR2ei7ZX2+KQdRi/WahNT/GmfOD4Vyzhx/66pcjp85dUvcmp6J8+txldXh07PPskdkS+V6EbD0vTOKlB0x9B/O6BS8ULly9PgE6x4kDPR/XX5pyYKj8xcCucsUmkNUQE0JvKKm2VioVK5HRE7UKOHbi6B94RzP+93jtpC0vWgXUF0hr3ipuw8uadwd3jXxoA9IK4Pah8t6BneV9GgjD28Svw1mlxFobgFbeFTz13cKbth93fDryp2CEq0a4hTA+aAPQ/ESJFDdvXLzzzrqNjlTqOP6uDeFf0uhvJ0ZP2QD8D6ZzU6u8YIbBAAAAAElFTkSuQmCC';
/**
 * Enum for Vernier godirect protocol.
 * @readonly
 * @enum {string}
 */

const BLEUUID = {
  service: 'd91714ef-28b9-4f91-ba16-f0d9a604f112',
  commandChar: 'f4bf14a6-c7d5-4b6d-8aa8-df1a7c83adcb',
  responseChar: 'b41e6675-a329-40e0-aa01-44d2f444babe'
};
/**
 * A time interval to wait (in milliseconds) before reporting to the BLE socket
 * that data has stopped coming from the peripheral.
 */

const BLETimeout = 4500;
/**
 * A string to report to the BLE socket when the GdxFor has stopped receiving data.
 * @type {string}
 */

const BLEDataStoppedError = 'Force and Acceleration extension stopped receiving data';
/**
 * Sensor ID numbers for the GDX-FOR.
 */

const GDXFOR_SENSOR = {
  FORCE: 1,
  ACCELERATION_X: 2,
  ACCELERATION_Y: 3,
  ACCELERATION_Z: 4,
  SPIN_SPEED_X: 5,
  SPIN_SPEED_Y: 6,
  SPIN_SPEED_Z: 7
};
/**
 * The update rate, in milliseconds, for sensor data input from the peripheral.
 */

const GDXFOR_UPDATE_RATE = 80;
/**
 * Threshold for pushing and pulling force, for the whenForcePushedOrPulled hat block.
 * @type {number}
 */

const FORCE_THRESHOLD = 5;
/**
 * Threshold for acceleration magnitude, for the "shaken" gesture.
 * @type {number}
 */

const SHAKEN_THRESHOLD = 30;
/**
 * Threshold for acceleration magnitude, to check if we are facing up.
 * @type {number}
 */

const FACING_THRESHOLD = 9;
/**
 * An offset for the facing threshold, used to check that we are no longer facing up.
 * @type {number}
 */

const FACING_THRESHOLD_OFFSET = 5;
/**
 * Threshold for acceleration magnitude, below which we are in freefall.
 * @type {number}
 */

const FREEFALL_THRESHOLD = 0.5;
/**
 * Factor used to account for influence of rotation during freefall.
 * @type {number}
 */

const FREEFALL_ROTATION_FACTOR = 0.3;
/**
 * Threshold in degrees for reporting that the sensor is tilted.
 * @type {number}
 */

const TILT_THRESHOLD = 15;
/**
 * Acceleration due to gravity, in m/s^2.
 * @type {number}
 */

const GRAVITY = 9.8;
/**
 * Manage communication with a GDX-FOR peripheral over a Scratch Link client socket.
 */

class GdxFor {
  /**
   * Construct a GDX-FOR communication object.
   * @param {Runtime} runtime - the Scratch 3.0 runtime
   * @param {string} extensionId - the id of the extension
   */
  constructor(runtime, extensionId) {
    /**
     * The Scratch 3.0 runtime used to trigger the green flag button.
     * @type {Runtime}
     * @private
     */
    this._runtime = runtime;
    /**
     * The BluetoothLowEnergy connection socket for reading/writing peripheral data.
     * @type {BLE}
     * @private
     */

    this._ble = null;
    /**
     * An @vernier/godirect Device
     * @type {Device}
     * @private
     */

    this._device = null;

    this._runtime.registerPeripheralExtension(extensionId, this);
    /**
     * The id of the extension this peripheral belongs to.
     */


    this._extensionId = extensionId;
    /**
     * The most recently received value for each sensor.
     * @type {Object.<string, number>}
     * @private
     */

    this._sensors = {
      force: 0,
      accelerationX: 0,
      accelerationY: 0,
      accelerationZ: 0,
      spinSpeedX: 0,
      spinSpeedY: 0,
      spinSpeedZ: 0
    };
    /**
     * Interval ID for data reading timeout.
     * @type {number}
     * @private
     */

    this._timeoutID = null;
    this.reset = this.reset.bind(this);
    this._onConnect = this._onConnect.bind(this);
  }
  /**
   * Called by the runtime when user wants to scan for a peripheral.
   */


  scan() {
    if (this._ble) {
      this._ble.disconnect();
    }

    this._ble = new BLE(this._runtime, this._extensionId, {
      filters: [{
        namePrefix: 'GDX-FOR'
      }],
      optionalServices: [BLEUUID.service]
    }, this._onConnect, this.reset);
  }
  /**
   * Called by the runtime when user wants to connect to a certain peripheral.
   * @param {number} id - the id of the peripheral to connect to.
   */


  connect(id) {
    if (this._ble) {
      this._ble.connectPeripheral(id);
    }
  }
  /**
   * Called by the runtime when a user exits the connection popup.
   * Disconnect from the GDX FOR.
   */


  disconnect() {
    if (this._ble) {
      this._ble.disconnect();
    }

    this.reset();
  }
  /**
   * Reset all the state and timeout/interval ids.
   */


  reset() {
    this._sensors = {
      force: 0,
      accelerationX: 0,
      accelerationY: 0,
      accelerationZ: 0,
      spinSpeedX: 0,
      spinSpeedY: 0,
      spinSpeedZ: 0
    };

    if (this._timeoutID) {
      window.clearInterval(this._timeoutID);
      this._timeoutID = null;
    }
  }
  /**
   * Return true if connected to the goforce device.
   * @return {boolean} - whether the goforce is connected.
   */


  isConnected() {
    let connected = false;

    if (this._ble) {
      connected = this._ble.isConnected();
    }

    return connected;
  }
  /**
   * Starts reading data from peripheral after BLE has connected to it.
   * @private
   */


  _onConnect() {
    const adapter = new ScratchLinkDeviceAdapter(this._ble, BLEUUID);
    godirect.createDevice(adapter, {
      open: true,
      startMeasurements: false
    }).then(device => {
      // Setup device
      this._device = device;
      this._device.keepValues = false; // todo: possibly remove after updating Vernier godirect module
      // Enable sensors

      this._device.sensors.forEach(sensor => {
        sensor.setEnabled(true);
      }); // Set sensor value-update behavior


      this._device.on('measurements-started', () => {
        const enabledSensors = this._device.sensors.filter(s => s.enabled);

        enabledSensors.forEach(sensor => {
          sensor.on('value-changed', s => {
            this._onSensorValueChanged(s);
          });
        });
        this._timeoutID = window.setInterval(() => this._ble.handleDisconnectError(BLEDataStoppedError), BLETimeout);
      }); // Start device


      this._device.start(GDXFOR_UPDATE_RATE);
    });
  }
  /**
   * Handler for sensor value changes from the goforce device.
   * @param {object} sensor - goforce device sensor whose value has changed
   * @private
   */


  _onSensorValueChanged(sensor) {
    switch (sensor.number) {
      case GDXFOR_SENSOR.FORCE:
        // Normalize the force, which can be measured between -50 and 50 N,
        // to be a value between -100 and 100.
        this._sensors.force = MathUtil.clamp(sensor.value * 2, -100, 100);
        break;

      case GDXFOR_SENSOR.ACCELERATION_X:
        this._sensors.accelerationX = sensor.value;
        break;

      case GDXFOR_SENSOR.ACCELERATION_Y:
        this._sensors.accelerationY = sensor.value;
        break;

      case GDXFOR_SENSOR.ACCELERATION_Z:
        this._sensors.accelerationZ = sensor.value;
        break;

      case GDXFOR_SENSOR.SPIN_SPEED_X:
        this._sensors.spinSpeedX = this._spinSpeedFromGyro(sensor.value);
        break;

      case GDXFOR_SENSOR.SPIN_SPEED_Y:
        this._sensors.spinSpeedY = this._spinSpeedFromGyro(sensor.value);
        break;

      case GDXFOR_SENSOR.SPIN_SPEED_Z:
        this._sensors.spinSpeedZ = this._spinSpeedFromGyro(sensor.value);
        break;
    } // cancel disconnect timeout and start a new one


    window.clearInterval(this._timeoutID);
    this._timeoutID = window.setInterval(() => this._ble.handleDisconnectError(BLEDataStoppedError), BLETimeout);
  }

  _spinSpeedFromGyro(val) {
    const framesPerSec = 1000 / this._runtime.currentStepTime;
    val = MathUtil.radToDeg(val);
    val = val / framesPerSec; // convert to from degrees per sec to degrees per frame

    val = val * -1;
    return val;
  }

  getForce() {
    return this._sensors.force;
  }

  getTiltFrontBack() {
    let back = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    const x = this.getAccelerationX();
    const y = this.getAccelerationY();
    const z = this.getAccelerationZ(); // Compute the yz unit vector

    const y2 = y * y;
    const z2 = z * z;
    let value = y2 + z2;
    value = Math.sqrt(value); // For sufficiently small zy vector values we are essentially at 90 degrees.
    // The following snaps to 90 and avoids divide-by-zero errors.
    // The snap factor was derived through observation -- just enough to
    // still allow single degree steps up to 90 (..., 87, 88, 89, 90).

    if (value < 0.35) {
      value = x < 0 ? 90 : -90;
    } else {
      value = x / value;
      value = Math.atan(value);
      value = MathUtil.radToDeg(value) * -1;
    } // Back is the inverse of front


    if (back) value *= -1;
    return value;
  }

  getTiltLeftRight() {
    let right = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    const x = this.getAccelerationX();
    const y = this.getAccelerationY();
    const z = this.getAccelerationZ(); // Compute the yz unit vector

    const x2 = x * x;
    const z2 = z * z;
    let value = x2 + z2;
    value = Math.sqrt(value); // For sufficiently small zy vector values we are essentially at 90 degrees.
    // The following snaps to 90 and avoids divide-by-zero errors.
    // The snap factor was derived through observation -- just enough to
    // still allow single degree steps up to 90 (..., 87, 88, 89, 90).

    if (value < 0.35) {
      value = y < 0 ? 90 : -90;
    } else {
      value = y / value;
      value = Math.atan(value);
      value = MathUtil.radToDeg(value) * -1;
    } // Right is the inverse of left


    if (right) value *= -1;
    return value;
  }

  getAccelerationX() {
    return this._sensors.accelerationX;
  }

  getAccelerationY() {
    return this._sensors.accelerationY;
  }

  getAccelerationZ() {
    return this._sensors.accelerationZ;
  }

  getSpinSpeedX() {
    return this._sensors.spinSpeedX;
  }

  getSpinSpeedY() {
    return this._sensors.spinSpeedY;
  }

  getSpinSpeedZ() {
    return this._sensors.spinSpeedZ;
  }

}
/**
 * Enum for pushed and pulled menu options.
 * @readonly
 * @enum {string}
 */


const PushPullValues = {
  PUSHED: 'pushed',
  PULLED: 'pulled'
};
/**
 * Enum for motion gesture menu options.
 * @readonly
 * @enum {string}
 */

const GestureValues = {
  SHAKEN: 'shaken',
  STARTED_FALLING: 'started falling',
  TURNED_FACE_UP: 'turned face up',
  TURNED_FACE_DOWN: 'turned face down'
};
/**
 * Enum for tilt axis menu options.
 * @readonly
 * @enum {string}
 */

const TiltAxisValues = {
  FRONT: 'front',
  BACK: 'back',
  LEFT: 'left',
  RIGHT: 'right',
  ANY: 'any'
};
/**
 * Enum for axis menu options.
 * @readonly
 * @enum {string}
 */

const AxisValues = {
  X: 'x',
  Y: 'y',
  Z: 'z'
};
/**
 * Scratch 3.0 blocks to interact with a GDX-FOR peripheral.
 */

class Scratch3GdxForBlocks {
  /**
   * @return {string} - the name of this extension.
   */
  static get EXTENSION_NAME() {
    return 'Force and Acceleration';
  }
  /**
   * @return {string} - the ID of this extension.
   */


  static get EXTENSION_ID() {
    return 'gdxfor';
  }

  get AXIS_MENU() {
    return [{
      text: 'x',
      value: AxisValues.X
    }, {
      text: 'y',
      value: AxisValues.Y
    }, {
      text: 'z',
      value: AxisValues.Z
    }];
  }

  get TILT_MENU() {
    return [{
      text: formatMessage({
        id: 'gdxfor.tiltDirectionMenu.front',
        default: 'front',
        description: 'label for front element in tilt direction picker for gdxfor extension'
      }),
      value: TiltAxisValues.FRONT
    }, {
      text: formatMessage({
        id: 'gdxfor.tiltDirectionMenu.back',
        default: 'back',
        description: 'label for back element in tilt direction picker for gdxfor extension'
      }),
      value: TiltAxisValues.BACK
    }, {
      text: formatMessage({
        id: 'gdxfor.tiltDirectionMenu.left',
        default: 'left',
        description: 'label for left element in tilt direction picker for gdxfor extension'
      }),
      value: TiltAxisValues.LEFT
    }, {
      text: formatMessage({
        id: 'gdxfor.tiltDirectionMenu.right',
        default: 'right',
        description: 'label for right element in tilt direction picker for gdxfor extension'
      }),
      value: TiltAxisValues.RIGHT
    }];
  }

  get TILT_MENU_ANY() {
    return [...this.TILT_MENU, {
      text: formatMessage({
        id: 'gdxfor.tiltDirectionMenu.any',
        default: 'any',
        description: 'label for any direction element in tilt direction picker for gdxfor extension'
      }),
      value: TiltAxisValues.ANY
    }];
  }

  get PUSH_PULL_MENU() {
    return [{
      text: formatMessage({
        id: 'gdxfor.pushed',
        default: 'pushed',
        description: 'the force sensor was pushed inward'
      }),
      value: PushPullValues.PUSHED
    }, {
      text: formatMessage({
        id: 'gdxfor.pulled',
        default: 'pulled',
        description: 'the force sensor was pulled outward'
      }),
      value: PushPullValues.PULLED
    }];
  }

  get GESTURE_MENU() {
    return [{
      text: formatMessage({
        id: 'gdxfor.shaken',
        default: 'shaken',
        description: 'the sensor was shaken'
      }),
      value: GestureValues.SHAKEN
    }, {
      text: formatMessage({
        id: 'gdxfor.startedFalling',
        default: 'started falling',
        description: 'the sensor started free falling'
      }),
      value: GestureValues.STARTED_FALLING
    }, {
      text: formatMessage({
        id: 'gdxfor.turnedFaceUp',
        default: 'turned face up',
        description: 'the sensor was turned to face up'
      }),
      value: GestureValues.TURNED_FACE_UP
    }, {
      text: formatMessage({
        id: 'gdxfor.turnedFaceDown',
        default: 'turned face down',
        description: 'the sensor was turned to face down'
      }),
      value: GestureValues.TURNED_FACE_DOWN
    }];
  }
  /**
   * Construct a set of GDX-FOR blocks.
   * @param {Runtime} runtime - the Scratch 3.0 runtime.
   */


  constructor(runtime) {
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime; // Create a new GdxFor peripheral instance

    this._peripheral = new GdxFor(this.runtime, Scratch3GdxForBlocks.EXTENSION_ID);
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: Scratch3GdxForBlocks.EXTENSION_ID,
      name: Scratch3GdxForBlocks.EXTENSION_NAME,
      blockIconURI: blockIconURI,
      menuIconURI: menuIconURI,
      showStatusButton: true,
      blocks: [{
        opcode: 'whenGesture',
        text: formatMessage({
          id: 'gdxfor.whenGesture',
          default: 'when [GESTURE]',
          description: 'when the sensor detects a gesture'
        }),
        blockType: BlockType.HAT,
        arguments: {
          GESTURE: {
            type: ArgumentType.STRING,
            menu: 'gestureOptions',
            defaultValue: GestureValues.SHAKEN
          }
        }
      }, {
        opcode: 'whenForcePushedOrPulled',
        text: formatMessage({
          id: 'gdxfor.whenForcePushedOrPulled',
          default: 'when force sensor [PUSH_PULL]',
          description: 'when the force sensor is pushed or pulled'
        }),
        blockType: BlockType.HAT,
        arguments: {
          PUSH_PULL: {
            type: ArgumentType.STRING,
            menu: 'pushPullOptions',
            defaultValue: PushPullValues.PUSHED
          }
        }
      }, {
        opcode: 'getForce',
        text: formatMessage({
          id: 'gdxfor.getForce',
          default: 'force',
          description: 'gets force'
        }),
        blockType: BlockType.REPORTER
      }, '---', {
        opcode: 'whenTilted',
        text: formatMessage({
          id: 'gdxfor.whenTilted',
          default: 'when tilted [TILT]',
          description: 'when the sensor detects tilt'
        }),
        blockType: BlockType.HAT,
        arguments: {
          TILT: {
            type: ArgumentType.STRING,
            menu: 'tiltAnyOptions',
            defaultValue: TiltAxisValues.ANY
          }
        }
      }, {
        opcode: 'isTilted',
        text: formatMessage({
          id: 'gdxfor.isTilted',
          default: 'tilted [TILT]?',
          description: 'is the device tilted?'
        }),
        blockType: BlockType.BOOLEAN,
        arguments: {
          TILT: {
            type: ArgumentType.STRING,
            menu: 'tiltAnyOptions',
            defaultValue: TiltAxisValues.ANY
          }
        }
      }, {
        opcode: 'getTilt',
        text: formatMessage({
          id: 'gdxfor.getTilt',
          default: 'tilt angle [TILT]',
          description: 'gets tilt'
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          TILT: {
            type: ArgumentType.STRING,
            menu: 'tiltOptions',
            defaultValue: TiltAxisValues.FRONT
          }
        }
      }, '---', {
        opcode: 'isFreeFalling',
        text: formatMessage({
          id: 'gdxfor.isFreeFalling',
          default: 'falling?',
          description: 'is the device in free fall?'
        }),
        blockType: BlockType.BOOLEAN
      }, {
        opcode: 'getSpinSpeed',
        text: formatMessage({
          id: 'gdxfor.getSpin',
          default: 'spin speed [DIRECTION]',
          description: 'gets spin speed'
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          DIRECTION: {
            type: ArgumentType.STRING,
            menu: 'axisOptions',
            defaultValue: AxisValues.Z
          }
        }
      }, {
        opcode: 'getAcceleration',
        text: formatMessage({
          id: 'gdxfor.getAcceleration',
          default: 'acceleration [DIRECTION]',
          description: 'gets acceleration'
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          DIRECTION: {
            type: ArgumentType.STRING,
            menu: 'axisOptions',
            defaultValue: AxisValues.X
          }
        }
      }],
      menus: {
        pushPullOptions: {
          acceptReporters: true,
          items: this.PUSH_PULL_MENU
        },
        gestureOptions: {
          acceptReporters: true,
          items: this.GESTURE_MENU
        },
        axisOptions: {
          acceptReporters: true,
          items: this.AXIS_MENU
        },
        tiltOptions: {
          acceptReporters: true,
          items: this.TILT_MENU
        },
        tiltAnyOptions: {
          acceptReporters: true,
          items: this.TILT_MENU_ANY
        }
      }
    };
  }

  whenForcePushedOrPulled(args) {
    switch (args.PUSH_PULL) {
      case PushPullValues.PUSHED:
        return this._peripheral.getForce() < FORCE_THRESHOLD * -1;

      case PushPullValues.PULLED:
        return this._peripheral.getForce() > FORCE_THRESHOLD;

      default:
        log.warn("unknown push/pull value in whenForcePushedOrPulled: ".concat(args.PUSH_PULL));
        return false;
    }
  }

  getForce() {
    return Math.round(this._peripheral.getForce());
  }

  whenGesture(args) {
    switch (args.GESTURE) {
      case GestureValues.SHAKEN:
        return this.gestureMagnitude() > SHAKEN_THRESHOLD;

      case GestureValues.STARTED_FALLING:
        return this.isFreeFalling();

      case GestureValues.TURNED_FACE_UP:
        return this._isFacing(GestureValues.TURNED_FACE_UP);

      case GestureValues.TURNED_FACE_DOWN:
        return this._isFacing(GestureValues.TURNED_FACE_DOWN);

      default:
        log.warn("unknown gesture value in whenGesture: ".concat(args.GESTURE));
        return false;
    }
  }

  _isFacing(direction) {
    if (typeof this._facingUp === 'undefined') {
      this._facingUp = false;
    }

    if (typeof this._facingDown === 'undefined') {
      this._facingDown = false;
    } // If the sensor is already facing up or down, reduce the threshold.
    // This prevents small fluctations in acceleration while it is being
    // turned from causing the hat block to trigger multiple times.


    let threshold = FACING_THRESHOLD;

    if (this._facingUp || this._facingDown) {
      threshold -= FACING_THRESHOLD_OFFSET;
    }

    this._facingUp = this._peripheral.getAccelerationZ() > threshold;
    this._facingDown = this._peripheral.getAccelerationZ() < threshold * -1;

    switch (direction) {
      case GestureValues.TURNED_FACE_UP:
        return this._facingUp;

      case GestureValues.TURNED_FACE_DOWN:
        return this._facingDown;

      default:
        return false;
    }
  }

  whenTilted(args) {
    return this._isTilted(args.TILT);
  }

  isTilted(args) {
    return this._isTilted(args.TILT);
  }

  getTilt(args) {
    return this._getTiltAngle(args.TILT);
  }

  _isTilted(direction) {
    switch (direction) {
      case TiltAxisValues.ANY:
        return this._getTiltAngle(TiltAxisValues.FRONT) > TILT_THRESHOLD || this._getTiltAngle(TiltAxisValues.BACK) > TILT_THRESHOLD || this._getTiltAngle(TiltAxisValues.LEFT) > TILT_THRESHOLD || this._getTiltAngle(TiltAxisValues.RIGHT) > TILT_THRESHOLD;

      default:
        return this._getTiltAngle(direction) > TILT_THRESHOLD;
    }
  }

  _getTiltAngle(direction) {
    // Tilt values are calculated using acceleration due to gravity,
    // so we need to return 0 when the peripheral is not connected.
    if (!this._peripheral.isConnected()) {
      return 0;
    }

    switch (direction) {
      case TiltAxisValues.FRONT:
        return Math.round(this._peripheral.getTiltFrontBack(true));

      case TiltAxisValues.BACK:
        return Math.round(this._peripheral.getTiltFrontBack(false));

      case TiltAxisValues.LEFT:
        return Math.round(this._peripheral.getTiltLeftRight(true));

      case TiltAxisValues.RIGHT:
        return Math.round(this._peripheral.getTiltLeftRight(false));

      default:
        log.warn("Unknown direction in getTilt: ".concat(direction));
    }
  }

  getSpinSpeed(args) {
    switch (args.DIRECTION) {
      case AxisValues.X:
        return Math.round(this._peripheral.getSpinSpeedX());

      case AxisValues.Y:
        return Math.round(this._peripheral.getSpinSpeedY());

      case AxisValues.Z:
        return Math.round(this._peripheral.getSpinSpeedZ());

      default:
        log.warn("Unknown direction in getSpinSpeed: ".concat(args.DIRECTION));
    }
  }

  getAcceleration(args) {
    switch (args.DIRECTION) {
      case AxisValues.X:
        return Math.round(this._peripheral.getAccelerationX());

      case AxisValues.Y:
        return Math.round(this._peripheral.getAccelerationY());

      case AxisValues.Z:
        return Math.round(this._peripheral.getAccelerationZ());

      default:
        log.warn("Unknown direction in getAcceleration: ".concat(args.DIRECTION));
    }
  }
  /**
   * @param {number} x - x axis vector
   * @param {number} y - y axis vector
   * @param {number} z - z axis vector
   * @return {number} - the magnitude of a three dimension vector.
   */


  magnitude(x, y, z) {
    return Math.sqrt(x * x + y * y + z * z);
  }

  accelMagnitude() {
    return this.magnitude(this._peripheral.getAccelerationX(), this._peripheral.getAccelerationY(), this._peripheral.getAccelerationZ());
  }

  gestureMagnitude() {
    return this.accelMagnitude() - GRAVITY;
  }

  spinMagnitude() {
    return this.magnitude(this._peripheral.getSpinSpeedX(), this._peripheral.getSpinSpeedY(), this._peripheral.getSpinSpeedZ());
  }

  isFreeFalling() {
    // When the peripheral is not connected, the acceleration magnitude
    // is 0 instead of ~9.8, which ends up calculating as a positive
    // free fall; so we need to return 'false' here to prevent returning 'true'.
    if (!this._peripheral.isConnected()) {
      return false;
    }

    const accelMag = this.accelMagnitude();
    const spinMag = this.spinMagnitude(); // We want to account for rotation during freefall,
    // so we tack on a an estimated "rotational effect"
    // The FREEFALL_ROTATION_FACTOR const is used to both scale the
    // gyro measurements and convert them to radians/second.
    // So, we compare our accel magnitude against:
    // FREEFALL_THRESHOLD + (some_scaled_magnitude_of_rotation).

    const ffThresh = FREEFALL_THRESHOLD + FREEFALL_ROTATION_FACTOR * spinMag;
    return accelMag < ffThresh;
  }

}

module.exports = Scratch3GdxForBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_gdx_for/scratch-link-device-adapter.js":
/*!************************************************************************!*\
  !*** ./src/extensions/scratch3_gdx_for/scratch-link-device-adapter.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Base64Util = __webpack_require__(/*! ../../util/base64-util */ "./src/util/base64-util.js");
/**
 * Adapter class
 */


class ScratchLinkDeviceAdapter {
  constructor(socket, _ref) {
    let {
      service,
      commandChar,
      responseChar
    } = _ref;
    this.socket = socket;
    this._service = service;
    this._commandChar = commandChar;
    this._responseChar = responseChar;
    this._onResponse = this._onResponse.bind(this);
    this._deviceOnResponse = null;
  }

  get godirectAdapter() {
    return true;
  }

  writeCommand(commandBuffer) {
    const data = Base64Util.uint8ArrayToBase64(commandBuffer);
    return this.socket.write(this._service, this._commandChar, data, 'base64');
  }

  setup(_ref2) {
    let {
      onResponse
    } = _ref2;
    this._deviceOnResponse = onResponse;
    return this.socket.startNotifications(this._service, this._responseChar, this._onResponse); // TODO:
    // How do we find out from scratch link if communication closes?
  }

  _onResponse(base64) {
    const array = Base64Util.base64ToUint8Array(base64);
    const response = new DataView(array.buffer);
    return this._deviceOnResponse(response);
  }

}

module.exports = ScratchLinkDeviceAdapter;

/***/ }),

/***/ "./src/extensions/scratch3_makeymakey/index.js":
/*!*****************************************************!*\
  !*** ./src/extensions/scratch3_makeymakey/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const formatMessage = __webpack_require__(/*! format-message */ "format-message");

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const Cast = __webpack_require__(/*! ../../util/cast */ "./src/util/cast.js");
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const blockIconURI = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MCA0MCI+PHN0eWxlPi5zdDJ7ZmlsbDpyZWR9LnN0M3tmaWxsOiNlMGUwZTB9LnN0NHtmaWxsOm5vbmU7c3Ryb2tlOiM2NjY7c3Ryb2tlLXdpZHRoOi41O3N0cm9rZS1taXRlcmxpbWl0OjEwfTwvc3R5bGU+PHBhdGggZD0iTTM1IDI4SDVhMSAxIDAgMCAxLTEtMVYxMmMwLS42LjQtMSAxLTFoMzBjLjUgMCAxIC40IDEgMXYxNWMwIC41LS41IDEtMSAxeiIgZmlsbD0iI2ZmZiIgaWQ9IkxheWVyXzYiLz48ZyBpZD0iTGF5ZXJfNCI+PHBhdGggY2xhc3M9InN0MiIgZD0iTTQgMjVoMzJ2Mi43SDR6TTEzIDI0aC0yLjJhMSAxIDAgMCAxLTEtMXYtOS43YzAtLjYuNC0xIDEtMUgxM2MuNiAwIDEgLjQgMSAxVjIzYzAgLjYtLjUgMS0xIDF6Ii8+PHBhdGggY2xhc3M9InN0MiIgZD0iTTYuMSAxOS4zdi0yLjJjMC0uNS40LTEgMS0xaDkuN2MuNSAwIDEgLjUgMSAxdjIuMmMwIC41LS41IDEtMSAxSDcuMWExIDEgMCAwIDEtMS0xeiIvPjxjaXJjbGUgY2xhc3M9InN0MiIgY3g9IjIyLjgiIGN5PSIxOC4yIiByPSIzLjQiLz48Y2lyY2xlIGNsYXNzPSJzdDIiIGN4PSIzMC42IiBjeT0iMTguMiIgcj0iMy40Ii8+PHBhdGggY2xhc3M9InN0MiIgZD0iTTQuMiAyN2gzMS45di43SDQuMnoiLz48L2c+PGcgaWQ9IkxheWVyXzUiPjxjaXJjbGUgY2xhc3M9InN0MyIgY3g9IjIyLjgiIGN5PSIxOC4yIiByPSIyLjMiLz48Y2lyY2xlIGNsYXNzPSJzdDMiIGN4PSIzMC42IiBjeT0iMTguMiIgcj0iMi4zIi8+PHBhdGggY2xhc3M9InN0MyIgZD0iTTEyLjUgMjIuOWgtMS4yYy0uMyAwLS41LS4yLS41LS41VjE0YzAtLjMuMi0uNS41LS41aDEuMmMuMyAwIC41LjIuNS41djguNGMwIC4zLS4yLjUtLjUuNXoiLz48cGF0aCBjbGFzcz0ic3QzIiBkPSJNNy4yIDE4Ljd2LTEuMmMwLS4zLjItLjUuNS0uNWg4LjRjLjMgMCAuNS4yLjUuNXYxLjJjMCAuMy0uMi41LS41LjVINy43Yy0uMyAwLS41LS4yLS41LS41ek00IDI2aDMydjJINHoiLz48L2c+PGcgaWQ9IkxheWVyXzMiPjxwYXRoIGNsYXNzPSJzdDQiIGQ9Ik0zNS4yIDI3LjlINC44YTEgMSAwIDAgMS0xLTFWMTIuMWMwLS42LjUtMSAxLTFoMzAuNWMuNSAwIDEgLjQgMSAxVjI3YTEgMSAwIDAgMS0xLjEuOXoiLz48cGF0aCBjbGFzcz0ic3Q0IiBkPSJNMzUuMiAyNy45SDQuOGExIDEgMCAwIDEtMS0xVjEyLjFjMC0uNi41LTEgMS0xaDMwLjVjLjUgMCAxIC40IDEgMVYyN2ExIDEgMCAwIDEtMS4xLjl6Ii8+PC9nPjwvc3ZnPg==';
/**
 * Length of the buffer to store key presses for the "when keys pressed in order" hat
 * @type {number}
 */

const KEY_BUFFER_LENGTH = 100;
/**
 * Timeout in milliseconds to reset the completed flag for a sequence.
 * @type {number}
 */

const SEQUENCE_HAT_TIMEOUT = 100;
/**
 * An id for the space key on a keyboard.
 */

const KEY_ID_SPACE = 'SPACE';
/**
 * An id for the left arrow key on a keyboard.
 */

const KEY_ID_LEFT = 'LEFT';
/**
 * An id for the right arrow key on a keyboard.
 */

const KEY_ID_RIGHT = 'RIGHT';
/**
 * An id for the up arrow key on a keyboard.
 */

const KEY_ID_UP = 'UP';
/**
 * An id for the down arrow key on a keyboard.
 */

const KEY_ID_DOWN = 'DOWN';
/**
 * Names used by keyboard io for keys used in scratch.
 * @enum {string}
 */

const SCRATCH_KEY_NAME = {
  [KEY_ID_SPACE]: 'space',
  [KEY_ID_LEFT]: 'left arrow',
  [KEY_ID_UP]: 'up arrow',
  [KEY_ID_RIGHT]: 'right arrow',
  [KEY_ID_DOWN]: 'down arrow'
};
/**
 * Class for the makey makey blocks in Scratch 3.0
 * @constructor
 */

class Scratch3MakeyMakeyBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    /**
     * A toggle that alternates true and false each frame, so that an
     * edge-triggered hat can trigger on every other frame.
     * @type {boolean}
     */

    this.frameToggle = false; // Set an interval that toggles the frameToggle every frame.

    setInterval(() => {
      this.frameToggle = !this.frameToggle;
    }, this.runtime.currentStepTime);
    this.keyPressed = this.keyPressed.bind(this);
    this.runtime.on('KEY_PRESSED', this.keyPressed);
    this._clearkeyPressBuffer = this._clearkeyPressBuffer.bind(this);
    this.runtime.on('PROJECT_STOP_ALL', this._clearkeyPressBuffer);
    /*
     * An object containing a set of sequence objects.
     * These are the key sequences currently being detected by the "when
     * keys pressed in order" hat block. Each sequence is keyed by its
     * string representation (the sequence's value in the menu, which is a
     * string of KEY_IDs separated by spaces). Each sequence object
     * has an array property (an array of KEY_IDs) and a boolean
     * completed property that is true when the sequence has just been
     * pressed.
     * @type {object}
     */

    this.sequences = {};
    /*
     * An array of the key codes of recently pressed keys.
     * @type {array}
     */

    this.keyPressBuffer = [];
  }
  /*
  * Localized short-form names of the space bar and arrow keys, for use in the
  * displayed menu items of the "when keys pressed in order" block.
  * @type {object}
  */


  get KEY_TEXT_SHORT() {
    return {
      [KEY_ID_SPACE]: formatMessage({
        id: 'makeymakey.spaceKey',
        default: 'space',
        description: 'The space key on a computer keyboard.'
      }),
      [KEY_ID_LEFT]: formatMessage({
        id: 'makeymakey.leftArrowShort',
        default: 'left',
        description: 'Short name for the left arrow key on a computer keyboard.'
      }),
      [KEY_ID_UP]: formatMessage({
        id: 'makeymakey.upArrowShort',
        default: 'up',
        description: 'Short name for the up arrow key on a computer keyboard.'
      }),
      [KEY_ID_RIGHT]: formatMessage({
        id: 'makeymakey.rightArrowShort',
        default: 'right',
        description: 'Short name for the right arrow key on a computer keyboard.'
      }),
      [KEY_ID_DOWN]: formatMessage({
        id: 'makeymakey.downArrowShort',
        default: 'down',
        description: 'Short name for the down arrow key on a computer keyboard.'
      })
    };
  }
  /*
   * An array of strings of KEY_IDs representing the default set of
   * key sequences for use by the "when keys pressed in order" block.
   * @type {array}
   */


  get DEFAULT_SEQUENCES() {
    return ["".concat(KEY_ID_LEFT, " ").concat(KEY_ID_UP, " ").concat(KEY_ID_RIGHT), "".concat(KEY_ID_RIGHT, " ").concat(KEY_ID_UP, " ").concat(KEY_ID_LEFT), "".concat(KEY_ID_LEFT, " ").concat(KEY_ID_RIGHT), "".concat(KEY_ID_RIGHT, " ").concat(KEY_ID_LEFT), "".concat(KEY_ID_UP, " ").concat(KEY_ID_DOWN), "".concat(KEY_ID_DOWN, " ").concat(KEY_ID_UP), "".concat(KEY_ID_UP, " ").concat(KEY_ID_RIGHT, " ").concat(KEY_ID_DOWN, " ").concat(KEY_ID_LEFT), "".concat(KEY_ID_UP, " ").concat(KEY_ID_LEFT, " ").concat(KEY_ID_DOWN, " ").concat(KEY_ID_RIGHT), "".concat(KEY_ID_UP, " ").concat(KEY_ID_UP, " ").concat(KEY_ID_DOWN, " ").concat(KEY_ID_DOWN, " ") + "".concat(KEY_ID_LEFT, " ").concat(KEY_ID_RIGHT, " ").concat(KEY_ID_LEFT, " ").concat(KEY_ID_RIGHT)];
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: 'makeymakey',
      name: 'Makey Makey',
      blockIconURI: blockIconURI,
      blocks: [{
        opcode: 'whenMakeyKeyPressed',
        text: formatMessage({
          id: 'makeymakey.whenKeyPressed',
          default: 'when [KEY] key pressed',
          description: 'when a keyboard key is pressed'
        }),
        blockType: BlockType.HAT,
        arguments: {
          KEY: {
            type: ArgumentType.STRING,
            menu: 'KEY',
            defaultValue: KEY_ID_SPACE
          }
        }
      }, {
        opcode: 'whenCodePressed',
        text: formatMessage({
          id: 'makeymakey.whenKeysPressedInOrder',
          default: 'when [SEQUENCE] pressed in order',
          description: 'when a sequence of keyboard keys is pressed in a specific order'
        }),
        blockType: BlockType.HAT,
        arguments: {
          SEQUENCE: {
            type: ArgumentType.STRING,
            menu: 'SEQUENCE',
            defaultValue: this.DEFAULT_SEQUENCES[0]
          }
        }
      }],
      menus: {
        KEY: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: 'makeymakey.spaceKey',
              default: 'space',
              description: 'The space key on a computer keyboard.'
            }),
            value: KEY_ID_SPACE
          }, {
            text: formatMessage({
              id: 'makeymakey.upArrow',
              default: 'up arrow',
              description: 'The up arrow key on a computer keyboard.'
            }),
            value: KEY_ID_UP
          }, {
            text: formatMessage({
              id: 'makeymakey.downArrow',
              default: 'down arrow',
              description: 'The down arrow key on a computer keyboard.'
            }),
            value: KEY_ID_DOWN
          }, {
            text: formatMessage({
              id: 'makeymakey.rightArrow',
              default: 'right arrow',
              description: 'The right arrow key on a computer keyboard.'
            }),
            value: KEY_ID_RIGHT
          }, {
            text: formatMessage({
              id: 'makeymakey.leftArrow',
              default: 'left arrow',
              description: 'The left arrow key on a computer keyboard.'
            }),
            value: KEY_ID_LEFT
          }, {
            text: 'w',
            value: 'w'
          }, {
            text: 'a',
            value: 'a'
          }, {
            text: 's',
            value: 's'
          }, {
            text: 'd',
            value: 'd'
          }, {
            text: 'f',
            value: 'f'
          }, {
            text: 'g',
            value: 'g'
          }]
        },
        SEQUENCE: {
          acceptReporters: true,
          items: this.buildSequenceMenu(this.DEFAULT_SEQUENCES)
        }
      }
    };
  }
  /*
   * Build the menu of key sequences.
   * @param {array} sequencesArray an array of strings of KEY_IDs.
   * @returns {array} an array of objects with text and value properties.
   */


  buildSequenceMenu(sequencesArray) {
    return sequencesArray.map(str => this.getMenuItemForSequenceString(str));
  }
  /*
   * Create a menu item for a sequence string.
   * @param {string} sequenceString a string of KEY_IDs.
   * @return {object} an object with text and value properties.
   */


  getMenuItemForSequenceString(sequenceString) {
    let sequenceArray = sequenceString.split(' ');
    sequenceArray = sequenceArray.map(str => this.KEY_TEXT_SHORT[str]);
    return {
      text: sequenceArray.join(' '),
      value: sequenceString
    };
  }
  /*
   * Check whether a keyboard key is currently pressed.
   * Also, toggle the results of the test on alternate frames, so that the
   * hat block fires repeatedly.
   * @param {object} args - the block arguments.
   * @property {number} KEY - a key code.
   * @param {object} util - utility object provided by the runtime.
   */


  whenMakeyKeyPressed(args, util) {
    let key = args.KEY; // Convert the key arg, if it is a KEY_ID, to the key name used by
    // the Keyboard io module.

    if (SCRATCH_KEY_NAME[args.KEY]) {
      key = SCRATCH_KEY_NAME[args.KEY];
    }

    const isDown = util.ioQuery('keyboard', 'getKeyIsDown', [key]);
    return isDown && this.frameToggle;
  }
  /*
   * A function called on the KEY_PRESSED event, to update the key press
   * buffer and check if any of the key sequences have been completed.
   * @param {string} key A scratch key name.
   */


  keyPressed(key) {
    // Store only the first word of the Scratch key name, so that e.g. when
    // "left arrow" is pressed, we store "LEFT", which matches KEY_ID_LEFT
    key = key.split(' ')[0];
    key = key.toUpperCase();
    this.keyPressBuffer.push(key); // Keep the buffer under the length limit

    if (this.keyPressBuffer.length > KEY_BUFFER_LENGTH) {
      this.keyPressBuffer.shift();
    } // Check the buffer for each sequence in use


    for (const str in this.sequences) {
      const arr = this.sequences[str].array; // Bail out if we don't have enough presses for this sequence

      if (this.keyPressBuffer.length < arr.length) {
        continue;
      }

      let missFlag = false; // Slice the buffer to the length of the sequence we're checking

      const bufferSegment = this.keyPressBuffer.slice(-1 * arr.length);

      for (let i = 0; i < arr.length; i++) {
        if (arr[i] !== bufferSegment[i]) {
          missFlag = true;
        }
      } // If the miss flag is false, the sequence matched the buffer


      if (!missFlag) {
        this.sequences[str].completed = true; // Clear the completed flag after a timeout. This is necessary because
        // the hat is edge-triggered (not event triggered). Multiple hats
        // may be checking the same sequence, so this timeout gives them enough
        // time to all trigger before resetting the flag.

        setTimeout(() => {
          this.sequences[str].completed = false;
        }, SEQUENCE_HAT_TIMEOUT);
      }
    }
  }
  /**
   * Clear the key press buffer.
   */


  _clearkeyPressBuffer() {
    this.keyPressBuffer = [];
  }
  /*
   * Add a key sequence to the set currently being checked on each key press.
   * @param {string} sequenceString a string of space-separated KEY_IDs.
   * @param {array} sequenceArray an array of KEY_IDs.
   */


  addSequence(sequenceString, sequenceArray) {
    // If we already have this sequence string, return.
    if (this.sequences.hasOwnProperty(sequenceString)) {
      return;
    }

    this.sequences[sequenceString] = {
      array: sequenceArray,
      completed: false
    };
  }
  /*
   * Check whether a key sequence was recently completed.
   * @param {object} args The block arguments.
   * @property {number} SEQUENCE A string of KEY_IDs.
   */


  whenCodePressed(args) {
    const sequenceString = Cast.toString(args.SEQUENCE).toUpperCase();
    const sequenceArray = sequenceString.split(' ');

    if (sequenceArray.length < 2) {
      return;
    }

    this.addSequence(sequenceString, sequenceArray);
    return this.sequences[sequenceString].completed;
  }

}

module.exports = Scratch3MakeyMakeyBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_microbit/index.js":
/*!***************************************************!*\
  !*** ./src/extensions/scratch3_microbit/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const log = __webpack_require__(/*! ../../util/log */ "./src/util/log.js");

const cast = __webpack_require__(/*! ../../util/cast */ "./src/util/cast.js");

const formatMessage = __webpack_require__(/*! format-message */ "format-message");

const BLE = __webpack_require__(/*! ../../io/ble */ "./src/io/ble.js");

const Base64Util = __webpack_require__(/*! ../../util/base64-util */ "./src/util/base64-util.js");
/**
 * Icon png to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const blockIconURI = 'data:image/png;base64,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';
/**
 * Enum for micro:bit BLE command protocol.
 * https://github.com/LLK/scratch-microbit-firmware/blob/master/protocol.md
 * @readonly
 * @enum {number}
 */

const BLECommand = {
  CMD_PIN_CONFIG: 0x80,
  CMD_DISPLAY_TEXT: 0x81,
  CMD_DISPLAY_LED: 0x82
};
/**
 * A time interval to wait (in milliseconds) before reporting to the BLE socket
 * that data has stopped coming from the peripheral.
 */

const BLETimeout = 4500;
/**
 * A time interval to wait (in milliseconds) while a block that sends a BLE message is running.
 * @type {number}
 */

const BLESendInterval = 100;
/**
 * A string to report to the BLE socket when the micro:bit has stopped receiving data.
 * @type {string}
 */

const BLEDataStoppedError = 'micro:bit extension stopped receiving data';
/**
 * Enum for micro:bit protocol.
 * https://github.com/LLK/scratch-microbit-firmware/blob/master/protocol.md
 * @readonly
 * @enum {string}
 */

const BLEUUID = {
  service: 0xf005,
  rxChar: '5261da01-fa7e-42ab-850b-7c80220097cc',
  txChar: '5261da02-fa7e-42ab-850b-7c80220097cc'
};
/**
 * Manage communication with a MicroBit peripheral over a Scrath Link client socket.
 */

class MicroBit {
  /**
   * Construct a MicroBit communication object.
   * @param {Runtime} runtime - the Scratch 3.0 runtime
   * @param {string} extensionId - the id of the extension
   */
  constructor(runtime, extensionId) {
    /**
     * The Scratch 3.0 runtime used to trigger the green flag button.
     * @type {Runtime}
     * @private
     */
    this._runtime = runtime;
    /**
     * The BluetoothLowEnergy connection socket for reading/writing peripheral data.
     * @type {BLE}
     * @private
     */

    this._ble = null;

    this._runtime.registerPeripheralExtension(extensionId, this);
    /**
     * The id of the extension this peripheral belongs to.
     */


    this._extensionId = extensionId;
    /**
     * The most recently received value for each sensor.
     * @type {Object.<string, number>}
     * @private
     */

    this._sensors = {
      tiltX: 0,
      tiltY: 0,
      buttonA: 0,
      buttonB: 0,
      touchPins: [0, 0, 0],
      gestureState: 0,
      ledMatrixState: new Uint8Array(5)
    };
    /**
     * The most recently received value for each gesture.
     * @type {Object.<string, Object>}
     * @private
     */

    this._gestures = {
      moving: false,
      move: {
        active: false,
        timeout: false
      },
      shake: {
        active: false,
        timeout: false
      },
      jump: {
        active: false,
        timeout: false
      }
    };
    /**
     * Interval ID for data reading timeout.
     * @type {number}
     * @private
     */

    this._timeoutID = null;
    /**
     * A flag that is true while we are busy sending data to the BLE socket.
     * @type {boolean}
     * @private
     */

    this._busy = false;
    /**
     * ID for a timeout which is used to clear the busy flag if it has been
     * true for a long time.
     */

    this._busyTimeoutID = null;
    this.reset = this.reset.bind(this);
    this._onConnect = this._onConnect.bind(this);
    this._onMessage = this._onMessage.bind(this);
  }
  /**
   * @param {string} text - the text to display.
   * @return {Promise} - a Promise that resolves when writing to peripheral.
   */


  displayText(text) {
    const output = new Uint8Array(text.length);

    for (let i = 0; i < text.length; i++) {
      output[i] = text.charCodeAt(i);
    }

    return this.send(BLECommand.CMD_DISPLAY_TEXT, output);
  }
  /**
   * @param {Uint8Array} matrix - the matrix to display.
   * @return {Promise} - a Promise that resolves when writing to peripheral.
   */


  displayMatrix(matrix) {
    return this.send(BLECommand.CMD_DISPLAY_LED, matrix);
  }
  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the X axis.
   */


  get tiltX() {
    return this._sensors.tiltX;
  }
  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the Y axis.
   */


  get tiltY() {
    return this._sensors.tiltY;
  }
  /**
   * @return {boolean} - the latest value received for the A button.
   */


  get buttonA() {
    return this._sensors.buttonA;
  }
  /**
   * @return {boolean} - the latest value received for the B button.
   */


  get buttonB() {
    return this._sensors.buttonB;
  }
  /**
   * @return {number} - the latest value received for the motion gesture states.
   */


  get gestureState() {
    return this._sensors.gestureState;
  }
  /**
   * @return {Uint8Array} - the current state of the 5x5 LED matrix.
   */


  get ledMatrixState() {
    return this._sensors.ledMatrixState;
  }
  /**
   * Called by the runtime when user wants to scan for a peripheral.
   */


  scan() {
    if (this._ble) {
      this._ble.disconnect();
    }

    this._ble = new BLE(this._runtime, this._extensionId, {
      filters: [{
        services: [BLEUUID.service]
      }]
    }, this._onConnect, this.reset);
  }
  /**
   * Called by the runtime when user wants to connect to a certain peripheral.
   * @param {number} id - the id of the peripheral to connect to.
   */


  connect(id) {
    if (this._ble) {
      this._ble.connectPeripheral(id);
    }
  }
  /**
   * Disconnect from the micro:bit.
   */


  disconnect() {
    if (this._ble) {
      this._ble.disconnect();
    }

    this.reset();
  }
  /**
   * Reset all the state and timeout/interval ids.
   */


  reset() {
    if (this._timeoutID) {
      window.clearTimeout(this._timeoutID);
      this._timeoutID = null;
    }
  }
  /**
   * Return true if connected to the micro:bit.
   * @return {boolean} - whether the micro:bit is connected.
   */


  isConnected() {
    let connected = false;

    if (this._ble) {
      connected = this._ble.isConnected();
    }

    return connected;
  }
  /**
   * Send a message to the peripheral BLE socket.
   * @param {number} command - the BLE command hex.
   * @param {Uint8Array} message - the message to write
   */


  send(command, message) {
    if (!this.isConnected()) return;
    if (this._busy) return; // Set a busy flag so that while we are sending a message and waiting for
    // the response, additional messages are ignored.

    this._busy = true; // Set a timeout after which to reset the busy flag. This is used in case
    // a BLE message was sent for which we never received a response, because
    // e.g. the peripheral was turned off after the message was sent. We reset
    // the busy flag after a while so that it is possible to try again later.

    this._busyTimeoutID = window.setTimeout(() => {
      this._busy = false;
    }, 5000);
    const output = new Uint8Array(message.length + 1);
    output[0] = command; // attach command to beginning of message

    for (let i = 0; i < message.length; i++) {
      output[i + 1] = message[i];
    }

    const data = Base64Util.uint8ArrayToBase64(output);

    this._ble.write(BLEUUID.service, BLEUUID.txChar, data, 'base64', true).then(() => {
      this._busy = false;
      window.clearTimeout(this._busyTimeoutID);
    });
  }
  /**
   * Starts reading data from peripheral after BLE has connected to it.
   * @private
   */


  _onConnect() {
    this._ble.read(BLEUUID.service, BLEUUID.rxChar, true, this._onMessage);

    this._timeoutID = window.setTimeout(() => this._ble.handleDisconnectError(BLEDataStoppedError), BLETimeout);
  }
  /**
   * Process the sensor data from the incoming BLE characteristic.
   * @param {object} base64 - the incoming BLE data.
   * @private
   */


  _onMessage(base64) {
    // parse data
    const data = Base64Util.base64ToUint8Array(base64);
    this._sensors.tiltX = data[1] | data[0] << 8;
    if (this._sensors.tiltX > 1 << 15) this._sensors.tiltX -= 1 << 16;
    this._sensors.tiltY = data[3] | data[2] << 8;
    if (this._sensors.tiltY > 1 << 15) this._sensors.tiltY -= 1 << 16;
    this._sensors.buttonA = data[4];
    this._sensors.buttonB = data[5];
    this._sensors.touchPins[0] = data[6];
    this._sensors.touchPins[1] = data[7];
    this._sensors.touchPins[2] = data[8];
    this._sensors.gestureState = data[9]; // cancel disconnect timeout and start a new one

    window.clearTimeout(this._timeoutID);
    this._timeoutID = window.setTimeout(() => this._ble.handleDisconnectError(BLEDataStoppedError), BLETimeout);
  }
  /**
   * @param {number} pin - the pin to check touch state.
   * @return {number} - the latest value received for the touch pin states.
   * @private
   */


  _checkPinState(pin) {
    return this._sensors.touchPins[pin];
  }

}
/**
 * Enum for tilt sensor direction.
 * @readonly
 * @enum {string}
 */


const MicroBitTiltDirection = {
  FRONT: 'front',
  BACK: 'back',
  LEFT: 'left',
  RIGHT: 'right',
  ANY: 'any'
};
/**
 * Enum for micro:bit gestures.
 * @readonly
 * @enum {string}
 */

const MicroBitGestures = {
  MOVED: 'moved',
  SHAKEN: 'shaken',
  JUMPED: 'jumped'
};
/**
 * Enum for micro:bit buttons.
 * @readonly
 * @enum {string}
 */

const MicroBitButtons = {
  A: 'A',
  B: 'B',
  ANY: 'any'
};
/**
 * Enum for micro:bit pin states.
 * @readonly
 * @enum {string}
 */

const MicroBitPinState = {
  ON: 'on',
  OFF: 'off'
};
/**
 * Scratch 3.0 blocks to interact with a MicroBit peripheral.
 */

class Scratch3MicroBitBlocks {
  /**
   * @return {string} - the name of this extension.
   */
  static get EXTENSION_NAME() {
    return 'micro:bit';
  }
  /**
   * @return {string} - the ID of this extension.
   */


  static get EXTENSION_ID() {
    return 'microbit';
  }
  /**
   * @return {number} - the tilt sensor counts as "tilted" if its tilt angle meets or exceeds this threshold.
   */


  static get TILT_THRESHOLD() {
    return 15;
  }
  /**
   * @return {array} - text and values for each buttons menu element
   */


  get BUTTONS_MENU() {
    return [{
      text: 'A',
      value: MicroBitButtons.A
    }, {
      text: 'B',
      value: MicroBitButtons.B
    }, {
      text: formatMessage({
        id: 'microbit.buttonsMenu.any',
        default: 'any',
        description: 'label for "any" element in button picker for micro:bit extension'
      }),
      value: MicroBitButtons.ANY
    }];
  }
  /**
   * @return {array} - text and values for each gestures menu element
   */


  get GESTURES_MENU() {
    return [{
      text: formatMessage({
        id: 'microbit.gesturesMenu.moved',
        default: 'moved',
        description: 'label for moved gesture in gesture picker for micro:bit extension'
      }),
      value: MicroBitGestures.MOVED
    }, {
      text: formatMessage({
        id: 'microbit.gesturesMenu.shaken',
        default: 'shaken',
        description: 'label for shaken gesture in gesture picker for micro:bit extension'
      }),
      value: MicroBitGestures.SHAKEN
    }, {
      text: formatMessage({
        id: 'microbit.gesturesMenu.jumped',
        default: 'jumped',
        description: 'label for jumped gesture in gesture picker for micro:bit extension'
      }),
      value: MicroBitGestures.JUMPED
    }];
  }
  /**
   * @return {array} - text and values for each pin state menu element
   */


  get PIN_STATE_MENU() {
    return [{
      text: formatMessage({
        id: 'microbit.pinStateMenu.on',
        default: 'on',
        description: 'label for on element in pin state picker for micro:bit extension'
      }),
      value: MicroBitPinState.ON
    }, {
      text: formatMessage({
        id: 'microbit.pinStateMenu.off',
        default: 'off',
        description: 'label for off element in pin state picker for micro:bit extension'
      }),
      value: MicroBitPinState.OFF
    }];
  }
  /**
   * @return {array} - text and values for each tilt direction menu element
   */


  get TILT_DIRECTION_MENU() {
    return [{
      text: formatMessage({
        id: 'microbit.tiltDirectionMenu.front',
        default: 'front',
        description: 'label for front element in tilt direction picker for micro:bit extension'
      }),
      value: MicroBitTiltDirection.FRONT
    }, {
      text: formatMessage({
        id: 'microbit.tiltDirectionMenu.back',
        default: 'back',
        description: 'label for back element in tilt direction picker for micro:bit extension'
      }),
      value: MicroBitTiltDirection.BACK
    }, {
      text: formatMessage({
        id: 'microbit.tiltDirectionMenu.left',
        default: 'left',
        description: 'label for left element in tilt direction picker for micro:bit extension'
      }),
      value: MicroBitTiltDirection.LEFT
    }, {
      text: formatMessage({
        id: 'microbit.tiltDirectionMenu.right',
        default: 'right',
        description: 'label for right element in tilt direction picker for micro:bit extension'
      }),
      value: MicroBitTiltDirection.RIGHT
    }];
  }
  /**
   * @return {array} - text and values for each tilt direction (plus "any") menu element
   */


  get TILT_DIRECTION_ANY_MENU() {
    return [...this.TILT_DIRECTION_MENU, {
      text: formatMessage({
        id: 'microbit.tiltDirectionMenu.any',
        default: 'any',
        description: 'label for any direction element in tilt direction picker for micro:bit extension'
      }),
      value: MicroBitTiltDirection.ANY
    }];
  }
  /**
   * Construct a set of MicroBit blocks.
   * @param {Runtime} runtime - the Scratch 3.0 runtime.
   */


  constructor(runtime) {
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime; // Create a new MicroBit peripheral instance

    this._peripheral = new MicroBit(this.runtime, Scratch3MicroBitBlocks.EXTENSION_ID);
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: Scratch3MicroBitBlocks.EXTENSION_ID,
      name: Scratch3MicroBitBlocks.EXTENSION_NAME,
      blockIconURI: blockIconURI,
      showStatusButton: true,
      blocks: [{
        opcode: 'whenButtonPressed',
        text: formatMessage({
          id: 'microbit.whenButtonPressed',
          default: 'when [BTN] button pressed',
          description: 'when the selected button on the micro:bit is pressed'
        }),
        blockType: BlockType.HAT,
        arguments: {
          BTN: {
            type: ArgumentType.STRING,
            menu: 'buttons',
            defaultValue: MicroBitButtons.A
          }
        }
      }, {
        opcode: 'isButtonPressed',
        text: formatMessage({
          id: 'microbit.isButtonPressed',
          default: '[BTN] button pressed?',
          description: 'is the selected button on the micro:bit pressed?'
        }),
        blockType: BlockType.BOOLEAN,
        arguments: {
          BTN: {
            type: ArgumentType.STRING,
            menu: 'buttons',
            defaultValue: MicroBitButtons.A
          }
        }
      }, '---', {
        opcode: 'whenGesture',
        text: formatMessage({
          id: 'microbit.whenGesture',
          default: 'when [GESTURE]',
          description: 'when the selected gesture is detected by the micro:bit'
        }),
        blockType: BlockType.HAT,
        arguments: {
          GESTURE: {
            type: ArgumentType.STRING,
            menu: 'gestures',
            defaultValue: MicroBitGestures.MOVED
          }
        }
      }, '---', {
        opcode: 'displaySymbol',
        text: formatMessage({
          id: 'microbit.displaySymbol',
          default: 'display [MATRIX]',
          description: 'display a pattern on the micro:bit display'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MATRIX: {
            type: ArgumentType.MATRIX,
            defaultValue: '0101010101100010101000100'
          }
        }
      }, {
        opcode: 'displayText',
        text: formatMessage({
          id: 'microbit.displayText',
          default: 'display text [TEXT]',
          description: 'display text on the micro:bit display'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          TEXT: {
            type: ArgumentType.STRING,
            defaultValue: formatMessage({
              id: 'microbit.defaultTextToDisplay',
              default: 'Hello!',
              description: "default text to display.\n                                IMPORTANT - the micro:bit only supports letters a-z, A-Z.\n                                Please substitute a default word in your language\n                                that can be written with those characters,\n                                substitute non-accented characters or leave it as \"Hello!\".\n                                Check the micro:bit site documentation for details"
            })
          }
        }
      }, {
        opcode: 'displayClear',
        text: formatMessage({
          id: 'microbit.clearDisplay',
          default: 'clear display',
          description: 'display nothing on the micro:bit display'
        }),
        blockType: BlockType.COMMAND
      }, '---', {
        opcode: 'whenTilted',
        text: formatMessage({
          id: 'microbit.whenTilted',
          default: 'when tilted [DIRECTION]',
          description: 'when the micro:bit is tilted in a direction'
        }),
        blockType: BlockType.HAT,
        arguments: {
          DIRECTION: {
            type: ArgumentType.STRING,
            menu: 'tiltDirectionAny',
            defaultValue: MicroBitTiltDirection.ANY
          }
        }
      }, {
        opcode: 'isTilted',
        text: formatMessage({
          id: 'microbit.isTilted',
          default: 'tilted [DIRECTION]?',
          description: 'is the micro:bit is tilted in a direction?'
        }),
        blockType: BlockType.BOOLEAN,
        arguments: {
          DIRECTION: {
            type: ArgumentType.STRING,
            menu: 'tiltDirectionAny',
            defaultValue: MicroBitTiltDirection.ANY
          }
        }
      }, {
        opcode: 'getTiltAngle',
        text: formatMessage({
          id: 'microbit.tiltAngle',
          default: 'tilt angle [DIRECTION]',
          description: 'how much the micro:bit is tilted in a direction'
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          DIRECTION: {
            type: ArgumentType.STRING,
            menu: 'tiltDirection',
            defaultValue: MicroBitTiltDirection.FRONT
          }
        }
      }, '---', {
        opcode: 'whenPinConnected',
        text: formatMessage({
          id: 'microbit.whenPinConnected',
          default: 'when pin [PIN] connected',
          description: 'when the pin detects a connection to Earth/Ground'
        }),
        blockType: BlockType.HAT,
        arguments: {
          PIN: {
            type: ArgumentType.STRING,
            menu: 'touchPins',
            defaultValue: '0'
          }
        }
      }],
      menus: {
        buttons: {
          acceptReporters: true,
          items: this.BUTTONS_MENU
        },
        gestures: {
          acceptReporters: true,
          items: this.GESTURES_MENU
        },
        pinState: {
          acceptReporters: true,
          items: this.PIN_STATE_MENU
        },
        tiltDirection: {
          acceptReporters: true,
          items: this.TILT_DIRECTION_MENU
        },
        tiltDirectionAny: {
          acceptReporters: true,
          items: this.TILT_DIRECTION_ANY_MENU
        },
        touchPins: {
          acceptReporters: true,
          items: ['0', '1', '2']
        }
      }
    };
  }
  /**
   * Test whether the A or B button is pressed
   * @param {object} args - the block's arguments.
   * @return {boolean} - true if the button is pressed.
   */


  whenButtonPressed(args) {
    if (args.BTN === 'any') {
      return this._peripheral.buttonA | this._peripheral.buttonB;
    } else if (args.BTN === 'A') {
      return this._peripheral.buttonA;
    } else if (args.BTN === 'B') {
      return this._peripheral.buttonB;
    }

    return false;
  }
  /**
   * Test whether the A or B button is pressed
   * @param {object} args - the block's arguments.
   * @return {boolean} - true if the button is pressed.
   */


  isButtonPressed(args) {
    if (args.BTN === 'any') {
      return (this._peripheral.buttonA | this._peripheral.buttonB) !== 0;
    } else if (args.BTN === 'A') {
      return this._peripheral.buttonA !== 0;
    } else if (args.BTN === 'B') {
      return this._peripheral.buttonB !== 0;
    }

    return false;
  }
  /**
   * Test whether the micro:bit is moving
   * @param {object} args - the block's arguments.
   * @return {boolean} - true if the micro:bit is moving.
   */


  whenGesture(args) {
    const gesture = cast.toString(args.GESTURE);

    if (gesture === 'moved') {
      return this._peripheral.gestureState >> 2 & 1;
    } else if (gesture === 'shaken') {
      return this._peripheral.gestureState & 1;
    } else if (gesture === 'jumped') {
      return this._peripheral.gestureState >> 1 & 1;
    }

    return false;
  }
  /**
   * Display a predefined symbol on the 5x5 LED matrix.
   * @param {object} args - the block's arguments.
   * @return {Promise} - a Promise that resolves after a tick.
   */


  displaySymbol(args) {
    const symbol = cast.toString(args.MATRIX).replace(/\s/g, '');

    const reducer = (accumulator, c, index) => {
      const value = c === '0' ? accumulator : accumulator + Math.pow(2, index);
      return value;
    };

    const hex = symbol.split('').reduce(reducer, 0);

    if (hex !== null) {
      this._peripheral.ledMatrixState[0] = hex & 0x1F;
      this._peripheral.ledMatrixState[1] = hex >> 5 & 0x1F;
      this._peripheral.ledMatrixState[2] = hex >> 10 & 0x1F;
      this._peripheral.ledMatrixState[3] = hex >> 15 & 0x1F;
      this._peripheral.ledMatrixState[4] = hex >> 20 & 0x1F;

      this._peripheral.displayMatrix(this._peripheral.ledMatrixState);
    }

    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }
  /**
   * Display text on the 5x5 LED matrix.
   * @param {object} args - the block's arguments.
   * @return {Promise} - a Promise that resolves after the text is done printing.
   * Note the limit is 19 characters
   * The print time is calculated by multiplying the number of horizontal pixels
   * by the default scroll delay of 120ms.
   * The number of horizontal pixels = 6px for each character in the string,
   * 1px before the string, and 5px after the string.
   */


  displayText(args) {
    const text = String(args.TEXT).substring(0, 19);
    if (text.length > 0) this._peripheral.displayText(text);
    const yieldDelay = 120 * (6 * text.length + 6);
    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, yieldDelay);
    });
  }
  /**
   * Turn all 5x5 matrix LEDs off.
   * @return {Promise} - a Promise that resolves after a tick.
   */


  displayClear() {
    for (let i = 0; i < 5; i++) {
      this._peripheral.ledMatrixState[i] = 0;
    }

    this._peripheral.displayMatrix(this._peripheral.ledMatrixState);

    return new Promise(resolve => {
      setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} DIRECTION - the tilt direction to test (front, back, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */


  whenTilted(args) {
    return this._isTilted(args.DIRECTION);
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} DIRECTION - the tilt direction to test (front, back, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */


  isTilted(args) {
    return this._isTilted(args.DIRECTION);
  }
  /**
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} DIRECTION - the direction (front, back, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(front) = -getTiltAngle(back) and getTiltAngle(left) = -getTiltAngle(right).
   */


  getTiltAngle(args) {
    return this._getTiltAngle(args.DIRECTION);
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {TiltDirection} direction - the tilt direction to test (front, back, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   * @private
   */


  _isTilted(direction) {
    switch (direction) {
      case MicroBitTiltDirection.ANY:
        return Math.abs(this._peripheral.tiltX / 10) >= Scratch3MicroBitBlocks.TILT_THRESHOLD || Math.abs(this._peripheral.tiltY / 10) >= Scratch3MicroBitBlocks.TILT_THRESHOLD;

      default:
        return this._getTiltAngle(direction) >= Scratch3MicroBitBlocks.TILT_THRESHOLD;
    }
  }
  /**
   * @param {TiltDirection} direction - the direction (front, back, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(front) = -getTiltAngle(back) and getTiltAngle(left) = -getTiltAngle(right).
   * @private
   */


  _getTiltAngle(direction) {
    switch (direction) {
      case MicroBitTiltDirection.FRONT:
        return Math.round(this._peripheral.tiltY / -10);

      case MicroBitTiltDirection.BACK:
        return Math.round(this._peripheral.tiltY / 10);

      case MicroBitTiltDirection.LEFT:
        return Math.round(this._peripheral.tiltX / -10);

      case MicroBitTiltDirection.RIGHT:
        return Math.round(this._peripheral.tiltX / 10);

      default:
        log.warn("Unknown tilt direction in _getTiltAngle: ".concat(direction));
    }
  }
  /**
   * @param {object} args - the block's arguments.
   * @return {boolean} - the touch pin state.
   * @private
   */


  whenPinConnected(args) {
    const pin = parseInt(args.PIN, 10);
    if (isNaN(pin)) return;
    if (pin < 0 || pin > 2) return false;
    return this._peripheral._checkPinState(pin);
  }

}

module.exports = Scratch3MicroBitBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/drums/1-snare.mp3":
/*!****************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/drums/1-snare.mp3 ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/90eaf6469dbf3a808a3d9739cc77358d.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/drums/10-wood-block.mp3":
/*!**********************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/drums/10-wood-block.mp3 ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/4240a79d13ecf2792f825457194c96d9.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/drums/11-cowbell.mp3":
/*!*******************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/drums/11-cowbell.mp3 ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/9ad12a9de73f49fb645902987027eb2b.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/drums/12-triangle.mp3":
/*!********************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/drums/12-triangle.mp3 ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/2b7b80de8884cc3cf584aa0deb86a59b.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/drums/13-bongo.mp3":
/*!*****************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/drums/13-bongo.mp3 ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/5c6533a34175f61a9cab627f671111e1.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/drums/14-conga.mp3":
/*!*****************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/drums/14-conga.mp3 ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/5888c4ba6b8a0767f8be5bbc81994397.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/drums/15-cabasa.mp3":
/*!******************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/drums/15-cabasa.mp3 ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/fad59dd220562492e6722aa8a97f9369.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/drums/16-guiro.mp3":
/*!*****************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/drums/16-guiro.mp3 ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/51a75dd50afd0bc6022dfc86455be19c.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/drums/17-vibraslap.mp3":
/*!*********************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/drums/17-vibraslap.mp3 ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/9f8e3a1db63c7a8fd976beca7e3546c3.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/drums/18-cuica.mp3":
/*!*****************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/drums/18-cuica.mp3 ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/b6a8e4a96ffcd83154ad2c5cbcb52751.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/drums/2-bass-drum.mp3":
/*!********************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/drums/2-bass-drum.mp3 ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/1c9630b745711a0b829841e8555d76e4.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/drums/3-side-stick.mp3":
/*!*********************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/drums/3-side-stick.mp3 ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/f8d8b9d9f1aa45900b786980418219b1.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/drums/4-crash-cymbal.mp3":
/*!***********************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/drums/4-crash-cymbal.mp3 ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/83f2d48d0c7d1e6be8a509d4d2c6d0e5.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/drums/5-open-hi-hat.mp3":
/*!**********************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/drums/5-open-hi-hat.mp3 ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/b700cf6f9c368ce49851d287ddd3b63c.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/drums/6-closed-hi-hat.mp3":
/*!************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/drums/6-closed-hi-hat.mp3 ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/3fbd690bdae84637e34b8b933a164e3d.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/drums/7-tambourine.mp3":
/*!*********************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/drums/7-tambourine.mp3 ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/a7c08a472cc8b1c4e0c45ae9b030b414.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/drums/8-hand-clap.mp3":
/*!********************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/drums/8-hand-clap.mp3 ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/f28b1ecd6fccd6218a837c14b1109da7.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/drums/9-claves.mp3":
/*!*****************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/drums/9-claves.mp3 ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/f9868658d8483a6dbcd600e0226dfeef.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/1-piano/108.mp3":
/*!**************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/1-piano/108.mp3 ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/10af80546707afae5507edb828dd35a0.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/1-piano/24.mp3":
/*!*************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/1-piano/24.mp3 ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/7a7fdb40997804d4778e2a12bd7599f7.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/1-piano/36.mp3":
/*!*************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/1-piano/36.mp3 ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/a61fc8393abec3c0d1e813fc01f252ee.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/1-piano/48.mp3":
/*!*************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/1-piano/48.mp3 ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/a0b130dbafdc7958b73d162239053173.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/1-piano/60.mp3":
/*!*************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/1-piano/60.mp3 ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/d72b98474fc83d6268886779339e242e.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/1-piano/72.mp3":
/*!*************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/1-piano/72.mp3 ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/d4b3ce804680eb7d58f6accc7436e807.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/1-piano/84.mp3":
/*!*************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/1-piano/84.mp3 ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/129b99ac19024c35228d855f42fb852b.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/1-piano/96.mp3":
/*!*************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/1-piano/96.mp3 ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/8c0c02f16572b730d422f96a3ce53e7f.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/10-clarinet/48.mp3":
/*!*****************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/10-clarinet/48.mp3 ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/00d2dff9d5ece15a67074374b2027590.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/10-clarinet/60.mp3":
/*!*****************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/10-clarinet/60.mp3 ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/09995475180591a6c64c8744fbfdf4d8.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/11-saxophone/36.mp3":
/*!******************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/11-saxophone/36.mp3 ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/961bfad11616b6f5c951c58499cf267a.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/11-saxophone/60.mp3":
/*!******************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/11-saxophone/60.mp3 ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/2b0cfb89b2c8d1badb03136fcf911c3b.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/11-saxophone/84.mp3":
/*!******************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/11-saxophone/84.mp3 ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/c44ce3bfa465281e765f197d6c3ee7ea.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/12-flute/60.mp3":
/*!**************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/12-flute/60.mp3 ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/e6180253665b8248f685c6d96881f75b.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/12-flute/72.mp3":
/*!**************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/12-flute/72.mp3 ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/b52b83f63e8482255d46f40ea454fa01.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/13-wooden-flute/60.mp3":
/*!*********************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/13-wooden-flute/60.mp3 ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/1e7ed7b14b056ebd80f434143846fb4e.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/13-wooden-flute/72.mp3":
/*!*********************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/13-wooden-flute/72.mp3 ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/c36dd943607003a3229aca77b49d32de.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/14-bassoon/36.mp3":
/*!****************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/14-bassoon/36.mp3 ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/f382f43d667b784d1bcd8cfe7aa6fff0.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/14-bassoon/48.mp3":
/*!****************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/14-bassoon/48.mp3 ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/5e0704b815761d38242f1b961ce9ef69.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/14-bassoon/60.mp3":
/*!****************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/14-bassoon/60.mp3 ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/1a87a73db1ba0193283680e37b35754e.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/15-choir/48.mp3":
/*!**************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/15-choir/48.mp3 ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/fc383956e315b7ee2bd8dd09de311701.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/15-choir/60.mp3":
/*!**************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/15-choir/60.mp3 ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/0b18f02669375ad2ee80bef8d07ea7ec.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/15-choir/72.mp3":
/*!**************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/15-choir/72.mp3 ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/1980303ffc6f5c17c601a9e5992aea77.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/16-vibraphone/60.mp3":
/*!*******************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/16-vibraphone/60.mp3 ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/57f0f65052d9dac78ee66b11cc696b6a.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/16-vibraphone/72.mp3":
/*!*******************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/16-vibraphone/72.mp3 ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/da1a6ebcd442e9d867b31fb21ce6a289.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/17-music-box/60.mp3":
/*!******************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/17-music-box/60.mp3 ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/bacc13779ca01580b89f39dd2118c22a.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/18-steel-drum/60.mp3":
/*!*******************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/18-steel-drum/60.mp3 ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/0dcd27b60c185811b19f59d56eaa12f6.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/19-marimba/60.mp3":
/*!****************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/19-marimba/60.mp3 ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/1a064f9a752824e781ccf79ab66850ed.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/2-electric-piano/60.mp3":
/*!**********************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/2-electric-piano/60.mp3 ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/a05bbf6359407ad7950e115edab178d9.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/20-synth-lead/60.mp3":
/*!*******************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/20-synth-lead/60.mp3 ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/da3126c6a70c4ef84192c33f99996354.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/21-synth-pad/60.mp3":
/*!******************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/21-synth-pad/60.mp3 ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/103fe904046c35630c600cb122492d78.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/3-organ/60.mp3":
/*!*************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/3-organ/60.mp3 ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/8ca9997e9ed7534a8d0f349a6125bd24.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/4-guitar/60.mp3":
/*!**************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/4-guitar/60.mp3 ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/83857346b7c2e6a351c69377e82a3606.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/5-electric-guitar/60.mp3":
/*!***********************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/5-electric-guitar/60.mp3 ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/ecb1cbda3b9c4f29ab971734d97e3faf.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/6-bass/36.mp3":
/*!************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/6-bass/36.mp3 ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/0043f23189fb3cbf2021a88959961ece.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/6-bass/48.mp3":
/*!************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/6-bass/48.mp3 ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/78a74345ee778afbd6abe637b4f69efc.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/7-pizzicato/60.mp3":
/*!*****************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/7-pizzicato/60.mp3 ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/d434438e5d193118e4aad3a846e1c7ba.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/8-cello/36.mp3":
/*!*************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/8-cello/36.mp3 ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/39563f3b38b1fdb805323b1f69dace54.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/8-cello/48.mp3":
/*!*************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/8-cello/48.mp3 ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/0e8ed599d9875c77d52db36de2b2b33f.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/8-cello/60.mp3":
/*!*************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/8-cello/60.mp3 ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/7337f194b0a727f4be98902487dfb615.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/9-trombone/36.mp3":
/*!****************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/9-trombone/36.mp3 ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/ed2a96fbdb476efe419246982e357121.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/9-trombone/48.mp3":
/*!****************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/9-trombone/48.mp3 ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/7c5a16e0627c64fd62ec597bb72b879d.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/assets/instruments/9-trombone/60.mp3":
/*!****************************************************************************!*\
  !*** ./src/extensions/scratch3_music/assets/instruments/9-trombone/60.mp3 ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "media/music/e27f7cdf42df8b768345ae83fecffe4b.mp3";

/***/ }),

/***/ "./src/extensions/scratch3_music/index.js":
/*!************************************************!*\
  !*** ./src/extensions/scratch3_music/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const Clone = __webpack_require__(/*! ../../util/clone */ "./src/util/clone.js");

const Cast = __webpack_require__(/*! ../../util/cast */ "./src/util/cast.js");

const formatMessage = __webpack_require__(/*! format-message */ "format-message");

const MathUtil = __webpack_require__(/*! ../../util/math-util */ "./src/util/math-util.js");

const Timer = __webpack_require__(/*! ../../util/timer */ "./src/util/timer.js");
/**
 * The instrument and drum sounds, loaded as static assets.
 * @type {object}
 */


let assetData = {};

try {
  assetData = __webpack_require__(/*! ./manifest */ "./src/extensions/scratch3_music/manifest.js");
} catch (e) {// Non-webpack environment, don't worry about assets.
}
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const blockIconURI = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PHRpdGxlPm11c2ljLWJsb2NrLWljb248L3RpdGxlPjxkZWZzPjxwYXRoIGQ9Ik0zMi4xOCAyNS44NzRDMzIuNjM2IDI4LjE1NyAzMC41MTIgMzAgMjcuNDMzIDMwYy0zLjA3IDAtNS45MjMtMS44NDMtNi4zNzItNC4xMjYtLjQ1OC0yLjI4NSAxLjY2NS00LjEzNiA0Ljc0My00LjEzNi42NDcgMCAxLjI4My4wODQgMS44OS4yMzQuMzM4LjA4Ni42MzcuMTguOTM4LjMwMi44Ny0uMDItLjEwNC0yLjI5NC0xLjgzNS0xMi4yMy0yLjEzNC0xMi4zMDIgMy4wNi0xLjg3IDguNzY4LTIuNzUyIDUuNzA4LS44ODUuMDc2IDQuODItMy42NSAzLjg0NC0zLjcyNC0uOTg3LTQuNjUtNy4xNTMuMjYzIDE0LjczOHptLTE2Ljk5OCA1Ljk5QzE1LjYzIDM0LjE0OCAxMy41MDcgMzYgMTAuNDQgMzZjLTMuMDcgMC01LjkyMi0xLjg1Mi02LjM4LTQuMTM2LS40NDgtMi4yODQgMS42NzQtNC4xMzUgNC43NS00LjEzNSAxLjAwMyAwIDEuOTc1LjE5NiAyLjg1NS41NDMuODIyLS4wNTUtLjE1LTIuMzc3LTEuODYyLTEyLjIyOC0yLjEzMy0xMi4zMDMgMy4wNi0xLjg3IDguNzY0LTIuNzUzIDUuNzA2LS44OTQuMDc2IDQuODItMy42NDggMy44MzQtMy43MjQtLjk4Ny00LjY1LTcuMTUyLjI2MiAxNC43Mzh6IiBpZD0iYSIvPjwvZGVmcz48ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPjx1c2UgZmlsbD0iI0ZGRiIgeGxpbms6aHJlZj0iI2EiLz48cGF0aCBzdHJva2Utb3BhY2l0eT0iLjEiIHN0cm9rZT0iIzAwMCIgZD0iTTI4LjQ1NiAyMS42NzVjLS4wMS0uMzEyLS4wODctLjgyNS0uMjU2LTEuNzAyLS4wOTYtLjQ5NS0uNjEyLTMuMDIyLS43NTMtMy43My0uMzk1LTEuOTgtLjc2LTMuOTItMS4xNDItNi4xMTMtLjczMi00LjIyMy0uNjkzLTYuMDUuMzQ0LTYuNTI3LjUtLjIzIDEuMDYtLjA4IDEuODQuMzUuNDE0LjIyNyAyLjE4MiAxLjM2NSAyLjA3IDEuMjk2IDEuOTk0IDEuMjQyIDMuNDY0IDEuNzc0IDQuOTMgMS41NDggMS41MjYtLjIzNyAyLjUwNC0uMDYgMi44NzYuNjE4LjM0OC42MzUuMDE1IDEuNDE2LS43MyAyLjE4LTEuNDcyIDEuNTE2LTMuOTc1IDIuNTE0LTUuODQ4IDIuMDIzLS44MjItLjIyLTEuMjM4LS40NjUtMi4zOC0xLjI2N2wtLjA5NS0uMDY2Yy4wNDcuNTkzLjI2NCAxLjc0LjcxNyAzLjgwMy4yOTQgMS4zMzYgMi4wOCA5LjE4NyAyLjYzNyAxMS42NzRsLjAwMi4wMTJjLjUyOCAyLjYzNy0xLjg3MyA0LjcyNC01LjIzNiA0LjcyNC0zLjI5IDAtNi4zNjMtMS45ODgtNi44NjItNC41MjgtLjUzLTIuNjQgMS44NzMtNC43MzQgNS4yMzMtNC43MzQuNjcyIDAgMS4zNDcuMDg1IDIuMDE0LjI1LjIyNy4wNTcuNDM2LjExOC42MzYuMTg3em0tMTYuOTk2IDUuOTljLS4wMS0uMzE4LS4wOS0uODM4LS4yNjYtMS43MzctLjA5LS40Ni0uNTk1LTIuOTM3LS43NTMtMy43MjctLjM5LTEuOTYtLjc1LTMuODktMS4xMy02LjA3LS43MzItNC4yMjMtLjY5Mi02LjA1LjM0NC02LjUyNi41MDItLjIzIDEuMDYtLjA4MiAxLjg0LjM1LjQxNS4yMjcgMi4xODIgMS4zNjQgMi4wNyAxLjI5NSAxLjk5MyAxLjI0MiAzLjQ2MiAxLjc3NCA0LjkyNiAxLjU0OCAxLjUyNS0uMjQgMi41MDQtLjA2NCAyLjg3Ni42MTQuMzQ4LjYzNS4wMTUgMS40MTUtLjcyOCAyLjE4LTEuNDc0IDEuNTE3LTMuOTc3IDIuNTEzLTUuODQ3IDIuMDE3LS44Mi0uMjItMS4yMzYtLjQ2NC0yLjM3OC0xLjI2N2wtLjA5NS0uMDY1Yy4wNDcuNTkzLjI2NCAxLjc0LjcxNyAzLjgwMi4yOTQgMS4zMzcgMi4wNzggOS4xOSAyLjYzNiAxMS42NzVsLjAwMy4wMTNjLjUxNyAyLjYzOC0xLjg4NCA0LjczMi01LjIzNCA0LjczMi0zLjI4NyAwLTYuMzYtMS45OTMtNi44Ny00LjU0LS41Mi0yLjY0IDEuODg0LTQuNzMgNS4yNC00LjczLjkwNSAwIDEuODAzLjE1IDIuNjUuNDM2eiIvPjwvZz48L3N2Zz4=';
/**
 * Icon svg to be displayed in the category menu, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len

const menuIconURI = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTE2LjA5IDEyLjkzN2MuMjI4IDEuMTQxLS44MzMgMi4wNjMtMi4zNzMgMi4wNjMtMS41MzUgMC0yLjk2Mi0uOTIyLTMuMTg2LTIuMDYzLS4yMy0xLjE0Mi44MzMtMi4wNjggMi4zNzItMi4wNjguMzIzIDAgLjY0MS4wNDIuOTQ1LjExN2EzLjUgMy41IDAgMCAxIC40NjguMTUxYy40MzUtLjAxLS4wNTItMS4xNDctLjkxNy02LjExNC0xLjA2Ny02LjE1MiAxLjUzLS45MzUgNC4zODQtMS4zNzcgMi44NTQtLjQ0Mi4wMzggMi40MS0xLjgyNSAxLjkyMi0xLjg2Mi0uNDkzLTIuMzI1LTMuNTc3LjEzMiA3LjM3ek03LjQ2IDguNTYzYy0xLjg2Mi0uNDkzLTIuMzI1LTMuNTc2LjEzIDcuMzdDNy44MTYgMTcuMDczIDYuNzU0IDE4IDUuMjIgMThjLTEuNTM1IDAtMi45NjEtLjkyNi0zLjE5LTIuMDY4LS4yMjQtMS4xNDIuODM3LTIuMDY3IDIuMzc1LTIuMDY3LjUwMSAwIC45ODcuMDk4IDEuNDI3LjI3Mi40MTItLjAyOC0uMDc0LTEuMTg5LS45My02LjExNEMzLjgzNCAxLjg3IDYuNDMgNy4wODcgOS4yODIgNi42NDZjMi44NTQtLjQ0Ny4wMzggMi40MS0xLjgyMyAxLjkxN3oiIGZpbGw9IiM1NzVFNzUiIGZpbGwtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==';
/**
 * Class for the music-related blocks in Scratch 3.0
 * @param {Runtime} runtime - the runtime instantiating this block package.
 * @constructor
 */

class Scratch3MusicBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    /**
     * The number of drum and instrument sounds currently being played simultaneously.
     * @type {number}
     * @private
     */

    this._concurrencyCounter = 0;
    /**
     * An array of sound players, one for each drum sound.
     * @type {Array}
     * @private
     */

    this._drumPlayers = [];
    /**
     * An array of arrays of sound players. Each instrument has one or more audio players.
     * @type {Array[]}
     * @private
     */

    this._instrumentPlayerArrays = [];
    /**
     * An array of arrays of sound players. Each instrument mya have an audio player for each playable note.
     * @type {Array[]}
     * @private
     */

    this._instrumentPlayerNoteArrays = [];
    /**
     * An array of audio bufferSourceNodes. Each time you play an instrument or drum sound,
     * a bufferSourceNode is created. We keep references to them to make sure their onended
     * events can fire.
     * @type {Array}
     * @private
     */

    this._bufferSources = [];

    this._loadAllSounds();

    this._onTargetCreated = this._onTargetCreated.bind(this);
    this.runtime.on('targetWasCreated', this._onTargetCreated);
    this._playNoteForPicker = this._playNoteForPicker.bind(this);
    this.runtime.on('PLAY_NOTE', this._playNoteForPicker);
  }
  /**
   * Decode the full set of drum and instrument sounds, and store the audio buffers in arrays.
   */


  _loadAllSounds() {
    const loadingPromises = [];
    this.DRUM_INFO.forEach((drumInfo, index) => {
      const filePath = "drums/".concat(drumInfo.fileName);

      const promise = this._storeSound(filePath, index, this._drumPlayers);

      loadingPromises.push(promise);
    });
    this.INSTRUMENT_INFO.forEach((instrumentInfo, instrumentIndex) => {
      this._instrumentPlayerArrays[instrumentIndex] = [];
      this._instrumentPlayerNoteArrays[instrumentIndex] = [];
      instrumentInfo.samples.forEach((sample, noteIndex) => {
        const filePath = "instruments/".concat(instrumentInfo.dirName, "/").concat(sample);

        const promise = this._storeSound(filePath, noteIndex, this._instrumentPlayerArrays[instrumentIndex]);

        loadingPromises.push(promise);
      });
    });
    Promise.all(loadingPromises).then(() => {// @TODO: Update the extension status indicator.
    });
  }
  /**
   * Decode a sound and store the player in an array.
   * @param {string} filePath - the audio file name.
   * @param {number} index - the index at which to store the audio player.
   * @param {array} playerArray - the array of players in which to store it.
   * @return {Promise} - a promise which will resolve once the sound has been stored.
   */


  _storeSound(filePath, index, playerArray) {
    const fullPath = "".concat(filePath, ".mp3");
    if (!assetData[fullPath]) return;
    const soundFile = assetData[fullPath];
    return fetch(soundFile).then(r => r.arrayBuffer()).then(soundBuffer => this._decodeSound(soundBuffer)).then(player => {
      playerArray[index] = player;
    });
  }
  /**
   * Decode a sound and return a promise with the audio buffer.
   * @param  {ArrayBuffer} soundBuffer - a buffer containing the encoded audio.
   * @return {Promise} - a promise which will resolve once the sound has decoded.
   */


  _decodeSound(soundBuffer) {
    const engine = this.runtime.audioEngine;

    if (!engine) {
      return Promise.reject(new Error('No Audio Context Detected'));
    } // Check for newer promise-based API


    return engine.decodeSoundPlayer({
      data: {
        buffer: soundBuffer
      }
    });
  }
  /**
   * Create data for a menu in scratch-blocks format, consisting of an array of objects with text and
   * value properties. The text is a translated string, and the value is one-indexed.
   * @param  {object[]} info - An array of info objects each having a name property.
   * @return {array} - An array of objects with text and value properties.
   * @private
   */


  _buildMenu(info) {
    return info.map((entry, index) => {
      const obj = {};
      obj.text = entry.name;
      obj.value = String(index + 1);
      return obj;
    });
  }
  /**
   * An array of info about each drum.
   * @type {object[]}
   * @param {string} name - the translatable name to display in the drums menu.
   * @param {string} fileName - the name of the audio file containing the drum sound.
   */


  get DRUM_INFO() {
    return [{
      name: formatMessage({
        id: 'music.drumSnare',
        default: '(1) Snare Drum',
        description: 'Sound of snare drum as used in a standard drum kit'
      }),
      fileName: '1-snare'
    }, {
      name: formatMessage({
        id: 'music.drumBass',
        default: '(2) Bass Drum',
        description: 'Sound of bass drum as used in a standard drum kit'
      }),
      fileName: '2-bass-drum'
    }, {
      name: formatMessage({
        id: 'music.drumSideStick',
        default: '(3) Side Stick',
        description: 'Sound of a drum stick hitting the side of a drum (usually the snare)'
      }),
      fileName: '3-side-stick'
    }, {
      name: formatMessage({
        id: 'music.drumCrashCymbal',
        default: '(4) Crash Cymbal',
        description: 'Sound of a drum stick hitting a crash cymbal'
      }),
      fileName: '4-crash-cymbal'
    }, {
      name: formatMessage({
        id: 'music.drumOpenHiHat',
        default: '(5) Open Hi-Hat',
        description: 'Sound of a drum stick hitting a hi-hat while open'
      }),
      fileName: '5-open-hi-hat'
    }, {
      name: formatMessage({
        id: 'music.drumClosedHiHat',
        default: '(6) Closed Hi-Hat',
        description: 'Sound of a drum stick hitting a hi-hat while closed'
      }),
      fileName: '6-closed-hi-hat'
    }, {
      name: formatMessage({
        id: 'music.drumTambourine',
        default: '(7) Tambourine',
        description: 'Sound of a tambourine being struck'
      }),
      fileName: '7-tambourine'
    }, {
      name: formatMessage({
        id: 'music.drumHandClap',
        default: '(8) Hand Clap',
        description: 'Sound of two hands clapping together'
      }),
      fileName: '8-hand-clap'
    }, {
      name: formatMessage({
        id: 'music.drumClaves',
        default: '(9) Claves',
        description: 'Sound of claves being struck together'
      }),
      fileName: '9-claves'
    }, {
      name: formatMessage({
        id: 'music.drumWoodBlock',
        default: '(10) Wood Block',
        description: 'Sound of a wood block being struck'
      }),
      fileName: '10-wood-block'
    }, {
      name: formatMessage({
        id: 'music.drumCowbell',
        default: '(11) Cowbell',
        description: 'Sound of a cowbell being struck'
      }),
      fileName: '11-cowbell'
    }, {
      name: formatMessage({
        id: 'music.drumTriangle',
        default: '(12) Triangle',
        description: 'Sound of a triangle (instrument) being struck'
      }),
      fileName: '12-triangle'
    }, {
      name: formatMessage({
        id: 'music.drumBongo',
        default: '(13) Bongo',
        description: 'Sound of a bongo being struck'
      }),
      fileName: '13-bongo'
    }, {
      name: formatMessage({
        id: 'music.drumConga',
        default: '(14) Conga',
        description: 'Sound of a conga being struck'
      }),
      fileName: '14-conga'
    }, {
      name: formatMessage({
        id: 'music.drumCabasa',
        default: '(15) Cabasa',
        description: 'Sound of a cabasa being shaken'
      }),
      fileName: '15-cabasa'
    }, {
      name: formatMessage({
        id: 'music.drumGuiro',
        default: '(16) Guiro',
        description: 'Sound of a guiro being played'
      }),
      fileName: '16-guiro'
    }, {
      name: formatMessage({
        id: 'music.drumVibraslap',
        default: '(17) Vibraslap',
        description: 'Sound of a Vibraslap being played'
      }),
      fileName: '17-vibraslap'
    }, {
      name: formatMessage({
        id: 'music.drumCuica',
        default: '(18) Cuica',
        description: 'Sound of a cuica being played'
      }),
      fileName: '18-cuica'
    }];
  }
  /**
   * An array of info about each instrument.
   * @type {object[]}
   * @param {string} name - the translatable name to display in the instruments menu.
   * @param {string} dirName - the name of the directory containing audio samples for this instrument.
   * @param {number} [releaseTime] - an optional duration for the release portion of each note.
   * @param {number[]} samples - an array of numbers representing the MIDI note number for each
   *                           sampled sound used to play this instrument.
   */


  get INSTRUMENT_INFO() {
    return [{
      name: formatMessage({
        id: 'music.instrumentPiano',
        default: '(1) Piano',
        description: 'Sound of a piano'
      }),
      dirName: '1-piano',
      releaseTime: 0.5,
      samples: [24, 36, 48, 60, 72, 84, 96, 108]
    }, {
      name: formatMessage({
        id: 'music.instrumentElectricPiano',
        default: '(2) Electric Piano',
        description: 'Sound of an electric piano'
      }),
      dirName: '2-electric-piano',
      releaseTime: 0.5,
      samples: [60]
    }, {
      name: formatMessage({
        id: 'music.instrumentOrgan',
        default: '(3) Organ',
        description: 'Sound of an organ'
      }),
      dirName: '3-organ',
      releaseTime: 0.5,
      samples: [60]
    }, {
      name: formatMessage({
        id: 'music.instrumentGuitar',
        default: '(4) Guitar',
        description: 'Sound of an accoustic guitar'
      }),
      dirName: '4-guitar',
      releaseTime: 0.5,
      samples: [60]
    }, {
      name: formatMessage({
        id: 'music.instrumentElectricGuitar',
        default: '(5) Electric Guitar',
        description: 'Sound of an electric guitar'
      }),
      dirName: '5-electric-guitar',
      releaseTime: 0.5,
      samples: [60]
    }, {
      name: formatMessage({
        id: 'music.instrumentBass',
        default: '(6) Bass',
        description: 'Sound of an accoustic upright bass'
      }),
      dirName: '6-bass',
      releaseTime: 0.25,
      samples: [36, 48]
    }, {
      name: formatMessage({
        id: 'music.instrumentPizzicato',
        default: '(7) Pizzicato',
        description: 'Sound of a string instrument (e.g. violin) being plucked'
      }),
      dirName: '7-pizzicato',
      releaseTime: 0.25,
      samples: [60]
    }, {
      name: formatMessage({
        id: 'music.instrumentCello',
        default: '(8) Cello',
        description: 'Sound of a cello being played with a bow'
      }),
      dirName: '8-cello',
      releaseTime: 0.1,
      samples: [36, 48, 60]
    }, {
      name: formatMessage({
        id: 'music.instrumentTrombone',
        default: '(9) Trombone',
        description: 'Sound of a trombone being played'
      }),
      dirName: '9-trombone',
      samples: [36, 48, 60]
    }, {
      name: formatMessage({
        id: 'music.instrumentClarinet',
        default: '(10) Clarinet',
        description: 'Sound of a clarinet being played'
      }),
      dirName: '10-clarinet',
      samples: [48, 60]
    }, {
      name: formatMessage({
        id: 'music.instrumentSaxophone',
        default: '(11) Saxophone',
        description: 'Sound of a saxophone being played'
      }),
      dirName: '11-saxophone',
      samples: [36, 60, 84]
    }, {
      name: formatMessage({
        id: 'music.instrumentFlute',
        default: '(12) Flute',
        description: 'Sound of a flute being played'
      }),
      dirName: '12-flute',
      samples: [60, 72]
    }, {
      name: formatMessage({
        id: 'music.instrumentWoodenFlute',
        default: '(13) Wooden Flute',
        description: 'Sound of a wooden flute being played'
      }),
      dirName: '13-wooden-flute',
      samples: [60, 72]
    }, {
      name: formatMessage({
        id: 'music.instrumentBassoon',
        default: '(14) Bassoon',
        description: 'Sound of a bassoon being played'
      }),
      dirName: '14-bassoon',
      samples: [36, 48, 60]
    }, {
      name: formatMessage({
        id: 'music.instrumentChoir',
        default: '(15) Choir',
        description: 'Sound of a choir singing'
      }),
      dirName: '15-choir',
      releaseTime: 0.25,
      samples: [48, 60, 72]
    }, {
      name: formatMessage({
        id: 'music.instrumentVibraphone',
        default: '(16) Vibraphone',
        description: 'Sound of a vibraphone being struck'
      }),
      dirName: '16-vibraphone',
      releaseTime: 0.5,
      samples: [60, 72]
    }, {
      name: formatMessage({
        id: 'music.instrumentMusicBox',
        default: '(17) Music Box',
        description: 'Sound of a music box playing'
      }),
      dirName: '17-music-box',
      releaseTime: 0.25,
      samples: [60]
    }, {
      name: formatMessage({
        id: 'music.instrumentSteelDrum',
        default: '(18) Steel Drum',
        description: 'Sound of a steel drum being struck'
      }),
      dirName: '18-steel-drum',
      releaseTime: 0.5,
      samples: [60]
    }, {
      name: formatMessage({
        id: 'music.instrumentMarimba',
        default: '(19) Marimba',
        description: 'Sound of a marimba being struck'
      }),
      dirName: '19-marimba',
      samples: [60]
    }, {
      name: formatMessage({
        id: 'music.instrumentSynthLead',
        default: '(20) Synth Lead',
        description: 'Sound of a "lead" synthesizer being played'
      }),
      dirName: '20-synth-lead',
      releaseTime: 0.1,
      samples: [60]
    }, {
      name: formatMessage({
        id: 'music.instrumentSynthPad',
        default: '(21) Synth Pad',
        description: 'Sound of a "pad" synthesizer being played'
      }),
      dirName: '21-synth-pad',
      releaseTime: 0.25,
      samples: [60]
    }];
  }
  /**
   * An array that is a mapping from MIDI instrument numbers to Scratch instrument numbers.
   * @type {number[]}
   */


  get MIDI_INSTRUMENTS() {
    return [// Acoustic Grand, Bright Acoustic, Electric Grand, Honky-Tonk
    1, 1, 1, 1, // Electric Piano 1, Electric Piano 2, Harpsichord, Clavinet
    2, 2, 4, 4, // Celesta, Glockenspiel, Music Box, Vibraphone
    17, 17, 17, 16, // Marimba, Xylophone, Tubular Bells, Dulcimer
    19, 16, 17, 17, // Drawbar Organ, Percussive Organ, Rock Organ, Church Organ
    3, 3, 3, 3, // Reed Organ, Accordion, Harmonica, Tango Accordion
    3, 3, 3, 3, // Nylon String Guitar, Steel String Guitar, Electric Jazz Guitar, Electric Clean Guitar
    4, 4, 5, 5, // Electric Muted Guitar, Overdriven Guitar,Distortion Guitar, Guitar Harmonics
    5, 5, 5, 5, // Acoustic Bass, Electric Bass (finger), Electric Bass (pick), Fretless Bass
    6, 6, 6, 6, // Slap Bass 1, Slap Bass 2, Synth Bass 1, Synth Bass 2
    6, 6, 6, 6, // Violin, Viola, Cello, Contrabass
    8, 8, 8, 8, // Tremolo Strings, Pizzicato Strings, Orchestral Strings, Timpani
    8, 7, 8, 19, // String Ensemble 1, String Ensemble 2, SynthStrings 1, SynthStrings 2
    8, 8, 8, 8, // Choir Aahs, Voice Oohs, Synth Voice, Orchestra Hit
    15, 15, 15, 19, // Trumpet, Trombone, Tuba, Muted Trumpet
    9, 9, 9, 9, // French Horn, Brass Section, SynthBrass 1, SynthBrass 2
    9, 9, 9, 9, // Soprano Sax, Alto Sax, Tenor Sax, Baritone Sax
    11, 11, 11, 11, // Oboe, English Horn, Bassoon, Clarinet
    14, 14, 14, 10, // Piccolo, Flute, Recorder, Pan Flute
    12, 12, 13, 13, // Blown Bottle, Shakuhachi, Whistle, Ocarina
    13, 13, 12, 12, // Lead 1 (square), Lead 2 (sawtooth), Lead 3 (calliope), Lead 4 (chiff)
    20, 20, 20, 20, // Lead 5 (charang), Lead 6 (voice), Lead 7 (fifths), Lead 8 (bass+lead)
    20, 20, 20, 20, // Pad 1 (new age), Pad 2 (warm), Pad 3 (polysynth), Pad 4 (choir)
    21, 21, 21, 21, // Pad 5 (bowed), Pad 6 (metallic), Pad 7 (halo), Pad 8 (sweep)
    21, 21, 21, 21, // FX 1 (rain), FX 2 (soundtrack), FX 3 (crystal), FX 4 (atmosphere)
    21, 21, 21, 21, // FX 5 (brightness), FX 6 (goblins), FX 7 (echoes), FX 8 (sci-fi)
    21, 21, 21, 21, // Sitar, Banjo, Shamisen, Koto
    4, 4, 4, 4, // Kalimba, Bagpipe, Fiddle, Shanai
    17, 14, 8, 10, // Tinkle Bell, Agogo, Steel Drums, Woodblock
    17, 17, 18, 19, // Taiko Drum, Melodic Tom, Synth Drum, Reverse Cymbal
    1, 1, 1, 1, // Guitar Fret Noise, Breath Noise, Seashore, Bird Tweet
    21, 21, 21, 21, // Telephone Ring, Helicopter, Applause, Gunshot
    21, 21, 21, 21];
  }
  /**
   * An array that is a mapping from MIDI drum numbers in range (35..81) to Scratch drum numbers.
   * It's in the format [drumNum, pitch, decay].
   * The pitch and decay properties are not currently being used.
   * @type {Array[]}
   */


  get MIDI_DRUMS() {
    return [[1, -4], // "BassDrum" in 2.0, "Bass Drum" in 3.0 (which was "Tom" in 2.0)
    [1, 0], // Same as just above
    [2, 0], [0, 0], [7, 0], [0, 2], [1, -6, 4], [5, 0], [1, -3, 3.2], [5, 0], // "HiHatPedal" in 2.0, "Closed Hi-Hat" in 3.0
    [1, 0, 3], [4, -8], [1, 4, 3], [1, 7, 2.7], [3, -8], [1, 10, 2.7], [4, -2], [3, -11], [4, 2], [6, 0], [3, 0, 3.5], [10, 0], [3, -8, 3.5], [16, -6], [4, 2], [12, 2], [12, 0], [13, 0, 0.2], [13, 0, 2], [13, -5, 2], [12, 12], [12, 5], [10, 19], [10, 12], [14, 0], [14, 0], // "Maracas" in 2.0, "Cabasa" in 3.0 (TODO: pitch up?)
    [17, 12], [17, 5], [15, 0], // "GuiroShort" in 2.0, "Guiro" in 3.0 (which was "GuiroLong" in 2.0) (TODO: decay?)
    [15, 0], [8, 0], [9, 0], [9, -4], [17, -5], [17, 0], [11, -6, 1], [11, -6, 3]];
  }
  /**
   * The key to load & store a target's music-related state.
   * @type {string}
   */


  static get STATE_KEY() {
    return 'Scratch.music';
  }
  /**
   * The default music-related state, to be used when a target has no existing music state.
   * @type {MusicState}
   */


  static get DEFAULT_MUSIC_STATE() {
    return {
      currentInstrument: 0
    };
  }
  /**
   * The minimum and maximum MIDI note numbers, for clamping the input to play note.
   * @type {{min: number, max: number}}
   */


  static get MIDI_NOTE_RANGE() {
    return {
      min: 0,
      max: 130
    };
  }
  /**
   * The minimum and maximum beat values, for clamping the duration of play note, play drum and rest.
   * 100 beats at the default tempo of 60bpm is 100 seconds.
   * @type {{min: number, max: number}}
   */


  static get BEAT_RANGE() {
    return {
      min: 0,
      max: 100
    };
  }
  /** The minimum and maximum tempo values, in bpm.
   * @type {{min: number, max: number}}
   */


  static get TEMPO_RANGE() {
    return {
      min: 20,
      max: 500
    };
  }
  /**
   * The maximum number of sounds to allow to play simultaneously.
   * @type {number}
   */


  static get CONCURRENCY_LIMIT() {
    return 30;
  }
  /**
   * @param {Target} target - collect music state for this target.
   * @returns {MusicState} the mutable music state associated with that target. This will be created if necessary.
   * @private
   */


  _getMusicState(target) {
    let musicState = target.getCustomState(Scratch3MusicBlocks.STATE_KEY);

    if (!musicState) {
      musicState = Clone.simple(Scratch3MusicBlocks.DEFAULT_MUSIC_STATE);
      target.setCustomState(Scratch3MusicBlocks.STATE_KEY, musicState);
    }

    return musicState;
  }
  /**
   * When a music-playing Target is cloned, clone the music state.
   * @param {Target} newTarget - the newly created target.
   * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
   * @listens Runtime#event:targetWasCreated
   * @private
   */


  _onTargetCreated(newTarget, sourceTarget) {
    if (sourceTarget) {
      const musicState = sourceTarget.getCustomState(Scratch3MusicBlocks.STATE_KEY);

      if (musicState) {
        newTarget.setCustomState(Scratch3MusicBlocks.STATE_KEY, Clone.simple(musicState));
      }
    }
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: 'music',
      name: formatMessage({
        id: 'music.categoryName',
        default: 'Music',
        description: 'Label for the Music extension category'
      }),
      menuIconURI: menuIconURI,
      blockIconURI: blockIconURI,
      blocks: [{
        opcode: 'playDrumForBeats',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'music.playDrumForBeats',
          default: 'play drum [DRUM] for [BEATS] beats',
          description: 'play drum sample for a number of beats'
        }),
        arguments: {
          DRUM: {
            type: ArgumentType.NUMBER,
            menu: 'DRUM',
            defaultValue: 1
          },
          BEATS: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.25
          }
        }
      }, {
        opcode: 'midiPlayDrumForBeats',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'music.midiPlayDrumForBeats',
          default: 'play drum [DRUM] for [BEATS] beats',
          description: 'play drum sample for a number of beats according to a mapping of MIDI codes'
        }),
        arguments: {
          DRUM: {
            type: ArgumentType.NUMBER,
            menu: 'DRUM',
            defaultValue: 1
          },
          BEATS: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.25
          }
        },
        hideFromPalette: true
      }, {
        opcode: 'restForBeats',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'music.restForBeats',
          default: 'rest for [BEATS] beats',
          description: 'rest (play no sound) for a number of beats'
        }),
        arguments: {
          BEATS: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.25
          }
        }
      }, {
        opcode: 'playNoteForBeats',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'music.playNoteForBeats',
          default: 'play note [NOTE] for [BEATS] beats',
          description: 'play a note for a number of beats'
        }),
        arguments: {
          NOTE: {
            type: ArgumentType.NOTE,
            defaultValue: 60
          },
          BEATS: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.25
          }
        }
      }, {
        opcode: 'setInstrument',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'music.setInstrument',
          default: 'set instrument to [INSTRUMENT]',
          description: 'set the instrument (e.g. piano, guitar, trombone) for notes played'
        }),
        arguments: {
          INSTRUMENT: {
            type: ArgumentType.NUMBER,
            menu: 'INSTRUMENT',
            defaultValue: 1
          }
        }
      }, {
        opcode: 'midiSetInstrument',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'music.midiSetInstrument',
          default: 'set instrument to [INSTRUMENT]',
          description: 'set the instrument for notes played according to a mapping of MIDI codes'
        }),
        arguments: {
          INSTRUMENT: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        hideFromPalette: true
      }, {
        opcode: 'setTempo',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'music.setTempo',
          default: 'set tempo to [TEMPO]',
          description: 'set tempo (speed) for notes, drums, and rests played'
        }),
        arguments: {
          TEMPO: {
            type: ArgumentType.NUMBER,
            defaultValue: 60
          }
        }
      }, {
        opcode: 'changeTempo',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'music.changeTempo',
          default: 'change tempo by [TEMPO]',
          description: 'change tempo (speed) for notes, drums, and rests played'
        }),
        arguments: {
          TEMPO: {
            type: ArgumentType.NUMBER,
            defaultValue: 20
          }
        }
      }, {
        opcode: 'getTempo',
        text: formatMessage({
          id: 'music.getTempo',
          default: 'tempo',
          description: 'get the current tempo (speed) for notes, drums, and rests played'
        }),
        blockType: BlockType.REPORTER
      }],
      menus: {
        DRUM: {
          acceptReporters: true,
          items: this._buildMenu(this.DRUM_INFO)
        },
        INSTRUMENT: {
          acceptReporters: true,
          items: this._buildMenu(this.INSTRUMENT_INFO)
        }
      }
    };
  }
  /**
   * Play a drum sound for some number of beats.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {int} DRUM - the number of the drum to play.
   * @property {number} BEATS - the duration in beats of the drum sound.
   */


  playDrumForBeats(args, util) {
    this._playDrumForBeats(args.DRUM, args.BEATS, util);
  }
  /**
   * Play a drum sound for some number of beats according to the range of "MIDI" drum codes supported.
   * This block is implemented for compatibility with old Scratch projects that use the
   * 'drum:duration:elapsed:from:' block.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   */


  midiPlayDrumForBeats(args, util) {
    let drumNum = Cast.toNumber(args.DRUM);
    drumNum = Math.round(drumNum);
    const midiDescription = this.MIDI_DRUMS[drumNum - 35];

    if (midiDescription) {
      drumNum = midiDescription[0];
    } else {
      drumNum = 2; // Default instrument used in Scratch 2.0
    }

    drumNum += 1; // drumNum input to _playDrumForBeats is one-indexed

    this._playDrumForBeats(drumNum, args.BEATS, util);
  }
  /**
   * Internal code to play a drum sound for some number of beats.
   * @param {number} drumNum - the drum number.
   * @param {beats} beats - the duration in beats to pause after playing the sound.
   * @param {object} util - utility object provided by the runtime.
   */


  _playDrumForBeats(drumNum, beats, util) {
    if (this._stackTimerNeedsInit(util)) {
      drumNum = Cast.toNumber(drumNum);
      drumNum = Math.round(drumNum);
      drumNum -= 1; // drums are one-indexed

      drumNum = MathUtil.wrapClamp(drumNum, 0, this.DRUM_INFO.length - 1);
      beats = Cast.toNumber(beats);
      beats = this._clampBeats(beats);

      this._playDrumNum(util, drumNum);

      this._startStackTimer(util, this._beatsToSec(beats));
    } else {
      this._checkStackTimer(util);
    }
  }
  /**
   * Play a drum sound using its 0-indexed number.
   * @param {object} util - utility object provided by the runtime.
   * @param {number} drumNum - the number of the drum to play.
   * @private
   */


  _playDrumNum(util, drumNum) {
    if (util.runtime.audioEngine === null) return;
    if (util.target.sprite.soundBank === null) return; // If we're playing too many sounds, do not play the drum sound.

    if (this._concurrencyCounter > Scratch3MusicBlocks.CONCURRENCY_LIMIT) {
      return;
    }

    const player = this._drumPlayers[drumNum];
    if (typeof player === 'undefined') return;

    if (player.isPlaying && !player.isStarting) {
      // Take the internal player state and create a new player with it.
      // `.play` does this internally but then instructs the sound to
      // stop.
      player.take();
    }

    const engine = util.runtime.audioEngine;
    const context = engine.audioContext;
    const volumeGain = context.createGain();
    volumeGain.gain.setValueAtTime(util.target.volume / 100, engine.currentTime);
    volumeGain.connect(engine.getInputNode());
    this._concurrencyCounter++;
    player.once('stop', () => {
      this._concurrencyCounter--;
    });
    player.play(); // Connect the player to the gain node.

    player.connect({
      getInputNode() {
        return volumeGain;
      }

    });
  }
  /**
   * Rest for some number of beats.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {number} BEATS - the duration in beats of the rest.
   */


  restForBeats(args, util) {
    if (this._stackTimerNeedsInit(util)) {
      let beats = Cast.toNumber(args.BEATS);
      beats = this._clampBeats(beats);

      this._startStackTimer(util, this._beatsToSec(beats));
    } else {
      this._checkStackTimer(util);
    }
  }
  /**
   * Play a note using the current musical instrument for some number of beats.
   * This function processes the arguments, and handles the timing of the block's execution.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {number} NOTE - the pitch of the note to play, interpreted as a MIDI note number.
   * @property {number} BEATS - the duration in beats of the note.
   */


  playNoteForBeats(args, util) {
    if (this._stackTimerNeedsInit(util)) {
      let note = Cast.toNumber(args.NOTE);
      note = MathUtil.clamp(note, Scratch3MusicBlocks.MIDI_NOTE_RANGE.min, Scratch3MusicBlocks.MIDI_NOTE_RANGE.max);
      let beats = Cast.toNumber(args.BEATS);
      beats = this._clampBeats(beats); // If the duration is 0, do not play the note. In Scratch 2.0, "play drum for 0 beats" plays the drum,
      // but "play note for 0 beats" is silent.

      if (beats === 0) return;

      const durationSec = this._beatsToSec(beats);

      this._playNote(util, note, durationSec);

      this._startStackTimer(util, durationSec);
    } else {
      this._checkStackTimer(util);
    }
  }

  _playNoteForPicker(noteNum, category) {
    if (category !== this.getInfo().name) return;
    const util = {
      runtime: this.runtime,
      target: this.runtime.getEditingTarget()
    };

    this._playNote(util, noteNum, 0.25);
  }
  /**
   * Play a note using the current instrument for a duration in seconds.
   * This function actually plays the sound, and handles the timing of the sound, including the
   * "release" portion of the sound, which continues briefly after the block execution has finished.
   * @param {object} util - utility object provided by the runtime.
   * @param {number} note - the pitch of the note to play, interpreted as a MIDI note number.
   * @param {number} durationSec - the duration in seconds to play the note.
   * @private
   */


  _playNote(util, note, durationSec) {
    if (util.runtime.audioEngine === null) return;
    if (util.target.sprite.soundBank === null) return; // If we're playing too many sounds, do not play the note.

    if (this._concurrencyCounter > Scratch3MusicBlocks.CONCURRENCY_LIMIT) {
      return;
    } // Determine which of the audio samples for this instrument to play


    const musicState = this._getMusicState(util.target);

    const inst = musicState.currentInstrument;
    const instrumentInfo = this.INSTRUMENT_INFO[inst];
    const sampleArray = instrumentInfo.samples;

    const sampleIndex = this._selectSampleIndexForNote(note, sampleArray); // If the audio sample has not loaded yet, bail out


    if (typeof this._instrumentPlayerArrays[inst] === 'undefined') return;
    if (typeof this._instrumentPlayerArrays[inst][sampleIndex] === 'undefined') return; // Fetch the sound player to play the note.

    const engine = util.runtime.audioEngine;

    if (!this._instrumentPlayerNoteArrays[inst][note]) {
      this._instrumentPlayerNoteArrays[inst][note] = this._instrumentPlayerArrays[inst][sampleIndex].take();
    }

    const player = this._instrumentPlayerNoteArrays[inst][note];

    if (player.isPlaying && !player.isStarting) {
      // Take the internal player state and create a new player with it.
      // `.play` does this internally but then instructs the sound to
      // stop.
      player.take();
    } // Set its pitch.


    const sampleNote = sampleArray[sampleIndex];

    const notePitchInterval = this._ratioForPitchInterval(note - sampleNote); // Create gain nodes for this note's volume and release, and chain them
    // to the output.


    const context = engine.audioContext;
    const volumeGain = context.createGain();
    volumeGain.gain.setValueAtTime(util.target.volume / 100, engine.currentTime);
    const releaseGain = context.createGain();
    volumeGain.connect(releaseGain);
    releaseGain.connect(engine.getInputNode()); // Schedule the release of the note, ramping its gain down to zero,
    // and then stopping the sound.

    let releaseDuration = this.INSTRUMENT_INFO[inst].releaseTime;

    if (typeof releaseDuration === 'undefined') {
      releaseDuration = 0.01;
    }

    const releaseStart = context.currentTime + durationSec;
    const releaseEnd = releaseStart + releaseDuration;
    releaseGain.gain.setValueAtTime(1, releaseStart);
    releaseGain.gain.linearRampToValueAtTime(0.0001, releaseEnd);
    this._concurrencyCounter++;
    player.once('stop', () => {
      this._concurrencyCounter--;
    }); // Start playing the note

    player.play(); // Connect the player to the gain node.

    player.connect({
      getInputNode() {
        return volumeGain;
      }

    }); // Set playback now after play creates the outputNode.

    player.outputNode.playbackRate.value = notePitchInterval; // Schedule playback to stop.

    player.outputNode.stop(releaseEnd);
  }
  /**
   * The samples array for each instrument is the set of pitches of the available audio samples.
   * This function selects the best one to use to play a given input note, and returns its index
   * in the samples array.
   * @param  {number} note - the input note to select a sample for.
   * @param  {number[]} samples - an array of the pitches of the available samples.
   * @return {index} the index of the selected sample in the samples array.
   * @private
   */


  _selectSampleIndexForNote(note, samples) {
    // Step backwards through the array of samples, i.e. in descending pitch, in order to find
    // the sample that is the closest one below (or matching) the pitch of the input note.
    for (let i = samples.length - 1; i >= 0; i--) {
      if (note >= samples[i]) {
        return i;
      }
    }

    return 0;
  }
  /**
   * Calcuate the frequency ratio for a given musical interval.
   * @param  {number} interval - the pitch interval to convert.
   * @return {number} a ratio corresponding to the input interval.
   * @private
   */


  _ratioForPitchInterval(interval) {
    return Math.pow(2, interval / 12);
  }
  /**
   * Clamp a duration in beats to the allowed min and max duration.
   * @param  {number} beats - a duration in beats.
   * @return {number} - the clamped duration.
   * @private
   */


  _clampBeats(beats) {
    return MathUtil.clamp(beats, Scratch3MusicBlocks.BEAT_RANGE.min, Scratch3MusicBlocks.BEAT_RANGE.max);
  }
  /**
   * Convert a number of beats to a number of seconds, using the current tempo.
   * @param  {number} beats - number of beats to convert to secs.
   * @return {number} seconds - number of seconds `beats` will last.
   * @private
   */


  _beatsToSec(beats) {
    return 60 / this.getTempo() * beats;
  }
  /**
   * Check if the stack timer needs initialization.
   * @param {object} util - utility object provided by the runtime.
   * @return {boolean} - true if the stack timer needs to be initialized.
   * @private
   */


  _stackTimerNeedsInit(util) {
    return !util.stackFrame.timer;
  }
  /**
   * Start the stack timer and the yield the thread if necessary.
   * @param {object} util - utility object provided by the runtime.
   * @param {number} duration - a duration in seconds to set the timer for.
   * @private
   */


  _startStackTimer(util, duration) {
    util.stackFrame.timer = new Timer();
    util.stackFrame.timer.start();
    util.stackFrame.duration = duration;
    util.yield();
  }
  /**
   * Check the stack timer, and if its time is not up yet, yield the thread.
   * @param {object} util - utility object provided by the runtime.
   * @private
   */


  _checkStackTimer(util) {
    const timeElapsed = util.stackFrame.timer.timeElapsed();

    if (timeElapsed < util.stackFrame.duration * 1000) {
      util.yield();
    }
  }
  /**
   * Select an instrument for playing notes.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {int} INSTRUMENT - the number of the instrument to select.
   */


  setInstrument(args, util) {
    this._setInstrument(args.INSTRUMENT, util, false);
  }
  /**
   * Select an instrument for playing notes according to a mapping of MIDI codes to Scratch instrument numbers.
   * This block is implemented for compatibility with old Scratch projects that use the 'midiInstrument:' block.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   * @property {int} INSTRUMENT - the MIDI number of the instrument to select.
   */


  midiSetInstrument(args, util) {
    this._setInstrument(args.INSTRUMENT, util, true);
  }
  /**
   * Internal code to select an instrument for playing notes. If mapMidi is true, set the instrument according to
   * the MIDI to Scratch instrument mapping.
   * @param {number} instNum - the instrument number.
   * @param {object} util - utility object provided by the runtime.
   * @param {boolean} mapMidi - whether or not instNum is a MIDI instrument number.
   */


  _setInstrument(instNum, util, mapMidi) {
    const musicState = this._getMusicState(util.target);

    instNum = Cast.toNumber(instNum);
    instNum = Math.round(instNum);
    instNum -= 1; // instruments are one-indexed

    if (mapMidi) {
      instNum = (this.MIDI_INSTRUMENTS[instNum] || 0) - 1;
    }

    instNum = MathUtil.wrapClamp(instNum, 0, this.INSTRUMENT_INFO.length - 1);
    musicState.currentInstrument = instNum;
  }
  /**
   * Set the current tempo to a new value.
   * @param {object} args - the block arguments.
   * @property {number} TEMPO - the tempo, in beats per minute.
   */


  setTempo(args) {
    const tempo = Cast.toNumber(args.TEMPO);

    this._updateTempo(tempo);
  }
  /**
   * Change the current tempo by some amount.
   * @param {object} args - the block arguments.
   * @property {number} TEMPO - the amount to change the tempo, in beats per minute.
   */


  changeTempo(args) {
    const change = Cast.toNumber(args.TEMPO);
    const tempo = change + this.getTempo();

    this._updateTempo(tempo);
  }
  /**
   * Update the current tempo, clamping it to the min and max allowable range.
   * @param {number} tempo - the tempo to set, in beats per minute.
   * @private
   */


  _updateTempo(tempo) {
    tempo = MathUtil.clamp(tempo, Scratch3MusicBlocks.TEMPO_RANGE.min, Scratch3MusicBlocks.TEMPO_RANGE.max);
    const stage = this.runtime.getTargetForStage();

    if (stage) {
      stage.tempo = tempo;
    }
  }
  /**
   * Get the current tempo.
   * @return {number} - the current tempo, in beats per minute.
   */


  getTempo() {
    const stage = this.runtime.getTargetForStage();

    if (stage) {
      return stage.tempo;
    }

    return 60;
  }

}

module.exports = Scratch3MusicBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_music/manifest.js":
/*!***************************************************!*\
  !*** ./src/extensions/scratch3_music/manifest.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  'drums/1-snare.mp3': __webpack_require__(/*! ./assets/drums/1-snare.mp3 */ "./src/extensions/scratch3_music/assets/drums/1-snare.mp3"),
  'drums/2-bass-drum.mp3': __webpack_require__(/*! ./assets/drums/2-bass-drum.mp3 */ "./src/extensions/scratch3_music/assets/drums/2-bass-drum.mp3"),
  'drums/3-side-stick.mp3': __webpack_require__(/*! ./assets/drums/3-side-stick.mp3 */ "./src/extensions/scratch3_music/assets/drums/3-side-stick.mp3"),
  'drums/4-crash-cymbal.mp3': __webpack_require__(/*! ./assets/drums/4-crash-cymbal.mp3 */ "./src/extensions/scratch3_music/assets/drums/4-crash-cymbal.mp3"),
  'drums/5-open-hi-hat.mp3': __webpack_require__(/*! ./assets/drums/5-open-hi-hat.mp3 */ "./src/extensions/scratch3_music/assets/drums/5-open-hi-hat.mp3"),
  'drums/6-closed-hi-hat.mp3': __webpack_require__(/*! ./assets/drums/6-closed-hi-hat.mp3 */ "./src/extensions/scratch3_music/assets/drums/6-closed-hi-hat.mp3"),
  'drums/7-tambourine.mp3': __webpack_require__(/*! ./assets/drums/7-tambourine.mp3 */ "./src/extensions/scratch3_music/assets/drums/7-tambourine.mp3"),
  'drums/8-hand-clap.mp3': __webpack_require__(/*! ./assets/drums/8-hand-clap.mp3 */ "./src/extensions/scratch3_music/assets/drums/8-hand-clap.mp3"),
  'drums/9-claves.mp3': __webpack_require__(/*! ./assets/drums/9-claves.mp3 */ "./src/extensions/scratch3_music/assets/drums/9-claves.mp3"),
  'drums/10-wood-block.mp3': __webpack_require__(/*! ./assets/drums/10-wood-block.mp3 */ "./src/extensions/scratch3_music/assets/drums/10-wood-block.mp3"),
  'drums/11-cowbell.mp3': __webpack_require__(/*! ./assets/drums/11-cowbell.mp3 */ "./src/extensions/scratch3_music/assets/drums/11-cowbell.mp3"),
  'drums/12-triangle.mp3': __webpack_require__(/*! ./assets/drums/12-triangle.mp3 */ "./src/extensions/scratch3_music/assets/drums/12-triangle.mp3"),
  'drums/13-bongo.mp3': __webpack_require__(/*! ./assets/drums/13-bongo.mp3 */ "./src/extensions/scratch3_music/assets/drums/13-bongo.mp3"),
  'drums/14-conga.mp3': __webpack_require__(/*! ./assets/drums/14-conga.mp3 */ "./src/extensions/scratch3_music/assets/drums/14-conga.mp3"),
  'drums/15-cabasa.mp3': __webpack_require__(/*! ./assets/drums/15-cabasa.mp3 */ "./src/extensions/scratch3_music/assets/drums/15-cabasa.mp3"),
  'drums/16-guiro.mp3': __webpack_require__(/*! ./assets/drums/16-guiro.mp3 */ "./src/extensions/scratch3_music/assets/drums/16-guiro.mp3"),
  'drums/17-vibraslap.mp3': __webpack_require__(/*! ./assets/drums/17-vibraslap.mp3 */ "./src/extensions/scratch3_music/assets/drums/17-vibraslap.mp3"),
  'drums/18-cuica.mp3': __webpack_require__(/*! ./assets/drums/18-cuica.mp3 */ "./src/extensions/scratch3_music/assets/drums/18-cuica.mp3"),
  'instruments/1-piano/24.mp3': __webpack_require__(/*! ./assets/instruments/1-piano/24.mp3 */ "./src/extensions/scratch3_music/assets/instruments/1-piano/24.mp3"),
  'instruments/1-piano/36.mp3': __webpack_require__(/*! ./assets/instruments/1-piano/36.mp3 */ "./src/extensions/scratch3_music/assets/instruments/1-piano/36.mp3"),
  'instruments/1-piano/48.mp3': __webpack_require__(/*! ./assets/instruments/1-piano/48.mp3 */ "./src/extensions/scratch3_music/assets/instruments/1-piano/48.mp3"),
  'instruments/1-piano/60.mp3': __webpack_require__(/*! ./assets/instruments/1-piano/60.mp3 */ "./src/extensions/scratch3_music/assets/instruments/1-piano/60.mp3"),
  'instruments/1-piano/72.mp3': __webpack_require__(/*! ./assets/instruments/1-piano/72.mp3 */ "./src/extensions/scratch3_music/assets/instruments/1-piano/72.mp3"),
  'instruments/1-piano/84.mp3': __webpack_require__(/*! ./assets/instruments/1-piano/84.mp3 */ "./src/extensions/scratch3_music/assets/instruments/1-piano/84.mp3"),
  'instruments/1-piano/96.mp3': __webpack_require__(/*! ./assets/instruments/1-piano/96.mp3 */ "./src/extensions/scratch3_music/assets/instruments/1-piano/96.mp3"),
  'instruments/1-piano/108.mp3': __webpack_require__(/*! ./assets/instruments/1-piano/108.mp3 */ "./src/extensions/scratch3_music/assets/instruments/1-piano/108.mp3"),
  'instruments/2-electric-piano/60.mp3': __webpack_require__(/*! ./assets/instruments/2-electric-piano/60.mp3 */ "./src/extensions/scratch3_music/assets/instruments/2-electric-piano/60.mp3"),
  'instruments/3-organ/60.mp3': __webpack_require__(/*! ./assets/instruments/3-organ/60.mp3 */ "./src/extensions/scratch3_music/assets/instruments/3-organ/60.mp3"),
  'instruments/4-guitar/60.mp3': __webpack_require__(/*! ./assets/instruments/4-guitar/60.mp3 */ "./src/extensions/scratch3_music/assets/instruments/4-guitar/60.mp3"),
  'instruments/5-electric-guitar/60.mp3': __webpack_require__(/*! ./assets/instruments/5-electric-guitar/60.mp3 */ "./src/extensions/scratch3_music/assets/instruments/5-electric-guitar/60.mp3"),
  'instruments/6-bass/36.mp3': __webpack_require__(/*! ./assets/instruments/6-bass/36.mp3 */ "./src/extensions/scratch3_music/assets/instruments/6-bass/36.mp3"),
  'instruments/6-bass/48.mp3': __webpack_require__(/*! ./assets/instruments/6-bass/48.mp3 */ "./src/extensions/scratch3_music/assets/instruments/6-bass/48.mp3"),
  'instruments/7-pizzicato/60.mp3': __webpack_require__(/*! ./assets/instruments/7-pizzicato/60.mp3 */ "./src/extensions/scratch3_music/assets/instruments/7-pizzicato/60.mp3"),
  'instruments/8-cello/36.mp3': __webpack_require__(/*! ./assets/instruments/8-cello/36.mp3 */ "./src/extensions/scratch3_music/assets/instruments/8-cello/36.mp3"),
  'instruments/8-cello/48.mp3': __webpack_require__(/*! ./assets/instruments/8-cello/48.mp3 */ "./src/extensions/scratch3_music/assets/instruments/8-cello/48.mp3"),
  'instruments/8-cello/60.mp3': __webpack_require__(/*! ./assets/instruments/8-cello/60.mp3 */ "./src/extensions/scratch3_music/assets/instruments/8-cello/60.mp3"),
  'instruments/9-trombone/36.mp3': __webpack_require__(/*! ./assets/instruments/9-trombone/36.mp3 */ "./src/extensions/scratch3_music/assets/instruments/9-trombone/36.mp3"),
  'instruments/9-trombone/48.mp3': __webpack_require__(/*! ./assets/instruments/9-trombone/48.mp3 */ "./src/extensions/scratch3_music/assets/instruments/9-trombone/48.mp3"),
  'instruments/9-trombone/60.mp3': __webpack_require__(/*! ./assets/instruments/9-trombone/60.mp3 */ "./src/extensions/scratch3_music/assets/instruments/9-trombone/60.mp3"),
  'instruments/10-clarinet/48.mp3': __webpack_require__(/*! ./assets/instruments/10-clarinet/48.mp3 */ "./src/extensions/scratch3_music/assets/instruments/10-clarinet/48.mp3"),
  'instruments/10-clarinet/60.mp3': __webpack_require__(/*! ./assets/instruments/10-clarinet/60.mp3 */ "./src/extensions/scratch3_music/assets/instruments/10-clarinet/60.mp3"),
  'instruments/11-saxophone/36.mp3': __webpack_require__(/*! ./assets/instruments/11-saxophone/36.mp3 */ "./src/extensions/scratch3_music/assets/instruments/11-saxophone/36.mp3"),
  'instruments/11-saxophone/60.mp3': __webpack_require__(/*! ./assets/instruments/11-saxophone/60.mp3 */ "./src/extensions/scratch3_music/assets/instruments/11-saxophone/60.mp3"),
  'instruments/11-saxophone/84.mp3': __webpack_require__(/*! ./assets/instruments/11-saxophone/84.mp3 */ "./src/extensions/scratch3_music/assets/instruments/11-saxophone/84.mp3"),
  'instruments/12-flute/60.mp3': __webpack_require__(/*! ./assets/instruments/12-flute/60.mp3 */ "./src/extensions/scratch3_music/assets/instruments/12-flute/60.mp3"),
  'instruments/12-flute/72.mp3': __webpack_require__(/*! ./assets/instruments/12-flute/72.mp3 */ "./src/extensions/scratch3_music/assets/instruments/12-flute/72.mp3"),
  'instruments/13-wooden-flute/60.mp3': __webpack_require__(/*! ./assets/instruments/13-wooden-flute/60.mp3 */ "./src/extensions/scratch3_music/assets/instruments/13-wooden-flute/60.mp3"),
  'instruments/13-wooden-flute/72.mp3': __webpack_require__(/*! ./assets/instruments/13-wooden-flute/72.mp3 */ "./src/extensions/scratch3_music/assets/instruments/13-wooden-flute/72.mp3"),
  'instruments/14-bassoon/36.mp3': __webpack_require__(/*! ./assets/instruments/14-bassoon/36.mp3 */ "./src/extensions/scratch3_music/assets/instruments/14-bassoon/36.mp3"),
  'instruments/14-bassoon/48.mp3': __webpack_require__(/*! ./assets/instruments/14-bassoon/48.mp3 */ "./src/extensions/scratch3_music/assets/instruments/14-bassoon/48.mp3"),
  'instruments/14-bassoon/60.mp3': __webpack_require__(/*! ./assets/instruments/14-bassoon/60.mp3 */ "./src/extensions/scratch3_music/assets/instruments/14-bassoon/60.mp3"),
  'instruments/15-choir/48.mp3': __webpack_require__(/*! ./assets/instruments/15-choir/48.mp3 */ "./src/extensions/scratch3_music/assets/instruments/15-choir/48.mp3"),
  'instruments/15-choir/60.mp3': __webpack_require__(/*! ./assets/instruments/15-choir/60.mp3 */ "./src/extensions/scratch3_music/assets/instruments/15-choir/60.mp3"),
  'instruments/15-choir/72.mp3': __webpack_require__(/*! ./assets/instruments/15-choir/72.mp3 */ "./src/extensions/scratch3_music/assets/instruments/15-choir/72.mp3"),
  'instruments/16-vibraphone/60.mp3': __webpack_require__(/*! ./assets/instruments/16-vibraphone/60.mp3 */ "./src/extensions/scratch3_music/assets/instruments/16-vibraphone/60.mp3"),
  'instruments/16-vibraphone/72.mp3': __webpack_require__(/*! ./assets/instruments/16-vibraphone/72.mp3 */ "./src/extensions/scratch3_music/assets/instruments/16-vibraphone/72.mp3"),
  'instruments/17-music-box/60.mp3': __webpack_require__(/*! ./assets/instruments/17-music-box/60.mp3 */ "./src/extensions/scratch3_music/assets/instruments/17-music-box/60.mp3"),
  'instruments/18-steel-drum/60.mp3': __webpack_require__(/*! ./assets/instruments/18-steel-drum/60.mp3 */ "./src/extensions/scratch3_music/assets/instruments/18-steel-drum/60.mp3"),
  'instruments/19-marimba/60.mp3': __webpack_require__(/*! ./assets/instruments/19-marimba/60.mp3 */ "./src/extensions/scratch3_music/assets/instruments/19-marimba/60.mp3"),
  'instruments/20-synth-lead/60.mp3': __webpack_require__(/*! ./assets/instruments/20-synth-lead/60.mp3 */ "./src/extensions/scratch3_music/assets/instruments/20-synth-lead/60.mp3"),
  'instruments/21-synth-pad/60.mp3': __webpack_require__(/*! ./assets/instruments/21-synth-pad/60.mp3 */ "./src/extensions/scratch3_music/assets/instruments/21-synth-pad/60.mp3")
};

/***/ }),

/***/ "./src/extensions/scratch3_pen/index.js":
/*!**********************************************!*\
  !*** ./src/extensions/scratch3_pen/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const TargetType = __webpack_require__(/*! ../../extension-support/target-type */ "./src/extension-support/target-type.js");

const Cast = __webpack_require__(/*! ../../util/cast */ "./src/util/cast.js");

const Clone = __webpack_require__(/*! ../../util/clone */ "./src/util/clone.js");

const Color = __webpack_require__(/*! ../../util/color */ "./src/util/color.js");

const formatMessage = __webpack_require__(/*! format-message */ "format-message");

const MathUtil = __webpack_require__(/*! ../../util/math-util */ "./src/util/math-util.js");

const RenderedTarget = __webpack_require__(/*! ../../sprites/rendered-target */ "./src/sprites/rendered-target.js");

const log = __webpack_require__(/*! ../../util/log */ "./src/util/log.js");

const StageLayering = __webpack_require__(/*! ../../engine/stage-layering */ "./src/engine/stage-layering.js");
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const blockIconURI = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48dGl0bGU+cGVuLWljb248L3RpdGxlPjxnIHN0cm9rZT0iIzU3NUU3NSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPjxwYXRoIGQ9Ik04Ljc1MyAzNC42MDJsLTQuMjUgMS43OCAxLjc4My00LjIzN2MxLjIxOC0yLjg5MiAyLjkwNy01LjQyMyA1LjAzLTcuNTM4TDMxLjA2NiA0LjkzYy44NDYtLjg0MiAyLjY1LS40MSA0LjAzMi45NjcgMS4zOCAxLjM3NSAxLjgxNiAzLjE3My45NyA0LjAxNUwxNi4zMTggMjkuNTljLTIuMTIzIDIuMTE2LTQuNjY0IDMuOC03LjU2NSA1LjAxMiIgZmlsbD0iI0ZGRiIvPjxwYXRoIGQ9Ik0yOS40MSA2LjExcy00LjQ1LTIuMzc4LTguMjAyIDUuNzcyYy0xLjczNCAzLjc2Ni00LjM1IDEuNTQ2LTQuMzUgMS41NDYiLz48cGF0aCBkPSJNMzYuNDIgOC44MjVjMCAuNDYzLS4xNC44NzMtLjQzMiAxLjE2NGwtOS4zMzUgOS4zYy4yODItLjI5LjQxLS42NjguNDEtMS4xMiAwLS44NzQtLjUwNy0xLjk2My0xLjQwNi0yLjg2OC0xLjM2Mi0xLjM1OC0zLjE0Ny0xLjgtNC4wMDItLjk5TDMwLjk5IDUuMDFjLjg0NC0uODQgMi42NS0uNDEgNC4wMzUuOTYuODk4LjkwNCAxLjM5NiAxLjk4MiAxLjM5NiAyLjg1NU0xMC41MTUgMzMuNzc0Yy0uNTczLjMwMi0xLjE1Ny41Ny0xLjc2NC44M0w0LjUgMzYuMzgybDEuNzg2LTQuMjM1Yy4yNTgtLjYwNC41My0xLjE4Ni44MzMtMS43NTcuNjkuMTgzIDEuNDQ4LjYyNSAyLjEwOCAxLjI4Mi42Ni42NTggMS4xMDIgMS40MTIgMS4yODcgMi4xMDIiIGZpbGw9IiM0Qzk3RkYiLz48cGF0aCBkPSJNMzYuNDk4IDguNzQ4YzAgLjQ2NC0uMTQuODc0LS40MzMgMS4xNjVsLTE5Ljc0MiAxOS42OGMtMi4xMyAyLjExLTQuNjczIDMuNzkzLTcuNTcyIDUuMDFMNC41IDM2LjM4bC45NzQtMi4zMTYgMS45MjUtLjgwOGMyLjg5OC0xLjIxOCA1LjQ0LTIuOSA3LjU3LTUuMDFsMTkuNzQzLTE5LjY4Yy4yOTItLjI5Mi40MzItLjcwMi40MzItMS4xNjUgMC0uNjQ2LS4yNy0xLjQtLjc4LTIuMTIyLjI1LjE3Mi41LjM3Ny43MzcuNjE0Ljg5OC45MDUgMS4zOTYgMS45ODMgMS4zOTYgMi44NTYiIGZpbGw9IiM1NzVFNzUiIG9wYWNpdHk9Ii4xNSIvPjxwYXRoIGQ9Ik0xOC40NSAxMi44M2MwIC41LS40MDQuOTA1LS45MDQuOTA1cy0uOTA1LS40MDUtLjkwNS0uOTA0YzAtLjUuNDA3LS45MDMuOTA2LS45MDMuNSAwIC45MDQuNDA0LjkwNC45MDR6IiBmaWxsPSIjNTc1RTc1Ii8+PC9nPjwvc3ZnPg==';
/**
 * Enum for pen color parameter values.
 * @readonly
 * @enum {string}
 */

const ColorParam = {
  COLOR: 'color',
  SATURATION: 'saturation',
  BRIGHTNESS: 'brightness',
  TRANSPARENCY: 'transparency'
};
/**
 * @typedef {object} PenState - the pen state associated with a particular target.
 * @property {Boolean} penDown - tracks whether the pen should draw for this target.
 * @property {number} color - the current color (hue) of the pen.
 * @property {PenAttributes} penAttributes - cached pen attributes for the renderer. This is the authoritative value for
 *   diameter but not for pen color.
 */

/**
 * Host for the Pen-related blocks in Scratch 3.0
 * @param {Runtime} runtime - the runtime instantiating this block package.
 * @constructor
 */

class Scratch3PenBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    /**
     * The ID of the renderer Drawable corresponding to the pen layer.
     * @type {int}
     * @private
     */

    this._penDrawableId = -1;
    /**
     * The ID of the renderer Skin corresponding to the pen layer.
     * @type {int}
     * @private
     */

    this._penSkinId = -1;
    this._onTargetCreated = this._onTargetCreated.bind(this);
    this._onTargetMoved = this._onTargetMoved.bind(this);
    runtime.on('targetWasCreated', this._onTargetCreated);
    runtime.on('RUNTIME_DISPOSED', this.clear.bind(this));
  }
  /**
   * The default pen state, to be used when a target has no existing pen state.
   * @type {PenState}
   */


  static get DEFAULT_PEN_STATE() {
    return {
      penDown: false,
      color: 66.66,
      saturation: 100,
      brightness: 100,
      transparency: 0,
      _shade: 50,
      // Used only for legacy `change shade by` blocks
      penAttributes: {
        color4f: [0, 0, 1, 1],
        diameter: 1
      }
    };
  }
  /**
   * The minimum and maximum allowed pen size.
   * The maximum is twice the diagonal of the stage, so that even an
   * off-stage sprite can fill it.
   * @type {{min: number, max: number}}
   */


  static get PEN_SIZE_RANGE() {
    return {
      min: 1,
      max: 1e308
    };
  }
  /**
   * The key to load & store a target's pen-related state.
   * @type {string}
   */


  static get STATE_KEY() {
    // tw: We've hardcoded this value in various places for slight performance gains
    // Make sure to update those if this changes.
    return 'Scratch.pen';
  }
  /**
   * Clamp a pen size value to the range allowed by the pen.
   * @param {number} requestedSize - the requested pen size.
   * @returns {number} the clamped size.
   * @private
   */


  _clampPenSize(requestedSize) {
    if (this.runtime.renderer && this.runtime.renderer.useHighQualityRender || !this.runtime.runtimeOptions.miscLimits) {
      return Math.max(0, requestedSize);
    }

    return MathUtil.clamp(requestedSize, Scratch3PenBlocks.PEN_SIZE_RANGE.min, Scratch3PenBlocks.PEN_SIZE_RANGE.max);
  }
  /**
   * Retrieve the ID of the renderer "Skin" corresponding to the pen layer. If
   * the pen Skin doesn't yet exist, create it.
   * @returns {int} the Skin ID of the pen layer, or -1 on failure.
   * @private
   */


  _getPenLayerID() {
    if (this._penSkinId < 0 && this.runtime.renderer) {
      this._penSkinId = this.runtime.renderer.createPenSkin();
      this._penDrawableId = this.runtime.renderer.createDrawable(StageLayering.PEN_LAYER);
      this.runtime.renderer.updateDrawableSkinId(this._penDrawableId, this._penSkinId);
    }

    return this._penSkinId;
  }
  /**
   * @param {Target} target - collect pen state for this target. Probably, but not necessarily, a RenderedTarget.
   * @returns {PenState} the mutable pen state associated with that target. This will be created if necessary.
   * @private
   */


  _getPenState(target) {
    let penState = target._customState['Scratch.pen'];

    if (!penState) {
      penState = Clone.simple(Scratch3PenBlocks.DEFAULT_PEN_STATE);
      target.setCustomState(Scratch3PenBlocks.STATE_KEY, penState);
    }

    return penState;
  }
  /**
   * When a pen-using Target is cloned, clone the pen state.
   * @param {Target} newTarget - the newly created target.
   * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
   * @listens Runtime#event:targetWasCreated
   * @private
   */


  _onTargetCreated(newTarget, sourceTarget) {
    if (sourceTarget) {
      const penState = sourceTarget.getCustomState(Scratch3PenBlocks.STATE_KEY);

      if (penState) {
        newTarget.setCustomState(Scratch3PenBlocks.STATE_KEY, Clone.simple(penState));

        if (penState.penDown) {
          newTarget.onTargetMoved = this._onTargetMoved;
        }
      }
    }
  }
  /**
   * Handle a target which has moved. This only fires when the pen is down.
   * @param {RenderedTarget} target - the target which has moved.
   * @param {number} oldX - the previous X position.
   * @param {number} oldY - the previous Y position.
   * @param {boolean} isForce - whether the movement was forced.
   * @private
   */


  _onTargetMoved(target, oldX, oldY, isForce) {
    // Only move the pen if the movement isn't forced (ie. dragged).
    if (!isForce) {
      const penSkinId = this._getPenLayerID();

      if (penSkinId >= 0) {
        const penState = this._getPenState(target);

        this.runtime.renderer.penLine(penSkinId, penState.penAttributes, oldX, oldY, target.x, target.y);
        this.runtime.requestRedraw();
      }
    }
  }
  /**
   * Wrap a color input into the range (0,100).
   * @param {number} value - the value to be wrapped.
   * @returns {number} the wrapped value.
   * @private
   */


  _wrapColor(value) {
    return MathUtil.wrapClamp(value, 0, 100);
  }
  /**
   * Initialize color parameters menu with localized strings
   * @returns {array} of the localized text and values for each menu element
   * @private
   */


  _initColorParam() {
    return [{
      text: formatMessage({
        id: 'pen.colorMenu.color',
        default: 'color',
        description: 'label for color element in color picker for pen extension'
      }),
      value: ColorParam.COLOR
    }, {
      text: formatMessage({
        id: 'pen.colorMenu.saturation',
        default: 'saturation',
        description: 'label for saturation element in color picker for pen extension'
      }),
      value: ColorParam.SATURATION
    }, {
      text: formatMessage({
        id: 'pen.colorMenu.brightness',
        default: 'brightness',
        description: 'label for brightness element in color picker for pen extension'
      }),
      value: ColorParam.BRIGHTNESS
    }, {
      text: formatMessage({
        id: 'pen.colorMenu.transparency',
        default: 'transparency',
        description: 'label for transparency element in color picker for pen extension'
      }),
      value: ColorParam.TRANSPARENCY
    }];
  }
  /**
   * Clamp a pen color parameter to the range (0,100).
   * @param {number} value - the value to be clamped.
   * @returns {number} the clamped value.
   * @private
   */


  _clampColorParam(value) {
    return MathUtil.clamp(value, 0, 100);
  }
  /**
   * Convert an alpha value to a pen transparency value.
   * Alpha ranges from 0 to 1, where 0 is transparent and 1 is opaque.
   * Transparency ranges from 0 to 100, where 0 is opaque and 100 is transparent.
   * @param {number} alpha - the input alpha value.
   * @returns {number} the transparency value.
   * @private
   */


  _alphaToTransparency(alpha) {
    return (1.0 - alpha) * 100.0;
  }
  /**
   * Convert a pen transparency value to an alpha value.
   * Alpha ranges from 0 to 1, where 0 is transparent and 1 is opaque.
   * Transparency ranges from 0 to 100, where 0 is opaque and 100 is transparent.
   * @param {number} transparency - the input transparency value.
   * @returns {number} the alpha value.
   * @private
   */


  _transparencyToAlpha(transparency) {
    return 1.0 - transparency / 100.0;
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: 'pen',
      name: formatMessage({
        id: 'pen.categoryName',
        default: 'Pen',
        description: 'Label for the pen extension category'
      }),
      blockIconURI: blockIconURI,
      blocks: [{
        opcode: 'clear',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.clear',
          default: 'erase all',
          description: 'erase all pen trails and stamps'
        })
      }, {
        opcode: 'stamp',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.stamp',
          default: 'stamp',
          description: 'render current costume on the background'
        }),
        filter: [TargetType.SPRITE]
      }, {
        opcode: 'penDown',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.penDown',
          default: 'pen down',
          description: 'start leaving a trail when the sprite moves'
        }),
        filter: [TargetType.SPRITE]
      }, {
        opcode: 'penUp',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.penUp',
          default: 'pen up',
          description: 'stop leaving a trail behind the sprite'
        }),
        filter: [TargetType.SPRITE]
      }, {
        opcode: 'setPenColorToColor',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.setColor',
          default: 'set pen color to [COLOR]',
          description: 'set the pen color to a particular (RGB) value'
        }),
        arguments: {
          COLOR: {
            type: ArgumentType.COLOR
          }
        },
        filter: [TargetType.SPRITE]
      }, {
        opcode: 'changePenColorParamBy',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.changeColorParam',
          default: 'change pen [COLOR_PARAM] by [VALUE]',
          description: 'change the state of a pen color parameter'
        }),
        arguments: {
          COLOR_PARAM: {
            type: ArgumentType.STRING,
            menu: 'colorParam',
            defaultValue: ColorParam.COLOR
          },
          VALUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 10
          }
        },
        filter: [TargetType.SPRITE]
      }, {
        opcode: 'setPenColorParamTo',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.setColorParam',
          default: 'set pen [COLOR_PARAM] to [VALUE]',
          description: 'set the state for a pen color parameter e.g. saturation'
        }),
        arguments: {
          COLOR_PARAM: {
            type: ArgumentType.STRING,
            menu: 'colorParam',
            defaultValue: ColorParam.COLOR
          },
          VALUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        },
        filter: [TargetType.SPRITE]
      }, {
        opcode: 'changePenSizeBy',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.changeSize',
          default: 'change pen size by [SIZE]',
          description: 'change the diameter of the trail left by a sprite'
        }),
        arguments: {
          SIZE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        filter: [TargetType.SPRITE]
      }, {
        opcode: 'setPenSizeTo',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.setSize',
          default: 'set pen size to [SIZE]',
          description: 'set the diameter of a trail left by a sprite'
        }),
        arguments: {
          SIZE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        filter: [TargetType.SPRITE]
      },
      /* Legacy blocks, should not be shown in flyout */
      {
        opcode: 'setPenShadeToNumber',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.setShade',
          default: 'LEGACY - set pen shade to [SHADE]',
          description: 'legacy pen blocks - set pen shade'
        }),
        arguments: {
          SHADE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        hideFromPalette: false
      }, {
        opcode: 'changePenShadeBy',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.changeShade',
          default: 'LEGACY - change pen shade by [SHADE]',
          description: 'legacy pen blocks - change pen shade'
        }),
        arguments: {
          SHADE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        hideFromPalette: false
      }, {
        opcode: 'setPenHueToNumber',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.setHue',
          default: 'LEGACY - set pen color to [HUE]',
          description: 'legacy pen blocks - set pen color to number'
        }),
        arguments: {
          HUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        hideFromPalette: false
      }, {
        opcode: 'changePenHueBy',
        blockType: BlockType.COMMAND,
        text: formatMessage({
          id: 'pen.changeHue',
          default: 'LEGACY - change pen color by [HUE]',
          description: 'legacy pen blocks - change pen color'
        }),
        arguments: {
          HUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        },
        hideFromPalette: false
      }],
      menus: {
        colorParam: {
          acceptReporters: true,
          items: this._initColorParam()
        }
      }
    };
  }
  /**
   * The pen "clear" block clears the pen layer's contents.
   */


  clear() {
    // used by compiler
    const penSkinId = this._getPenLayerID();

    if (penSkinId >= 0) {
      this.runtime.renderer.penClear(penSkinId);
      this.runtime.requestRedraw();
    }
  }
  /**
   * The pen "stamp" block stamps the current drawable's image onto the pen layer.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   */


  stamp(args, util) {
    this._stamp(util.target);
  }

  _stamp(target) {
    // used by compiler
    const penSkinId = this._getPenLayerID();

    if (penSkinId >= 0) {
      this.runtime.renderer.penStamp(penSkinId, target.drawableID);
      this.runtime.requestRedraw();
    }
  }
  /**
   * The pen "pen down" block causes the target to leave pen trails on future motion.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   */


  penDown(args, util) {
    this._penDown(util.target);
  }

  _penDown(target) {
    // used by compiler
    const penState = this._getPenState(target);

    if (!penState.penDown) {
      penState.penDown = true;
      target.onTargetMoved = this._onTargetMoved;
    }

    const penSkinId = this._getPenLayerID();

    if (penSkinId >= 0) {
      this.runtime.renderer.penPoint(penSkinId, penState.penAttributes, target.x, target.y);
      this.runtime.requestRedraw();
    }
  }
  /**
   * The pen "pen up" block stops the target from leaving pen trails.
   * @param {object} args - the block arguments.
   * @param {object} util - utility object provided by the runtime.
   */


  penUp(args, util) {
    this._penUp(util.target);
  }

  _penUp(target) {
    // used by compiler
    const penState = this._getPenState(target);

    if (penState.penDown) {
      penState.penDown = false;
      target.onTargetMoved = null;
    }
  }
  /**
   * The pen "set pen color to {color}" block sets the pen to a particular RGB color.
   * The transparency is reset to 0.
   * @param {object} args - the block arguments.
   *  @property {int} COLOR - the color to set, expressed as a 24-bit RGB value (0xRRGGBB).
   * @param {object} util - utility object provided by the runtime.
   */


  setPenColorToColor(args, util) {
    this._setPenColorToColor(args.COLOR, util.target);
  }

  _setPenColorToColor(color, target) {
    // used by compiler
    const penState = this._getPenState(target);

    const rgb = Cast.toRgbColorObject(color);
    const hsv = Color.rgbToHsv(rgb);
    penState.color = hsv.h / 360 * 100;
    penState.saturation = hsv.s * 100;
    penState.brightness = hsv.v * 100;

    if (rgb.hasOwnProperty('a')) {
      penState.transparency = 100 * (1 - rgb.a / 255.0);
    } else {
      penState.transparency = 0;
    } // Set the legacy "shade" value the same way scratch 2 did.


    penState._shade = penState.brightness / 2;

    this._updatePenColor(penState);
  }
  /**
   * Update the cached color from the color, saturation, brightness and transparency values
   * in the provided PenState object.
   * @param {PenState} penState - the pen state to update.
   * @private
   */


  _updatePenColor(penState) {
    const rgb = Color.hsvToRgb({
      h: penState.color * 360 / 100,
      s: penState.saturation / 100,
      v: penState.brightness / 100
    });
    penState.penAttributes.color4f[0] = rgb.r / 255.0;
    penState.penAttributes.color4f[1] = rgb.g / 255.0;
    penState.penAttributes.color4f[2] = rgb.b / 255.0;
    penState.penAttributes.color4f[3] = this._transparencyToAlpha(penState.transparency);
  }
  /**
   * Set or change a single color parameter on the pen state, and update the pen color.
   * @param {ColorParam} param - the name of the color parameter to set or change.
   * @param {number} value - the value to set or change the param by.
   * @param {PenState} penState - the pen state to update.
   * @param {boolean} change - if true change param by value, if false set param to value.
   * @private
   */


  _setOrChangeColorParam(param, value, penState, change) {
    // used by compiler
    switch (param) {
      case ColorParam.COLOR:
        penState.color = this._wrapColor(value + (change ? penState.color : 0));
        break;

      case ColorParam.SATURATION:
        penState.saturation = this._clampColorParam(value + (change ? penState.saturation : 0));
        break;

      case ColorParam.BRIGHTNESS:
        penState.brightness = this._clampColorParam(value + (change ? penState.brightness : 0));
        break;

      case ColorParam.TRANSPARENCY:
        penState.transparency = this._clampColorParam(value + (change ? penState.transparency : 0));
        break;

      default:
        log.warn("Tried to set or change unknown color parameter: ".concat(param));
    }

    this._updatePenColor(penState);
  }
  /**
   * The "change pen {ColorParam} by {number}" block changes one of the pen's color parameters
   * by a given amound.
   * @param {object} args - the block arguments.
   *  @property {ColorParam} COLOR_PARAM - the name of the selected color parameter.
   *  @property {number} VALUE - the amount to change the selected parameter by.
   * @param {object} util - utility object provided by the runtime.
   */


  changePenColorParamBy(args, util) {
    const penState = this._getPenState(util.target);

    this._setOrChangeColorParam(args.COLOR_PARAM, Cast.toNumber(args.VALUE), penState, true);
  }
  /**
   * The "set pen {ColorParam} to {number}" block sets one of the pen's color parameters
   * to a given amound.
   * @param {object} args - the block arguments.
   *  @property {ColorParam} COLOR_PARAM - the name of the selected color parameter.
   *  @property {number} VALUE - the amount to set the selected parameter to.
   * @param {object} util - utility object provided by the runtime.
   */


  setPenColorParamTo(args, util) {
    const penState = this._getPenState(util.target);

    this._setOrChangeColorParam(args.COLOR_PARAM, Cast.toNumber(args.VALUE), penState, false);
  }
  /**
   * The pen "change pen size by {number}" block changes the pen size by the given amount.
   * @param {object} args - the block arguments.
   *  @property {number} SIZE - the amount of desired size change.
   * @param {object} util - utility object provided by the runtime.
   */


  changePenSizeBy(args, util) {
    this._changePenSizeBy(Cast.toNumber(args.SIZE), util.target);
  }

  _changePenSizeBy(size, target) {
    // used by compiler
    const penAttributes = this._getPenState(target).penAttributes;

    penAttributes.diameter = this._clampPenSize(penAttributes.diameter + size);
  }
  /**
   * The pen "set pen size to {number}" block sets the pen size to the given amount.
   * @param {object} args - the block arguments.
   *  @property {number} SIZE - the amount of desired size change.
   * @param {object} util - utility object provided by the runtime.
   */


  setPenSizeTo(args, util) {
    this._setPenSizeTo(Cast.toNumber(args.SIZE), util.target);
  }

  _setPenSizeTo(size, target) {
    // used by compiler
    const penAttributes = this._getPenState(target).penAttributes;

    penAttributes.diameter = this._clampPenSize(size);
  }
  /* LEGACY OPCODES */

  /**
   * Scratch 2 "hue" param is equivelant to twice the new "color" param.
   * @param {object} args - the block arguments.
   *  @property {number} HUE - the amount to set the hue to.
   * @param {object} util - utility object provided by the runtime.
   */


  setPenHueToNumber(args, util) {
    this._setPenHueToNumber(Cast.toNumber(args.HUE), util.target);
  }

  _setPenHueToNumber(hueValue, target) {
    const penState = this._getPenState(target);

    const colorValue = hueValue / 2;

    this._setOrChangeColorParam(ColorParam.COLOR, colorValue, penState, false);

    this._setOrChangeColorParam(ColorParam.TRANSPARENCY, 0, penState, false);

    this._legacyUpdatePenColor(penState);
  }
  /**
   * Scratch 2 "hue" param is equivelant to twice the new "color" param.
   * @param {object} args - the block arguments.
   *  @property {number} HUE - the amount of desired hue change.
   * @param {object} util - utility object provided by the runtime.
   */


  changePenHueBy(args, util) {
    this._changePenHueBy(Cast.toNumber(args.HUE), util.target);
  }

  _changePenHueBy(hueChange, target) {
    // used by compiler
    const penState = this._getPenState(target);

    const colorChange = hueChange / 2;

    this._setOrChangeColorParam(ColorParam.COLOR, colorChange, penState, true);

    this._legacyUpdatePenColor(penState);
  }
  /**
   * Use legacy "set shade" code to calculate RGB value for shade,
   * then convert back to HSV and store those components.
   * It is important to also track the given shade in penState._shade
   * because it cannot be accurately backed out of the new HSV later.
   * @param {object} args - the block arguments.
   *  @property {number} SHADE - the amount to set the shade to.
   * @param {object} util - utility object provided by the runtime.
   */


  setPenShadeToNumber(args, util) {
    this._setPenShadeToNumber(Cast.toNumber(args.SHADE), util.target);
  }

  _setPenShadeToNumber(shade, target) {
    const penState = this._getPenState(target);

    let newShade = Cast.toNumber(shade); // Wrap clamp the new shade value the way scratch 2 did.

    newShade = newShade % 200;
    if (newShade < 0) newShade += 200; // And store the shade that was used to compute this new color for later use.

    penState._shade = newShade;

    this._legacyUpdatePenColor(penState);
  }
  /**
   * Because "shade" cannot be backed out of hsv consistently, use the previously
   * stored penState._shade to make the shade change.
   * @param {object} args - the block arguments.
   *  @property {number} SHADE - the amount of desired shade change.
   * @param {object} util - utility object provided by the runtime.
   */


  changePenShadeBy(args, util) {
    this._changePenShadeBy(args.SHADE, util.target);
  }

  _changePenShadeBy(shade, target) {
    const penState = this._getPenState(target);

    const shadeChange = Cast.toNumber(shade);

    this._setPenShadeToNumber(penState._shade + shadeChange, target);
  }
  /**
   * Update the pen state's color from its hue & shade values, Scratch 2.0 style.
   * @param {object} penState - update the HSV & RGB values in this pen state from its hue & shade values.
   * @private
   */


  _legacyUpdatePenColor(penState) {
    // Create the new color in RGB using the scratch 2 "shade" model
    let rgb = Color.hsvToRgb({
      h: penState.color * 360 / 100,
      s: 1,
      v: 1
    });
    const shade = penState._shade > 100 ? 200 - penState._shade : penState._shade;

    if (shade < 50) {
      rgb = Color.mixRgb(Color.RGB_BLACK, rgb, (10 + shade) / 60);
    } else {
      rgb = Color.mixRgb(rgb, Color.RGB_WHITE, (shade - 50) / 60);
    } // Update the pen state according to new color


    const hsv = Color.rgbToHsv(rgb);
    penState.color = 100 * hsv.h / 360;
    penState.saturation = 100 * hsv.s;
    penState.brightness = 100 * hsv.v;

    this._updatePenColor(penState);
  }

}

module.exports = Scratch3PenBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_text2speech/index.js":
/*!******************************************************!*\
  !*** ./src/extensions/scratch3_text2speech/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const formatMessage = __webpack_require__(/*! format-message */ "format-message");

const languageNames = __webpack_require__(/*! scratch-translate-extension-languages */ "./node_modules/scratch-translate-extension-languages/languages.json");

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const Cast = __webpack_require__(/*! ../../util/cast */ "./src/util/cast.js");

const MathUtil = __webpack_require__(/*! ../../util/math-util */ "./src/util/math-util.js");

const Clone = __webpack_require__(/*! ../../util/clone */ "./src/util/clone.js");

const log = __webpack_require__(/*! ../../util/log */ "./src/util/log.js");

const fetchWithTimeout = __webpack_require__(/*! ../../util/fetch-with-timeout */ "./src/util/fetch-with-timeout.js");
/**
 * Icon svg to be displayed in the blocks category menu, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const menuIconURI = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjBweCIgaGVpZ2h0PSIyMHB4IiB2aWV3Qm94PSIwIDAgMjAgMjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDUyLjIgKDY3MTQ1KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5FeHRlbnNpb25zL1NvZnR3YXJlL1RleHQtdG8tU3BlZWNoLU1lbnU8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZyBpZD0iRXh0ZW5zaW9ucy9Tb2Z0d2FyZS9UZXh0LXRvLVNwZWVjaC1NZW51IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyBpZD0idGV4dDJzcGVlY2giIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIuMDAwMDAwLCAyLjAwMDAwMCkiIGZpbGwtcnVsZT0ibm9uemVybyI+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik01Ljc1LDguODM0NjcxNzMgQzUuNzUsOC4zMjY5NjM0NCA1LjAwMzAwNzI3LDguMDQyMjEzNzEgNC41NTYyODAxMiw4LjQ0NDE0OTk5IEwzLjIwNjI4MDEyLDkuNTI1MzU3MDIgQzIuNjk2NzMzNzgsOS45MzM0NDk2OCAyLjAzNzQ4Njc1LDEwLjE2NTg3ODggMS4zNSwxMC4xNjU4Nzg4IEwxLjE1LDEwLjE2NTg3ODggQzAuNjMyNTk2MTY1LDEwLjE2NTg3ODggMC4yNSwxMC41MTA2MDAyIDAuMjUsMTAuOTUyMDM1NSBMMC4yNSwxMy4wNjkzOTkzIEMwLjI1LDEzLjUxMDgzNDYgMC42MzI1OTYxNjUsMTMuODU1NTU2IDEuMTUsMTMuODU1NTU2IEwxLjM1LDEzLjg1NTU1NiBDMi4wNzg3Nzg0MSwxMy44NTU1NTYgMi43MjY4NjE2MSwxNC4wNjY3NjM2IDMuMjU5ODYwNDksMTQuNDk5IEw0LjU1OTIwMTQ3LDE1LjU3OTY2MDggQzUuMDEzMDkyNzYsMTUuOTU0NTM5NiA1Ljc1LDE1LjY3MzYzNDQgNS43NSwxNS4xNDE3MTI4IEw1Ljc1LDguODM0NjcxNzMgWiIgaWQ9InNwZWFrZXIiIHN0cm9rZS1vcGFjaXR5PSIwLjE1IiBzdHJva2U9IiMwMDAwMDAiIHN0cm9rZS13aWR0aD0iMC41IiBmaWxsPSIjNEQ0RDREIj48L3BhdGg+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0xMC43MDQ4MzEzLDggQzkuNzkwNjc0NjgsOS4xMzExNDg0NyA4LjMwNjYxODQsOS43MTQyODU3MSA3LjgzMzMzMzMzLDkuNzE0Mjg1NzEgQzcuODMzMzMzMzMsOS43MTQyODU3MSA3LjUsOS43MTQyODU3MSA3LjUsOS4zODA5NTIzOCBDNy41LDkuMDg1MjI2ODQgOC4wNjIyMDE2OCw4LjkwMTk0MTY0IDguMTg5MDYwNjcsNy41Njc1NDA1OCBDNi44ODk5Njk5MSw2LjkwNjc5MDA1IDYsNS41NTczMjY4MyA2LDQgQzYsMS43OTA4NjEgNy43OTA4NjEsNC4wNTgxMjI1MWUtMTYgMTAsMCBMMTIsMCBDMTQuMjA5MTM5LC00LjA1ODEyMjUxZS0xNiAxNiwxLjc5MDg2MSAxNiw0IEMxNiw2LjIwOTEzOSAxNC4yMDkxMzksOCAxMiw4IEwxMC43MDQ4MzEzLDggWiIgaWQ9InNwZWVjaCIgZmlsbD0iIzBFQkQ4QyI+PC9wYXRoPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+';
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len

const blockIconURI = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNDBweCIgaGVpZ2h0PSI0MHB4IiB2aWV3Qm94PSIwIDAgNDAgNDAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDUyLjIgKDY3MTQ1KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5FeHRlbnNpb25zL1NvZnR3YXJlL1RleHQtdG8tU3BlZWNoLUJsb2NrPC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGcgaWQ9IkV4dGVuc2lvbnMvU29mdHdhcmUvVGV4dC10by1TcGVlY2gtQmxvY2siIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIHN0cm9rZS1vcGFjaXR5PSIwLjE1Ij4KICAgICAgICA8ZyBpZD0idGV4dDJzcGVlY2giIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQuMDAwMDAwLCA0LjAwMDAwMCkiIGZpbGwtcnVsZT0ibm9uemVybyIgc3Ryb2tlPSIjMDAwMDAwIj4KICAgICAgICAgICAgPHBhdGggZD0iTTExLjUsMTcuNjY5MzQzNSBDMTEuNSwxNi42NTM5MjY5IDEwLjAwNjAxNDUsMTYuMDg0NDI3NCA5LjExMjU2MDI0LDE2Ljg4ODMgTDYuNDEyNTYwMjQsMTkuMDUwNzE0IEM1LjM5MzQ2NzU1LDE5Ljg2Njg5OTQgNC4wNzQ5NzM1MSwyMC4zMzE3NTc1IDIuNywyMC4zMzE3NTc1IEwyLjMsMjAuMzMxNzU3NSBDMS4yNjUxOTIzMywyMC4zMzE3NTc1IDAuNSwyMS4wMjEyMDAzIDAuNSwyMS45MDQwNzEgTDAuNSwyNi4xMzg3OTg2IEMwLjUsMjcuMDIxNjY5MyAxLjI2NTE5MjMzLDI3LjcxMTExMiAyLjMsMjcuNzExMTEyIEwyLjcsMjcuNzExMTEyIEM0LjE1NzU1NjgyLDI3LjcxMTExMiA1LjQ1MzcyMzIyLDI4LjEzMzUyNzEgNi41MTk3MjA5OCwyOC45OTggTDkuMTE4NDAyOTMsMzEuMTU5MzIxNiBDMTAuMDI2MTg1NSwzMS45MDkwNzkzIDExLjUsMzEuMzQ3MjY4OSAxMS41LDMwLjI4MzQyNTUgTDExLjUsMTcuNjY5MzQzNSBaIiBpZD0ic3BlYWtlciIgZmlsbD0iIzRENEQ0RCI+PC9wYXRoPgogICAgICAgICAgICA8cGF0aCBkPSJNMjEuNjQzNjA2NiwxNi41IEMxOS45NzcwMDk5LDE4LjQzNzAyMzQgMTcuMTA1MDI3NSwxOS45Mjg1NzE0IDE1LjY2NjY2NjcsMTkuOTI4NTcxNCBDMTUuNTEyNjM5NywxOS45Mjg1NzE0IDE1LjMxNjYyOTIsMTkuODk1OTAzIDE1LjEwOTcyNjUsMTkuNzkyNDUxNyBDMTQuNzM3NjAzOSwxOS42MDYzOTA0IDE0LjUsMTkuMjQ5OTg0NiAxNC41LDE4Ljc2MTkwNDggQzE0LjUsMTguNjU2ODA0MSAxNC41MTcwNTU1LDE4LjU1NDUwNzYgMTQuNTQ5NDQ2NywxOC40NTQwODQ0IEMxNC42MjU3NTQ1LDE4LjIxNzUwNjMgMTUuMTczNTcyMSwxNy40Njc1MzEgMTUuMjc3MjA3MSwxNy4yODA5ODgxIEMxNS41NDYzNTI2LDE2Ljc5NjUyNjEgMTUuNzM5MDI1LDE2LjIwNjM1NjEgMTUuODQzMjg5MSwxNS40MTYwMDM0IEMxMy4xODk3MDA1LDEzLjkyNjgzNjkgMTEuNSwxMS4xMTM5NjY4IDExLjUsOCBDMTEuNSwzLjMwNTU3OTYzIDE1LjMwNTU3OTYsLTAuNSAyMCwtMC41IEwyNCwtMC41IEMyOC42OTQ0MjA0LC0wLjUgMzIuNSwzLjMwNTU3OTYzIDMyLjUsOCBDMzIuNSwxMi42OTQ0MjA0IDI4LjY5NDQyMDQsMTYuNSAyNCwxNi41IEwyMS42NDM2MDY2LDE2LjUgWiIgaWQ9InNwZWVjaCIgZmlsbD0iI0ZGRkZGRiI+PC9wYXRoPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+';
/**
 * The url of the synthesis server.
 * @type {string}
 */

const SERVER_HOST = 'https://synthesis-service.scratch.mit.edu';
/**
 * How long to wait in ms before timing out requests to synthesis server.
 * @type {int}
 */

const SERVER_TIMEOUT = 10000; // 10 seconds

/**
 * Volume for playback of speech sounds, as a percentage.
 * @type {number}
 */

const SPEECH_VOLUME = 250;
/**
 * An id for one of the voices.
 */

const ALTO_ID = 'ALTO';
/**
 * An id for one of the voices.
 */

const TENOR_ID = 'TENOR';
/**
 * An id for one of the voices.
 */

const SQUEAK_ID = 'SQUEAK';
/**
 * An id for one of the voices.
 */

const GIANT_ID = 'GIANT';
/**
 * An id for one of the voices.
 */

const KITTEN_ID = 'KITTEN';
/**
 * Playback rate for the tenor voice, for cases where we have only a female gender voice.
 */

const FEMALE_TENOR_RATE = 0.89; // -2 semitones

/**
 * Playback rate for the giant voice, for cases where we have only a female gender voice.
 */

const FEMALE_GIANT_RATE = 0.79; // -4 semitones

/**
 * Language ids. The value for each language id is a valid Scratch locale.
 */

const ARABIC_ID = 'ar';
const CHINESE_ID = 'zh-cn';
const DANISH_ID = 'da';
const DUTCH_ID = 'nl';
const ENGLISH_ID = 'en';
const FRENCH_ID = 'fr';
const GERMAN_ID = 'de';
const HINDI_ID = 'hi';
const ICELANDIC_ID = 'is';
const ITALIAN_ID = 'it';
const JAPANESE_ID = 'ja';
const KOREAN_ID = 'ko';
const NORWEGIAN_ID = 'nb';
const POLISH_ID = 'pl';
const PORTUGUESE_BR_ID = 'pt-br';
const PORTUGUESE_ID = 'pt';
const ROMANIAN_ID = 'ro';
const RUSSIAN_ID = 'ru';
const SPANISH_ID = 'es';
const SPANISH_419_ID = 'es-419';
const SWEDISH_ID = 'sv';
const TURKISH_ID = 'tr';
const WELSH_ID = 'cy';
/**
 * Class for the text2speech blocks.
 * @constructor
 */

class Scratch3Text2SpeechBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    /**
     * Map of soundPlayers by sound id.
     * @type {Map<string, SoundPlayer>}
     */

    this._soundPlayers = new Map();
    this._stopAllSpeech = this._stopAllSpeech.bind(this);

    if (this.runtime) {
      this.runtime.on('PROJECT_STOP_ALL', this._stopAllSpeech);
    }

    this._onTargetCreated = this._onTargetCreated.bind(this);

    if (this.runtime) {
      runtime.on('targetWasCreated', this._onTargetCreated);
    }
    /**
     * A list of all Scratch locales that are supported by the extension.
     * @type {Array}
     */


    this._supportedLocales = this._getSupportedLocales();
  }
  /**
   * An object with info for each voice.
   */


  get VOICE_INFO() {
    return {
      [ALTO_ID]: {
        name: formatMessage({
          id: 'text2speech.alto',
          default: 'alto',
          description: 'Name for a voice with ambiguous gender.'
        }),
        gender: 'female',
        playbackRate: 1
      },
      [TENOR_ID]: {
        name: formatMessage({
          id: 'text2speech.tenor',
          default: 'tenor',
          description: 'Name for a voice with ambiguous gender.'
        }),
        gender: 'male',
        playbackRate: 1
      },
      [SQUEAK_ID]: {
        name: formatMessage({
          id: 'text2speech.squeak',
          default: 'squeak',
          description: 'Name for a funny voice with a high pitch.'
        }),
        gender: 'female',
        playbackRate: 1.19 // +3 semitones

      },
      [GIANT_ID]: {
        name: formatMessage({
          id: 'text2speech.giant',
          default: 'giant',
          description: 'Name for a funny voice with a low pitch.'
        }),
        gender: 'male',
        playbackRate: 0.84 // -3 semitones

      },
      [KITTEN_ID]: {
        name: formatMessage({
          id: 'text2speech.kitten',
          default: 'kitten',
          description: 'A baby cat.'
        }),
        gender: 'female',
        playbackRate: 1.41 // +6 semitones

      }
    };
  }
  /**
   * An object with information for each language.
   *
   * A note on the different sets of locales referred to in this extension:
   *
   * SCRATCH LOCALE
   *      Set by the editor, and used to store the language state in the project.
   *      Listed in l10n: https://github.com/LLK/scratch-l10n/blob/master/src/supported-locales.js
   * SUPPORTED LOCALE
   *      A Scratch locale that has a corresponding extension locale.
   * EXTENSION LOCALE
   *      A locale corresponding to one of the available spoken languages
   *      in the extension. There can be multiple supported locales for a single
   *      extension locale. For example, for both written versions of chinese,
   *      zh-cn and zh-tw, we use a single spoken language (Mandarin). So there
   *      are two supported locales, with a single extension locale.
   * SPEECH SYNTH LOCALE
   *      A different locale code system, used by our speech synthesis service.
   *      Each extension locale has a speech synth locale.
   */


  get LANGUAGE_INFO() {
    return {
      [ARABIC_ID]: {
        name: 'Arabic',
        locales: ['ar'],
        speechSynthLocale: 'arb',
        singleGender: true
      },
      [CHINESE_ID]: {
        name: 'Chinese (Mandarin)',
        locales: ['zh-cn', 'zh-tw'],
        speechSynthLocale: 'cmn-CN',
        singleGender: true
      },
      [DANISH_ID]: {
        name: 'Danish',
        locales: ['da'],
        speechSynthLocale: 'da-DK'
      },
      [DUTCH_ID]: {
        name: 'Dutch',
        locales: ['nl'],
        speechSynthLocale: 'nl-NL'
      },
      [ENGLISH_ID]: {
        name: 'English',
        locales: ['en'],
        speechSynthLocale: 'en-US'
      },
      [FRENCH_ID]: {
        name: 'French',
        locales: ['fr'],
        speechSynthLocale: 'fr-FR'
      },
      [GERMAN_ID]: {
        name: 'German',
        locales: ['de'],
        speechSynthLocale: 'de-DE'
      },
      [HINDI_ID]: {
        name: 'Hindi',
        locales: ['hi'],
        speechSynthLocale: 'hi-IN',
        singleGender: true
      },
      [ICELANDIC_ID]: {
        name: 'Icelandic',
        locales: ['is'],
        speechSynthLocale: 'is-IS'
      },
      [ITALIAN_ID]: {
        name: 'Italian',
        locales: ['it'],
        speechSynthLocale: 'it-IT'
      },
      [JAPANESE_ID]: {
        name: 'Japanese',
        locales: ['ja', 'ja-hira'],
        speechSynthLocale: 'ja-JP'
      },
      [KOREAN_ID]: {
        name: 'Korean',
        locales: ['ko'],
        speechSynthLocale: 'ko-KR',
        singleGender: true
      },
      [NORWEGIAN_ID]: {
        name: 'Norwegian',
        locales: ['nb', 'nn'],
        speechSynthLocale: 'nb-NO',
        singleGender: true
      },
      [POLISH_ID]: {
        name: 'Polish',
        locales: ['pl'],
        speechSynthLocale: 'pl-PL'
      },
      [PORTUGUESE_BR_ID]: {
        name: 'Portuguese (Brazilian)',
        locales: ['pt-br'],
        speechSynthLocale: 'pt-BR'
      },
      [PORTUGUESE_ID]: {
        name: 'Portuguese (European)',
        locales: ['pt'],
        speechSynthLocale: 'pt-PT'
      },
      [ROMANIAN_ID]: {
        name: 'Romanian',
        locales: ['ro'],
        speechSynthLocale: 'ro-RO',
        singleGender: true
      },
      [RUSSIAN_ID]: {
        name: 'Russian',
        locales: ['ru'],
        speechSynthLocale: 'ru-RU'
      },
      [SPANISH_ID]: {
        name: 'Spanish (European)',
        locales: ['es'],
        speechSynthLocale: 'es-ES'
      },
      [SPANISH_419_ID]: {
        name: 'Spanish (Latin American)',
        locales: ['es-419'],
        speechSynthLocale: 'es-US'
      },
      [SWEDISH_ID]: {
        name: 'Swedish',
        locales: ['sv'],
        speechSynthLocale: 'sv-SE',
        singleGender: true
      },
      [TURKISH_ID]: {
        name: 'Turkish',
        locales: ['tr'],
        speechSynthLocale: 'tr-TR',
        singleGender: true
      },
      [WELSH_ID]: {
        name: 'Welsh',
        locales: ['cy'],
        speechSynthLocale: 'cy-GB',
        singleGender: true
      }
    };
  }
  /**
   * The key to load & store a target's text2speech state.
   * @return {string} The key.
   */


  static get STATE_KEY() {
    return 'Scratch.text2speech';
  }
  /**
   * The default state, to be used when a target has no existing state.
   * @type {Text2SpeechState}
   */


  static get DEFAULT_TEXT2SPEECH_STATE() {
    return {
      voiceId: ALTO_ID
    };
  }
  /**
   * A default language to use for speech synthesis.
   * @type {string}
   */


  get DEFAULT_LANGUAGE() {
    return ENGLISH_ID;
  }
  /**
   * @param {Target} target - collect  state for this target.
   * @returns {Text2SpeechState} the mutable state associated with that target. This will be created if necessary.
   * @private
   */


  _getState(target) {
    let state = target.getCustomState(Scratch3Text2SpeechBlocks.STATE_KEY);

    if (!state) {
      state = Clone.simple(Scratch3Text2SpeechBlocks.DEFAULT_TEXT2SPEECH_STATE);
      target.setCustomState(Scratch3Text2SpeechBlocks.STATE_KEY, state);
    }

    return state;
  }
  /**
   * When a Target is cloned, clone the state.
   * @param {Target} newTarget - the newly created target.
   * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.
   * @listens Runtime#event:targetWasCreated
   * @private
   */


  _onTargetCreated(newTarget, sourceTarget) {
    if (sourceTarget) {
      const state = sourceTarget.getCustomState(Scratch3Text2SpeechBlocks.STATE_KEY);

      if (state) {
        newTarget.setCustomState(Scratch3Text2SpeechBlocks.STATE_KEY, Clone.simple(state));
      }
    }
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    // Only localize the default input to the "speak" block if we are in a
    // supported language.
    let defaultTextToSpeak = 'hello';

    if (this.isSupportedLanguage(this.getEditorLanguage())) {
      defaultTextToSpeak = formatMessage({
        id: 'text2speech.defaultTextToSpeak',
        default: 'hello',
        description: 'hello: the default text to speak'
      });
    }

    return {
      id: 'text2speech',
      name: formatMessage({
        id: 'text2speech.categoryName',
        default: 'Text to Speech',
        description: 'Name of the Text to Speech extension.'
      }),
      blockIconURI: blockIconURI,
      menuIconURI: menuIconURI,
      blocks: [{
        opcode: 'speakAndWait',
        text: formatMessage({
          id: 'text2speech.speakAndWaitBlock',
          default: 'speak [WORDS]',
          description: 'Speak some words.'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          WORDS: {
            type: ArgumentType.STRING,
            defaultValue: defaultTextToSpeak
          }
        }
      }, {
        opcode: 'setVoice',
        text: formatMessage({
          id: 'text2speech.setVoiceBlock',
          default: 'set voice to [VOICE]',
          description: 'Set the voice for speech synthesis.'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          VOICE: {
            type: ArgumentType.STRING,
            menu: 'voices',
            defaultValue: ALTO_ID
          }
        }
      }, {
        opcode: 'setLanguage',
        text: formatMessage({
          id: 'text2speech.setLanguageBlock',
          default: 'set language to [LANGUAGE]',
          description: 'Set the language for speech synthesis.'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          LANGUAGE: {
            type: ArgumentType.STRING,
            menu: 'languages',
            defaultValue: this.getCurrentLanguage()
          }
        }
      }],
      menus: {
        voices: {
          acceptReporters: true,
          items: this.getVoiceMenu()
        },
        languages: {
          acceptReporters: true,
          items: this.getLanguageMenu()
        }
      }
    };
  }
  /**
   * Get the language code currently set in the editor, or fall back to the
   * browser locale.
   * @return {string} a Scratch locale code.
   */


  getEditorLanguage() {
    const locale = formatMessage.setup().locale || navigator.language || navigator.userLanguage || this.DEFAULT_LANGUAGE;
    return locale.toLowerCase();
  }
  /**
   * Get the language code currently set for the extension.
   * @returns {string} a Scratch locale code.
   */


  getCurrentLanguage() {
    const stage = this.runtime.getTargetForStage();
    if (!stage) return this.DEFAULT_LANGUAGE; // If no language has been set, set it to the editor locale (or default).

    if (!stage.textToSpeechLanguage) {
      this.setCurrentLanguage(this.getEditorLanguage());
    }

    return stage.textToSpeechLanguage;
  }
  /**
   * Set the language code for the extension.
   * It is stored in the stage so it can be saved and loaded with the project.
   * @param {string} locale a locale code.
   */


  setCurrentLanguage(locale) {
    const stage = this.runtime.getTargetForStage();
    if (!stage) return;

    if (this.isSupportedLanguage(locale)) {
      stage.textToSpeechLanguage = this._getExtensionLocaleForSupportedLocale(locale);
    } // Support language names dropped onto the menu via reporter block
    // such as a variable containing a language name (in any language),
    // or the translate extension's language reporter.


    const localeForDroppedName = languageNames.nameMap[locale.toLowerCase()];

    if (localeForDroppedName && this.isSupportedLanguage(localeForDroppedName)) {
      stage.textToSpeechLanguage = this._getExtensionLocaleForSupportedLocale(localeForDroppedName);
    } // If the language is null, set it to the default language.
    // This can occur e.g. if the extension was loaded with the editor
    // set to a language that is not in the list.


    if (!stage.textToSpeechLanguage) {
      stage.textToSpeechLanguage = this.DEFAULT_LANGUAGE;
    }
  }
  /**
   * Get the extension locale for a supported locale, or null.
   * @param {string} locale a locale code.
   * @returns {?string} a locale supported by the extension.
   */


  _getExtensionLocaleForSupportedLocale(locale) {
    for (const lang in this.LANGUAGE_INFO) {
      if (this.LANGUAGE_INFO[lang].locales.includes(locale)) {
        return lang;
      }
    }

    log.error("cannot find extension locale for locale ".concat(locale));
  }
  /**
   * Get the locale code used by the speech synthesis server corresponding to
   * the current language code set for the extension.
   * @returns {string} a speech synthesis locale.
   */


  _getSpeechSynthLocale() {
    let speechSynthLocale = this.LANGUAGE_INFO[this.DEFAULT_LANGUAGE].speechSynthLocale;

    if (this.LANGUAGE_INFO[this.getCurrentLanguage()]) {
      speechSynthLocale = this.LANGUAGE_INFO[this.getCurrentLanguage()].speechSynthLocale;
    }

    return speechSynthLocale;
  }
  /**
   * Get an array of the locales supported by this extension.
   * @returns {Array} An array of locale strings.
   */


  _getSupportedLocales() {
    return Object.keys(this.LANGUAGE_INFO).reduce((acc, lang) => acc.concat(this.LANGUAGE_INFO[lang].locales), []);
  }
  /**
   * Check if a Scratch language code is in the list of supported languages for the
   * speech synthesis service.
   * @param {string} languageCode the language code to check.
   * @returns {boolean} true if the language code is supported.
   */


  isSupportedLanguage(languageCode) {
    return this._supportedLocales.includes(languageCode);
  }
  /**
   * Get the menu of voices for the "set voice" block.
   * @return {array} the text and value for each menu item.
   */


  getVoiceMenu() {
    return Object.keys(this.VOICE_INFO).map(voiceId => ({
      text: this.VOICE_INFO[voiceId].name,
      value: voiceId
    }));
  }
  /**
   * Get the localized menu of languages for the "set language" block.
   * For each language:
   *   if there is a custom translated spoken language name, use that;
   *   otherwise use the translation in the languageNames menuMap;
   *   otherwise fall back to the untranslated name in LANGUAGE_INFO.
   * @return {array} the text and value for each menu item.
   */


  getLanguageMenu() {
    const editorLanguage = this.getEditorLanguage(); // Get the array of localized language names

    const localizedNameMap = {};
    let nameArray = languageNames.menuMap[editorLanguage];

    if (nameArray) {
      // Also get any localized names of spoken languages
      let spokenNameArray = [];

      if (languageNames.spokenLanguages) {
        spokenNameArray = languageNames.spokenLanguages[editorLanguage];
        nameArray = nameArray.concat(spokenNameArray);
      } // Create a map of language code to localized name
      // The localized spoken language names have been concatenated onto
      // the end of the name array, so the result of the forEach below is
      // when there is both a written language name (e.g. 'Chinese
      // (simplified)') and a spoken language name (e.g. 'Chinese
      // (Mandarin)', we always use the spoken version.


      nameArray.forEach(lang => {
        localizedNameMap[lang.code] = lang.name;
      });
    }

    return Object.keys(this.LANGUAGE_INFO).map(key => {
      let name = this.LANGUAGE_INFO[key].name;
      const localizedName = localizedNameMap[key];

      if (localizedName) {
        name = localizedName;
      } // Uppercase the first character of the name


      name = name.charAt(0).toUpperCase() + name.slice(1);
      return {
        text: name,
        value: key
      };
    });
  }
  /**
   * Set the voice for speech synthesis for this sprite.
   * @param  {object} args Block arguments
   * @param {object} util Utility object provided by the runtime.
   */


  setVoice(args, util) {
    const state = this._getState(util.target);

    let voice = args.VOICE; // If the arg is a dropped number, treat it as a voice index

    let voiceNum = parseInt(voice, 10);

    if (!isNaN(voiceNum)) {
      voiceNum -= 1; // Treat dropped args as one-indexed

      voiceNum = MathUtil.wrapClamp(voiceNum, 0, Object.keys(this.VOICE_INFO).length - 1);
      voice = Object.keys(this.VOICE_INFO)[voiceNum];
    } // Only set the voice if the arg is a valid voice id.


    if (Object.keys(this.VOICE_INFO).includes(voice)) {
      state.voiceId = voice;
    }
  }
  /**
   * Set the language for speech synthesis.
   * @param  {object} args Block arguments
   */


  setLanguage(args) {
    this.setCurrentLanguage(args.LANGUAGE);
  }
  /**
   * Stop all currently playing speech sounds.
   */


  _stopAllSpeech() {
    this._soundPlayers.forEach(player => {
      player.stop();
    });
  }
  /**
   * Convert the provided text into a sound file and then play the file.
   * @param  {object} args Block arguments
   * @param {object} util Utility object provided by the runtime.
   * @return {Promise} A promise that resolves after playing the sound
   */


  speakAndWait(args, util) {
    // Cast input to string
    let words = Cast.toString(args.WORDS);

    let locale = this._getSpeechSynthLocale();

    const state = this._getState(util.target);

    let gender = this.VOICE_INFO[state.voiceId].gender;
    let playbackRate = this.VOICE_INFO[state.voiceId].playbackRate; // Special case for voices where the synthesis service only provides a
    // single gender voice. In that case, always request the female voice,
    // and set special playback rates for the tenor and giant voices.

    if (this.LANGUAGE_INFO[this.getCurrentLanguage()].singleGender) {
      gender = 'female';

      if (state.voiceId === TENOR_ID) {
        playbackRate = FEMALE_TENOR_RATE;
      }

      if (state.voiceId === GIANT_ID) {
        playbackRate = FEMALE_GIANT_RATE;
      }
    }

    if (state.voiceId === KITTEN_ID) {
      words = words.replace(/\S+/g, 'meow');
      locale = this.LANGUAGE_INFO[this.DEFAULT_LANGUAGE].speechSynthLocale;
    } // Build up URL


    let path = "".concat(SERVER_HOST, "/synth");
    path += "?locale=".concat(locale);
    path += "&gender=".concat(gender);
    path += "&text=".concat(encodeURIComponent(words.substring(0, 128))); // Perform HTTP request to get audio file

    return fetchWithTimeout(path, {}, SERVER_TIMEOUT).then(res => {
      if (res.status !== 200) {
        throw new Error("HTTP ".concat(res.status, " error reaching translation service"));
      }

      return res.arrayBuffer();
    }).then(buffer => {
      // Play the sound
      const sound = {
        data: {
          buffer
        }
      };
      return this.runtime.audioEngine.decodeSoundPlayer(sound);
    }).then(soundPlayer => {
      this._soundPlayers.set(soundPlayer.id, soundPlayer);

      soundPlayer.setPlaybackRate(playbackRate); // Increase the volume

      const engine = this.runtime.audioEngine;
      const chain = engine.createEffectChain();
      chain.set('volume', SPEECH_VOLUME);
      soundPlayer.connect(chain);
      soundPlayer.play();
      return new Promise(resolve => {
        soundPlayer.on('stop', () => {
          this._soundPlayers.delete(soundPlayer.id);

          resolve();
        });
      });
    }).catch(err => {
      log.warn(err);
    });
  }

}

module.exports = Scratch3Text2SpeechBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_translate/index.js":
/*!****************************************************!*\
  !*** ./src/extensions/scratch3_translate/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const Cast = __webpack_require__(/*! ../../util/cast */ "./src/util/cast.js");

const log = __webpack_require__(/*! ../../util/log */ "./src/util/log.js");

const fetchWithTimeout = __webpack_require__(/*! ../../util/fetch-with-timeout */ "./src/util/fetch-with-timeout.js");

const languageNames = __webpack_require__(/*! scratch-translate-extension-languages */ "./node_modules/scratch-translate-extension-languages/languages.json");

const formatMessage = __webpack_require__(/*! format-message */ "format-message");
/**
 * Icon svg to be displayed in the blocks category menu, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const menuIconURI = 'data:image/png;base64,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';
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len

const blockIconURI = 'data:image/png;base64,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';
/**
 * The url of the translate server.
 * @type {string}
 */

const serverURL = 'https://trampoline.turbowarp.org/translate/';
/**
 * How long to wait in ms before timing out requests to translate server.
 * @type {int}
 */

const serverTimeoutMs = 10000; // 10 seconds (chosen arbitrarily).

/**
 * Class for the translate block in Scratch 3.0.
 * @constructor
 */

class Scratch3TranslateBlocks {
  constructor() {
    /**
     * Language code of the viewer, based on their locale.
     * @type {string}
     * @private
     */
    this._viewerLanguageCode = this.getViewerLanguageCode();
    /**
     * List of supported language name and language code pairs, for use in the block menu.
     * Filled in by getInfo so it is updated when the interface language changes.
     * @type {Array.<object.<string, string>>}
     * @private
     */

    this._supportedLanguages = [];
    /**
     * A randomly selected language code, for use as the default value in the language menu.
     * Properly filled in getInfo so it is updated when the interface languages changes.
     * @type {string}
     * @private
     */

    this._randomLanguageCode = 'en';
    /**
     * The result from the most recent translation.
     * @type {string}
     * @private
     */

    this._translateResult = '';
    /**
     * The language of the text most recently translated.
     * @type {string}
     * @private
     */

    this._lastLangTranslated = '';
    /**
     * The text most recently translated.
     * @type {string}
     * @private
     */

    this._lastTextTranslated = '';
  }
  /**
   * The key to load & store a target's translate state.
   * @return {string} The key.
   */


  static get STATE_KEY() {
    return 'Scratch.translate';
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    this._supportedLanguages = this._getSupportedLanguages(this.getViewerLanguageCode());
    this._randomLanguageCode = this._supportedLanguages[Math.floor(Math.random() * this._supportedLanguages.length)].value;
    return {
      id: 'translate',
      name: formatMessage({
        id: 'translate.categoryName',
        default: 'Translate',
        description: 'Name of extension that adds translate blocks'
      }),
      blockIconURI: blockIconURI,
      menuIconURI: menuIconURI,
      blocks: [{
        opcode: 'getTranslate',
        text: formatMessage({
          id: 'translate.translateBlock',
          default: 'translate [WORDS] to [LANGUAGE]',
          description: 'translate some text to a different language'
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          WORDS: {
            type: ArgumentType.STRING,
            defaultValue: formatMessage({
              id: 'translate.defaultTextToTranslate',
              default: 'hello',
              description: 'hello: the default text to translate'
            })
          },
          LANGUAGE: {
            type: ArgumentType.STRING,
            menu: 'languages',
            defaultValue: this._randomLanguageCode
          }
        }
      }, {
        opcode: 'getViewerLanguage',
        text: formatMessage({
          id: 'translate.viewerLanguage',
          default: 'language',
          description: 'the languge of the project viewer'
        }),
        blockType: BlockType.REPORTER,
        arguments: {}
      }],
      menus: {
        languages: {
          acceptReporters: true,
          items: this._supportedLanguages
        }
      }
    };
  }
  /**
   * Computes a list of language code and name pairs for the given language.
   * @param {string} code The language code to get the list of language pairs
   * @return {Array.<object.<string, string>>} An array of languge name and
   *   language code pairs.
   * @private
   */


  _getSupportedLanguages(code) {
    return languageNames.menuMap[code].map(entry => {
      const obj = {
        text: entry.name,
        value: entry.code
      };
      return obj;
    });
  }
  /**
   * Get the human readable language value for the reporter block.
   * @return {string} the language name of the project viewer.
   */


  getViewerLanguage() {
    this._viewerLanguageCode = this.getViewerLanguageCode();
    const names = languageNames.menuMap[this._viewerLanguageCode];
    let langNameObj = names.find(obj => obj.code === this._viewerLanguageCode); // If we don't have a name entry yet, try looking it up via the Google langauge
    // code instead of Scratch's (e.g. for es-419 we look up es to get espanol)

    if (!langNameObj && languageNames.scratchToGoogleMap[this._viewerLanguageCode]) {
      const lookupCode = languageNames.scratchToGoogleMap[this._viewerLanguageCode];
      langNameObj = names.find(obj => obj.code === lookupCode);
    }

    let langName = this._viewerLanguageCode;

    if (langNameObj) {
      langName = langNameObj.name;
    }

    return langName;
  }
  /**
   * Get the viewer's language code.
   * @return {string} the language code.
   */


  getViewerLanguageCode() {
    const locale = formatMessage.setup().locale;
    const viewerLanguages = [locale].concat(navigator.languages);
    const languageKeys = Object.keys(languageNames.menuMap); // Return the first entry in viewerLanguages that matches
    // one of the available language keys.

    const languageCode = viewerLanguages.reduce((acc, lang) => {
      if (acc) {
        return acc;
      }

      if (languageKeys.indexOf(lang.toLowerCase()) > -1) {
        return lang;
      }

      return acc;
    }, '') || 'en';
    return languageCode.toLowerCase();
  }
  /**
   * Get a language code from a block argument. The arg can be a language code
   * or a language name, written in any language.
   * @param  {object} arg A block argument.
   * @return {string} A language code.
   */


  getLanguageCodeFromArg(arg) {
    const languageArg = Cast.toString(arg).toLowerCase(); // Check if the arg matches a language code in the menu.

    if (languageNames.menuMap.hasOwnProperty(languageArg)) {
      return languageArg;
    } // Check for a dropped-in language name, and convert to a language code.


    if (languageNames.nameMap.hasOwnProperty(languageArg)) {
      return languageNames.nameMap[languageArg];
    } // There are some languages we launched in the language menu that Scratch did not
    // end up launching in. In order to keep projects that may have had that menu item
    // working, check for those language codes and let them through.
    // Examples: 'ab', 'hi'.


    if (languageNames.previouslySupported.indexOf(languageArg) !== -1) {
      return languageArg;
    } // Default to English.


    return 'en';
  }
  /**
   * Translates the text in the translate block to the language specified in the menu.
   * @param {object} args - the block arguments.
   * @return {Promise} - a promise that resolves after the response from the translate server.
   */


  getTranslate(args) {
    // If the text contains only digits 0-9 and nothing else, return it without
    // making a request.
    if (/^\d+$/.test(args.WORDS)) return Promise.resolve(args.WORDS); // Don't remake the request if we already have the value.

    if (this._lastTextTranslated === args.WORDS && this._lastLangTranslated === args.LANGUAGE) {
      return this._translateResult;
    }

    const lang = this.getLanguageCodeFromArg(args.LANGUAGE);
    let urlBase = "".concat(serverURL, "translate?language=");
    urlBase += lang;
    urlBase += '&text=';
    urlBase += encodeURIComponent(args.WORDS);
    const tempThis = this;
    const translatePromise = fetchWithTimeout(urlBase, {}, serverTimeoutMs).then(response => response.text()).then(responseText => {
      const translated = JSON.parse(responseText).result;
      tempThis._translateResult = translated; // Cache what we just translated so we don't keep making the
      // same call over and over.

      tempThis._lastTextTranslated = args.WORDS;
      tempThis._lastLangTranslated = args.LANGUAGE;
      return translated;
    }).catch(err => {
      log.warn("error fetching translate result! ".concat(err));
      return '';
    });
    return translatePromise;
  }

}

module.exports = Scratch3TranslateBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_video_sensing/index.js":
/*!********************************************************!*\
  !*** ./src/extensions/scratch3_video_sensing/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Runtime = __webpack_require__(/*! ../../engine/runtime */ "./src/engine/runtime.js");

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const Clone = __webpack_require__(/*! ../../util/clone */ "./src/util/clone.js");

const Cast = __webpack_require__(/*! ../../util/cast */ "./src/util/cast.js");

const formatMessage = __webpack_require__(/*! format-message */ "format-message");

const Video = __webpack_require__(/*! ../../io/video */ "./src/io/video.js");

const VideoMotion = __webpack_require__(/*! ./library */ "./src/extensions/scratch3_video_sensing/library.js");
/**
 * Icon svg to be displayed in the blocks category menu, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const menuIconURI = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjBweCIgaGVpZ2h0PSIyMHB4IiB2aWV3Qm94PSIwIDAgMjAgMjAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDUyLjIgKDY3MTQ1KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5FeHRlbnNpb25zL1NvZnR3YXJlL1ZpZGVvLVNlbnNpbmctTWVudTwvdGl0bGU+CiAgICA8ZGVzYz5DcmVhdGVkIHdpdGggU2tldGNoLjwvZGVzYz4KICAgIDxnIGlkPSJFeHRlbnNpb25zL1NvZnR3YXJlL1ZpZGVvLVNlbnNpbmctTWVudSIgc3Ryb2tlPSJub25lIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCI+CiAgICAgICAgPGcgaWQ9InZpZGVvLW1vdGlvbiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDUuMDAwMDAwKSIgZmlsbC1ydWxlPSJub256ZXJvIj4KICAgICAgICAgICAgPGNpcmNsZSBpZD0iT3ZhbC1Db3B5IiBmaWxsPSIjMEVCRDhDIiBvcGFjaXR5PSIwLjI1IiBjeD0iMTYiIGN5PSI4IiByPSIyIj48L2NpcmNsZT4KICAgICAgICAgICAgPGNpcmNsZSBpZD0iT3ZhbC1Db3B5IiBmaWxsPSIjMEVCRDhDIiBvcGFjaXR5PSIwLjUiIGN4PSIxNiIgY3k9IjYiIHI9IjIiPjwvY2lyY2xlPgogICAgICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsLUNvcHkiIGZpbGw9IiMwRUJEOEMiIG9wYWNpdHk9IjAuNzUiIGN4PSIxNiIgY3k9IjQiIHI9IjIiPjwvY2lyY2xlPgogICAgICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsIiBmaWxsPSIjMEVCRDhDIiBjeD0iMTYiIGN5PSIyIiByPSIyIj48L2NpcmNsZT4KICAgICAgICAgICAgPHBhdGggZD0iTTExLjMzNTk3MzksMi4yMDk3ODgyNSBMOC4yNSw0LjIwOTk1NjQ5IEw4LjI1LDMuMDUgQzguMjUsMi4wNDQ4ODIyNyA3LjQ2ODU5MDMxLDEuMjUgNi41LDEuMjUgTDIuMDUsMS4yNSBDMS4wMzgwNzExOSwxLjI1IDAuMjUsMi4wMzgwNzExOSAwLjI1LDMuMDUgTDAuMjUsNyBDMC4yNSw3Ljk2MzY5OTM3IDEuMDQyMjQ5MTksOC43NTU5NDg1NiAyLjA1LDguOCBMNi41LDguOCBDNy40NTA4MzAwOSw4LjggOC4yNSw3Ljk3MzI3MjUgOC4yNSw3IEw4LjI1LDUuODU4NDUyNDEgTDguNjI4NjIzOTQsNi4wODU2MjY3NyBMMTEuNDI2Nzc2Nyw3Ljc3MzIyMzMgQzExLjQzNjg5NDMsNy43ODMzNDA5MSAxMS40NzU3NjU1LDcuOCAxMS41LDcuOCBDMTEuNjMzNDkzMiw3LjggMTEuNzUsNy42OTEyNjAzNCAxMS43NSw3LjU1IEwxMS43NSwyLjQgQzExLjc1LDIuNDE4MzgyNjkgMTEuNzIxOTAyOSwyLjM1MjgyMjgyIDExLjY4NTYyNjgsMi4yNzg2MjM5NCBDMTEuNjEyOTUyOCwyLjE1NzUwMDY5IDExLjQ3MDc5NjgsMi4xMjkwNjk1IDExLjMzNTk3MzksMi4yMDk3ODgyNSBaIiBpZD0idmlkZW9fMzdfIiBzdHJva2Utb3BhY2l0eT0iMC4xNSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNSIgZmlsbD0iIzRENEQ0RCI+PC9wYXRoPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+';
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len

const blockIconURI = 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iNDBweCIgaGVpZ2h0PSI0MHB4IiB2aWV3Qm94PSIwIDAgNDAgNDAiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDUyLjIgKDY3MTQ1KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5FeHRlbnNpb25zL1NvZnR3YXJlL1ZpZGVvLVNlbnNpbmctQmxvY2s8L3RpdGxlPgogICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+CiAgICA8ZyBpZD0iRXh0ZW5zaW9ucy9Tb2Z0d2FyZS9WaWRlby1TZW5zaW5nLUJsb2NrIiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2Utb3BhY2l0eT0iMC4xNSI+CiAgICAgICAgPGcgaWQ9InZpZGVvLW1vdGlvbiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsIDEwLjAwMDAwMCkiIGZpbGwtcnVsZT0ibm9uemVybyIgc3Ryb2tlPSIjMDAwMDAwIj4KICAgICAgICAgICAgPGNpcmNsZSBpZD0iT3ZhbC1Db3B5IiBmaWxsPSIjRkZGRkZGIiBvcGFjaXR5PSIwLjI1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGN4PSIzMiIgY3k9IjE2IiByPSI0LjUiPjwvY2lyY2xlPgogICAgICAgICAgICA8Y2lyY2xlIGlkPSJPdmFsLUNvcHkiIGZpbGw9IiNGRkZGRkYiIG9wYWNpdHk9IjAuNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjeD0iMzIiIGN5PSIxMiIgcj0iNC41Ij48L2NpcmNsZT4KICAgICAgICAgICAgPGNpcmNsZSBpZD0iT3ZhbC1Db3B5IiBmaWxsPSIjRkZGRkZGIiBvcGFjaXR5PSIwLjc1IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGN4PSIzMiIgY3k9IjgiIHI9IjQuNSI+PC9jaXJjbGU+CiAgICAgICAgICAgIDxjaXJjbGUgaWQ9Ik92YWwiIGZpbGw9IiNGRkZGRkYiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgY3g9IjMyIiBjeT0iNCIgcj0iNC41Ij48L2NpcmNsZT4KICAgICAgICAgICAgPHBhdGggZD0iTTIyLjY3MTk0NzcsNC40MTk1NzY0OSBMMTYuNSw4LjQxOTkxMjk4IEwxNi41LDYuMSBDMTYuNSw0LjA4OTc2NDU0IDE0LjkzNzE4MDYsMi41IDEzLDIuNSBMNC4xLDIuNSBDMi4wNzYxNDIzNywyLjUgMC41LDQuMDc2MTQyMzcgMC41LDYuMSBMMC41LDE0IEMwLjUsMTUuOTI3Mzk4NyAyLjA4NDQ5ODM5LDE3LjUxMTg5NzEgNC4xLDE3LjYgTDEzLDE3LjYgQzE0LjkwMTY2MDIsMTcuNiAxNi41LDE1Ljk0NjU0NSAxNi41LDE0IEwxNi41LDExLjcxNjkwNDggTDIyLjc1NzI0NzksMTUuNDcxMjUzNSBMMjIuODUzNTUzNCwxNS41NDY0NDY2IEMyMi44NzM3ODg2LDE1LjU2NjY4MTggMjIuOTUxNTMxLDE1LjYgMjMsMTUuNiBDMjMuMjY2OTg2NSwxNS42IDIzLjUsMTUuMzgyNTIwNyAyMy41LDE1LjEgTDIzLjUsNC44IEMyMy41LDQuODM2NzY1MzggMjMuNDQzODA1OCw0LjcwNTY0NTYzIDIzLjM3MTI1MzUsNC41NTcyNDc4OCBDMjMuMjI1OTA1Niw0LjMxNTAwMTM5IDIyLjk0MTU5MzcsNC4yNTgxMzg5OSAyMi42NzE5NDc3LDQuNDE5NTc2NDkgWiIgaWQ9InZpZGVvXzM3XyIgZmlsbD0iIzRENEQ0RCI+PC9wYXRoPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zdmc+';
/**
 * Sensor attribute video sensor block should report.
 * @readonly
 * @enum {string}
 */

const SensingAttribute = {
  /** The amount of motion. */
  MOTION: 'motion',

  /** The direction of the motion. */
  DIRECTION: 'direction'
};
/**
 * Subject video sensor block should report for.
 * @readonly
 * @enum {string}
 */

const SensingSubject = {
  /** The sensor traits of the whole stage. */
  STAGE: 'Stage',

  /** The senosr traits of the area overlapped by this sprite. */
  SPRITE: 'this sprite'
};
/**
 * States the video sensing activity can be set to.
 * @readonly
 * @enum {string}
 */

const VideoState = {
  /** Video turned off. */
  OFF: 'off',

  /** Video turned on with default y axis mirroring. */
  ON: 'on',

  /** Video turned on without default y axis mirroring. */
  ON_FLIPPED: 'on-flipped'
};
/**
 * Class for the motion-related blocks in Scratch 3.0
 * @param {Runtime} runtime - the runtime instantiating this block package.
 * @constructor
 */

class Scratch3VideoSensingBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
    /**
     * The motion detection algoritm used to power the motion amount and
     * direction values.
     * @type {VideoMotion}
     */

    this.detect = new VideoMotion();
    /**
     * The last millisecond epoch timestamp that the video stream was
     * analyzed.
     * @type {number}
     */

    this._lastUpdate = null;
    /**
     * A flag to determine if this extension has been installed in a project.
     * It is set to false the first time getInfo is run.
     * @type {boolean}
     */

    this.firstInstall = true;

    if (this.runtime.ioDevices) {
      // Configure the video device with values from globally stored locations.
      this.runtime.on(Runtime.PROJECT_LOADED, this.updateVideoDisplay.bind(this)); // Clear target motion state values when the project starts.

      this.runtime.on(Runtime.PROJECT_RUN_START, this.reset.bind(this)); // Kick off looping the analysis logic.

      this._loop();
    }
  }
  /**
   * After analyzing a frame the amount of milliseconds until another frame
   * is analyzed.
   * @type {number}
   */


  static get INTERVAL() {
    return 33;
  }
  /**
   * Dimensions the video stream is analyzed at after its rendered to the
   * sample canvas.
   * @type {Array.<number>}
   */


  static get DIMENSIONS() {
    return [480, 360];
  }
  /**
   * The key to load & store a target's motion-related state.
   * @type {string}
   */


  static get STATE_KEY() {
    return 'Scratch.videoSensing';
  }
  /**
   * The default motion-related state, to be used when a target has no existing motion state.
   * @type {MotionState}
   */


  static get DEFAULT_MOTION_STATE() {
    return {
      motionFrameNumber: 0,
      motionAmount: 0,
      motionDirection: 0
    };
  }
  /**
   * The transparency setting of the video preview stored in a value
   * accessible by any object connected to the virtual machine.
   * @type {number}
   */


  get globalVideoTransparency() {
    const stage = this.runtime.getTargetForStage();

    if (stage) {
      return stage.videoTransparency;
    }

    return 50;
  }

  set globalVideoTransparency(transparency) {
    const stage = this.runtime.getTargetForStage();

    if (stage) {
      stage.videoTransparency = transparency;
    }

    return transparency;
  }
  /**
   * The video state of the video preview stored in a value accessible by any
   * object connected to the virtual machine.
   * @type {number}
   */


  get globalVideoState() {
    const stage = this.runtime.getTargetForStage();

    if (stage) {
      return stage.videoState;
    } // Though the default value for the stage is normally 'on', we need to default
    // to 'off' here to prevent the video device from briefly activating
    // while waiting for stage targets to be installed that say it should be off


    return VideoState.OFF;
  }

  set globalVideoState(state) {
    const stage = this.runtime.getTargetForStage();

    if (stage) {
      stage.videoState = state;
    }

    return state;
  }
  /**
   * Get the latest values for video transparency and state,
   * and set the video device to use them.
   */


  updateVideoDisplay() {
    this.setVideoTransparency({
      TRANSPARENCY: this.globalVideoTransparency
    });
    this.videoToggle({
      VIDEO_STATE: this.globalVideoState
    });
  }
  /**
   * Reset the extension's data motion detection data. This will clear out
   * for example old frames, so the first analyzed frame will not be compared
   * against a frame from before reset was called.
   */


  reset() {
    this.detect.reset();
    const targets = this.runtime.targets;

    for (let i = 0; i < targets.length; i++) {
      const state = targets[i].getCustomState(Scratch3VideoSensingBlocks.STATE_KEY);

      if (state) {
        state.motionAmount = 0;
        state.motionDirection = 0;
      }
    }
  }
  /**
   * Occasionally step a loop to sample the video, stamp it to the preview
   * skin, and add a TypedArray copy of the canvas's pixel data.
   * @private
   */


  _loop() {
    setTimeout(this._loop.bind(this), Math.max(this.runtime.currentStepTime, Scratch3VideoSensingBlocks.INTERVAL)); // Add frame to detector

    const time = Date.now();

    if (this._lastUpdate === null) {
      this._lastUpdate = time;
    }

    const offset = time - this._lastUpdate;

    if (offset > Scratch3VideoSensingBlocks.INTERVAL) {
      const frame = this.runtime.ioDevices.video.getFrame({
        format: Video.FORMAT_IMAGE_DATA,
        dimensions: Scratch3VideoSensingBlocks.DIMENSIONS
      });

      if (frame) {
        this._lastUpdate = time;
        this.detect.addFrame(frame.data);
      }
    }
  }
  /**
   * Create data for a menu in scratch-blocks format, consisting of an array
   * of objects with text and value properties. The text is a translated
   * string, and the value is one-indexed.
   * @param {object[]} info - An array of info objects each having a name
   *   property.
   * @return {array} - An array of objects with text and value properties.
   * @private
   */


  _buildMenu(info) {
    return info.map((entry, index) => {
      const obj = {};
      obj.text = entry.name;
      obj.value = entry.value || String(index + 1);
      return obj;
    });
  }
  /**
   * @param {Target} target - collect motion state for this target.
   * @returns {MotionState} the mutable motion state associated with that
   *   target. This will be created if necessary.
   * @private
   */


  _getMotionState(target) {
    let motionState = target.getCustomState(Scratch3VideoSensingBlocks.STATE_KEY);

    if (!motionState) {
      motionState = Clone.simple(Scratch3VideoSensingBlocks.DEFAULT_MOTION_STATE);
      target.setCustomState(Scratch3VideoSensingBlocks.STATE_KEY, motionState);
    }

    return motionState;
  }

  static get SensingAttribute() {
    return SensingAttribute;
  }
  /**
   * An array of choices of whether a reporter should return the frame's
   * motion amount or direction.
   * @type {object[]}
   * @param {string} name - the translatable name to display in sensor
   *   attribute menu
   * @param {string} value - the serializable value of the attribute
   */


  get ATTRIBUTE_INFO() {
    return [{
      name: formatMessage({
        id: 'videoSensing.motion',
        default: 'motion',
        description: 'Attribute for the "video [ATTRIBUTE] on [SUBJECT]" block'
      }),
      value: SensingAttribute.MOTION
    }, {
      name: formatMessage({
        id: 'videoSensing.direction',
        default: 'direction',
        description: 'Attribute for the "video [ATTRIBUTE] on [SUBJECT]" block'
      }),
      value: SensingAttribute.DIRECTION
    }];
  }

  static get SensingSubject() {
    return SensingSubject;
  }
  /**
   * An array of info about the subject choices.
   * @type {object[]}
   * @param {string} name - the translatable name to display in the subject menu
   * @param {string} value - the serializable value of the subject
   */


  get SUBJECT_INFO() {
    return [{
      name: formatMessage({
        id: 'videoSensing.sprite',
        default: 'sprite',
        description: 'Subject for the "video [ATTRIBUTE] on [SUBJECT]" block'
      }),
      value: SensingSubject.SPRITE
    }, {
      name: formatMessage({
        id: 'videoSensing.stage',
        default: 'stage',
        description: 'Subject for the "video [ATTRIBUTE] on [SUBJECT]" block'
      }),
      value: SensingSubject.STAGE
    }];
  }
  /**
   * States the video sensing activity can be set to.
   * @readonly
   * @enum {string}
   */


  static get VideoState() {
    return VideoState;
  }
  /**
   * An array of info on video state options for the "turn video [STATE]" block.
   * @type {object[]}
   * @param {string} name - the translatable name to display in the video state menu
   * @param {string} value - the serializable value stored in the block
   */


  get VIDEO_STATE_INFO() {
    return [{
      name: formatMessage({
        id: 'videoSensing.off',
        default: 'off',
        description: 'Option for the "turn video [STATE]" block'
      }),
      value: VideoState.OFF
    }, {
      name: formatMessage({
        id: 'videoSensing.on',
        default: 'on',
        description: 'Option for the "turn video [STATE]" block'
      }),
      value: VideoState.ON
    }, {
      name: formatMessage({
        id: 'videoSensing.onFlipped',
        default: 'on flipped',
        description: 'Option for the "turn video [STATE]" block that causes the video to be flipped' + ' horizontally (reversed as in a mirror)'
      }),
      value: VideoState.ON_FLIPPED
    }];
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    // Set the video display properties to defaults the first time
    // getInfo is run. This turns on the video device when it is
    // first added to a project, and is overwritten by a PROJECT_LOADED
    // event listener that later calls updateVideoDisplay
    if (this.firstInstall) {
      this.globalVideoState = VideoState.ON;
      this.globalVideoTransparency = 50;
      this.updateVideoDisplay();
      this.firstInstall = false;
    } // Return extension definition


    return {
      id: 'videoSensing',
      name: formatMessage({
        id: 'videoSensing.categoryName',
        default: 'Video Sensing',
        description: 'Label for the video sensing extension category'
      }),
      blockIconURI: blockIconURI,
      menuIconURI: menuIconURI,
      blocks: [{
        // @todo this hat needs to be set itself to restart existing
        // threads like Scratch 2's behaviour.
        opcode: 'whenMotionGreaterThan',
        text: formatMessage({
          id: 'videoSensing.whenMotionGreaterThan',
          default: 'when video motion > [REFERENCE]',
          description: 'Event that triggers when the amount of motion is greater than [REFERENCE]'
        }),
        blockType: BlockType.HAT,
        arguments: {
          REFERENCE: {
            type: ArgumentType.NUMBER,
            defaultValue: 10
          }
        }
      }, {
        opcode: 'videoOn',
        blockType: BlockType.REPORTER,
        text: formatMessage({
          id: 'videoSensing.videoOn',
          default: 'video [ATTRIBUTE] on [SUBJECT]',
          description: 'Reporter that returns the amount of [ATTRIBUTE] for the selected [SUBJECT]'
        }),
        arguments: {
          ATTRIBUTE: {
            type: ArgumentType.NUMBER,
            menu: 'ATTRIBUTE',
            defaultValue: SensingAttribute.MOTION
          },
          SUBJECT: {
            type: ArgumentType.NUMBER,
            menu: 'SUBJECT',
            defaultValue: SensingSubject.SPRITE
          }
        }
      }, {
        opcode: 'videoToggle',
        text: formatMessage({
          id: 'videoSensing.videoToggle',
          default: 'turn video [VIDEO_STATE]',
          description: 'Controls display of the video preview layer'
        }),
        arguments: {
          VIDEO_STATE: {
            type: ArgumentType.NUMBER,
            menu: 'VIDEO_STATE',
            defaultValue: VideoState.ON
          }
        }
      }, {
        opcode: 'setVideoTransparency',
        text: formatMessage({
          id: 'videoSensing.setVideoTransparency',
          default: 'set video transparency to [TRANSPARENCY]',
          description: 'Controls transparency of the video preview layer'
        }),
        arguments: {
          TRANSPARENCY: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        }
      }],
      menus: {
        ATTRIBUTE: {
          acceptReporters: true,
          items: this._buildMenu(this.ATTRIBUTE_INFO)
        },
        SUBJECT: {
          acceptReporters: true,
          items: this._buildMenu(this.SUBJECT_INFO)
        },
        VIDEO_STATE: {
          acceptReporters: true,
          items: this._buildMenu(this.VIDEO_STATE_INFO)
        }
      }
    };
  }
  /**
   * Analyze a part of the frame that a target overlaps.
   * @param {Target} target - a target to determine where to analyze
   * @returns {MotionState} the motion state for the given target
   */


  _analyzeLocalMotion(target) {
    const drawable = this.runtime.renderer._allDrawables[target.drawableID];

    const state = this._getMotionState(target);

    this.detect.getLocalMotion(drawable, state);
    return state;
  }
  /**
   * A scratch reporter block handle that analyzes the last two frames and
   * depending on the arguments, returns the motion or direction for the
   * whole stage or just the target sprite.
   * @param {object} args - the block arguments
   * @param {BlockUtility} util - the block utility
   * @returns {number} the motion amount or direction of the stage or sprite
   */


  videoOn(args, util) {
    this.detect.analyzeFrame();
    let state = this.detect;

    if (args.SUBJECT === SensingSubject.SPRITE) {
      state = this._analyzeLocalMotion(util.target);
    }

    if (args.ATTRIBUTE === SensingAttribute.MOTION) {
      return state.motionAmount;
    }

    return state.motionDirection;
  }
  /**
   * A scratch hat block edge handle that analyzes the last two frames where
   * the target sprite overlaps and if it has more motion than the given
   * reference value.
   * @param {object} args - the block arguments
   * @param {BlockUtility} util - the block utility
   * @returns {boolean} true if the sprite overlaps more motion than the
   *   reference
   */


  whenMotionGreaterThan(args, util) {
    this.detect.analyzeFrame();

    const state = this._analyzeLocalMotion(util.target);

    return state.motionAmount > Number(args.REFERENCE);
  }
  /**
   * A scratch command block handle that configures the video state from
   * passed arguments.
   * @param {object} args - the block arguments
   * @param {VideoState} args.VIDEO_STATE - the video state to set the device to
   */


  videoToggle(args) {
    const state = args.VIDEO_STATE;
    this.globalVideoState = state;

    if (state === VideoState.OFF) {
      this.runtime.ioDevices.video.disableVideo();
    } else {
      this.runtime.ioDevices.video.enableVideo(); // Mirror if state is ON. Do not mirror if state is ON_FLIPPED.

      this.runtime.ioDevices.video.mirror = state === VideoState.ON;
    }
  }
  /**
   * A scratch command block handle that configures the video preview's
   * transparency from passed arguments.
   * @param {object} args - the block arguments
   * @param {number} args.TRANSPARENCY - the transparency to set the video
   *   preview to
   */


  setVideoTransparency(args) {
    const transparency = Cast.toNumber(args.TRANSPARENCY);
    this.globalVideoTransparency = transparency;
    this.runtime.ioDevices.video.setPreviewGhost(transparency);
  }

}

module.exports = Scratch3VideoSensingBlocks;

/***/ }),

/***/ "./src/extensions/scratch3_video_sensing/library.js":
/*!**********************************************************!*\
  !*** ./src/extensions/scratch3_video_sensing/library.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @file library.js
 *
 * Tony Hwang and John Maloney, January 2011
 * Michael "Z" Goddard, March 2018
 *
 * Video motion sensing primitives.
 */
const {
  motionVector,
  scratchAtan2
} = __webpack_require__(/*! ./math */ "./src/extensions/scratch3_video_sensing/math.js");
/**
 * The width of the intended resolution to analyze for motion.
 * @type {number}
 */


const WIDTH = 480;
/**
 * The height of the intended resolution to analyze for motion.
 * @type {number}
 */

const HEIGHT = 360;
/**
 * A constant value to scale the magnitude of the x and y components called u
 * and v. This creates the motionAmount value.
 *
 * Old note: chosen empirically to give a range of roughly 0-100
 *
 * @type {number}
 */

const AMOUNT_SCALE = 100;
/**
 * A constant value to scale the magnitude of the x and y components called u
 * and v in the local motion derivative. This creates the motionAmount value on
 * a target's motion state.
 *
 * Old note: note 2e-4 * activePixelNum is an experimentally tuned threshold
 * for my logitech Pro 9000 webcam - TTH
 *
 * @type {number}
 */

const LOCAL_AMOUNT_SCALE = AMOUNT_SCALE * 2e-4;
/**
 * The motion amount must be higher than the THRESHOLD to calculate a new
 * direction value.
 * @type {number}
 */

const THRESHOLD = 10;
/**
 * The size of the radius of the window of summarized values when considering
 * the motion inside the full resolution of the sample.
 * @type {number}
 */

const WINSIZE = 8;
/**
 * A ceiling for the motionAmount stored to a local target's motion state. The
 * motionAmount is not allowed to be larger than LOCAL_MAX_AMOUNT.
 * @type {number}
 */

const LOCAL_MAX_AMOUNT = 100;
/**
 * The motion amount for a target's local motion must be higher than the
 * LOCAL_THRESHOLD to calculate a new direction value.
 * @type {number}
 */

const LOCAL_THRESHOLD = THRESHOLD / 3;
/**
 * Store the necessary image pixel data to compares frames of a video and
 * detect an amount and direction of motion in the full sample or in a
 * specified area.
 * @constructor
 */

class VideoMotion {
  constructor() {
    /**
     * The number of frames that have been added from a source.
     * @type {number}
     */
    this.frameNumber = 0;
    /**
     * The frameNumber last analyzed.
     * @type {number}
     */

    this.lastAnalyzedFrame = 0;
    /**
     * The amount of motion detected in the current frame.
     * @type {number}
     */

    this.motionAmount = 0;
    /**
     * The direction the motion detected in the frame is general moving in.
     * @type {number}
     */

    this.motionDirection = 0;
    /**
     * A copy of the current frame's pixel values. A index of the array is
     * represented in RGBA. The lowest byte is red. The next is green. The
     * next is blue. And the last is the alpha value of that pixel.
     * @type {Uint32Array}
     */

    this.curr = null;
    /**
     * A copy of the last frame's pixel values.
     * @type {Uint32Array}
     */

    this.prev = null;
    /**
     * A buffer for holding one component of a pixel's full value twice.
     * One for the current value. And one for the last value.
     * @type {number}
     */

    this._arrays = new ArrayBuffer(WIDTH * HEIGHT * 2 * 1);
    /**
     * A clamped uint8 view of _arrays. One component of each index of the
     * curr member is copied into this array.
     * @type {number}
     */

    this._curr = new Uint8ClampedArray(this._arrays, WIDTH * HEIGHT * 0 * 1, WIDTH * HEIGHT);
    /**
     * A clamped uint8 view of _arrays. One component of each index of the
     * prev member is copied into this array.
     * @type {number}
     */

    this._prev = new Uint8ClampedArray(this._arrays, WIDTH * HEIGHT * 1 * 1, WIDTH * HEIGHT);
  }
  /**
   * Reset internal state so future frame analysis does not consider values
   * from before this method was called.
   */


  reset() {
    this.frameNumber = 0;
    this.lastAnalyzedFrame = 0;
    this.motionAmount = this.motionDirection = 0;
    this.prev = this.curr = null;
  }
  /**
   * Add a frame to be next analyzed. The passed array represent a pixel with
   * each index in the RGBA format.
   * @param {Uint32Array} source - a source frame of pixels to copy
   */


  addFrame(source) {
    this.frameNumber++; // Swap curr to prev.

    this.prev = this.curr; // Create a clone of the array so any modifications made to the source
    // array do not affect the work done in here.

    this.curr = new Uint32Array(source.buffer.slice(0)); // Swap _prev and _curr. Copy one of the color components of the new
    // array into _curr overwriting what was the old _prev data.

    const _tmp = this._prev;
    this._prev = this._curr;
    this._curr = _tmp;

    for (let i = 0; i < this.curr.length; i++) {
      this._curr[i] = this.curr[i] & 0xff;
    }
  }
  /**
   * Analyze the current frame against the previous frame determining the
   * amount of motion and direction of the motion.
   */


  analyzeFrame() {
    if (!this.curr || !this.prev) {
      this.motionAmount = this.motionDirection = -1; // Don't have two frames to analyze yet

      return;
    } // Return early if new data has not been received.


    if (this.lastAnalyzedFrame === this.frameNumber) {
      return;
    }

    this.lastAnalyzedFrame = this.frameNumber;
    const {
      _curr: curr,
      _prev: prev
    } = this;
    const winStep = WINSIZE * 2 + 1;
    const wmax = WIDTH - WINSIZE - 1;
    const hmax = HEIGHT - WINSIZE - 1; // Accumulate 2d motion vectors from groups of pixels and average it
    // later.

    let uu = 0;
    let vv = 0;
    let n = 0; // Iterate over groups of cells building up the components to determine
    // a motion vector for each cell instead of the whole frame to avoid
    // integer overflows.

    for (let i = WINSIZE + 1; i < hmax; i += winStep) {
      for (let j = WINSIZE + 1; j < wmax; j += winStep) {
        let A2 = 0;
        let A1B2 = 0;
        let B1 = 0;
        let C1 = 0;
        let C2 = 0; // This is a performance critical math region.

        let address = (i - WINSIZE) * WIDTH + j - WINSIZE;
        let nextAddress = address + winStep;
        const maxAddress = (i + WINSIZE) * WIDTH + j + WINSIZE;

        for (; address <= maxAddress; address += WIDTH - winStep, nextAddress += WIDTH) {
          for (; address <= nextAddress; address += 1) {
            // The difference in color between the last frame and
            // the current frame.
            const gradT = prev[address] - curr[address]; // The difference between the pixel to the left and the
            // pixel to the right.

            const gradX = curr[address - 1] - curr[address + 1]; // The difference between the pixel above and the pixel
            // below.

            const gradY = curr[address - WIDTH] - curr[address + WIDTH]; // Add the combined values of this pixel to previously
            // considered pixels.

            A2 += gradX * gradX;
            A1B2 += gradX * gradY;
            B1 += gradY * gradY;
            C2 += gradX * gradT;
            C1 += gradY * gradT;
          }
        } // Use the accumalated values from the for loop to determine a
        // motion direction.


        const {
          u,
          v
        } = motionVector(A2, A1B2, B1, C2, C1); // If u and v are within negative winStep to positive winStep,
        // add them to a sum that will later be averaged.

        if (-winStep < u && u < winStep && -winStep < v && v < winStep) {
          uu += u;
          vv += v;
          n++;
        }
      }
    } // Average the summed vector values of all of the motion groups.


    uu /= n;
    vv /= n; // Scale the magnitude of the averaged UV vector.

    this.motionAmount = Math.round(AMOUNT_SCALE * Math.hypot(uu, vv));

    if (this.motionAmount > THRESHOLD) {
      // Scratch direction
      this.motionDirection = scratchAtan2(vv, uu);
    }
  }
  /**
   * Build motion amount and direction values based on stored current and
   * previous frame that overlaps a given drawable.
   * @param {Drawable} drawable - touchable and bounded drawable to build motion for
   * @param {MotionState} state - state to store built values to
   */


  getLocalMotion(drawable, state) {
    if (!this.curr || !this.prev) {
      state.motionAmount = state.motionDirection = -1; // Don't have two frames to analyze yet

      return;
    } // Skip if the current frame has already been considered for this state.


    if (state.motionFrameNumber !== this.frameNumber) {
      const {
        _prev: prev,
        _curr: curr
      } = this; // The public APIs for Renderer#isTouching manage keeping the matrix and
      // silhouette up-to-date, which is needed for drawable#isTouching to work (used below)

      drawable.updateCPURenderAttributes(); // Restrict the region the amount and direction are built from to
      // the area of the current frame overlapped by the given drawable's
      // bounding box.

      const boundingRect = drawable.getFastBounds(); // Transform the bounding box from scratch space to a space from 0,
      // 0 to WIDTH, HEIGHT.

      const xmin = Math.max(Math.floor(boundingRect.left + WIDTH / 2), 1);
      const xmax = Math.min(Math.floor(boundingRect.right + WIDTH / 2), WIDTH - 1);
      const ymin = Math.max(Math.floor(HEIGHT / 2 - boundingRect.top), 1);
      const ymax = Math.min(Math.floor(HEIGHT / 2 - boundingRect.bottom), HEIGHT - 1);
      let A2 = 0;
      let A1B2 = 0;
      let B1 = 0;
      let C1 = 0;
      let C2 = 0;
      let scaleFactor = 0;
      const position = [0, 0, 0]; // This is a performance critical math region.

      for (let i = ymin; i < ymax; i++) {
        for (let j = xmin; j < xmax; j++) {
          // i and j are in a coordinate planning ranging from 0 to
          // HEIGHT and 0 to WIDTH. Transform that into Scratch's
          // range of HEIGHT / 2 to -HEIGHT / 2 and -WIDTH / 2 to
          // WIDTH / 2;
          position[0] = j - WIDTH / 2;
          position[1] = HEIGHT / 2 - i; // Consider only pixels in the drawable that can touch the
          // edge or other drawables. Empty space in the current skin
          // is skipped.

          if (drawable.isTouching(position)) {
            const address = i * WIDTH + j; // The difference in color between the last frame and
            // the current frame.

            const gradT = prev[address] - curr[address]; // The difference between the pixel to the left and the
            // pixel to the right.

            const gradX = curr[address - 1] - curr[address + 1]; // The difference between the pixel above and the pixel
            // below.

            const gradY = curr[address - WIDTH] - curr[address + WIDTH]; // Add the combined values of this pixel to previously
            // considered pixels.

            A2 += gradX * gradX;
            A1B2 += gradX * gradY;
            B1 += gradY * gradY;
            C2 += gradX * gradT;
            C1 += gradY * gradT;
            scaleFactor++;
          }
        }
      } // Use the accumalated values from the for loop to determine a
      // motion direction.


      let {
        u,
        v
      } = motionVector(A2, A1B2, B1, C2, C1);
      let activePixelNum = 0;

      if (scaleFactor) {
        // Store the area of the sprite in pixels
        activePixelNum = scaleFactor;
        scaleFactor /= 2 * WINSIZE * 2 * WINSIZE;
        u = u / scaleFactor;
        v = v / scaleFactor;
      } // Scale the magnitude of the averaged UV vector and the number of
      // overlapping drawable pixels.


      state.motionAmount = Math.round(LOCAL_AMOUNT_SCALE * activePixelNum * Math.hypot(u, v));

      if (state.motionAmount > LOCAL_MAX_AMOUNT) {
        // Clip all magnitudes greater than 100.
        state.motionAmount = LOCAL_MAX_AMOUNT;
      }

      if (state.motionAmount > LOCAL_THRESHOLD) {
        // Scratch direction.
        state.motionDirection = scratchAtan2(v, u);
      } // Skip future calls on this state until a new frame is added.


      state.motionFrameNumber = this.frameNumber;
    }
  }

}

module.exports = VideoMotion;

/***/ }),

/***/ "./src/extensions/scratch3_video_sensing/math.js":
/*!*******************************************************!*\
  !*** ./src/extensions/scratch3_video_sensing/math.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A constant value helping to transform a value in radians to degrees.
 * @type {number}
 */
const TO_DEGREE = 180 / Math.PI;
/**
 * A object reused to save on memory allocation returning u and v vector from
 * motionVector.
 * @type {UV}
 */

const _motionVectorOut = {
  u: 0,
  v: 0
};
/**
 * Determine a motion vector combinations of the color component difference on
 * the x axis, y axis, and temporal axis.
 * @param {number} A2 - a sum of x axis squared
 * @param {number} A1B2 - a sum of x axis times y axis
 * @param {number} B1 - a sum of y axis squared
 * @param {number} C2 - a sum of x axis times temporal axis
 * @param {number} C1 - a sum of y axis times temporal axis
 * @param {UV} out - optional object to store return UV info in
 * @returns {UV} a uv vector representing the motion for the given input
 */

const motionVector = function motionVector(A2, A1B2, B1, C2, C1) {
  let out = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : _motionVectorOut;
  // Compare sums of X * Y and sums of X squared and Y squared.
  const delta = A1B2 * A1B2 - A2 * B1;

  if (delta) {
    // System is not singular - solving by Kramer method.
    const deltaX = -(C1 * A1B2 - C2 * B1);
    const deltaY = -(A1B2 * C2 - A2 * C1);
    const Idelta = 8 / delta;
    out.u = deltaX * Idelta;
    out.v = deltaY * Idelta;
  } else {
    // Singular system - find optical flow in gradient direction.
    const Norm = (A1B2 + A2) * (A1B2 + A2) + (B1 + A1B2) * (B1 + A1B2);

    if (Norm) {
      const IGradNorm = 8 / Norm;
      const temp = -(C1 + C2) * IGradNorm;
      out.u = (A1B2 + A2) * temp;
      out.v = (B1 + A1B2) * temp;
    } else {
      out.u = 0;
      out.v = 0;
    }
  }

  return out;
};
/**
 * Translate an angle in degrees with the range -180 to 180 rotated to
 * Scratch's reference angle.
 * @param {number} degrees - angle in range -180 to 180
 * @returns {number} angle from Scratch's reference angle
 */


const scratchDegrees = function scratchDegrees(degrees) {
  return (degrees + 270) % 360 - 180;
};
/**
 * Get the angle of the y and x component of a 2d vector in degrees in
 * Scratch's coordinate plane.
 * @param {number} y - the y component of a 2d vector
 * @param {number} x - the x component of a 2d vector
 * @returns {number} angle in degrees in Scratch's coordinate plane
 */


const scratchAtan2 = function scratchAtan2(y, x) {
  return scratchDegrees(Math.atan2(y, x) * TO_DEGREE);
};

module.exports = {
  motionVector,
  scratchDegrees,
  scratchAtan2
};

/***/ }),

/***/ "./src/extensions/scratch3_wedo2/index.js":
/*!************************************************!*\
  !*** ./src/extensions/scratch3_wedo2/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const Cast = __webpack_require__(/*! ../../util/cast */ "./src/util/cast.js");

const formatMessage = __webpack_require__(/*! format-message */ "format-message");

const color = __webpack_require__(/*! ../../util/color */ "./src/util/color.js");

const BLE = __webpack_require__(/*! ../../io/ble */ "./src/io/ble.js");

const Base64Util = __webpack_require__(/*! ../../util/base64-util */ "./src/util/base64-util.js");

const MathUtil = __webpack_require__(/*! ../../util/math-util */ "./src/util/math-util.js");

const RateLimiter = __webpack_require__(/*! ../../util/rateLimiter.js */ "./src/util/rateLimiter.js");

const log = __webpack_require__(/*! ../../util/log */ "./src/util/log.js");
/**
 * Icon svg to be displayed at the left edge of each extension block, encoded as a data URI.
 * @type {string}
 */
// eslint-disable-next-line max-len


const iconURI = 'data:image/png;base64,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';
/**
 * A list of WeDo 2.0 BLE service UUIDs.
 * @enum
 */

const BLEService = {
  DEVICE_SERVICE: '00001523-1212-efde-1523-785feabcd123',
  IO_SERVICE: '00004f0e-1212-efde-1523-785feabcd123'
};
/**
 * A list of WeDo 2.0 BLE characteristic UUIDs.
 *
 * Characteristics on DEVICE_SERVICE:
 * - ATTACHED_IO
 *
 * Characteristics on IO_SERVICE:
 * - INPUT_VALUES
 * - INPUT_COMMAND
 * - OUTPUT_COMMAND
 *
 * @enum
 */

const BLECharacteristic = {
  ATTACHED_IO: '00001527-1212-efde-1523-785feabcd123',
  LOW_VOLTAGE_ALERT: '00001528-1212-efde-1523-785feabcd123',
  INPUT_VALUES: '00001560-1212-efde-1523-785feabcd123',
  INPUT_COMMAND: '00001563-1212-efde-1523-785feabcd123',
  OUTPUT_COMMAND: '00001565-1212-efde-1523-785feabcd123'
};
/**
 * A time interval to wait (in milliseconds) in between battery check calls.
 * @type {number}
 */

const BLEBatteryCheckInterval = 5000;
/**
 * A time interval to wait (in milliseconds) while a block that sends a BLE message is running.
 * @type {number}
 */

const BLESendInterval = 100;
/**
 * A maximum number of BLE message sends per second, to be enforced by the rate limiter.
 * @type {number}
 */

const BLESendRateMax = 20;
/**
 * Enum for WeDo 2.0 sensor and output types.
 * @readonly
 * @enum {number}
 */

const WeDo2Device = {
  MOTOR: 1,
  PIEZO: 22,
  LED: 23,
  TILT: 34,
  DISTANCE: 35
};
/**
 * Enum for connection/port ids assigned to internal WeDo 2.0 output devices.
 * @readonly
 * @enum {number}
 */
// TODO: Check for these more accurately at startup?

const WeDo2ConnectID = {
  LED: 6,
  PIEZO: 5
};
/**
 * Enum for ids for various output commands on the WeDo 2.0.
 * @readonly
 * @enum {number}
 */

const WeDo2Command = {
  MOTOR_POWER: 1,
  PLAY_TONE: 2,
  STOP_TONE: 3,
  WRITE_RGB: 4,
  SET_VOLUME: 255
};
/**
 * Enum for modes for input sensors on the WeDo 2.0.
 * @enum {number}
 */

const WeDo2Mode = {
  TILT: 0,
  // angle
  DISTANCE: 0,
  // detect
  LED: 1 // RGB

};
/**
 * Enum for units for input sensors on the WeDo 2.0.
 *
 * 0 = raw
 * 1 = percent
 *
 * @enum {number}
 */

const WeDo2Unit = {
  TILT: 0,
  DISTANCE: 1,
  LED: 0
};
/**
 * Manage power, direction, and timers for one WeDo 2.0 motor.
 */

class WeDo2Motor {
  /**
   * Construct a WeDo 2.0 Motor instance.
   * @param {WeDo2} parent - the WeDo 2.0 peripheral which owns this motor.
   * @param {int} index - the zero-based index of this motor on its parent peripheral.
   */
  constructor(parent, index) {
    /**
     * The WeDo 2.0 peripheral which owns this motor.
     * @type {WeDo2}
     * @private
     */
    this._parent = parent;
    /**
     * The zero-based index of this motor on its parent peripheral.
     * @type {int}
     * @private
     */

    this._index = index;
    /**
     * This motor's current direction: 1 for "this way" or -1 for "that way"
     * @type {number}
     * @private
     */

    this._direction = 1;
    /**
     * This motor's current power level, in the range [0,100].
     * @type {number}
     * @private
     */

    this._power = 100;
    /**
     * Is this motor currently moving?
     * @type {boolean}
     * @private
     */

    this._isOn = false;
    /**
     * If the motor has been turned on or is actively braking for a specific duration, this is the timeout ID for
     * the end-of-action handler. Cancel this when changing plans.
     * @type {Object}
     * @private
     */

    this._pendingTimeoutId = null;
    /**
     * The starting time for the pending timeout.
     * @type {Object}
     * @private
     */

    this._pendingTimeoutStartTime = null;
    /**
     * The delay/duration of the pending timeout.
     * @type {Object}
     * @private
     */

    this._pendingTimeoutDelay = null;
    this.startBraking = this.startBraking.bind(this);
    this.turnOff = this.turnOff.bind(this);
  }
  /**
   * @return {number} - the duration of active braking after a call to startBraking(). Afterward, turn the motor off.
   * @constructor
   */


  static get BRAKE_TIME_MS() {
    return 1000;
  }
  /**
   * @return {int} - this motor's current direction: 1 for "this way" or -1 for "that way"
   */


  get direction() {
    return this._direction;
  }
  /**
   * @param {int} value - this motor's new direction: 1 for "this way" or -1 for "that way"
   */


  set direction(value) {
    if (value < 0) {
      this._direction = -1;
    } else {
      this._direction = 1;
    }
  }
  /**
   * @return {int} - this motor's current power level, in the range [0,100].
   */


  get power() {
    return this._power;
  }
  /**
   * @param {int} value - this motor's new power level, in the range [0,100].
   */


  set power(value) {
    const p = Math.max(0, Math.min(value, 100)); // Lego Wedo 2.0 hub only turns motors at power range [30 - 100], so
    // map value from [0 - 100] to [30 - 100].

    if (p === 0) {
      this._power = 0;
    } else {
      const delta = 100 / p;
      this._power = 30 + 70 / delta;
    }
  }
  /**
   * @return {boolean} - true if this motor is currently moving, false if this motor is off or braking.
   */


  get isOn() {
    return this._isOn;
  }
  /**
   * @return {boolean} - time, in milliseconds, of when the pending timeout began.
   */


  get pendingTimeoutStartTime() {
    return this._pendingTimeoutStartTime;
  }
  /**
   * @return {boolean} - delay, in milliseconds, of the pending timeout.
   */


  get pendingTimeoutDelay() {
    return this._pendingTimeoutDelay;
  }
  /**
   * Turn this motor on indefinitely.
   */


  turnOn() {
    if (this._power === 0) return;

    const cmd = this._parent.generateOutputCommand(this._index + 1, WeDo2Command.MOTOR_POWER, [this._power * this._direction] // power in range 0-100
    );

    this._parent.send(BLECharacteristic.OUTPUT_COMMAND, cmd);

    this._isOn = true;

    this._clearTimeout();
  }
  /**
   * Turn this motor on for a specific duration.
   * @param {number} milliseconds - run the motor for this long.
   */


  turnOnFor(milliseconds) {
    if (this._power === 0) return;
    milliseconds = Math.max(0, milliseconds);
    this.turnOn();

    this._setNewTimeout(this.startBraking, milliseconds);
  }
  /**
   * Start active braking on this motor. After a short time, the motor will turn off.
   */


  startBraking() {
    if (this._power === 0) return;

    const cmd = this._parent.generateOutputCommand(this._index + 1, WeDo2Command.MOTOR_POWER, [127] // 127 = break
    );

    this._parent.send(BLECharacteristic.OUTPUT_COMMAND, cmd);

    this._isOn = false;

    this._setNewTimeout(this.turnOff, WeDo2Motor.BRAKE_TIME_MS);
  }
  /**
   * Turn this motor off.
   * @param {boolean} [useLimiter=true] - if true, use the rate limiter
   */


  turnOff() {
    let useLimiter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    if (this._power === 0) return;

    const cmd = this._parent.generateOutputCommand(this._index + 1, WeDo2Command.MOTOR_POWER, [0] // 0 = stop
    );

    this._parent.send(BLECharacteristic.OUTPUT_COMMAND, cmd, useLimiter);

    this._isOn = false;
  }
  /**
   * Clear the motor action timeout, if any. Safe to call even when there is no pending timeout.
   * @private
   */


  _clearTimeout() {
    if (this._pendingTimeoutId !== null) {
      clearTimeout(this._pendingTimeoutId);
      this._pendingTimeoutId = null;
      this._pendingTimeoutStartTime = null;
      this._pendingTimeoutDelay = null;
    }
  }
  /**
   * Set a new motor action timeout, after clearing an existing one if necessary.
   * @param {Function} callback - to be called at the end of the timeout.
   * @param {int} delay - wait this many milliseconds before calling the callback.
   * @private
   */


  _setNewTimeout(callback, delay) {
    this._clearTimeout();

    const timeoutID = setTimeout(() => {
      if (this._pendingTimeoutId === timeoutID) {
        this._pendingTimeoutId = null;
        this._pendingTimeoutStartTime = null;
        this._pendingTimeoutDelay = null;
      }

      callback();
    }, delay);
    this._pendingTimeoutId = timeoutID;
    this._pendingTimeoutStartTime = Date.now();
    this._pendingTimeoutDelay = delay;
  }

}
/**
 * Manage communication with a WeDo 2.0 peripheral over a Bluetooth Low Energy client socket.
 */


class WeDo2 {
  constructor(runtime, extensionId) {
    /**
     * The Scratch 3.0 runtime used to trigger the green flag button.
     * @type {Runtime}
     * @private
     */
    this._runtime = runtime;

    this._runtime.on('PROJECT_STOP_ALL', this.stopAll.bind(this));
    /**
     * The id of the extension this peripheral belongs to.
     */


    this._extensionId = extensionId;
    /**
     * A list of the ids of the motors or sensors in ports 1 and 2.
     * @type {string[]}
     * @private
     */

    this._ports = ['none', 'none'];
    /**
     * The motors which this WeDo 2.0 could possibly have.
     * @type {WeDo2Motor[]}
     * @private
     */

    this._motors = [null, null];
    /**
     * The most recently received value for each sensor.
     * @type {Object.<string, number>}
     * @private
     */

    this._sensors = {
      tiltX: 0,
      tiltY: 0,
      distance: 0
    };
    /**
     * The Bluetooth connection socket for reading/writing peripheral data.
     * @type {BLE}
     * @private
     */

    this._ble = null;

    this._runtime.registerPeripheralExtension(extensionId, this);
    /**
     * A rate limiter utility, to help limit the rate at which we send BLE messages
     * over the socket to Scratch Link to a maximum number of sends per second.
     * @type {RateLimiter}
     * @private
     */


    this._rateLimiter = new RateLimiter(BLESendRateMax);
    /**
     * An interval id for the battery check interval.
     * @type {number}
     * @private
     */

    this._batteryLevelIntervalId = null;
    this.reset = this.reset.bind(this);
    this._onConnect = this._onConnect.bind(this);
    this._onMessage = this._onMessage.bind(this);
    this._checkBatteryLevel = this._checkBatteryLevel.bind(this);
  }
  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the X axis.
   */


  get tiltX() {
    return this._sensors.tiltX;
  }
  /**
   * @return {number} - the latest value received for the tilt sensor's tilt about the Y axis.
   */


  get tiltY() {
    return this._sensors.tiltY;
  }
  /**
   * @return {number} - the latest value received from the distance sensor.
   */


  get distance() {
    return this._sensors.distance;
  }
  /**
   * Access a particular motor on this peripheral.
   * @param {int} index - the zero-based index of the desired motor.
   * @return {WeDo2Motor} - the WeDo2Motor instance, if any, at that index.
   */


  motor(index) {
    return this._motors[index];
  }
  /**
   * Stop all the motors that are currently running.
   */


  stopAllMotors() {
    this._motors.forEach(motor => {
      if (motor) {
        // Send the motor off command without using the rate limiter.
        // This allows the stop button to stop motors even if we are
        // otherwise flooded with commands.
        motor.turnOff(false);
      }
    });
  }
  /**
   * Set the WeDo 2.0 peripheral's LED to a specific color.
   * @param {int} inputRGB - a 24-bit RGB color in 0xRRGGBB format.
   * @return {Promise} - a promise of the completion of the set led send operation.
   */


  setLED(inputRGB) {
    const rgb = [inputRGB >> 16 & 0x000000FF, inputRGB >> 8 & 0x000000FF, inputRGB & 0x000000FF];
    const cmd = this.generateOutputCommand(WeDo2ConnectID.LED, WeDo2Command.WRITE_RGB, rgb);
    return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd);
  }
  /**
   * Sets the input mode of the LED to RGB.
   * @return {Promise} - a promise returned by the send operation.
   */


  setLEDMode() {
    const cmd = this.generateInputCommand(WeDo2ConnectID.LED, WeDo2Device.LED, WeDo2Mode.LED, 0, WeDo2Unit.LED, false);
    return this.send(BLECharacteristic.INPUT_COMMAND, cmd);
  }
  /**
   * Switch off the LED on the WeDo 2.0.
   * @return {Promise} - a promise of the completion of the stop led send operation.
   */


  stopLED() {
    const cmd = this.generateOutputCommand(WeDo2ConnectID.LED, WeDo2Command.WRITE_RGB, [0, 0, 0]);
    return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd);
  }
  /**
   * Play a tone from the WeDo 2.0 peripheral for a specific amount of time.
   * @param {int} tone - the pitch of the tone, in Hz.
   * @param {int} milliseconds - the duration of the note, in milliseconds.
   * @return {Promise} - a promise of the completion of the play tone send operation.
   */


  playTone(tone, milliseconds) {
    const cmd = this.generateOutputCommand(WeDo2ConnectID.PIEZO, WeDo2Command.PLAY_TONE, [tone, tone >> 8, milliseconds, milliseconds >> 8]);
    return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd);
  }
  /**
   * Stop the tone playing from the WeDo 2.0 peripheral, if any.
   * @return {Promise} - a promise that the command sent.
   */


  stopTone() {
    const cmd = this.generateOutputCommand(WeDo2ConnectID.PIEZO, WeDo2Command.STOP_TONE); // Send this command without using the rate limiter, because it is
    // only triggered by the stop button.

    return this.send(BLECharacteristic.OUTPUT_COMMAND, cmd, false);
  }
  /**
   * Stop the tone playing and motors on the WeDo 2.0 peripheral.
   */


  stopAll() {
    if (!this.isConnected()) return;
    this.stopTone();
    this.stopAllMotors();
  }
  /**
   * Called by the runtime when user wants to scan for a WeDo 2.0 peripheral.
   */


  scan() {
    if (this._ble) {
      this._ble.disconnect();
    }

    this._ble = new BLE(this._runtime, this._extensionId, {
      filters: [{
        services: [BLEService.DEVICE_SERVICE]
      }],
      optionalServices: [BLEService.IO_SERVICE]
    }, this._onConnect, this.reset);
  }
  /**
   * Called by the runtime when user wants to connect to a certain WeDo 2.0 peripheral.
   * @param {number} id - the id of the peripheral to connect to.
   */


  connect(id) {
    if (this._ble) {
      this._ble.connectPeripheral(id);
    }
  }
  /**
   * Disconnects from the current BLE socket.
   */


  disconnect() {
    if (this._ble) {
      this._ble.disconnect();
    }

    this.reset();
  }
  /**
   * Reset all the state and timeout/interval ids.
   */


  reset() {
    this._ports = ['none', 'none'];
    this._motors = [null, null];
    this._sensors = {
      tiltX: 0,
      tiltY: 0,
      distance: 0
    };

    if (this._batteryLevelIntervalId) {
      window.clearInterval(this._batteryLevelIntervalId);
      this._batteryLevelIntervalId = null;
    }
  }
  /**
   * Called by the runtime to detect whether the WeDo 2.0 peripheral is connected.
   * @return {boolean} - the connected state.
   */


  isConnected() {
    let connected = false;

    if (this._ble) {
      connected = this._ble.isConnected();
    }

    return connected;
  }
  /**
   * Write a message to the WeDo 2.0 peripheral BLE socket.
   * @param {number} uuid - the UUID of the characteristic to write to
   * @param {Array} message - the message to write.
   * @param {boolean} [useLimiter=true] - if true, use the rate limiter
   * @return {Promise} - a promise result of the write operation
   */


  send(uuid, message) {
    let useLimiter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    if (!this.isConnected()) return Promise.resolve();

    if (useLimiter) {
      if (!this._rateLimiter.okayToSend()) return Promise.resolve();
    }

    return this._ble.write(BLEService.IO_SERVICE, uuid, Base64Util.uint8ArrayToBase64(message), 'base64');
  }
  /**
   * Generate a WeDo 2.0 'Output Command' in the byte array format
   * (CONNECT ID, COMMAND ID, NUMBER OF BYTES, VALUES ...).
   *
   * This sends a command to the WeDo 2.0 to actuate the specified outputs.
   *
   * @param  {number} connectID - the port (Connect ID) to send a command to.
   * @param  {number} commandID - the id of the byte command.
   * @param  {array}  values    - the list of values to write to the command.
   * @return {array}            - a generated output command.
   */


  generateOutputCommand(connectID, commandID) {
    let values = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    let command = [connectID, commandID];

    if (values) {
      command = command.concat(values.length).concat(values);
    }

    return command;
  }
  /**
   * Generate a WeDo 2.0 'Input Command' in the byte array format
   * (COMMAND ID, COMMAND TYPE, CONNECT ID, TYPE ID, MODE, DELTA INTERVAL (4 BYTES),
   * UNIT, NOTIFICATIONS ENABLED).
   *
   * This sends a command to the WeDo 2.0 that sets that input format
   * of the specified inputs and sets value change notifications.
   *
   * @param  {number}  connectID           - the port (Connect ID) to send a command to.
   * @param  {number}  type                - the type of input sensor.
   * @param  {number}  mode                - the mode of the input sensor.
   * @param  {number}  delta               - the delta change needed to trigger notification.
   * @param  {array}   units               - the unit of the input sensor value.
   * @param  {boolean} enableNotifications - whether to enable notifications.
   * @return {array}                       - a generated input command.
   */


  generateInputCommand(connectID, type, mode, delta, units, enableNotifications) {
    const command = [1, // Command ID = 1 = "Sensor Format"
    2, // Command Type = 2 = "Write"
    connectID, type, mode, delta, 0, // Delta Interval Byte 2
    0, // Delta Interval Byte 3
    0, // Delta Interval Byte 4
    units, enableNotifications ? 1 : 0];
    return command;
  }
  /**
   * Sets LED mode and initial color and starts reading data from peripheral after BLE has connected.
   * @private
   */


  _onConnect() {
    this.setLEDMode();
    this.setLED(0x0000FF);

    this._ble.startNotifications(BLEService.DEVICE_SERVICE, BLECharacteristic.ATTACHED_IO, this._onMessage);

    this._batteryLevelIntervalId = window.setInterval(this._checkBatteryLevel, BLEBatteryCheckInterval);
  }
  /**
   * Process the sensor data from the incoming BLE characteristic.
   * @param {object} base64 - the incoming BLE data.
   * @private
   */


  _onMessage(base64) {
    const data = Base64Util.base64ToUint8Array(base64); // log.info(data);

    /**
     * If first byte of data is '1' or '2', then either clear the
     * sensor present in ports 1 or 2 or set their format.
     *
     * If first byte of data is anything else, read incoming sensor value.
     */

    switch (data[0]) {
      case 1:
      case 2:
        {
          const connectID = data[0];

          if (data[1] === 0) {
            // clear sensor or motor
            this._clearPort(connectID);
          } else {
            // register sensor or motor
            this._registerSensorOrMotor(connectID, data[3]);
          }

          break;
        }

      default:
        {
          // read incoming sensor value
          const connectID = data[1];
          const type = this._ports[connectID - 1];

          if (type === WeDo2Device.DISTANCE) {
            this._sensors.distance = data[2];
          }

          if (type === WeDo2Device.TILT) {
            this._sensors.tiltX = data[2];
            this._sensors.tiltY = data[3];
          }

          break;
        }
    }
  }
  /**
   * Check the battery level on the WeDo 2.0. If the WeDo 2.0 has disconnected
   * for some reason, the BLE socket will get an error back and automatically
   * close the socket.
   */


  _checkBatteryLevel() {
    this._ble.read(BLEService.DEVICE_SERVICE, BLECharacteristic.LOW_VOLTAGE_ALERT, false);
  }
  /**
   * Register a new sensor or motor connected at a port.  Store the type of
   * sensor or motor internally, and then register for notifications on input
   * values if it is a sensor.
   * @param {number} connectID - the port to register a sensor or motor on.
   * @param {number} type - the type ID of the sensor or motor
   * @private
   */


  _registerSensorOrMotor(connectID, type) {
    // Record which port is connected to what type of device
    this._ports[connectID - 1] = type; // Record motor port

    if (type === WeDo2Device.MOTOR) {
      this._motors[connectID - 1] = new WeDo2Motor(this, connectID - 1);
    } else {
      // Set input format for tilt or distance sensor
      const typeString = type === WeDo2Device.DISTANCE ? 'DISTANCE' : 'TILT';
      const cmd = this.generateInputCommand(connectID, type, WeDo2Mode[typeString], 1, WeDo2Unit[typeString], true);
      this.send(BLECharacteristic.INPUT_COMMAND, cmd);

      this._ble.startNotifications(BLEService.IO_SERVICE, BLECharacteristic.INPUT_VALUES, this._onMessage);
    }
  }
  /**
   * Clear the sensor or motor present at port 1 or 2.
   * @param {number} connectID - the port to clear.
   * @private
   */


  _clearPort(connectID) {
    const type = this._ports[connectID - 1];

    if (type === WeDo2Device.TILT) {
      this._sensors.tiltX = this._sensors.tiltY = 0;
    }

    if (type === WeDo2Device.DISTANCE) {
      this._sensors.distance = 0;
    }

    this._ports[connectID - 1] = 'none';
    this._motors[connectID - 1] = null;
  }

}
/**
 * Enum for motor specification.
 * @readonly
 * @enum {string}
 */


const WeDo2MotorLabel = {
  DEFAULT: 'motor',
  A: 'motor A',
  B: 'motor B',
  ALL: 'all motors'
};
/**
 * Enum for motor direction specification.
 * @readonly
 * @enum {string}
 */

const WeDo2MotorDirection = {
  FORWARD: 'this way',
  BACKWARD: 'that way',
  REVERSE: 'reverse'
};
/**
 * Enum for tilt sensor direction.
 * @readonly
 * @enum {string}
 */

const WeDo2TiltDirection = {
  UP: 'up',
  DOWN: 'down',
  LEFT: 'left',
  RIGHT: 'right',
  ANY: 'any'
};
/**
 * Scratch 3.0 blocks to interact with a LEGO WeDo 2.0 peripheral.
 */

class Scratch3WeDo2Blocks {
  /**
   * @return {string} - the ID of this extension.
   */
  static get EXTENSION_ID() {
    return 'wedo2';
  }
  /**
   * @return {number} - the tilt sensor counts as "tilted" if its tilt angle meets or exceeds this threshold.
   */


  static get TILT_THRESHOLD() {
    return 15;
  }
  /**
   * Construct a set of WeDo 2.0 blocks.
   * @param {Runtime} runtime - the Scratch 3.0 runtime.
   */


  constructor(runtime) {
    /**
     * The Scratch 3.0 runtime.
     * @type {Runtime}
     */
    this.runtime = runtime; // Create a new WeDo 2.0 peripheral instance

    this._peripheral = new WeDo2(this.runtime, Scratch3WeDo2Blocks.EXTENSION_ID);
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: Scratch3WeDo2Blocks.EXTENSION_ID,
      name: 'WeDo 2.0',
      blockIconURI: iconURI,
      showStatusButton: true,
      blocks: [{
        opcode: 'motorOnFor',
        text: formatMessage({
          id: 'wedo2.motorOnFor',
          default: 'turn [MOTOR_ID] on for [DURATION] seconds',
          description: 'turn a motor on for some time'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_ID',
            defaultValue: WeDo2MotorLabel.DEFAULT
          },
          DURATION: {
            type: ArgumentType.NUMBER,
            defaultValue: 1
          }
        }
      }, {
        opcode: 'motorOn',
        text: formatMessage({
          id: 'wedo2.motorOn',
          default: 'turn [MOTOR_ID] on',
          description: 'turn a motor on indefinitely'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_ID',
            defaultValue: WeDo2MotorLabel.DEFAULT
          }
        }
      }, {
        opcode: 'motorOff',
        text: formatMessage({
          id: 'wedo2.motorOff',
          default: 'turn [MOTOR_ID] off',
          description: 'turn a motor off'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_ID',
            defaultValue: WeDo2MotorLabel.DEFAULT
          }
        }
      }, {
        opcode: 'startMotorPower',
        text: formatMessage({
          id: 'wedo2.startMotorPower',
          default: 'set [MOTOR_ID] power to [POWER]',
          description: 'set the motor\'s power and turn it on'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_ID',
            defaultValue: WeDo2MotorLabel.DEFAULT
          },
          POWER: {
            type: ArgumentType.NUMBER,
            defaultValue: 100
          }
        }
      }, {
        opcode: 'setMotorDirection',
        text: formatMessage({
          id: 'wedo2.setMotorDirection',
          default: 'set [MOTOR_ID] direction to [MOTOR_DIRECTION]',
          description: 'set the motor\'s turn direction'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          MOTOR_ID: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_ID',
            defaultValue: WeDo2MotorLabel.DEFAULT
          },
          MOTOR_DIRECTION: {
            type: ArgumentType.STRING,
            menu: 'MOTOR_DIRECTION',
            defaultValue: WeDo2MotorDirection.FORWARD
          }
        }
      }, {
        opcode: 'setLightHue',
        text: formatMessage({
          id: 'wedo2.setLightHue',
          default: 'set light color to [HUE]',
          description: 'set the LED color'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          HUE: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        }
      }, {
        opcode: 'playNoteFor',
        text: formatMessage({
          id: 'wedo2.playNoteFor',
          default: 'play note [NOTE] for [DURATION] seconds',
          description: 'play a certain note for some time'
        }),
        blockType: BlockType.COMMAND,
        arguments: {
          NOTE: {
            type: ArgumentType.NUMBER,
            // TODO: ArgumentType.MIDI_NOTE?
            defaultValue: 60
          },
          DURATION: {
            type: ArgumentType.NUMBER,
            defaultValue: 0.5
          }
        },
        hideFromPalette: true
      }, {
        opcode: 'whenDistance',
        text: formatMessage({
          id: 'wedo2.whenDistance',
          default: 'when distance [OP] [REFERENCE]',
          description: 'check for when distance is < or > than reference'
        }),
        blockType: BlockType.HAT,
        arguments: {
          OP: {
            type: ArgumentType.STRING,
            menu: 'OP',
            defaultValue: '<'
          },
          REFERENCE: {
            type: ArgumentType.NUMBER,
            defaultValue: 50
          }
        }
      }, {
        opcode: 'whenTilted',
        text: formatMessage({
          id: 'wedo2.whenTilted',
          default: 'when tilted [TILT_DIRECTION_ANY]',
          description: 'check when tilted in a certain direction'
        }),
        func: 'isTilted',
        blockType: BlockType.HAT,
        arguments: {
          TILT_DIRECTION_ANY: {
            type: ArgumentType.STRING,
            menu: 'TILT_DIRECTION_ANY',
            defaultValue: WeDo2TiltDirection.ANY
          }
        }
      }, {
        opcode: 'getDistance',
        text: formatMessage({
          id: 'wedo2.getDistance',
          default: 'distance',
          description: 'the value returned by the distance sensor'
        }),
        blockType: BlockType.REPORTER
      }, {
        opcode: 'isTilted',
        text: formatMessage({
          id: 'wedo2.isTilted',
          default: 'tilted [TILT_DIRECTION_ANY]?',
          description: 'whether the tilt sensor is tilted'
        }),
        blockType: BlockType.BOOLEAN,
        arguments: {
          TILT_DIRECTION_ANY: {
            type: ArgumentType.STRING,
            menu: 'TILT_DIRECTION_ANY',
            defaultValue: WeDo2TiltDirection.ANY
          }
        }
      }, {
        opcode: 'getTiltAngle',
        text: formatMessage({
          id: 'wedo2.getTiltAngle',
          default: 'tilt angle [TILT_DIRECTION]',
          description: 'the angle returned by the tilt sensor'
        }),
        blockType: BlockType.REPORTER,
        arguments: {
          TILT_DIRECTION: {
            type: ArgumentType.STRING,
            menu: 'TILT_DIRECTION',
            defaultValue: WeDo2TiltDirection.UP
          }
        }
      }],
      menus: {
        MOTOR_ID: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: 'wedo2.motorId.default',
              default: 'motor',
              description: 'label for motor element in motor menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2MotorLabel.DEFAULT
          }, {
            text: formatMessage({
              id: 'wedo2.motorId.a',
              default: 'motor A',
              description: 'label for motor A element in motor menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2MotorLabel.A
          }, {
            text: formatMessage({
              id: 'wedo2.motorId.b',
              default: 'motor B',
              description: 'label for motor B element in motor menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2MotorLabel.B
          }, {
            text: formatMessage({
              id: 'wedo2.motorId.all',
              default: 'all motors',
              description: 'label for all motors element in motor menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2MotorLabel.ALL
          }]
        },
        MOTOR_DIRECTION: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: 'wedo2.motorDirection.forward',
              default: 'this way',
              description: 'label for forward element in motor direction menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2MotorDirection.FORWARD
          }, {
            text: formatMessage({
              id: 'wedo2.motorDirection.backward',
              default: 'that way',
              description: 'label for backward element in motor direction menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2MotorDirection.BACKWARD
          }, {
            text: formatMessage({
              id: 'wedo2.motorDirection.reverse',
              default: 'reverse',
              description: 'label for reverse element in motor direction menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2MotorDirection.REVERSE
          }]
        },
        TILT_DIRECTION: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: 'wedo2.tiltDirection.up',
              default: 'up',
              description: 'label for up element in tilt direction menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2TiltDirection.UP
          }, {
            text: formatMessage({
              id: 'wedo2.tiltDirection.down',
              default: 'down',
              description: 'label for down element in tilt direction menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2TiltDirection.DOWN
          }, {
            text: formatMessage({
              id: 'wedo2.tiltDirection.left',
              default: 'left',
              description: 'label for left element in tilt direction menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2TiltDirection.LEFT
          }, {
            text: formatMessage({
              id: 'wedo2.tiltDirection.right',
              default: 'right',
              description: 'label for right element in tilt direction menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2TiltDirection.RIGHT
          }]
        },
        TILT_DIRECTION_ANY: {
          acceptReporters: true,
          items: [{
            text: formatMessage({
              id: 'wedo2.tiltDirection.up',
              default: 'up'
            }),
            value: WeDo2TiltDirection.UP
          }, {
            text: formatMessage({
              id: 'wedo2.tiltDirection.down',
              default: 'down'
            }),
            value: WeDo2TiltDirection.DOWN
          }, {
            text: formatMessage({
              id: 'wedo2.tiltDirection.left',
              default: 'left'
            }),
            value: WeDo2TiltDirection.LEFT
          }, {
            text: formatMessage({
              id: 'wedo2.tiltDirection.right',
              default: 'right'
            }),
            value: WeDo2TiltDirection.RIGHT
          }, {
            text: formatMessage({
              id: 'wedo2.tiltDirection.any',
              default: 'any',
              description: 'label for any element in tilt direction menu for LEGO WeDo 2 extension'
            }),
            value: WeDo2TiltDirection.ANY
          }]
        },
        OP: {
          acceptReporters: true,
          items: ['<', '>']
        }
      }
    };
  }
  /**
   * Turn specified motor(s) on for a specified duration.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to activate.
   * @property {int} DURATION - the amount of time to run the motors.
   * @return {Promise} - a promise which will resolve at the end of the duration.
   */


  motorOnFor(args) {
    // TODO: cast args.MOTOR_ID?
    let durationMS = Cast.toNumber(args.DURATION) * 1000;
    durationMS = MathUtil.clamp(durationMS, 0, 15000);
    return new Promise(resolve => {
      this._forEachMotor(args.MOTOR_ID, motorIndex => {
        const motor = this._peripheral.motor(motorIndex);

        if (motor) {
          motor.turnOnFor(durationMS);
        }
      }); // Run for some time even when no motor is connected


      setTimeout(resolve, durationMS);
    });
  }
  /**
   * Turn specified motor(s) on indefinitely.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to activate.
   * @return {Promise} - a Promise that resolves after some delay.
   */


  motorOn(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) {
        motor.turnOn();
      }
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }
  /**
   * Turn specified motor(s) off.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to deactivate.
   * @return {Promise} - a Promise that resolves after some delay.
   */


  motorOff(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) {
        motor.turnOff();
      }
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }
  /**
   * Turn specified motor(s) off.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to be affected.
   * @property {int} POWER - the new power level for the motor(s).
   * @return {Promise} - a Promise that resolves after some delay.
   */


  startMotorPower(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) {
        motor.power = MathUtil.clamp(Cast.toNumber(args.POWER), 0, 100);
        motor.turnOn();
      }
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }
  /**
   * Set the direction of rotation for specified motor(s).
   * If the direction is 'reverse' the motor(s) will be reversed individually.
   * @param {object} args - the block's arguments.
   * @property {MotorID} MOTOR_ID - the motor(s) to be affected.
   * @property {MotorDirection} MOTOR_DIRECTION - the new direction for the motor(s).
   * @return {Promise} - a Promise that resolves after some delay.
   */


  setMotorDirection(args) {
    // TODO: cast args.MOTOR_ID?
    this._forEachMotor(args.MOTOR_ID, motorIndex => {
      const motor = this._peripheral.motor(motorIndex);

      if (motor) {
        switch (args.MOTOR_DIRECTION) {
          case WeDo2MotorDirection.FORWARD:
            motor.direction = 1;
            break;

          case WeDo2MotorDirection.BACKWARD:
            motor.direction = -1;
            break;

          case WeDo2MotorDirection.REVERSE:
            motor.direction = -motor.direction;
            break;

          default:
            log.warn("Unknown motor direction in setMotorDirection: ".concat(args.DIRECTION));
            break;
        } // keep the motor on if it's running, and update the pending timeout if needed


        if (motor.isOn) {
          if (motor.pendingTimeoutDelay) {
            motor.turnOnFor(motor.pendingTimeoutStartTime + motor.pendingTimeoutDelay - Date.now());
          } else {
            motor.turnOn();
          }
        }
      }
    });

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }
  /**
   * Set the LED's hue.
   * @param {object} args - the block's arguments.
   * @property {number} HUE - the hue to set, in the range [0,100].
   * @return {Promise} - a Promise that resolves after some delay.
   */


  setLightHue(args) {
    // Convert from [0,100] to [0,360]
    let inputHue = Cast.toNumber(args.HUE);
    inputHue = MathUtil.wrapClamp(inputHue, 0, 100);
    const hue = inputHue * 360 / 100;
    const rgbObject = color.hsvToRgb({
      h: hue,
      s: 1,
      v: 1
    });
    const rgbDecimal = color.rgbToDecimal(rgbObject);

    this._peripheral.setLED(rgbDecimal);

    return new Promise(resolve => {
      window.setTimeout(() => {
        resolve();
      }, BLESendInterval);
    });
  }
  /**
   * Make the WeDo 2.0 peripheral play a MIDI note for the specified duration.
   * @param {object} args - the block's arguments.
   * @property {number} NOTE - the MIDI note to play.
   * @property {number} DURATION - the duration of the note, in seconds.
   * @return {Promise} - a promise which will resolve at the end of the duration.
   */


  playNoteFor(args) {
    let durationMS = Cast.toNumber(args.DURATION) * 1000;
    durationMS = MathUtil.clamp(durationMS, 0, 3000);
    const note = MathUtil.clamp(Cast.toNumber(args.NOTE), 25, 125); // valid WeDo 2.0 sounds

    if (durationMS === 0) return; // WeDo 2.0 plays duration '0' forever

    return new Promise(resolve => {
      const tone = this._noteToTone(note);

      this._peripheral.playTone(tone, durationMS); // Run for some time even when no piezo is connected


      setTimeout(resolve, durationMS);
    });
  }
  /**
   * Compare the distance sensor's value to a reference.
   * @param {object} args - the block's arguments.
   * @property {string} OP - the comparison operation: '<' or '>'.
   * @property {number} REFERENCE - the value to compare against.
   * @return {boolean} - the result of the comparison, or false on error.
   */


  whenDistance(args) {
    switch (args.OP) {
      case '<':
        return this._peripheral.distance < Cast.toNumber(args.REFERENCE);

      case '>':
        return this._peripheral.distance > Cast.toNumber(args.REFERENCE);

      default:
        log.warn("Unknown comparison operator in whenDistance: ".concat(args.OP));
        return false;
    }
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */


  whenTilted(args) {
    return this._isTilted(args.TILT_DIRECTION_ANY);
  }
  /**
   * @return {number} - the distance sensor's value, scaled to the [0,100] range.
   */


  getDistance() {
    return this._peripheral.distance;
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION_ANY - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   */


  isTilted(args) {
    return this._isTilted(args.TILT_DIRECTION_ANY);
  }
  /**
   * @param {object} args - the block's arguments.
   * @property {TiltDirection} TILT_DIRECTION - the direction (up, down, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).
   */


  getTiltAngle(args) {
    return this._getTiltAngle(args.TILT_DIRECTION);
  }
  /**
   * Test whether the tilt sensor is currently tilted.
   * @param {TiltDirection} direction - the tilt direction to test (up, down, left, right, or any).
   * @return {boolean} - true if the tilt sensor is tilted past a threshold in the specified direction.
   * @private
   */


  _isTilted(direction) {
    switch (direction) {
      case WeDo2TiltDirection.ANY:
        return this._getTiltAngle(WeDo2TiltDirection.UP) >= Scratch3WeDo2Blocks.TILT_THRESHOLD || this._getTiltAngle(WeDo2TiltDirection.DOWN) >= Scratch3WeDo2Blocks.TILT_THRESHOLD || this._getTiltAngle(WeDo2TiltDirection.LEFT) >= Scratch3WeDo2Blocks.TILT_THRESHOLD || this._getTiltAngle(WeDo2TiltDirection.RIGHT) >= Scratch3WeDo2Blocks.TILT_THRESHOLD;

      default:
        return this._getTiltAngle(direction) >= Scratch3WeDo2Blocks.TILT_THRESHOLD;
    }
  }
  /**
   * @param {TiltDirection} direction - the direction (up, down, left, right) to check.
   * @return {number} - the tilt sensor's angle in the specified direction.
   * Note that getTiltAngle(up) = -getTiltAngle(down) and getTiltAngle(left) = -getTiltAngle(right).
   * @private
   */


  _getTiltAngle(direction) {
    switch (direction) {
      case WeDo2TiltDirection.UP:
        return this._peripheral.tiltY > 45 ? 256 - this._peripheral.tiltY : -this._peripheral.tiltY;

      case WeDo2TiltDirection.DOWN:
        return this._peripheral.tiltY > 45 ? this._peripheral.tiltY - 256 : this._peripheral.tiltY;

      case WeDo2TiltDirection.LEFT:
        return this._peripheral.tiltX > 45 ? 256 - this._peripheral.tiltX : -this._peripheral.tiltX;

      case WeDo2TiltDirection.RIGHT:
        return this._peripheral.tiltX > 45 ? this._peripheral.tiltX - 256 : this._peripheral.tiltX;

      default:
        log.warn("Unknown tilt direction in _getTiltAngle: ".concat(direction));
    }
  }
  /**
   * Call a callback for each motor indexed by the provided motor ID.
   * @param {MotorID} motorID - the ID specifier.
   * @param {Function} callback - the function to call with the numeric motor index for each motor.
   * @private
   */


  _forEachMotor(motorID, callback) {
    let motors;

    switch (motorID) {
      case WeDo2MotorLabel.A:
        motors = [0];
        break;

      case WeDo2MotorLabel.B:
        motors = [1];
        break;

      case WeDo2MotorLabel.ALL:
      case WeDo2MotorLabel.DEFAULT:
        motors = [0, 1];
        break;

      default:
        log.warn("Invalid motor ID: ".concat(motorID));
        motors = [];
        break;
    }

    for (const index of motors) {
      callback(index);
    }
  }
  /**
   * @param {number} midiNote - the MIDI note value to convert.
   * @return {number} - the frequency, in Hz, corresponding to that MIDI note value.
   * @private
   */


  _noteToTone(midiNote) {
    // Note that MIDI note 69 is A4, 440 Hz
    return 440 * Math.pow(2, (midiNote - 69) / 12);
  }

}

module.exports = Scratch3WeDo2Blocks;

/***/ }),

/***/ "./src/extensions/tw/index.js":
/*!************************************!*\
  !*** ./src/extensions/tw/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const formatMessage = __webpack_require__(/*! format-message */ "format-message");

const BlockType = __webpack_require__(/*! ../../extension-support/block-type */ "./src/extension-support/block-type.js");

const ArgumentType = __webpack_require__(/*! ../../extension-support/argument-type */ "./src/extension-support/argument-type.js");

const Cast = __webpack_require__(/*! ../../util/cast */ "./src/util/cast.js");
/**
 * Class for TurboWarp blocks
 * @constructor
 */


class TurboWarpBlocks {
  constructor(runtime) {
    /**
     * The runtime instantiating this block package.
     * @type {Runtime}
     */
    this.runtime = runtime;
  }
  /**
   * @returns {object} metadata for this extension and its blocks.
   */


  getInfo() {
    return {
      id: 'tw',
      name: 'TurboWarp',
      color1: '#ff4c4c',
      color2: '#e64444',
      docsURI: 'https://docs.turbowarp.org/blocks',
      blocks: [{
        opcode: 'getLastKeyPressed',
        text: formatMessage({
          id: 'tw.blocks.lastKeyPressed',
          default: 'last key pressed',
          description: 'Block that returns the last key that was pressed'
        }),
        disableMonitor: true,
        blockType: BlockType.REPORTER
      }, {
        opcode: 'getButtonIsDown',
        text: formatMessage({
          id: 'tw.blocks.buttonIsDown',
          default: '[MOUSE_BUTTON] mouse button down?',
          description: 'Block that returns whether a specific mouse button is down'
        }),
        blockType: BlockType.BOOLEAN,
        arguments: {
          MOUSE_BUTTON: {
            type: ArgumentType.NUMBER,
            menu: 'mouseButton',
            defaultValue: '0'
          }
        }
      }],
      menus: {
        mouseButton: {
          items: [{
            text: formatMessage({
              id: 'tw.blocks.mouseButton.primary',
              default: '(0) primary',
              description: 'Dropdown item to select primary (usually left) mouse button'
            }),
            value: '0'
          }, {
            text: formatMessage({
              id: 'tw.blocks.mouseButton.middle',
              default: '(1) middle',
              description: 'Dropdown item to select middle mouse button'
            }),
            value: '1'
          }, {
            text: formatMessage({
              id: 'tw.blocks.mouseButton.secondary',
              default: '(2) secondary',
              description: 'Dropdown item to select secondary (usually right) mouse button'
            }),
            value: '2'
          }],
          acceptReporters: true
        }
      }
    };
  }

  getLastKeyPressed(args, util) {
    return util.ioQuery('keyboard', 'getLastKeyPressed');
  }

  getButtonIsDown(args, util) {
    const button = Cast.toNumber(args.MOUSE_BUTTON);
    return util.ioQuery('mouse', 'getButtonIsDown', [button]);
  }

}

module.exports = TurboWarpBlocks;

/***/ }),

/***/ "./src/import/load-costume.js":
/*!************************************!*\
  !*** ./src/import/load-costume.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");

const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");

const AsyncLimiter = __webpack_require__(/*! ../util/async-limiter */ "./src/util/async-limiter.js");

const {
  loadSvgString,
  serializeSvgToString
} = __webpack_require__(/*! scratch-svg-renderer */ "./node_modules/scratch-svg-renderer/src/index.js");

const {
  parseVectorMetadata
} = __webpack_require__(/*! ../serialization/tw-costume-import-export */ "./src/serialization/tw-costume-import-export.js");

const loadVector_ = function loadVector_(costume, runtime, rotationCenter, optVersion) {
  return new Promise(resolve => {
    let svgString = costume.asset.decodeText(); // TW: We allow SVGs to specify their rotation center using a special comment.

    if (typeof rotationCenter === 'undefined') {
      const parsedRotationCenter = parseVectorMetadata(svgString);

      if (parsedRotationCenter) {
        rotationCenter = parsedRotationCenter;
        costume.rotationCenterX = rotationCenter[0];
        costume.rotationCenterY = rotationCenter[1];
      }
    } // SVG Renderer load fixes "quirks" associated with Scratch 2 projects


    if (optVersion && optVersion === 2) {
      // scratch-svg-renderer fixes syntax that causes loading issues,
      // and if optVersion is 2, fixes "quirks" associated with Scratch 2 SVGs,
      const fixedSvgString = serializeSvgToString(loadSvgString(svgString, true
      /* fromVersion2 */
      )); // If the string changed, put back into storage

      if (svgString !== fixedSvgString) {
        svgString = fixedSvgString;
        const storage = runtime.storage;
        costume.asset.encodeTextData(fixedSvgString, storage.DataFormat.SVG, true);
        costume.assetId = costume.asset.assetId;
        costume.md5 = "".concat(costume.assetId, ".").concat(costume.dataFormat);
      }
    } // createSVGSkin does the right thing if rotationCenter isn't provided, so it's okay if it's
    // undefined here


    costume.skinId = runtime.renderer.createSVGSkin(svgString, rotationCenter);
    costume.size = runtime.renderer.getSkinSize(costume.skinId); // Now we should have a rotationCenter even if we didn't before

    if (!rotationCenter) {
      rotationCenter = runtime.renderer.getSkinRotationCenter(costume.skinId);
      costume.rotationCenterX = rotationCenter[0];
      costume.rotationCenterY = rotationCenter[1];
      costume.bitmapResolution = 1;
    }

    if (runtime.isPackaged) {
      costume.asset = null;
    }

    resolve(costume);
  });
};

const canvasPool = function () {
  /**
   * A pool of canvas objects that can be reused to reduce memory
   * allocations. And time spent in those allocations and the later garbage
   * collection.
   */
  class CanvasPool {
    constructor() {
      this.pool = [];
      this.clearSoon = null;
    }
    /**
     * After a short wait period clear the pool to let the VM collect
     * garbage.
     */


    clear() {
      if (!this.clearSoon) {
        this.clearSoon = new Promise(resolve => setTimeout(resolve, 1000)).then(() => {
          this.pool.length = 0;
          this.clearSoon = null;
        });
      }
    }
    /**
     * Return a canvas. Create the canvas if the pool is empty.
     * @returns {HTMLCanvasElement} A canvas element.
     */


    create() {
      return this.pool.pop() || document.createElement('canvas');
    }
    /**
     * Release the canvas to be reused.
     * @param {HTMLCanvasElement} canvas A canvas element.
     */


    release(canvas) {
      this.clear();
      this.pool.push(canvas);
    }

  }

  return new CanvasPool();
}();
/**
 * @param {string} src URL of image
 * @returns {Promise<HTMLImageElement>}
 */


const readAsImageElement = src => new Promise((resolve, reject) => {
  const image = new Image();

  image.onload = function () {
    resolve(image);
    image.onload = null;
    image.onerror = null;
  };

  image.onerror = function () {
    reject(new Error('Costume load failed. Asset could not be read.'));
    image.onload = null;
    image.onerror = null;
  };

  image.src = src;
});
/**
 * @param {Asset} asset scratch-storage asset
 * @returns {Promise<HTMLImageElement|ImageBitmap>}
 */


const _persistentReadImage = async asset => {
  // Sometimes, when a lot of images are loaded at once, especially in Chrome, reading an image
  // can throw an error even on valid images. To mitigate this, we'll retry image reading a few
  // time with delays.
  let firstError;

  for (let i = 0; i < 3; i++) {
    try {
      if (typeof createImageBitmap === 'function') {
        const imageBitmap = await createImageBitmap(new Blob([asset.data.buffer], {
          type: asset.assetType.contentType
        })); // If we do too many createImageBitmap at the same time, some browsers (Chrome) will
        // sometimes resolve with undefined. We limit concurrency so this shouldn't ever
        // happen, but if it somehow does, throw an error so it can be retried or so that it
        // falls back to scratch's broken costume handling.

        if (!imageBitmap) {
          throw new Error("createImageBitmap resolved with ".concat(imageBitmap));
        }

        return imageBitmap;
      }

      return await readAsImageElement(asset.encodeDataURI());
    } catch (e) {
      if (!firstError) {
        firstError = e;
      }

      log.warn(e);
      await new Promise(resolve => setTimeout(resolve, Math.random() * 2000));
    }
  }

  throw firstError;
}; // Browsers break when we do too many createImageBitmap at the same time.


const readImage = new AsyncLimiter(_persistentReadImage, 25);
/**
 * Return a promise to fetch a bitmap from storage and return it as a canvas
 * If the costume has bitmapResolution 1, it will be converted to bitmapResolution 2 here (the standard for Scratch 3)
 * If the costume has a text layer asset, which is a text part from Scratch 1.4, then this function
 * will merge the two image assets. See the issue LLK/scratch-vm#672 for more information.
 * @param {!object} costume - the Scratch costume object.
 * @param {!Runtime} runtime - Scratch runtime, used to access the v2BitmapAdapter
 * @param {?object} rotationCenter - optionally passed in coordinates for the center of rotation for the image. If
 *     none is given, the rotation center of the costume will be set to the middle of the costume later on.
 * @property {number} costume.bitmapResolution - the resolution scale for a bitmap costume.
 * @returns {?Promise} - a promise which will resolve to an object {canvas, rotationCenter, assetMatchesBase},
 *     or reject on error.
 *     assetMatchesBase is true if the asset matches the base layer; false if it required adjustment
 */

const fetchBitmapCanvas_ = function fetchBitmapCanvas_(costume, runtime, rotationCenter) {
  if (!costume || !costume.asset) {
    // TODO: We can probably remove this check...
    return Promise.reject('Costume load failed. Assets were missing.');
  }

  if (!runtime.v2BitmapAdapter) {
    return Promise.reject('No V2 Bitmap adapter present.');
  }

  return Promise.all([costume.asset, costume.textLayerAsset].map(asset => {
    if (!asset) {
      return null;
    }

    return readImage.do(asset);
  })).then((_ref) => {
    let [baseImageElement, textImageElement] = _ref;

    if (!baseImageElement) {
      throw new Error('Loading bitmap costume base failed.');
    }

    const scale = costume.bitmapResolution === 1 ? 2 : 1;
    let imageOrCanvas;
    let canvas;

    if (textImageElement) {
      canvas = canvasPool.create();
      canvas.width = baseImageElement.width;
      canvas.height = baseImageElement.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(baseImageElement, 0, 0);
      ctx.drawImage(textImageElement, 0, 0);
      imageOrCanvas = canvas;
    } else {
      imageOrCanvas = baseImageElement;
    }

    if (scale !== 1) {
      // resize() returns a new canvas.
      imageOrCanvas = runtime.v2BitmapAdapter.resize(imageOrCanvas, imageOrCanvas.width * scale, imageOrCanvas.height * scale); // Old canvas is no longer used.

      if (canvas) {
        canvasPool.release(canvas);
      }
    } // This informs TurboWarp/scratch-render that this canvas won't be reused by the canvas pool,
    // which helps it optimize memory use.


    imageOrCanvas.reusable = false; // By scaling, we've converted it to bitmap resolution 2

    if (rotationCenter) {
      rotationCenter[0] = rotationCenter[0] * scale;
      rotationCenter[1] = rotationCenter[1] * scale;
      costume.rotationCenterX = rotationCenter[0];
      costume.rotationCenterY = rotationCenter[1];
    }

    costume.bitmapResolution = 2; // Clean up the costume object

    delete costume.textLayerMD5;
    delete costume.textLayerAsset;
    return {
      image: imageOrCanvas,
      rotationCenter,
      // True if the asset matches the base layer; false if it required adjustment
      assetMatchesBase: scale === 1 && !textImageElement
    };
  }).finally(() => {
    // Clean up the text layer properties if it fails to load
    delete costume.textLayerMD5;
    delete costume.textLayerAsset;
  });
};

const toDataURL = imageOrCanvas => {
  if (imageOrCanvas instanceof HTMLCanvasElement) {
    return imageOrCanvas.toDataURL();
  }

  const canvas = canvasPool.create();
  canvas.width = imageOrCanvas.width;
  canvas.height = imageOrCanvas.height;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(imageOrCanvas, 0, 0);
  const url = canvas.toDataURL();
  canvasPool.release(canvas);
  return url;
};

const loadBitmap_ = function loadBitmap_(costume, runtime, _rotationCenter) {
  return fetchBitmapCanvas_(costume, runtime, _rotationCenter).then(fetched => {
    const updateCostumeAsset = function updateCostumeAsset(dataURI) {
      if (!runtime.v2BitmapAdapter) {
        // TODO: This might be a bad practice since the returned
        // promise isn't acted on. If this is something we should be
        // creating a rejected promise for we should also catch it
        // somewhere and act on that error (like logging).
        //
        // Return a rejection to stop executing updateCostumeAsset.
        return Promise.reject('No V2 Bitmap adapter present.');
      }

      const storage = runtime.storage;
      costume.asset = storage.createAsset(storage.AssetType.ImageBitmap, storage.DataFormat.PNG, runtime.v2BitmapAdapter.convertDataURIToBinary(dataURI), null, true // generate md5
      );
      costume.dataFormat = storage.DataFormat.PNG;
      costume.assetId = costume.asset.assetId;
      costume.md5 = "".concat(costume.assetId, ".").concat(costume.dataFormat);
    };

    if (!fetched.assetMatchesBase) {
      updateCostumeAsset(toDataURL(fetched.image));
    }

    return fetched;
  }).then((_ref2) => {
    let {
      image,
      rotationCenter
    } = _ref2;
    // createBitmapSkin does the right thing if costume.rotationCenter is undefined.
    // That will be the case if you upload a bitmap asset or create one by taking a photo.
    let center;

    if (rotationCenter) {
      // fetchBitmapCanvas will ensure that the costume's bitmap resolution is 2 and its rotation center is
      // scaled to match, so it's okay to always divide by 2.
      center = [rotationCenter[0] / 2, rotationCenter[1] / 2];
    } // TODO: costume.bitmapResolution will always be 2 at this point because of fetchBitmapCanvas_, so we don't
    // need to pass it in here.


    costume.skinId = runtime.renderer.createBitmapSkin(image, costume.bitmapResolution, center);
    const renderSize = runtime.renderer.getSkinSize(costume.skinId);
    costume.size = [renderSize[0] * 2, renderSize[1] * 2]; // Actual size, since all bitmaps are resolution 2

    if (!rotationCenter) {
      rotationCenter = runtime.renderer.getSkinRotationCenter(costume.skinId); // Actual rotation center, since all bitmaps are resolution 2

      costume.rotationCenterX = rotationCenter[0] * 2;
      costume.rotationCenterY = rotationCenter[1] * 2;
      costume.bitmapResolution = 2;
    }

    if (runtime.isPackaged) {
      costume.asset = null;
    }

    return costume;
  });
}; // Handle all manner of costume errors with a Gray Question Mark (default costume)
// and preserve as much of the original costume data as possible
// Returns a promise of a costume


const handleCostumeLoadError = function handleCostumeLoadError(costume, runtime) {
  // Keep track of the old asset information until we're done loading the default costume
  const oldAsset = costume.asset; // could be null

  const oldAssetId = costume.assetId;
  const oldRotationX = costume.rotationCenterX;
  const oldRotationY = costume.rotationCenterY;
  const oldBitmapResolution = costume.bitmapResolution;
  const oldDataFormat = costume.dataFormat;
  const AssetType = runtime.storage.AssetType;
  const isVector = costume.dataFormat === AssetType.ImageVector.runtimeFormat; // Use default asset if original fails to load

  costume.assetId = isVector ? runtime.storage.defaultAssetId.ImageVector : runtime.storage.defaultAssetId.ImageBitmap;
  costume.asset = runtime.storage.get(costume.assetId);
  costume.md5 = "".concat(costume.assetId, ".").concat(costume.asset.dataFormat);
  const defaultCostumePromise = isVector ? loadVector_(costume, runtime) : loadBitmap_(costume, runtime);
  return defaultCostumePromise.then(loadedCostume => {
    loadedCostume.broken = {};
    loadedCostume.broken.assetId = oldAssetId;
    loadedCostume.broken.md5 = "".concat(oldAssetId, ".").concat(oldDataFormat); // Should be null if we got here because the costume was missing

    loadedCostume.broken.asset = oldAsset;
    loadedCostume.broken.dataFormat = oldDataFormat;
    loadedCostume.broken.rotationCenterX = oldRotationX;
    loadedCostume.broken.rotationCenterY = oldRotationY;
    loadedCostume.broken.bitmapResolution = oldBitmapResolution;
    return loadedCostume;
  });
};
/**
 * Initialize a costume from an asset asynchronously.
 * Do not call this unless there is a renderer attached.
 * @param {!object} costume - the Scratch costume object.
 * @property {int} skinId - the ID of the costume's render skin, once installed.
 * @property {number} rotationCenterX - the X component of the costume's origin.
 * @property {number} rotationCenterY - the Y component of the costume's origin.
 * @property {number} [bitmapResolution] - the resolution scale for a bitmap costume.
 * @property {!Asset} costume.asset - the asset of the costume loaded from storage.
 * @param {!Runtime} runtime - Scratch runtime, used to access the storage module.
 * @param {?int} optVersion - Version of Scratch that the costume comes from. If this is set
 *     to 2, scratch 3 will perform an upgrade step to handle quirks in SVGs from Scratch 2.0.
 * @returns {?Promise} - a promise which will resolve after skinId is set, or null on error.
 */


const loadCostumeFromAsset = function loadCostumeFromAsset(costume, runtime, optVersion) {
  costume.assetId = costume.asset.assetId;
  const renderer = runtime.renderer;

  if (!renderer) {
    log.warn('No rendering module present; cannot load costume: ', costume.name);
    return Promise.resolve(costume);
  }

  const AssetType = runtime.storage.AssetType;
  let rotationCenter; // Use provided rotation center and resolution if they are defined. Bitmap resolution
  // should only ever be 1 or 2.

  if (typeof costume.rotationCenterX === 'number' && !isNaN(costume.rotationCenterX) && typeof costume.rotationCenterY === 'number' && !isNaN(costume.rotationCenterY)) {
    rotationCenter = [costume.rotationCenterX, costume.rotationCenterY];
  }

  if (costume.asset.assetType.runtimeFormat === AssetType.ImageVector.runtimeFormat) {
    return loadVector_(costume, runtime, rotationCenter, optVersion).catch(error => {
      log.warn("Error loading vector image: ".concat(error));
      return handleCostumeLoadError(costume, runtime);
    });
  }

  return loadBitmap_(costume, runtime, rotationCenter, optVersion).catch(error => {
    log.warn("Error loading bitmap image: ".concat(error));
    return handleCostumeLoadError(costume, runtime);
  });
};
/**
 * Load a costume's asset into memory asynchronously.
 * Do not call this unless there is a renderer attached.
 * @param {!string} md5ext - the MD5 and extension of the costume to be loaded.
 * @param {!object} costume - the Scratch costume object.
 * @property {int} skinId - the ID of the costume's render skin, once installed.
 * @property {number} rotationCenterX - the X component of the costume's origin.
 * @property {number} rotationCenterY - the Y component of the costume's origin.
 * @property {number} [bitmapResolution] - the resolution scale for a bitmap costume.
 * @param {!Runtime} runtime - Scratch runtime, used to access the storage module.
 * @param {?int} optVersion - Version of Scratch that the costume comes from. If this is set
 *     to 2, scratch 3 will perform an upgrade step to handle quirks in SVGs from Scratch 2.0.
 * @returns {?Promise} - a promise which will resolve after skinId is set, or null on error.
 */


const loadCostume = function loadCostume(md5ext, costume, runtime, optVersion) {
  const idParts = StringUtil.splitFirst(md5ext, '.');
  const md5 = idParts[0];
  const ext = idParts[1].toLowerCase();
  costume.dataFormat = ext;

  if (costume.asset) {
    // Costume comes with asset. It could be coming from image upload, drag and drop, or file
    return loadCostumeFromAsset(costume, runtime, optVersion);
  } // Need to load the costume from storage. The server should have a reference to this md5.


  if (!runtime.storage) {
    log.warn('No storage module present; cannot load costume asset: ', md5ext);
    return Promise.resolve(costume);
  }

  if (!runtime.storage.defaultAssetId) {
    log.warn("No default assets found");
    return Promise.resolve(costume);
  }

  const AssetType = runtime.storage.AssetType;
  const assetType = ext === 'svg' ? AssetType.ImageVector : AssetType.ImageBitmap;
  const costumePromise = runtime.storage.load(assetType, md5, ext);
  let textLayerPromise;

  if (costume.textLayerMD5) {
    textLayerPromise = runtime.storage.load(AssetType.ImageBitmap, costume.textLayerMD5, 'png');
  } else {
    textLayerPromise = Promise.resolve(null);
  }

  return Promise.all([costumePromise, textLayerPromise]).then(assetArray => {
    if (assetArray[0]) {
      costume.asset = assetArray[0];
    } else {
      return handleCostumeLoadError(costume, runtime);
    }

    if (assetArray[1]) {
      costume.textLayerAsset = assetArray[1];
    }

    return loadCostumeFromAsset(costume, runtime, optVersion);
  }).catch(error => {
    // Handle case where storage.load rejects with errors
    // instead of resolving null
    log.warn('Error loading costume: ', error);
    return handleCostumeLoadError(costume, runtime);
  });
};

module.exports = {
  loadCostume,
  loadCostumeFromAsset
};

/***/ }),

/***/ "./src/import/load-sound.js":
/*!**********************************!*\
  !*** ./src/import/load-sound.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");

const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");
/**
 * Initialize a sound from an asset asynchronously.
 * @param {!object} sound - the Scratch sound object.
 * @property {string} md5 - the MD5 and extension of the sound to be loaded.
 * @property {Buffer} data - sound data will be written here once loaded.
 * @param {!Asset} soundAsset - the asset loaded from storage.
 * @param {!Runtime} runtime - Scratch runtime, used to access the storage module.
 * @param {SoundBank} soundBank - Scratch Audio SoundBank to add sounds to.
 * @returns {!Promise} - a promise which will resolve to the sound when ready.
 */


const loadSoundFromAsset = function loadSoundFromAsset(sound, soundAsset, runtime, soundBank) {
  sound.assetId = soundAsset.assetId;

  if (!runtime.audioEngine) {
    log.warn('No audio engine present; cannot load sound asset: ', sound.md5);
    return Promise.resolve(sound);
  }

  return runtime.audioEngine.decodeSoundPlayer(Object.assign({}, sound, {
    data: soundAsset.data
  })).then(soundPlayer => {
    sound.soundId = soundPlayer.id; // Set the sound sample rate and sample count based on the
    // the audio buffer from the audio engine since the sound
    // gets resampled by the audio engine

    const soundBuffer = soundPlayer.buffer;
    sound.rate = soundBuffer.sampleRate;
    sound.sampleCount = soundBuffer.length;

    if (soundBank !== null) {
      soundBank.addSoundPlayer(soundPlayer);
    }

    if (runtime.isPackaged) {
      sound.asset = null;
    }

    return sound;
  });
}; // Handle sound loading errors by replacing the runtime sound with the
// default sound from storage, but keeping track of the original sound metadata
// in a `broken` field


const handleSoundLoadError = function handleSoundLoadError(sound, runtime, soundBank) {
  // Keep track of the old asset information until we're done loading the default sound
  const oldAsset = sound.asset; // could be null

  const oldAssetId = sound.assetId;
  const oldSample = sound.sampleCount;
  const oldRate = sound.rate;
  const oldFormat = sound.format;
  const oldDataFormat = sound.dataFormat; // Use default asset if original fails to load

  sound.assetId = runtime.storage.defaultAssetId.Sound;
  sound.asset = runtime.storage.get(sound.assetId);
  sound.md5 = "".concat(sound.assetId, ".").concat(sound.asset.dataFormat);
  return loadSoundFromAsset(sound, sound.asset, runtime, soundBank).then(loadedSound => {
    loadedSound.broken = {};
    loadedSound.broken.assetId = oldAssetId;
    loadedSound.broken.md5 = "".concat(oldAssetId, ".").concat(oldDataFormat); // Should be null if we got here because the sound was missing

    loadedSound.broken.asset = oldAsset;
    loadedSound.broken.sampleCount = oldSample;
    loadedSound.broken.rate = oldRate;
    loadedSound.broken.format = oldFormat;
    loadedSound.broken.dataFormat = oldDataFormat;
    return loadedSound;
  });
};
/**
 * Load a sound's asset into memory asynchronously.
 * @param {!object} sound - the Scratch sound object.
 * @property {string} md5 - the MD5 and extension of the sound to be loaded.
 * @property {Buffer} data - sound data will be written here once loaded.
 * @param {!Runtime} runtime - Scratch runtime, used to access the storage module.
 * @param {SoundBank} soundBank - Scratch Audio SoundBank to add sounds to.
 * @returns {!Promise} - a promise which will resolve to the sound when ready.
 */


const loadSound = function loadSound(sound, runtime, soundBank) {
  if (!runtime.storage) {
    log.warn('No storage module present; cannot load sound asset: ', sound.md5);
    return Promise.resolve(sound);
  }

  const idParts = StringUtil.splitFirst(sound.md5, '.');
  const md5 = idParts[0];
  const ext = idParts[1].toLowerCase();
  sound.dataFormat = ext;
  return (sound.asset && Promise.resolve(sound.asset) || runtime.storage.load(runtime.storage.AssetType.Sound, md5, ext)).then(soundAsset => {
    sound.asset = soundAsset;

    if (!soundAsset) {
      log.warn('Failed to find sound data: ', sound.md5);
      return handleSoundLoadError(sound, runtime, soundBank);
    }

    return loadSoundFromAsset(sound, soundAsset, runtime, soundBank);
  }).catch(e => {
    log.warn("Failed to load sound: ".concat(sound.md5, " with error: ").concat(e));
    return handleSoundLoadError(sound, runtime, soundBank);
  });
};

module.exports = {
  loadSound,
  loadSoundFromAsset
};

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const VirtualMachine = __webpack_require__(/*! ./virtual-machine */ "./src/virtual-machine.js");

module.exports = VirtualMachine;

/***/ }),

/***/ "./src/io/ble.js":
/*!***********************!*\
  !*** ./src/io/ble.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const JSONRPC = __webpack_require__(/*! ../util/jsonrpc */ "./src/util/jsonrpc.js");

class BLE extends JSONRPC {
  /**
   * A BLE peripheral socket object.  It handles connecting, over web sockets, to
   * BLE peripherals, and reading and writing data to them.
   * @param {Runtime} runtime - the Runtime for sending/receiving GUI update events.
   * @param {string} extensionId - the id of the extension using this socket.
   * @param {object} peripheralOptions - the list of options for peripheral discovery.
   * @param {object} connectCallback - a callback for connection.
   * @param {object} resetCallback - a callback for resetting extension state.
   */
  constructor(runtime, extensionId, peripheralOptions, connectCallback) {
    let resetCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    super();
    this._socket = runtime.getScratchLinkSocket('BLE');

    this._socket.setOnOpen(this.requestPeripheral.bind(this));

    this._socket.setOnClose(this.handleDisconnectError.bind(this));

    this._socket.setOnError(this._handleRequestError.bind(this));

    this._socket.setHandleMessage(this._handleMessage.bind(this));

    this._sendMessage = this._socket.sendMessage.bind(this._socket);
    this._availablePeripherals = {};
    this._connectCallback = connectCallback;
    this._connected = false;
    this._characteristicDidChangeCallback = null;
    this._resetCallback = resetCallback;
    this._discoverTimeoutID = null;
    this._extensionId = extensionId;
    this._peripheralOptions = peripheralOptions;
    this._runtime = runtime;

    this._socket.open();
  }
  /**
   * Request connection to the peripheral.
   * If the web socket is not yet open, request when the socket promise resolves.
   */


  requestPeripheral() {
    this._availablePeripherals = {};

    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    }

    this._discoverTimeoutID = window.setTimeout(this._handleDiscoverTimeout.bind(this), 15000);
    this.sendRemoteRequest('discover', this._peripheralOptions).catch(e => {
      this._handleRequestError(e);
    });
  }
  /**
   * Try connecting to the input peripheral id, and then call the connect
   * callback if connection is successful.
   * @param {number} id - the id of the peripheral to connect to
   */


  connectPeripheral(id) {
    this.sendRemoteRequest('connect', {
      peripheralId: id
    }).then(() => {
      this._connected = true;

      this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTED);

      this._connectCallback();
    }).catch(e => {
      this._handleRequestError(e);
    });
  }
  /**
   * Close the websocket.
   */


  disconnect() {
    if (this._connected) {
      this._connected = false;
    }

    if (this._socket.isOpen()) {
      this._socket.close();
    }

    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    } // Sets connection status icon to orange


    this._runtime.emit(this._runtime.constructor.PERIPHERAL_DISCONNECTED);
  }
  /**
   * @return {bool} whether the peripheral is connected.
   */


  isConnected() {
    return this._connected;
  }
  /**
   * Start receiving notifications from the specified ble service.
   * @param {number} serviceId - the ble service to read.
   * @param {number} characteristicId - the ble characteristic to get notifications from.
   * @param {object} onCharacteristicChanged - callback for characteristic change notifications.
   * @return {Promise} - a promise from the remote startNotifications request.
   */


  startNotifications(serviceId, characteristicId) {
    let onCharacteristicChanged = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    const params = {
      serviceId,
      characteristicId
    };
    this._characteristicDidChangeCallback = onCharacteristicChanged;
    return this.sendRemoteRequest('startNotifications', params).catch(e => {
      this.handleDisconnectError(e);
    });
  }
  /**
   * Read from the specified ble service.
   * @param {number} serviceId - the ble service to read.
   * @param {number} characteristicId - the ble characteristic to read.
   * @param {boolean} optStartNotifications - whether to start receiving characteristic change notifications.
   * @param {object} onCharacteristicChanged - callback for characteristic change notifications.
   * @return {Promise} - a promise from the remote read request.
   */


  read(serviceId, characteristicId) {
    let optStartNotifications = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    let onCharacteristicChanged = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    const params = {
      serviceId,
      characteristicId
    };

    if (optStartNotifications) {
      params.startNotifications = true;
    }

    if (onCharacteristicChanged) {
      this._characteristicDidChangeCallback = onCharacteristicChanged;
    }

    return this.sendRemoteRequest('read', params).catch(e => {
      this.handleDisconnectError(e);
    });
  }
  /**
   * Write data to the specified ble service.
   * @param {number} serviceId - the ble service to write.
   * @param {number} characteristicId - the ble characteristic to write.
   * @param {string} message - the message to send.
   * @param {string} encoding - the message encoding type.
   * @param {boolean} withResponse - if true, resolve after peripheral's response.
   * @return {Promise} - a promise from the remote send request.
   */


  write(serviceId, characteristicId, message) {
    let encoding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    let withResponse = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    const params = {
      serviceId,
      characteristicId,
      message
    };

    if (encoding) {
      params.encoding = encoding;
    }

    if (withResponse !== null) {
      params.withResponse = withResponse;
    }

    return this.sendRemoteRequest('write', params).catch(e => {
      this.handleDisconnectError(e);
    });
  }
  /**
   * Handle a received call from the socket.
   * @param {string} method - a received method label.
   * @param {object} params - a received list of parameters.
   * @return {object} - optional return value.
   */


  didReceiveCall(method, params) {
    switch (method) {
      case 'didDiscoverPeripheral':
        this._availablePeripherals[params.peripheralId] = params;

        this._runtime.emit(this._runtime.constructor.PERIPHERAL_LIST_UPDATE, this._availablePeripherals);

        if (this._discoverTimeoutID) {
          window.clearTimeout(this._discoverTimeoutID);
        }

        break;

      case 'userDidPickPeripheral':
        this._availablePeripherals[params.peripheralId] = params;

        this._runtime.emit(this._runtime.constructor.USER_PICKED_PERIPHERAL, this._availablePeripherals);

        if (this._discoverTimeoutID) {
          window.clearTimeout(this._discoverTimeoutID);
        }

        break;

      case 'userDidNotPickPeripheral':
        this._runtime.emit(this._runtime.constructor.PERIPHERAL_SCAN_TIMEOUT);

        if (this._discoverTimeoutID) {
          window.clearTimeout(this._discoverTimeoutID);
        }

        break;

      case 'characteristicDidChange':
        if (this._characteristicDidChangeCallback) {
          this._characteristicDidChangeCallback(params.message);
        }

        break;

      case 'ping':
        return 42;
    }
  }
  /**
   * Handle an error resulting from losing connection to a peripheral.
   *
   * This could be due to:
   * - battery depletion
   * - going out of bluetooth range
   * - being powered down
   *
   * Disconnect the socket, and if the extension using this socket has a
   * reset callback, call it. Finally, emit an error to the runtime.
   */


  handleDisconnectError()
  /* e */
  {
    // log.error(`BLE error: ${JSON.stringify(e)}`);
    if (!this._connected) return;
    this.disconnect();

    if (this._resetCallback) {
      this._resetCallback();
    }

    this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTION_LOST_ERROR, {
      message: "Scratch lost connection to",
      extensionId: this._extensionId
    });
  }

  _handleRequestError()
  /* e */
  {
    // log.error(`BLE error: ${JSON.stringify(e)}`);
    this._runtime.emit(this._runtime.constructor.PERIPHERAL_REQUEST_ERROR, {
      message: "Scratch lost connection to",
      extensionId: this._extensionId
    });
  }

  _handleDiscoverTimeout() {
    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    }

    this._runtime.emit(this._runtime.constructor.PERIPHERAL_SCAN_TIMEOUT);
  }

}

module.exports = BLE;

/***/ }),

/***/ "./src/io/bt.js":
/*!**********************!*\
  !*** ./src/io/bt.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const JSONRPC = __webpack_require__(/*! ../util/jsonrpc */ "./src/util/jsonrpc.js");

class BT extends JSONRPC {
  /**
   * A BT peripheral socket object.  It handles connecting, over web sockets, to
   * BT peripherals, and reading and writing data to them.
   * @param {Runtime} runtime - the Runtime for sending/receiving GUI update events.
   * @param {string} extensionId - the id of the extension using this socket.
   * @param {object} peripheralOptions - the list of options for peripheral discovery.
   * @param {object} connectCallback - a callback for connection.
   * @param {object} resetCallback - a callback for resetting extension state.
   * @param {object} messageCallback - a callback for message sending.
   */
  constructor(runtime, extensionId, peripheralOptions, connectCallback) {
    let resetCallback = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    let messageCallback = arguments.length > 5 ? arguments[5] : undefined;
    super();
    this._socket = runtime.getScratchLinkSocket('BT');

    this._socket.setOnOpen(this.requestPeripheral.bind(this));

    this._socket.setOnError(this._handleRequestError.bind(this));

    this._socket.setOnClose(this.handleDisconnectError.bind(this));

    this._socket.setHandleMessage(this._handleMessage.bind(this));

    this._sendMessage = this._socket.sendMessage.bind(this._socket);
    this._availablePeripherals = {};
    this._connectCallback = connectCallback;
    this._connected = false;
    this._characteristicDidChangeCallback = null;
    this._resetCallback = resetCallback;
    this._discoverTimeoutID = null;
    this._extensionId = extensionId;
    this._peripheralOptions = peripheralOptions;
    this._messageCallback = messageCallback;
    this._runtime = runtime;

    this._socket.open();
  }
  /**
   * Request connection to the peripheral.
   * If the web socket is not yet open, request when the socket promise resolves.
   */


  requestPeripheral() {
    this._availablePeripherals = {};

    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    }

    this._discoverTimeoutID = window.setTimeout(this._handleDiscoverTimeout.bind(this), 15000);
    this.sendRemoteRequest('discover', this._peripheralOptions).catch(e => this._handleRequestError(e));
  }
  /**
   * Try connecting to the input peripheral id, and then call the connect
   * callback if connection is successful.
   * @param {number} id - the id of the peripheral to connect to
   * @param {string} pin - an optional pin for pairing
   */


  connectPeripheral(id) {
    let pin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    const params = {
      peripheralId: id
    };

    if (pin) {
      params.pin = pin;
    }

    this.sendRemoteRequest('connect', params).then(() => {
      this._connected = true;

      this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTED);

      this._connectCallback();
    }).catch(e => {
      this._handleRequestError(e);
    });
  }
  /**
   * Close the websocket.
   */


  disconnect() {
    if (this._connected) {
      this._connected = false;
    }

    if (this._socket.isOpen()) {
      this._socket.close();
    }

    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    } // Sets connection status icon to orange


    this._runtime.emit(this._runtime.constructor.PERIPHERAL_DISCONNECTED);
  }
  /**
   * @return {bool} whether the peripheral is connected.
   */


  isConnected() {
    return this._connected;
  }

  sendMessage(options) {
    return this.sendRemoteRequest('send', options).catch(e => {
      this.handleDisconnectError(e);
    });
  }
  /**
   * Handle a received call from the socket.
   * @param {string} method - a received method label.
   * @param {object} params - a received list of parameters.
   * @return {object} - optional return value.
   */


  didReceiveCall(method, params) {
    // TODO: Add peripheral 'undiscover' handling
    switch (method) {
      case 'didDiscoverPeripheral':
        this._availablePeripherals[params.peripheralId] = params;

        this._runtime.emit(this._runtime.constructor.PERIPHERAL_LIST_UPDATE, this._availablePeripherals);

        if (this._discoverTimeoutID) {
          window.clearTimeout(this._discoverTimeoutID);
        }

        break;

      case 'userDidPickPeripheral':
        this._availablePeripherals[params.peripheralId] = params;

        this._runtime.emit(this._runtime.constructor.USER_PICKED_PERIPHERAL, this._availablePeripherals);

        if (this._discoverTimeoutID) {
          window.clearTimeout(this._discoverTimeoutID);
        }

        break;

      case 'userDidNotPickPeripheral':
        this._runtime.emit(this._runtime.constructor.PERIPHERAL_SCAN_TIMEOUT);

        if (this._discoverTimeoutID) {
          window.clearTimeout(this._discoverTimeoutID);
        }

        break;

      case 'didReceiveMessage':
        this._messageCallback(params); // TODO: refine?


        break;

      default:
        return 'nah';
    }
  }
  /**
   * Handle an error resulting from losing connection to a peripheral.
   *
   * This could be due to:
   * - battery depletion
   * - going out of bluetooth range
   * - being powered down
   *
   * Disconnect the socket, and if the extension using this socket has a
   * reset callback, call it. Finally, emit an error to the runtime.
   */


  handleDisconnectError()
  /* e */
  {
    // log.error(`BT error: ${JSON.stringify(e)}`);
    if (!this._connected) return;
    this.disconnect();

    if (this._resetCallback) {
      this._resetCallback();
    }

    this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTION_LOST_ERROR, {
      message: "Scratch lost connection to",
      extensionId: this._extensionId
    });
  }

  _handleRequestError()
  /* e */
  {
    // log.error(`BT error: ${JSON.stringify(e)}`);
    this._runtime.emit(this._runtime.constructor.PERIPHERAL_REQUEST_ERROR, {
      message: "Scratch lost connection to",
      extensionId: this._extensionId
    });
  }

  _handleDiscoverTimeout() {
    if (this._discoverTimeoutID) {
      window.clearTimeout(this._discoverTimeoutID);
    }

    this._runtime.emit(this._runtime.constructor.PERIPHERAL_SCAN_TIMEOUT);
  }

}

module.exports = BT;

/***/ }),

/***/ "./src/io/clock.js":
/*!*************************!*\
  !*** ./src/io/clock.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Timer = __webpack_require__(/*! ../util/timer */ "./src/util/timer.js");

class Clock {
  constructor(runtime) {
    this._projectTimer = new Timer({
      now: () => runtime.currentMSecs
    });

    this._projectTimer.start();

    this._pausedTime = null;
    this._paused = false;
    /**
     * Reference to the owning Runtime.
     * @type{!Runtime}
     */

    this.runtime = runtime;
  }

  projectTimer() {
    if (this._paused) {
      return this._pausedTime / 1000;
    }

    return this._projectTimer.timeElapsed() / 1000;
  }

  pause() {
    this._paused = true;
    this._pausedTime = this._projectTimer.timeElapsed();
  }

  resume() {
    this._paused = false;

    const dt = this._projectTimer.timeElapsed() - this._pausedTime;

    this._projectTimer.startTime += dt;
  }

  resetProjectTimer() {
    this._projectTimer.start();
  }

}

module.exports = Clock;

/***/ }),

/***/ "./src/io/cloud.js":
/*!*************************!*\
  !*** ./src/io/cloud.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Variable = __webpack_require__(/*! ../engine/variable */ "./src/engine/variable.js");

const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");

class Cloud {
  /**
   * @typedef updateVariable
   * @param {string} name The name of the cloud variable to update on the server
   * @param {(string | number)} value The value to update the cloud variable with.
   */

  /**
   * A cloud data provider, responsible for managing the connection to the
   * cloud data server and for posting data about cloud data activity to
   * this IO device.
   * @typedef {object} CloudProvider
   * @property {updateVariable} updateVariable A function which sends a cloud variable
   * update to the cloud data server.
   * @property {Function} requestCloseConnection A function which closes
   * the connection to the cloud data server.
   */

  /**
   * Part of a cloud io data post indicating a cloud variable update.
   * @typedef {object} VarUpdateData
   * @property {string} name The name of the variable to update
   * @property {(number | string)} value The scalar value to update the variable with
   */

  /**
   * A cloud io data post message.
   * @typedef {object} CloudIOData
   * @property {VarUpdateData} varUpdate A {@link VarUpdateData} message indicating
   * a cloud variable update
   */

  /**
   * Cloud IO Device responsible for sending and receiving messages from
   * cloud provider (mananging the cloud server connection) and interacting
   * with cloud variables in the current project.
   * @param {Runtime} runtime The runtime context for this cloud io device.
   */
  constructor(runtime) {
    /**
     * Reference to the cloud data provider, responsible for mananging
     * the web socket connection to the cloud data server.
     * @type {?CloudProvider}
     */
    this.provider = null;
    /**
     * Reference to the runtime that owns this cloud io device.
     * @type {!Runtime}
     */

    this.runtime = runtime;
    /**
     * Reference to the stage target which owns the cloud variables
     * in the project.
     * @type {?Target}
     */

    this.stage = null;
  }
  /**
   * Set a reference to the cloud data provider.
   * @param {CloudProvider} provider The cloud data provider
   */


  setProvider(provider) {
    this.provider = provider;
  }
  /**
   * Set a reference to the stage target which owns the
   * cloud variables in the project.
   * @param {Target} stage The stage target
   */


  setStage(stage) {
    this.stage = stage;
  }
  /**
   * Handle incoming data to this io device.
   * @param {CloudIOData} data The {@link CloudIOData} object to process
   */


  postData(data) {
    if (data.varUpdate) {
      this.updateCloudVariable(data.varUpdate);
    }
  }

  requestCreateVariable(variable) {
    if (this.runtime.canAddCloudVariable()) {
      if (this.provider) {
        this.provider.createVariable(variable.name, variable.value); // We'll set the cloud flag and update the
        // cloud variable limit when we actually
        // get a confirmation from the cloud data server
      }
    } // TODO else track creation for later

  }
  /**
   * Request the cloud data provider to update the given variable with
   * the given value. Does nothing if this io device does not have a provider set.
   * @param {string} name The name of the variable to update
   * @param {string | number} value The value to update the variable with
   */


  requestUpdateVariable(name, value) {
    if (this.provider) {
      this.provider.updateVariable(name, value);
    }
  }
  /**
   * Request the cloud data provider to rename the variable with the given name
   * to the given new name. Does nothing if this io device does not have a provider set.
   * @param {string} oldName The name of the variable to rename
   * @param {string | number} newName The new name for the variable
   */


  requestRenameVariable(oldName, newName) {
    if (this.provider) {
      this.provider.renameVariable(oldName, newName);
    }
  }
  /**
   * Request the cloud data provider to delete the variable with the given name
   * Does nothing if this io device does not have a provider set.
   * @param {string} name The name of the variable to delete
   */


  requestDeleteVariable(name) {
    if (this.provider) {
      this.provider.deleteVariable(name);
    }
  }
  /**
   * Update a cloud variable in the runtime based on the message received
   * from the cloud provider.
   * @param {VarData} varUpdate A {@link VarData} object describing
   * a cloud variable update received from the cloud data provider.
   */


  updateCloudVariable(varUpdate) {
    const varName = varUpdate.name;
    const variable = this.stage.lookupVariableByNameAndType(varName, Variable.SCALAR_TYPE);

    if (!variable || !variable.isCloud) {
      log.warn("Received an update for a cloud variable that does not exist: ".concat(varName));
      return;
    }

    variable.value = varUpdate.value;
  }
  /**
   * Request the cloud data provider to close the web socket connection and
   * clear this io device of references to the cloud data provider and the
   * stage.
   */


  clear() {
    if (!this.provider) return;
    this.provider.requestCloseConnection();
    this.provider = null;
    this.stage = null;
  }

}

module.exports = Cloud;

/***/ }),

/***/ "./src/io/keyboard.js":
/*!****************************!*\
  !*** ./src/io/keyboard.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Cast = __webpack_require__(/*! ../util/cast */ "./src/util/cast.js");
/**
 * Names used internally for keys used in scratch, also known as "scratch keys".
 * @enum {string}
 */


const KEY_NAME = {
  SPACE: 'space',
  LEFT: 'left arrow',
  UP: 'up arrow',
  RIGHT: 'right arrow',
  DOWN: 'down arrow',
  ENTER: 'enter',
  // tw: extra keys
  BACKSPACE: 'backspace',
  DELETE: 'delete',
  SHIFT: 'shift',
  CAPS_LOCK: 'caps lock',
  SCROLL_LOCK: 'scroll lock',
  CONTROL: 'control',
  ESCAPE: 'escape',
  INSERT: 'insert',
  HOME: 'home',
  END: 'end',
  PAGE_UP: 'page up',
  PAGE_DOWN: 'page down'
};
/**
 * An array of the names of scratch keys.
 * @type {Array<string>}
 */

const KEY_NAME_LIST = Object.keys(KEY_NAME).map(name => KEY_NAME[name]);

class Keyboard {
  constructor(runtime) {
    /**
     * List of currently pressed scratch keys.
     * A scratch key is:
     * A key you can press on a keyboard, excluding modifier keys.
     * An uppercase string of length one;
     *     except for special key names for arrow keys and space (e.g. 'left arrow').
     * Can be a non-english unicode letter like:      .
     * @type{Array.<string>}
     */
    this._keysPressed = [];
    /**
     * Reference to the owning Runtime.
     * Can be used, for example, to activate hats.
     * @type{!Runtime}
     */

    this.runtime = runtime; // tw: track last pressed key

    this.lastKeyPressed = '';
    this._numeralKeyCodesToStringKey = new Map();
  }
  /**
   * Convert from a keyboard event key name to a Scratch key name.
   * @param  {string} keyString the input key string.
   * @return {string} the corresponding Scratch key, or an empty string.
   */


  _keyStringToScratchKey(keyString) {
    keyString = Cast.toString(keyString); // Convert space and arrow keys to their Scratch key names.

    switch (keyString) {
      case ' ':
        return KEY_NAME.SPACE;

      case 'ArrowLeft':
      case 'Left':
        return KEY_NAME.LEFT;

      case 'ArrowUp':
      case 'Up':
        return KEY_NAME.UP;

      case 'Right':
      case 'ArrowRight':
        return KEY_NAME.RIGHT;

      case 'Down':
      case 'ArrowDown':
        return KEY_NAME.DOWN;

      case 'Enter':
        return KEY_NAME.ENTER;
      // tw: extra keys

      case 'Backspace':
        return KEY_NAME.BACKSPACE;

      case 'Delete':
        return KEY_NAME.DELETE;

      case 'Shift':
        return KEY_NAME.SHIFT;

      case 'CapsLock':
        return KEY_NAME.CAPS_LOCK;

      case 'ScrollLock':
        return KEY_NAME.SCROLL_LOCK;

      case 'Control':
        return KEY_NAME.CONTROL;

      case 'Escape':
        return KEY_NAME.ESCAPE;

      case 'Insert':
        return KEY_NAME.INSERT;

      case 'Home':
        return KEY_NAME.HOME;

      case 'End':
        return KEY_NAME.END;

      case 'PageUp':
        return KEY_NAME.PAGE_UP;

      case 'PageDown':
        return KEY_NAME.PAGE_DOWN;
    } // Ignore modifier keys


    if (keyString.length > 1) {
      return '';
    } // tw: toUpperCase() happens later. We need to track key case.


    return keyString;
  }
  /**
   * Convert from a block argument to a Scratch key name.
   * @param  {string} keyArg the input arg.
   * @return {string} the corresponding Scratch key.
   */


  _keyArgToScratchKey(keyArg) {
    // If a number was dropped in, try to convert from ASCII to Scratch key.
    if (typeof keyArg === 'number') {
      // Check for the ASCII range containing numbers, some punctuation,
      // and uppercase letters.
      if (keyArg >= 48 && keyArg <= 90) {
        return String.fromCharCode(keyArg);
      }

      switch (keyArg) {
        case 32:
          return KEY_NAME.SPACE;

        case 37:
          return KEY_NAME.LEFT;

        case 38:
          return KEY_NAME.UP;

        case 39:
          return KEY_NAME.RIGHT;

        case 40:
          return KEY_NAME.DOWN;
      }
    }

    keyArg = Cast.toString(keyArg); // If the arg matches a special key name, return it.

    if (KEY_NAME_LIST.includes(keyArg)) {
      return keyArg;
    } // Use only the first character.


    if (keyArg.length > 1) {
      keyArg = keyArg[0];
    } // Check for the space character.


    if (keyArg === ' ') {
      return KEY_NAME.SPACE;
    } // tw: support Scratch 2 hacked blocks
    // There are more hacked blocks but most of them get mangled by Scratch 2 -> Scratch 3 conversion


    if (keyArg === '\r') {
      // this probably belongs upstream
      return KEY_NAME.ENTER;
    }

    if (keyArg === '\u001b') {
      return KEY_NAME.ESCAPE;
    }

    return keyArg.toUpperCase();
  }
  /**
   * Keyboard DOM event handler.
   * @param  {object} data Data from DOM event.
   */


  postData(data) {
    if (!data.key) return; // tw: convert single letter keys to uppercase because of changes in _keyStringToScratchKey

    const scratchKeyCased = this._keyStringToScratchKey(data.key);

    const scratchKey = scratchKeyCased.length === 1 ? scratchKeyCased.toUpperCase() : scratchKeyCased;
    if (scratchKey === '') return;

    const index = this._keysPressed.indexOf(scratchKey);

    if (data.isDown) {
      // tw: track last pressed key
      this.lastKeyPressed = scratchKeyCased;
      this.runtime.emit('KEY_PRESSED', scratchKey); // If not already present, add to the list.

      if (index < 0) {
        this._keysPressed.push(scratchKey);
      }
    } else if (index > -1) {
      // If already present, remove from the list.
      this._keysPressed.splice(index, 1);
    } // Fix for https://github.com/LLK/scratch-vm/issues/2271


    if (data.hasOwnProperty('keyCode')) {
      const keyCode = data.keyCode;

      if (this._numeralKeyCodesToStringKey.has(keyCode)) {
        const lastKeyOfSameCode = this._numeralKeyCodesToStringKey.get(keyCode);

        if (lastKeyOfSameCode !== scratchKey) {
          const indexToUnpress = this._keysPressed.indexOf(lastKeyOfSameCode);

          if (indexToUnpress !== -1) {
            this._keysPressed.splice(indexToUnpress, 1);
          }
        }
      }

      this._numeralKeyCodesToStringKey.set(keyCode, scratchKey);
    }
  }
  /**
   * Get key down state for a specified key.
   * @param  {Any} keyArg key argument.
   * @return {boolean} Is the specified key down?
   */


  getKeyIsDown(keyArg) {
    if (keyArg === 'any') {
      return this._keysPressed.length > 0;
    }

    const scratchKey = this._keyArgToScratchKey(keyArg);

    return this._keysPressed.indexOf(scratchKey) > -1;
  } // tw: expose last pressed key


  getLastKeyPressed() {
    return this.lastKeyPressed;
  }

}

module.exports = Keyboard;

/***/ }),

/***/ "./src/io/mouse.js":
/*!*************************!*\
  !*** ./src/io/mouse.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const MathUtil = __webpack_require__(/*! ../util/math-util */ "./src/util/math-util.js");

const roundToThreeDecimals = number => Math.round(number * 1000) / 1000;

class Mouse {
  constructor(runtime) {
    this._clientX = 0;
    this._clientY = 0;
    this._scratchX = 0;
    this._scratchY = 0;
    this._buttons = new Set();
    this.usesRightClickDown = false;
    this._isDown = false;
    /**
     * Reference to the owning Runtime.
     * Can be used, for example, to activate hats.
     * @type{!Runtime}
     */

    this.runtime = runtime;
  }
  /**
   * Activate "event_whenthisspriteclicked" hats.
   * @param  {Target} target to trigger hats on.
   * @private
   */


  _activateClickHats(target) {
    // Activate both "this sprite clicked" and "stage clicked"
    // They were separated into two opcodes for labeling,
    // but should act the same way.
    // Intentionally not checking isStage to make it work when sharing blocks.
    // @todo the blocks should be converted from one to another when shared
    this.runtime.startHats('event_whenthisspriteclicked', null, target);
    this.runtime.startHats('event_whenstageclicked', null, target);
  }
  /**
   * Find a target by XY location
   * @param  {number} x X position to be sent to the renderer.
   * @param  {number} y Y position to be sent to the renderer.
   * @return {Target} the target at that location
   * @private
   */


  _pickTarget(x, y) {
    if (this.runtime.renderer) {
      const drawableID = this.runtime.renderer.pick(x, y);

      for (let i = 0; i < this.runtime.targets.length; i++) {
        const target = this.runtime.targets[i];

        if (target.hasOwnProperty('drawableID') && target.drawableID === drawableID) {
          return target;
        }
      }
    } // Return the stage if no target was found


    return this.runtime.getTargetForStage();
  }
  /**
   * Mouse DOM event handler.
   * @param  {object} data Data from DOM event.
   */


  postData(data) {
    if (data.x) {
      this._clientX = data.x;
      this._scratchX = MathUtil.clamp(this.runtime.stageWidth * (data.x / data.canvasWidth - 0.5), -(this.runtime.stageWidth / 2), this.runtime.stageWidth / 2);
    }

    if (data.y) {
      this._clientY = data.y;
      this._scratchY = MathUtil.clamp(-this.runtime.stageHeight * (data.y / data.canvasHeight - 0.5), -(this.runtime.stageHeight / 2), this.runtime.stageHeight / 2);
    }

    if (typeof data.isDown !== 'undefined') {
      // If no button specified, default to left button for compatibility
      const button = typeof data.button === 'undefined' ? 0 : data.button;

      if (data.isDown) {
        this._buttons.add(button);
      } else {
        this._buttons.delete(button);
      }

      const previousDownState = this._isDown;
      this._isDown = data.isDown; // Do not trigger if down state has not changed

      if (previousDownState === this._isDown) return; // Never trigger click hats at the end of a drag

      if (data.wasDragged) return; // Do not activate click hats for clicks outside canvas bounds

      if (!(data.x > 0 && data.x < data.canvasWidth && data.y > 0 && data.y < data.canvasHeight)) return;

      const target = this._pickTarget(data.x, data.y);

      const isNewMouseDown = !previousDownState && this._isDown;
      const isNewMouseUp = previousDownState && !this._isDown; // Draggable targets start click hats on mouse up.
      // Non-draggable targets start click hats on mouse down.

      if (target.draggable && isNewMouseUp) {
        this._activateClickHats(target);
      } else if (!target.draggable && isNewMouseDown) {
        this._activateClickHats(target);
      }
    }
  }
  /**
   * Get the X position of the mouse in client coordinates.
   * @return {number} Non-clamped X position of the mouse cursor.
   */


  getClientX() {
    return this._clientX;
  }
  /**
   * Get the Y position of the mouse in client coordinates.
   * @return {number} Non-clamped Y position of the mouse cursor.
   */


  getClientY() {
    return this._clientY;
  }
  /**
   * Get the X position of the mouse in scratch coordinates.
   * @return {number} Clamped and integer rounded X position of the mouse cursor.
   */


  getScratchX() {
    if (this.runtime.runtimeOptions.miscLimits) {
      return Math.round(this._scratchX);
    }

    return roundToThreeDecimals(this._scratchX);
  }
  /**
   * Get the Y position of the mouse in scratch coordinates.
   * @return {number} Clamped and integer rounded Y position of the mouse cursor.
   */


  getScratchY() {
    if (this.runtime.runtimeOptions.miscLimits) {
      return Math.round(this._scratchY);
    }

    return roundToThreeDecimals(this._scratchY);
  }
  /**
   * Get the down state of the mouse.
   * @return {boolean} Is the mouse down?
   */


  getIsDown() {
    return this._isDown;
  }
  /**
   * tw: Get the down state of a specific button of the mouse.
   * @param {number} button The ID of the button. 0 = left, 1 = middle, 2 = right
   * @return {boolean} Is the mouse button down?
   */


  getButtonIsDown(button) {
    if (button === 2) {
      this.usesRightClickDown = true;
    }

    return this._buttons.has(button);
  }

}

module.exports = Mouse;

/***/ }),

/***/ "./src/io/mouseWheel.js":
/*!******************************!*\
  !*** ./src/io/mouseWheel.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

class MouseWheel {
  constructor(runtime) {
    /**
     * Reference to the owning Runtime.
     * @type{!Runtime}
     */
    this.runtime = runtime;
  }
  /**
   * Mouse wheel DOM event handler.
   * @param  {object} data Data from DOM event.
   */


  postData(data) {
    const matchFields = {};

    if (data.deltaY < 0) {
      matchFields.KEY_OPTION = 'up arrow';
    } else if (data.deltaY > 0) {
      matchFields.KEY_OPTION = 'down arrow';
    } else {
      return;
    }

    this.runtime.startHats('event_whenkeypressed', matchFields);
  }

}

module.exports = MouseWheel;

/***/ }),

/***/ "./src/io/userData.js":
/*!****************************!*\
  !*** ./src/io/userData.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

class UserData {
  constructor() {
    this._username = '';
  }
  /**
   * Handler for updating the username
   * @param {object} data Data posted to this ioDevice.
   * @property {!string} username The new username.
   */


  postData(data) {
    this._username = data.username;
  }
  /**
   * Getter for username. Initially empty string, until set via postData.
   * @returns {!string} The current username
   */


  getUsername() {
    return this._username;
  }

}

module.exports = UserData;

/***/ }),

/***/ "./src/io/video.js":
/*!*************************!*\
  !*** ./src/io/video.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");

class Video {
  constructor(runtime) {
    this.runtime = runtime;
    /**
     * @typedef VideoProvider
     * @property {Function} enableVideo - Requests camera access from the user, and upon success,
     * enables the video feed
     * @property {Function} disableVideo - Turns off the video feed
     * @property {Function} getFrame - Return frame data from the video feed in
     * specified dimensions, format, and mirroring.
     */

    this.provider = null;
    /**
     * Id representing a Scratch Renderer skin the video is rendered to for
     * previewing.
     * @type {number}
     */

    this._skinId = -1;
    /**
     * Id for a drawable using the video's skin that will render as a video
     * preview.
     * @type {Drawable}
     */

    this._drawable = -1;
    /**
     * Store the last state of the video transparency ghost effect
     * @type {number}
     */

    this._ghost = 0;
    /**
     * Store a flag that allows the preview to be forced transparent.
     * @type {number}
     */

    this._forceTransparentPreview = false;
  }

  static get FORMAT_IMAGE_DATA() {
    return 'image-data';
  }

  static get FORMAT_CANVAS() {
    return 'canvas';
  }
  /**
   * Dimensions the video stream is analyzed at after its rendered to the
   * sample canvas.
   * @type {Array.<number>}
   */


  static get DIMENSIONS() {
    return [480, 360];
  }
  /**
   * Order preview drawable is inserted at in the renderer.
   * @type {number}
   */


  static get ORDER() {
    return 1;
  }
  /**
   * Set a video provider for this device. A default implementation of
   * a video provider can be found in scratch-gui/src/lib/video/video-provider
   * @param {VideoProvider} provider - Video provider to use
   */


  setProvider(provider) {
    this.provider = provider;
  }
  /**
   * Request video be enabled.  Sets up video, creates video skin and enables preview.
   *
   * ioDevices.video.requestVideo()
   *
   * @return {Promise.<Video>} resolves a promise to this IO device when video is ready.
   */


  enableVideo() {
    if (!this.provider) return null;
    return this.provider.enableVideo().then(() => this._setupPreview());
  }
  /**
   * Disable video stream (turn video off)
   * @return {void}
   */


  disableVideo() {
    this._disablePreview();

    if (!this.provider) return null;
    this.provider.disableVideo();
  }
  /**
   * Return frame data from the video feed in a specified dimensions, format, and mirroring.
   *
   * @param {object} frameInfo A descriptor of the frame you would like to receive.
   * @param {Array.<number>} frameInfo.dimensions [width, height] array of numbers.  Defaults to [480,360]
   * @param {boolean} frameInfo.mirror If you specificly want a mirror/non-mirror frame, defaults to the global
   *                                   mirror state (ioDevices.video.mirror)
   * @param {string} frameInfo.format Requested video format, available formats are 'image-data' and 'canvas'.
   * @param {number} frameInfo.cacheTimeout Will reuse previous image data if the time since capture is less than
   *                                        the cacheTimeout.  Defaults to 16ms.
   *
   * @return {ArrayBuffer|Canvas|string|null} Frame data in requested format, null when errors.
   */


  getFrame(_ref) {
    let {
      dimensions = Video.DIMENSIONS,
      mirror = this.mirror,
      format = Video.FORMAT_IMAGE_DATA,
      cacheTimeout = this._frameCacheTimeout
    } = _ref;
    if (this.provider) return this.provider.getFrame({
      dimensions,
      mirror,
      format,
      cacheTimeout
    });
    return null;
  }
  /**
   * Set the preview ghost effect
   * @param {number} ghost from 0 (visible) to 100 (invisible) - ghost effect
   */


  setPreviewGhost(ghost) {
    this._ghost = ghost; // Confirm that the default value has been changed to a valid id for the drawable

    if (this._drawable !== -1) {
      this.runtime.renderer.updateDrawableEffect(this._drawable, 'ghost', this._forceTransparentPreview ? 100 : ghost);
    }
  }

  _disablePreview() {
    if (this._skinId !== -1) {
      this.runtime.renderer.updateBitmapSkin(this._skinId, new ImageData(...Video.DIMENSIONS), 1);
      this.runtime.renderer.updateDrawableVisible(this._drawable, false);
    }

    this._renderPreviewFrame = null;
  }

  _setupPreview() {
    const {
      renderer
    } = this.runtime;
    if (!renderer) return;

    if (this._skinId === -1 && this._drawable === -1) {
      this._skinId = renderer.createBitmapSkin(new ImageData(...Video.DIMENSIONS), 1);
      this._drawable = renderer.createDrawable(StageLayering.VIDEO_LAYER);
      renderer.updateDrawableSkinId(this._drawable, this._skinId); // TW: Video probably contains the user's face. This is private information.
      // This API won't exist if we're using a vanilla scratch-render

      if (renderer.markSkinAsPrivate) {
        renderer.markSkinAsPrivate(this._skinId);
      }
    } // if we haven't already created and started a preview frame render loop, do so


    if (!this._renderPreviewFrame) {
      renderer.updateDrawableEffect(this._drawable, 'ghost', this._forceTransparentPreview ? 100 : this._ghost);
      renderer.updateDrawableVisible(this._drawable, true);

      this._renderPreviewFrame = () => {
        clearTimeout(this._renderPreviewTimeout);

        if (!this._renderPreviewFrame) {
          return;
        }

        this._renderPreviewTimeout = setTimeout(this._renderPreviewFrame, this.runtime.currentStepTime);
        const imageData = this.getFrame({
          format: Video.FORMAT_IMAGE_DATA,
          cacheTimeout: this.runtime.currentStepTime
        });

        if (!imageData) {
          renderer.updateBitmapSkin(this._skinId, new ImageData(...Video.DIMENSIONS), 1);
          return;
        }

        renderer.updateBitmapSkin(this._skinId, imageData, 1);
        this.runtime.requestRedraw();
      };

      this._renderPreviewFrame();
    }
  }

  get videoReady() {
    if (this.provider) return this.provider.videoReady;
    return false;
  }
  /**
   * Method implemented by all IO devices to allow external changes.
   * The only change available externally is hiding the preview, used e.g. to
   * prevent drawing the preview into project thumbnails.
   * @param {object} - data passed to this IO device.
   * @property {boolean} forceTransparentPreview - whether the preview should be forced transparent.
   */


  postData(_ref2) {
    let {
      forceTransparentPreview
    } = _ref2;
    this._forceTransparentPreview = forceTransparentPreview; // Setting the ghost to the current value will pick up the forceTransparentPreview
    // flag and override the current ghost. The complexity is to prevent blocks
    // from overriding forceTransparentPreview

    this.setPreviewGhost(this._ghost);
  }

}

module.exports = Video;

/***/ }),

/***/ "./src/serialization/deserialize-assets.js":
/*!*************************************************!*\
  !*** ./src/serialization/deserialize-assets.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const JSZip = __webpack_require__(/*! jszip */ "jszip");

const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");
/**
 * Deserializes sound from file into storage cache so that it can
 * be loaded into the runtime.
 * @param {object} sound Descriptor for sound from sb3 file
 * @param {Runtime} runtime The runtime containing the storage to cache the sounds in
 * @param {JSZip} zip The zip containing the sound file being described by `sound`
 * @param {string} assetFileName Optional file name for the given asset
 * (sb2 files have filenames of the form [int].[ext],
 * sb3 files have filenames of the form [md5].[ext])
 * @return {Promise} Promise that resolves after the described sound has been stored
 * into the runtime storage cache, the sound was already stored, or an error has
 * occurred.
 */


const deserializeSound = function deserializeSound(sound, runtime, zip, assetFileName) {
  const fileName = assetFileName ? assetFileName : sound.md5;
  const storage = runtime.storage;

  if (!storage) {
    log.warn('No storage module present; cannot load sound asset: ', fileName);
    return Promise.resolve(null);
  }

  if (!zip) {
    // Zip will not be provided if loading project json from server
    return Promise.resolve(null);
  }

  let soundFile = zip.file(fileName);

  if (!soundFile) {
    // look for assetfile in a flat list of files, or in a folder
    const fileMatch = new RegExp("^([^/]*/)?".concat(fileName, "$"));
    soundFile = zip.file(fileMatch)[0]; // use first matching file
  }

  if (!soundFile) {
    log.error("Could not find sound file associated with the ".concat(sound.name, " sound."));
    return Promise.resolve(null);
  }

  if (!JSZip.support.uint8array) {
    log.error('JSZip uint8array is not supported in this browser.');
    return Promise.resolve(null);
  }

  const dataFormat = sound.dataFormat.toLowerCase() === 'mp3' ? storage.DataFormat.MP3 : storage.DataFormat.WAV;
  return soundFile.async('uint8array').then(data => storage.createAsset(storage.AssetType.Sound, dataFormat, data, null, true)).then(asset => {
    sound.asset = asset;
    sound.assetId = asset.assetId;
    sound.md5 = "".concat(asset.assetId, ".").concat(asset.dataFormat);
  });
};
/**
 * Deserializes costume from file into storage cache so that it can
 * be loaded into the runtime.
 * @param {object} costume Descriptor for costume from sb3 file
 * @param {Runtime} runtime The runtime containing the storage to cache the costumes in
 * @param {JSZip} zip The zip containing the costume file being described by `costume`
 * @param {string} assetFileName Optional file name for the given asset
 * (sb2 files have filenames of the form [int].[ext],
 * sb3 files have filenames of the form [md5].[ext])
 * @param {string} textLayerFileName Optional file name for the given asset's text layer
 * (sb2 only; files have filenames of the form [int].png)
 * @return {Promise} Promise that resolves after the described costume has been stored
 * into the runtime storage cache, the costume was already stored, or an error has
 * occurred.
 */


const deserializeCostume = function deserializeCostume(costume, runtime, zip, assetFileName, textLayerFileName) {
  const storage = runtime.storage;
  const assetId = costume.assetId;
  const fileName = assetFileName ? assetFileName : "".concat(assetId, ".").concat(costume.dataFormat);

  if (!storage) {
    log.warn('No storage module present; cannot load costume asset: ', fileName);
    return Promise.resolve(null);
  }

  if (costume.asset) {
    // When uploading a sprite from an image file, the asset data will be provided
    // @todo Cache the asset data somewhere and pull it out here
    return Promise.resolve(storage.createAsset(costume.asset.assetType, costume.asset.dataFormat, new Uint8Array(Object.keys(costume.asset.data).map(key => costume.asset.data[key])), null, true)).then(asset => {
      costume.asset = asset;
      costume.assetId = asset.assetId;
      costume.md5 = "".concat(asset.assetId, ".").concat(asset.dataFormat);
    });
  }

  if (!zip) {
    // Zip will not be provided if loading project json from server
    return Promise.resolve(null);
  }

  let costumeFile = zip.file(fileName);

  if (!costumeFile) {
    // look for assetfile in a flat list of files, or in a folder
    const fileMatch = new RegExp("^([^/]*/)?".concat(fileName, "$"));
    costumeFile = zip.file(fileMatch)[0]; // use the first matched file
  }

  if (!costumeFile) {
    log.error("Could not find costume file associated with the ".concat(costume.name, " costume."));
    return Promise.resolve(null);
  }

  let assetType = null;
  const costumeFormat = costume.dataFormat.toLowerCase();

  if (costumeFormat === 'svg') {
    assetType = storage.AssetType.ImageVector;
  } else if (['png', 'bmp', 'jpeg', 'jpg', 'gif'].indexOf(costumeFormat) >= 0) {
    assetType = storage.AssetType.ImageBitmap;
  } else {
    log.error("Unexpected file format for costume: ".concat(costumeFormat));
  }

  if (!JSZip.support.uint8array) {
    log.error('JSZip uint8array is not supported in this browser.');
    return Promise.resolve(null);
  } // textLayerMD5 exists if there is a text layer, which is a png of text from Scratch 1.4
  // that was opened in Scratch 2.0. In this case, set costume.textLayerAsset.


  let textLayerFilePromise;

  if (costume.textLayerMD5) {
    const textLayerFile = zip.file(textLayerFileName);

    if (!textLayerFile) {
      log.error("Could not find text layer file associated with the ".concat(costume.name, " costume."));
      return Promise.resolve(null);
    }

    textLayerFilePromise = textLayerFile.async('uint8array').then(data => storage.createAsset(storage.AssetType.ImageBitmap, 'png', data, costume.textLayerMD5)).then(asset => {
      costume.textLayerAsset = asset;
    });
  } else {
    textLayerFilePromise = Promise.resolve(null);
  }

  return Promise.all([textLayerFilePromise, costumeFile.async('uint8array').then(data => storage.createAsset(assetType, // TODO eventually we want to map non-png's to their actual file types?
  costumeFormat, data, null, true)).then(asset => {
    costume.asset = asset;
    costume.assetId = asset.assetId;
    costume.md5 = "".concat(asset.assetId, ".").concat(asset.dataFormat);
  })]);
};

module.exports = {
  deserializeSound,
  deserializeCostume
};

/***/ }),

/***/ "./src/serialization/sb2.js":
/*!**********************************!*\
  !*** ./src/serialization/sb2.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview
 * Partial implementation of an SB2 JSON importer.
 * Parses provided JSON and then generates all needed
 * scratch-vm runtime structures.
 */
const Blocks = __webpack_require__(/*! ../engine/blocks */ "./src/engine/blocks.js");

const RenderedTarget = __webpack_require__(/*! ../sprites/rendered-target */ "./src/sprites/rendered-target.js");

const Sprite = __webpack_require__(/*! ../sprites/sprite */ "./src/sprites/sprite.js");

const Color = __webpack_require__(/*! ../util/color */ "./src/util/color.js");

const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");

const uid = __webpack_require__(/*! ../util/uid */ "./src/util/uid.js");

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");

const MathUtil = __webpack_require__(/*! ../util/math-util */ "./src/util/math-util.js");

const specMap = __webpack_require__(/*! ./sb2_specmap */ "./src/serialization/sb2_specmap.js");

const Comment = __webpack_require__(/*! ../engine/comment */ "./src/engine/comment.js");

const Variable = __webpack_require__(/*! ../engine/variable */ "./src/engine/variable.js");

const MonitorRecord = __webpack_require__(/*! ../engine/monitor-record */ "./src/engine/monitor-record.js");

const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");

const ScratchXUtilities = __webpack_require__(/*! ../extension-support/tw-scratchx-utilities */ "./src/extension-support/tw-scratchx-utilities.js");

const {
  loadCostume
} = __webpack_require__(/*! ../import/load-costume.js */ "./src/import/load-costume.js");

const {
  loadSound
} = __webpack_require__(/*! ../import/load-sound.js */ "./src/import/load-sound.js");

const {
  deserializeCostume,
  deserializeSound
} = __webpack_require__(/*! ./deserialize-assets.js */ "./src/serialization/deserialize-assets.js"); // Constants used during deserialization of an SB2 file


const CORE_EXTENSIONS = ['argument', 'control', 'data', 'event', 'looks', 'math', 'motion', 'operator', 'procedures', 'sensing', 'sound']; // Adjust script coordinates to account for
// larger block size in scratch-blocks.
// @todo: Determine more precisely the right formulas here.

const WORKSPACE_X_SCALE = 1.5;
const WORKSPACE_Y_SCALE = 2.2; // By examining ScratchX projects, we've found that ScratchX can use either "\u001f" or "."
// to separate the extension name from the extension method opcode eg. "Text To Speech.say"
// eslint-disable-next-line no-control-regex

const SCRATCHX_OPCODE_SEPARATOR = /\u001f|\./;
/**
 * @param {string} opcode
 * @returns {boolean}
 */

const isPossiblyScratchXBlock = opcode => SCRATCHX_OPCODE_SEPARATOR.test(opcode);
/**
 * @param {string} opcode
 * @returns {string}
 */


const mapScratchXOpcode = opcode => {
  const [extensionName, extensionMethod] = opcode.split(SCRATCHX_OPCODE_SEPARATOR);
  const newOpcodeBase = ScratchXUtilities.generateExtensionId(extensionName);
  return "".concat(newOpcodeBase, "_").concat(extensionMethod);
};
/**
 * @param {object} block
 * @returns {object}
 */


const mapScratchXBlock = block => {
  const opcode = block[0];
  const argumentCount = block.length - 1;
  const args = [];

  for (let i = 0; i < argumentCount; i++) {
    args.push({
      type: 'input',
      inputOp: 'text',
      inputName: ScratchXUtilities.argumentIndexToId(i)
    });
  }

  return {
    opcode: mapScratchXOpcode(opcode),
    argMap: args
  };
};
/**
 * Convert a Scratch 2.0 procedure string (e.g., "my_procedure %s %b %n")
 * into an argument map. This allows us to provide the expected inputs
 * to a mutated procedure call.
 * @param {string} procCode Scratch 2.0 procedure string.
 * @return {object} Argument map compatible with those in sb2specmap.
 */


const parseProcedureArgMap = function parseProcedureArgMap(procCode) {
  const argMap = [{} // First item in list is op string.
  ];
  const INPUT_PREFIX = 'input';
  let inputCount = 0; // Split by %n, %b, %s.

  const parts = procCode.split(/(?=[^\\]%[nbs])/);

  for (let i = 0; i < parts.length; i++) {
    const part = parts[i].trim();

    if (part.substring(0, 1) === '%') {
      const argType = part.substring(1, 2);
      const arg = {
        type: 'input',
        inputName: INPUT_PREFIX + inputCount++
      };

      if (argType === 'n') {
        arg.inputOp = 'math_number';
      } else if (argType === 's') {
        arg.inputOp = 'text';
      } else if (argType === 'b') {
        arg.inputOp = 'boolean';
      }

      argMap.push(arg);
    }
  }

  return argMap;
};
/**
 * Generate a list of "argument IDs" for procdefs and caller mutations.
 * IDs just end up being `input0`, `input1`, ... which is good enough.
 * @param {string} procCode Scratch 2.0 procedure string.
 * @return {Array.<string>} Array of argument id strings.
 */


const parseProcedureArgIds = function parseProcedureArgIds(procCode) {
  return parseProcedureArgMap(procCode).map(arg => arg.inputName).filter(name => name); // Filter out unnamed inputs which are labels
};
/**
 * Flatten a block tree into a block list.
 * Children are temporarily stored on the `block.children` property.
 * @param {Array.<object>} blocks list generated by `parseBlockList`.
 * @return {Array.<object>} Flattened list to be passed to `blocks.createBlock`.
 */


const flatten = function flatten(blocks) {
  let finalBlocks = [];

  for (let i = 0; i < blocks.length; i++) {
    const block = blocks[i];
    finalBlocks.push(block);

    if (block.children) {
      finalBlocks = finalBlocks.concat(flatten(block.children));
    }

    delete block.children;
  }

  return finalBlocks;
};
/**
 * Parse any list of blocks from SB2 JSON into a list of VM-format blocks.
 * Could be used to parse a top-level script,
 * a list of blocks in a branch (e.g., in forever),
 * or a list of blocks in an argument (e.g., move [pick random...]).
 * @param {Array.<object>} blockList SB2 JSON-format block list.
 * @param {Function} addBroadcastMsg function to update broadcast message name map
 * @param {Function} getVariableId function to retreive a variable's ID based on name
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 * @param {ParseState} parseState - info on the state of parsing beyond the current block.
 * @param {object<int, Comment>} comments - Comments from sb2 project that need to be attached to blocks.
 * They are indexed in this object by the sb2 flattened block list index indicating
 * which block they should attach to.
 * @param {int} commentIndex The current index of the top block in this list if it were in a flattened
 * list of all blocks for the target
 * @return {Array<Array.<object>|int>} Tuple where first item is the Scratch VM-format block list, and
 * second item is the updated comment index
 */


const parseBlockList = function parseBlockList(blockList, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex) {
  const resultingList = [];
  let previousBlock = null; // For setting next.

  for (let i = 0; i < blockList.length; i++) {
    const block = blockList[i]; // eslint-disable-next-line no-use-before-define

    const parsedBlockAndComments = parseBlock(block, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex);
    const parsedBlock = parsedBlockAndComments[0]; // Update commentIndex

    commentIndex = parsedBlockAndComments[1];
    if (!parsedBlock) continue;

    if (previousBlock) {
      parsedBlock.parent = previousBlock.id;
      previousBlock.next = parsedBlock.id;
    }

    previousBlock = parsedBlock;
    resultingList.push(parsedBlock);
  }

  return [resultingList, commentIndex];
};
/**
 * Parse a Scratch object's scripts into VM blocks.
 * This should only handle top-level scripts that include X, Y coordinates.
 * @param {!object} scripts Scripts object from SB2 JSON.
 * @param {!Blocks} blocks Blocks object to load parsed blocks into.
 * @param {Function} addBroadcastMsg function to update broadcast message name map
 * @param {Function} getVariableId function to retreive a variable's ID based on name
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 * @param {object} comments Comments that need to be attached to the blocks that need to be parsed
 */


const parseScripts = function parseScripts(scripts, blocks, addBroadcastMsg, getVariableId, extensions, comments) {
  // Keep track of the index of the current script being
  // parsed in order to attach block comments correctly
  let scriptIndexForComment = 0;

  for (let i = 0; i < scripts.length; i++) {
    const script = scripts[i];
    const scriptX = script[0];
    const scriptY = script[1];
    const blockList = script[2];
    const parseState = {};
    const [parsedBlockList, newCommentIndex] = parseBlockList(blockList, addBroadcastMsg, getVariableId, extensions, parseState, comments, scriptIndexForComment);
    scriptIndexForComment = newCommentIndex;

    if (parsedBlockList[0]) {
      parsedBlockList[0].x = scriptX * WORKSPACE_X_SCALE;
      parsedBlockList[0].y = scriptY * WORKSPACE_Y_SCALE;
      parsedBlockList[0].topLevel = true;
      parsedBlockList[0].parent = null;
    } // Flatten children and create add the blocks.


    const convertedBlocks = flatten(parsedBlockList);

    for (let j = 0; j < convertedBlocks.length; j++) {
      blocks.createBlock(convertedBlocks[j]);
    }
  }
};
/**
 * Create a callback for assigning fixed IDs to imported variables
 * Generator stores the global variable mapping in a closure
 * @param {!string} targetId the id of the target to scope the variable to
 * @return {string} variable ID
 */


const generateVariableIdGetter = function () {
  let globalVariableNameMap = {};

  const namer = (targetId, name, type) => "".concat(targetId, "-").concat(StringUtil.replaceUnsafeChars(name), "-").concat(type);

  return function (targetId, topLevel) {
    // Reset the global variable map if topLevel
    if (topLevel) globalVariableNameMap = {};
    return function (name, type) {
      if (topLevel) {
        // Store the name/id pair in the globalVariableNameMap
        globalVariableNameMap["".concat(name, "-").concat(type)] = namer(targetId, name, type);
        return globalVariableNameMap["".concat(name, "-").concat(type)];
      } // Not top-level, so first check the global name map


      if (globalVariableNameMap["".concat(name, "-").concat(type)]) return globalVariableNameMap["".concat(name, "-").concat(type)];
      return namer(targetId, name, type);
    };
  };
}();

const globalBroadcastMsgStateGenerator = function () {
  let broadcastMsgNameMap = {};
  const allBroadcastFields = [];
  const emptyStringName = uid();
  return function (topLevel) {
    if (topLevel) broadcastMsgNameMap = {};
    return {
      broadcastMsgMapUpdater: function broadcastMsgMapUpdater(name, field) {
        name = name.toLowerCase();

        if (name === '') {
          name = emptyStringName;
        }

        broadcastMsgNameMap[name] = "broadcastMsgId-".concat(StringUtil.replaceUnsafeChars(name));
        allBroadcastFields.push(field);
        return broadcastMsgNameMap[name];
      },
      globalBroadcastMsgs: broadcastMsgNameMap,
      allBroadcastFields: allBroadcastFields,
      emptyMsgName: emptyStringName
    };
  };
}();
/**
 * Parse a single monitor object and create all its in-memory VM objects.
 *
 * It is important that monitors are parsed last,
 * - after all sprite targets have finished parsing, and
 * - after the rest of the stage has finished parsing.
 *
 * It is specifically important that all the scripts in the project
 * have been parsed and all the relevant targets exist, have uids,
 * and have their variables initialized.
 * Calling this function before these things are true, will result in
 * undefined behavior.
 * @param {!object} object - From-JSON "Monitor object"
 * @param {!Runtime} runtime - (in/out) Runtime object to load monitor info into.
 * @param {!Array.<Target>} targets - Targets have already been parsed.
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 */


const parseMonitorObject = (object, runtime, targets, extensions) => {
  // If we can't find the block in the spec map, ignore it.
  // This happens for things like Lego Wedo 1.0 monitors.
  const mapped = specMap[object.cmd];

  if (!mapped) {
    log.warn("Could not find monitor block with opcode: ".concat(object.cmd));
    return;
  } // In scratch 2.0, there are two monitors that now correspond to extension
  // blocks (tempo and video motion/direction). In the case of the
  // video motion/direction block, this reporter is not monitorable in Scratch 3.0.
  // In the case of the tempo block, we should import it and load the music extension
  // only when the monitor is actually visible.


  const opcode = specMap[object.cmd].opcode;
  const extIndex = opcode.indexOf('_');
  const extID = opcode.substring(0, extIndex);

  if (extID === 'videoSensing') {
    return;
  } else if (CORE_EXTENSIONS.indexOf(extID) === -1 && extID !== '' && !extensions.extensionIDs.has(extID) && !object.visible) {
    // Don't import this monitor if it refers to a non-core extension that
    // doesn't exist anywhere else in the project and it isn't visible.
    // This should only apply to the tempo block at this point since
    // there are no other sb2 blocks that are now extension monitors.
    return;
  }

  let target = null; // List blocks don't come in with their target name set.
  // Find the target by searching for a target with matching variable name/type.

  if (!object.hasOwnProperty('target')) {
    for (let i = 0; i < targets.length; i++) {
      const currTarget = targets[i];
      const listVariables = Object.keys(currTarget.variables).filter(key => {
        const variable = currTarget.variables[key];
        return variable.type === Variable.LIST_TYPE && variable.name === object.listName;
      });

      if (listVariables.length > 0) {
        target = currTarget; // Keep this target for later use

        object.target = currTarget.getName(); // Set target name to normalize with other monitors
      }
    }
  } // Get the target for this monitor, if not gotten above.


  target = target || targets.filter(t => t.getName() === object.target)[0];
  if (!target) throw new Error('Cannot create monitor for target that cannot be found by name'); // Create var id getter to make block naming/parsing easier, variables already created.

  const getVariableId = generateVariableIdGetter(target.id, false); // eslint-disable-next-line no-use-before-define

  const [block, _] = parseBlock([object.cmd, object.param], // Scratch 2 monitor blocks only have one param.
  null, // `addBroadcastMsg`, not needed for monitor blocks.
  getVariableId, extensions, {}, null, // `comments`, not needed for monitor blocks
  null // `commentIndex`, not needed for monitor blocks
  ); // Monitor blocks have special IDs to match the toolbox obtained from the getId
  // function in the runtime.monitorBlocksInfo. Variable monitors, however,
  // get their IDs from the variable id they reference.

  if (object.cmd === 'getVar:') {
    block.id = getVariableId(object.param, Variable.SCALAR_TYPE);
  } else if (object.cmd === 'contentsOfList:') {
    block.id = getVariableId(object.param, Variable.LIST_TYPE);
  } else if (runtime.monitorBlockInfo.hasOwnProperty(block.opcode)) {
    block.id = runtime.monitorBlockInfo[block.opcode].getId(target.id, block.fields);
  } else {
    // If the opcode can't be found in the runtime monitorBlockInfo,
    // then default to using the block opcode as the id instead.
    // This is for extension monitors, and assumes that extension monitors
    // cannot be sprite specific.
    block.id = block.opcode;
  } // Block needs a targetId if it is targetting something other than the stage


  block.targetId = target.isStage ? null : target.id; // Property required for running monitored blocks.

  block.isMonitored = object.visible;
  const existingMonitorBlock = runtime.monitorBlocks._blocks[block.id];

  if (existingMonitorBlock) {
    // A monitor block already exists if the toolbox has been loaded and
    // the monitor block is not target specific (because the block gets recycled).
    // Update the existing block with the relevant monitor information.
    existingMonitorBlock.isMonitored = object.visible;
    existingMonitorBlock.targetId = block.targetId;
  } else {
    // Blocks can be created with children, flatten and add to monitorBlocks.
    const newBlocks = flatten([block]);

    for (let i = 0; i < newBlocks.length; i++) {
      runtime.monitorBlocks.createBlock(newBlocks[i]);
    }
  } // Convert numbered mode into strings for better understandability.


  switch (object.mode) {
    case 1:
      object.mode = 'default';
      break;

    case 2:
      object.mode = 'large';
      break;

    case 3:
      object.mode = 'slider';
      break;
  } // Create a monitor record for the runtime's monitorState


  runtime.requestAddMonitor(MonitorRecord({
    id: block.id,
    targetId: block.targetId,
    spriteName: block.targetId ? object.target : null,
    opcode: block.opcode,
    params: runtime.monitorBlocks._getBlockParams(block),
    value: '',
    mode: object.mode,
    sliderMin: object.sliderMin,
    sliderMax: object.sliderMax,
    isDiscrete: object.isDiscrete,
    x: object.x,
    y: object.y,
    width: object.width,
    height: object.height,
    visible: object.visible
  }));
};
/**
 * Parse the assets of a single "Scratch object" and load them. This
 * preprocesses objects to support loading the data for those assets over a
 * network while the objects are further processed into Blocks, Sprites, and a
 * list of needed Extensions.
 * @param {!object} object - From-JSON "Scratch object:" sprite, stage, watcher.
 * @param {!Runtime} runtime - Runtime object to load all structures into.
 * @param {boolean} topLevel - Whether this is the top-level object (stage).
 * @param {?object} zip - Optional zipped assets for local file import
 * @return {?{costumePromises:Array.<Promise>,soundPromises:Array.<Promise>,soundBank:SoundBank,children:object}}
 *   Object of arrays of promises and child objects for asset objects used in
 *   Sprites. As well as a SoundBank for the sound assets. null for unsupported
 *   objects.
 */


const parseScratchAssets = function parseScratchAssets(object, runtime, topLevel, zip) {
  if (!object.hasOwnProperty('objName')) {
    // Skip parsing monitors. Or any other objects missing objName.
    return null;
  }

  const assets = {
    costumePromises: [],
    soundPromises: [],
    soundBank: runtime.audioEngine && runtime.audioEngine.createBank(),
    children: []
  }; // Costumes from JSON.

  const costumePromises = assets.costumePromises;

  if (object.hasOwnProperty('costumes')) {
    for (let i = 0; i < object.costumes.length; i++) {
      const costumeSource = object.costumes[i];
      const bitmapResolution = costumeSource.bitmapResolution || 1;
      const costume = {
        name: costumeSource.costumeName,
        bitmapResolution: bitmapResolution,
        rotationCenterX: topLevel ? 240 * bitmapResolution : costumeSource.rotationCenterX,
        rotationCenterY: topLevel ? 180 * bitmapResolution : costumeSource.rotationCenterY,
        // TODO we eventually want this next property to be called
        // md5ext to reflect what it actually contains, however this
        // will be a very extensive change across many repositories
        // and should be done carefully and altogether
        md5: costumeSource.baseLayerMD5,
        skinId: null
      };
      const md5ext = costumeSource.baseLayerMD5;
      const idParts = StringUtil.splitFirst(md5ext, '.');
      const md5 = idParts[0];
      let ext;

      if (idParts.length === 2 && idParts[1]) {
        ext = idParts[1];
      } else {
        // Default to 'png' if baseLayerMD5 is not formatted correctly
        ext = 'png'; // Fix costume md5 for later

        costume.md5 = "".concat(costume.md5, ".").concat(ext);
      }

      costume.dataFormat = ext;
      costume.assetId = md5;

      if (costumeSource.textLayerMD5) {
        costume.textLayerMD5 = StringUtil.splitFirst(costumeSource.textLayerMD5, '.')[0];
      } // If there is no internet connection, or if the asset is not in storage
      // for some reason, and we are doing a local .sb2 import, (e.g. zip is provided)
      // the file name of the costume should be the baseLayerID followed by the file ext


      const assetFileName = "".concat(costumeSource.baseLayerID, ".").concat(ext);
      const textLayerFileName = costumeSource.textLayerID ? "".concat(costumeSource.textLayerID, ".png") : null;
      costumePromises.push(deserializeCostume(costume, runtime, zip, assetFileName, textLayerFileName).then(() => loadCostume(costume.md5, costume, runtime, 2
      /* optVersion */
      )));
    }
  } // Sounds from JSON


  const {
    soundBank,
    soundPromises
  } = assets;

  if (object.hasOwnProperty('sounds')) {
    for (let s = 0; s < object.sounds.length; s++) {
      const soundSource = object.sounds[s];
      const sound = {
        name: soundSource.soundName,
        format: soundSource.format,
        rate: soundSource.rate,
        sampleCount: soundSource.sampleCount,
        // TODO we eventually want this next property to be called
        // md5ext to reflect what it actually contains, however this
        // will be a very extensive change across many repositories
        // and should be done carefully and altogether
        // (for example, the audio engine currently relies on this
        // property to be named 'md5')
        md5: soundSource.md5,
        data: null
      };
      const md5ext = soundSource.md5;
      const idParts = StringUtil.splitFirst(md5ext, '.');
      const md5 = idParts[0];
      const ext = idParts[1].toLowerCase();
      sound.dataFormat = ext;
      sound.assetId = md5; // If there is no internet connection, or if the asset is not in storage
      // for some reason, and we are doing a local .sb2 import, (e.g. zip is provided)
      // the file name of the sound should be the soundID (provided from the project.json)
      // followed by the file ext

      const assetFileName = "".concat(soundSource.soundID, ".").concat(ext);
      soundPromises.push(deserializeSound(sound, runtime, zip, assetFileName).then(() => loadSound(sound, runtime, soundBank)));
    }
  } // The stage will have child objects; recursively process them.


  const childrenAssets = assets.children;

  if (object.children) {
    for (let m = 0; m < object.children.length; m++) {
      childrenAssets.push(parseScratchAssets(object.children[m], runtime, false, zip));
    }
  }

  return assets;
};
/**
 * Parse a single "Scratch object" and create all its in-memory VM objects.
 * TODO: parse the "info" section, especially "savedExtensions"
 * @param {!object} object - From-JSON "Scratch object:" sprite, stage, watcher.
 * @param {!Runtime} runtime - Runtime object to load all structures into.
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 * @param {boolean} topLevel - Whether this is the top-level object (stage).
 * @param {?object} zip - Optional zipped assets for local file import
 * @param {object} assets - Promises for assets of this scratch object grouped
 *   into costumes and sounds
 * @return {!Promise.<Array.<Target>>} Promise for the loaded targets when ready, or null for unsupported objects.
 */


const parseScratchObject = function parseScratchObject(object, runtime, extensions, topLevel, zip, assets) {
  if (!object.hasOwnProperty('objName')) {
    if (object.hasOwnProperty('listName')) {
      // Shim these objects so they can be processed as monitors
      object.cmd = 'contentsOfList:';
      object.param = object.listName;
      object.mode = 'list';
    } // Defer parsing monitors until targets are all parsed


    object.deferredMonitor = true;
    return Promise.resolve(object);
  } // Blocks container for this object.


  const blocks = new Blocks(runtime); // @todo: For now, load all Scratch objects (stage/sprites) as a Sprite.

  const sprite = new Sprite(blocks, runtime); // Sprite/stage name from JSON.

  if (object.hasOwnProperty('objName')) {
    if (topLevel && object.objName !== 'Stage') {
      for (const child of object.children) {
        if (!child.hasOwnProperty('objName') && child.target === object.objName) {
          child.target = 'Stage';
        }
      }

      object.objName = 'Stage';
    }

    sprite.name = object.objName;
  } // Costumes from JSON.


  const costumePromises = assets.costumePromises; // Sounds from JSON

  const {
    soundBank,
    soundPromises
  } = assets; // Create the first clone, and load its run-state from JSON.

  const target = sprite.createClone(topLevel ? StageLayering.BACKGROUND_LAYER : StageLayering.SPRITE_LAYER);
  const getVariableId = generateVariableIdGetter(target.id, topLevel);
  const globalBroadcastMsgObj = globalBroadcastMsgStateGenerator(topLevel);
  const addBroadcastMsg = globalBroadcastMsgObj.broadcastMsgMapUpdater; // Load target properties from JSON.

  if (object.hasOwnProperty('variables')) {
    for (let j = 0; j < object.variables.length; j++) {
      const variable = object.variables[j]; // A variable is a cloud variable if:
      // - the project says it's a cloud variable, and
      // - it's a stage variable, and
      // - the runtime can support another cloud variable

      const isCloud = variable.isPersistent && topLevel && runtime.canAddCloudVariable();
      const newVariable = new Variable(getVariableId(variable.name, Variable.SCALAR_TYPE), variable.name, Variable.SCALAR_TYPE, isCloud);
      if (isCloud) runtime.addCloudVariable();
      newVariable.value = variable.value;
      target.variables[newVariable.id] = newVariable;
    }
  } // If included, parse any and all comments on the object (this includes top-level
  // workspace comments as well as comments attached to specific blocks)


  const blockComments = {};

  if (object.hasOwnProperty('scriptComments')) {
    const comments = object.scriptComments.map(commentDesc => {
      const [commentX, commentY, commentWidth, commentHeight, commentFullSize, flattenedBlockIndex, commentText] = commentDesc;
      const isBlockComment = commentDesc[5] >= 0;
      const newComment = new Comment(null, // generate a new id for this comment
      commentText, // text content of sb2 comment
      // Only serialize x & y position of comment if it's a workspace comment
      // If it's a block comment, we'll let scratch-blocks handle positioning
      isBlockComment ? null : commentX * WORKSPACE_X_SCALE, isBlockComment ? null : commentY * WORKSPACE_Y_SCALE, commentWidth * WORKSPACE_X_SCALE, commentHeight * WORKSPACE_Y_SCALE, !commentFullSize);

      if (isBlockComment) {
        // commentDesc[5] refers to the index of the block that this
        // comment is attached to --  in a flattened version of the
        // scripts array.
        // If commentDesc[5] is -1, this is a workspace comment (we don't need to do anything
        // extra at this point), otherwise temporarily save the flattened script array
        // index as the blockId property of the new comment. We will
        // change this to refer to the actual block id of the corresponding
        // block when that block gets created
        newComment.blockId = flattenedBlockIndex; // Add this comment to the block comments object with its script index
        // as the key

        if (blockComments.hasOwnProperty(flattenedBlockIndex)) {
          blockComments[flattenedBlockIndex].push(newComment);
        } else {
          blockComments[flattenedBlockIndex] = [newComment];
        }
      }

      return newComment;
    }); // Add all the comments that were just created to the target.comments,
    // referenced by id

    comments.forEach(comment => {
      target.comments[comment.id] = comment;
    });
  } // If included, parse any and all scripts/blocks on the object.


  if (object.hasOwnProperty('scripts')) {
    parseScripts(object.scripts, blocks, addBroadcastMsg, getVariableId, extensions, blockComments);
  } // If there are any comments referring to a numerical block ID, make them
  // workspace comments. These are comments that were originally created as
  // block comments, detached from the block, and then had the associated
  // block deleted.
  // These comments should be imported as workspace comments
  // by making their blockIDs (which currently refer to non-existing blocks)
  // null (See #1452).


  for (const commentIndex in blockComments) {
    const currBlockComments = blockComments[commentIndex];
    currBlockComments.forEach(c => {
      if (typeof c.blockId === 'number') {
        c.blockId = null;
      }
    });
  } // Update stage specific blocks (e.g. sprite clicked <=> stage clicked)


  blocks.updateTargetSpecificBlocks(topLevel); // topLevel = isStage

  if (object.hasOwnProperty('lists')) {
    for (let k = 0; k < object.lists.length; k++) {
      const list = object.lists[k];
      const newVariable = new Variable(getVariableId(list.listName, Variable.LIST_TYPE), list.listName, Variable.LIST_TYPE, false);
      newVariable.value = list.contents;
      target.variables[newVariable.id] = newVariable;
    }
  }

  if (object.hasOwnProperty('scratchX')) {
    target.x = object.scratchX;
  }

  if (object.hasOwnProperty('scratchY')) {
    target.y = object.scratchY;
  }

  if (object.hasOwnProperty('direction')) {
    target.direction = object.direction;
  }

  if (object.hasOwnProperty('isDraggable')) {
    target.draggable = object.isDraggable;
  }

  if (object.hasOwnProperty('scale')) {
    // SB2 stores as 1.0 = 100%; we use % in the VM.
    target.size = object.scale * 100;
  }

  if (object.hasOwnProperty('visible')) {
    target.visible = object.visible;
  }

  if (object.hasOwnProperty('currentCostumeIndex')) {
    // Current costume index can sometimes be a floating
    // point number, use Math.floor to come up with an appropriate index
    // and clamp it to the actual number of costumes the object has for good measure.
    target.currentCostume = MathUtil.clamp(Math.floor(object.currentCostumeIndex), 0, object.costumes.length - 1);
  }

  if (object.hasOwnProperty('rotationStyle')) {
    if (object.rotationStyle === 'none') {
      target.rotationStyle = RenderedTarget.ROTATION_STYLE_NONE;
    } else if (object.rotationStyle === 'leftRight') {
      target.rotationStyle = RenderedTarget.ROTATION_STYLE_LEFT_RIGHT;
    } else if (object.rotationStyle === 'normal') {
      target.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;
    }
  }

  if (object.hasOwnProperty('tempoBPM')) {
    target.tempo = object.tempoBPM;
  }

  if (object.hasOwnProperty('videoAlpha')) {
    // SB2 stores alpha as opacity, where 1.0 is opaque.
    // We convert to a percentage, and invert it so 100% is full transparency.
    target.videoTransparency = 100 - 100 * object.videoAlpha;
  }

  if (object.hasOwnProperty('info')) {
    if (object.info.hasOwnProperty('videoOn')) {
      if (object.info.videoOn) {
        target.videoState = RenderedTarget.VIDEO_STATE.ON;
      } else {
        target.videoState = RenderedTarget.VIDEO_STATE.OFF;
      }
    }
  }

  if (object.hasOwnProperty('indexInLibrary')) {
    // Temporarily store the 'indexInLibrary' property from the sb2 file
    // so that we can correctly order sprites in the target pane.
    // This will be deleted after we are done parsing and ordering the targets list.
    target.targetPaneOrder = object.indexInLibrary;
  }

  target.isStage = topLevel;
  Promise.all(costumePromises).then(costumes => {
    sprite.costumes = costumes;
  });
  Promise.all(soundPromises).then(sounds => {
    sprite.sounds = sounds; // Make sure if soundBank is undefined, sprite.soundBank is then null.

    sprite.soundBank = soundBank || null;
  }); // The stage will have child objects; recursively process them.

  const childrenPromises = [];

  if (object.children) {
    for (let m = 0; m < object.children.length; m++) {
      childrenPromises.push(parseScratchObject(object.children[m], runtime, extensions, false, zip, assets.children[m]));
    }
  }

  return Promise.all(costumePromises.concat(soundPromises)).then(() => Promise.all(childrenPromises).then(children => {
    // Need create broadcast msgs as variables after
    // all other targets have finished processing.
    if (target.isStage) {
      const allBroadcastMsgs = globalBroadcastMsgObj.globalBroadcastMsgs;
      const allBroadcastMsgFields = globalBroadcastMsgObj.allBroadcastFields;
      const oldEmptyMsgName = globalBroadcastMsgObj.emptyMsgName;

      if (allBroadcastMsgs[oldEmptyMsgName]) {
        // Find a fresh 'messageN'
        let currIndex = 1;

        while (allBroadcastMsgs["message".concat(currIndex)]) {
          currIndex += 1;
        }

        const newEmptyMsgName = "message".concat(currIndex); // Add the new empty message name to the broadcast message
        // name map, and assign it the old id.
        // Then, delete the old entry in map.

        allBroadcastMsgs[newEmptyMsgName] = allBroadcastMsgs[oldEmptyMsgName];
        delete allBroadcastMsgs[oldEmptyMsgName]; // Now update all the broadcast message fields with
        // the new empty message name.

        for (let i = 0; i < allBroadcastMsgFields.length; i++) {
          if (allBroadcastMsgFields[i].value === '') {
            allBroadcastMsgFields[i].value = newEmptyMsgName;
          }
        }
      } // Traverse the broadcast message name map and create
      // broadcast messages as variables on the stage (which is this
      // target).


      for (const msgName in allBroadcastMsgs) {
        const msgId = allBroadcastMsgs[msgName];
        const newMsg = new Variable(msgId, msgName, Variable.BROADCAST_MESSAGE_TYPE, false);
        target.variables[newMsg.id] = newMsg;
      }
    }

    let targets = [target];
    const deferredMonitors = [];

    for (let n = 0; n < children.length; n++) {
      if (children[n]) {
        if (children[n].deferredMonitor) {
          deferredMonitors.push(children[n]);
        } else {
          targets = targets.concat(children[n]);
        }
      }
    } // It is important that monitors are parsed last
    // - after all sprite targets have finished parsing
    // - and this is the last thing that happens in the stage parsing
    // It is specifically important that all the scripts in the project
    // have been parsed and all the relevant targets exist, have uids,
    // and have their variables initialized.


    for (let n = 0; n < deferredMonitors.length; n++) {
      parseMonitorObject(deferredMonitors[n], runtime, targets, extensions);
    }

    return targets;
  }));
};

const reorderParsedTargets = function reorderParsedTargets(targets) {
  // Reorder parsed targets based on the temporary targetPaneOrder property
  // and then delete it.
  const reordered = targets.map((t, index) => {
    t.layerOrder = index;
    return t;
  }).sort((a, b) => a.targetPaneOrder - b.targetPaneOrder); // Delete the temporary target pane ordering since we shouldn't need it anymore.

  reordered.forEach(t => {
    delete t.targetPaneOrder;
  });
  return reordered;
};
/**
 * Top-level handler. Parse provided JSON,
 * and process the top-level object (the stage object).
 * @param {!object} json SB2-format JSON to load.
 * @param {!Runtime} runtime Runtime object to load all structures into.
 * @param {boolean=} optForceSprite If set, treat as sprite (Sprite2).
 * @param {?object} zip Optional zipped assets for local file import
 * @return {Promise.<ImportedProject>} Promise that resolves to the loaded targets when ready.
 */


const sb2import = function sb2import(json, runtime, optForceSprite, zip) {
  const extensions = {
    extensionIDs: new Set(),
    extensionURLs: new Map()
  };
  return Promise.resolve(parseScratchAssets(json, runtime, !optForceSprite, zip)) // Force this promise to wait for the next loop in the js tick. Let
  // storage have some time to send off asset requests.
  .then(assets => Promise.resolve(assets)).then(assets => parseScratchObject(json, runtime, extensions, !optForceSprite, zip, assets)).then(reorderParsedTargets).then(targets => ({
    targets,
    extensions
  }));
};
/**
 * Given the sb2 block, inspect the specmap for a translation method or object.
 * @param {!object} block a sb2 formatted block
 * @return {object} specmap block to parse this opcode
 */


const specMapBlock = function specMapBlock(block) {
  const opcode = block[0];
  const mapped = opcode && specMap[opcode];

  if (!mapped) {
    if (opcode && isPossiblyScratchXBlock(opcode)) {
      return mapScratchXBlock(block);
    }

    log.warn("Couldn't find SB2 block: ".concat(opcode));
    return null;
  }

  if (typeof mapped === 'function') {
    return mapped(block);
  }

  return mapped;
};
/**
 * Parse a single SB2 JSON-formatted block and its children.
 * @param {!object} sb2block SB2 JSON-formatted block.
 * @param {Function} addBroadcastMsg function to update broadcast message name map
 * @param {Function} getVariableId function to retrieve a variable's ID based on name
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 * @param {ParseState} parseState - info on the state of parsing beyond the current block.
 * @param {object<int, Comment>} comments - Comments from sb2 project that need to be attached to blocks.
 * They are indexed in this object by the sb2 flattened block list index indicating
 * which block they should attach to.
 * @param {int} commentIndex The comment index for the block to be parsed if it were in a flattened
 * list of all blocks for the target
 * @return {Array.<object|int>} Tuple where first item is the Scratch VM-format block (or null if unsupported object),
 * and second item is the updated comment index (after this block and its children are parsed)
 */


const parseBlock = function parseBlock(sb2block, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex) {
  const commentsForParsedBlock = comments && typeof commentIndex === 'number' && !isNaN(commentIndex) ? comments[commentIndex] : null;
  const blockMetadata = specMapBlock(sb2block);

  if (!blockMetadata) {
    // No block opcode found, exclude this block, increment the commentIndex,
    // make all block comments into workspace comments and send them to zero/zero
    // to prevent serialization issues.
    if (commentsForParsedBlock) {
      commentsForParsedBlock.forEach(comment => {
        comment.blockId = null;
        comment.x = comment.y = 0;
      });
    }

    return [null, commentIndex + 1];
  }

  const oldOpcode = sb2block[0]; // If the block is from an extension, record it.

  const index = blockMetadata.opcode.indexOf('_');
  const prefix = blockMetadata.opcode.substring(0, index);

  if (CORE_EXTENSIONS.indexOf(prefix) === -1) {
    if (prefix !== '') extensions.extensionIDs.add(prefix);
  } // Block skeleton.


  const activeBlock = {
    id: uid(),
    // Generate a new block unique ID.
    opcode: blockMetadata.opcode,
    // Converted, e.g. "motion_movesteps".
    inputs: {},
    // Inputs to this block and the blocks they point to.
    fields: {},
    // Fields on this block and their values.
    next: null,
    // Next block.
    shadow: false,
    // No shadow blocks in an SB2 by default.
    children: [] // Store any generated children, flattened in `flatten`.

  }; // Attach any comments to this block..

  if (commentsForParsedBlock) {
    // Attach only the last comment to the block, make all others workspace comments
    activeBlock.comment = commentsForParsedBlock[commentsForParsedBlock.length - 1].id;
    commentsForParsedBlock.forEach(comment => {
      if (comment.id === activeBlock.comment) {
        comment.blockId = activeBlock.id;
      } else {
        // All other comments don't get a block ID and are sent back to zero.
        // This is important, because if they have `null` x/y, serialization breaks.
        comment.blockId = null;
        comment.x = comment.y = 0;
      }
    });
  }

  commentIndex++;
  const parentExpectedArg = parseState.expectedArg; // For a procedure call, generate argument map from proc string.

  if (oldOpcode === 'call') {
    blockMetadata.argMap = parseProcedureArgMap(sb2block[1]);
  } // Look at the expected arguments in `blockMetadata.argMap.`
  // The basic problem here is to turn positional SB2 arguments into
  // non-positional named Scratch VM arguments.


  for (let i = 0; i < blockMetadata.argMap.length; i++) {
    const expectedArg = blockMetadata.argMap[i];
    const providedArg = sb2block[i + 1]; // (i = 0 is opcode)
    // Whether the input is obscuring a shadow.

    let shadowObscured = false; // Positional argument is an input.

    if (expectedArg.type === 'input') {
      // Create a new block and input metadata.
      const inputUid = uid();
      activeBlock.inputs[expectedArg.inputName] = {
        name: expectedArg.inputName,
        block: null,
        shadow: null
      };

      if (typeof providedArg === 'object' && providedArg) {
        // Block or block list occupies the input.
        let innerBlocks;
        parseState.expectedArg = expectedArg;

        if (typeof providedArg[0] === 'object' && providedArg[0]) {
          // Block list occupies the input.
          [innerBlocks, commentIndex] = parseBlockList(providedArg, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex);
        } else {
          // Single block occupies the input.
          const parsedBlockDesc = parseBlock(providedArg, addBroadcastMsg, getVariableId, extensions, parseState, comments, commentIndex);
          innerBlocks = parsedBlockDesc[0] ? [parsedBlockDesc[0]] : []; // Update commentIndex

          commentIndex = parsedBlockDesc[1];
        }

        parseState.expectedArg = parentExpectedArg; // Check if innerBlocks is not an empty list.
        // An empty list indicates that all the inner blocks from the sb2 have
        // unknown opcodes and have been skipped.

        if (innerBlocks.length > 0) {
          let previousBlock = null;

          for (let j = 0; j < innerBlocks.length; j++) {
            if (j === 0) {
              innerBlocks[j].parent = activeBlock.id;
            } else {
              innerBlocks[j].parent = previousBlock;
            }

            previousBlock = innerBlocks[j].id;
          }

          activeBlock.inputs[expectedArg.inputName].block = innerBlocks[0].id;
          activeBlock.children = activeBlock.children.concat(innerBlocks);
        } // Obscures any shadow.


        shadowObscured = true;
      } // Generate a shadow block to occupy the input.


      if (!expectedArg.inputOp) {
        // Undefined inputOp. inputOp should always be defined for inputs.
        log.warn("Unknown input operation for input ".concat(expectedArg.inputName, " of opcode ").concat(activeBlock.opcode, "."));
        continue;
      }

      if (expectedArg.inputOp === 'boolean' || expectedArg.inputOp === 'substack') {
        // No editable shadow input; e.g., for a boolean.
        continue;
      } // Each shadow has a field generated for it automatically.
      // Value to be filled in the field.


      let fieldValue = providedArg; // Shadows' field names match the input name, except for these:

      let fieldName = expectedArg.inputName;

      if (expectedArg.inputOp === 'math_number' || expectedArg.inputOp === 'math_whole_number' || expectedArg.inputOp === 'math_positive_number' || expectedArg.inputOp === 'math_integer' || expectedArg.inputOp === 'math_angle') {
        fieldName = 'NUM'; // Fields are given Scratch 2.0 default values if obscured.

        if (shadowObscured) {
          fieldValue = 10;
        }
      } else if (expectedArg.inputOp === 'text') {
        fieldName = 'TEXT';

        if (shadowObscured) {
          fieldValue = '';
        }
      } else if (expectedArg.inputOp === 'colour_picker') {
        // Convert SB2 color to hex.
        fieldValue = Color.decimalToHex(providedArg);
        fieldName = 'COLOUR';

        if (shadowObscured) {
          fieldValue = '#990000';
        }
      } else if (expectedArg.inputOp === 'event_broadcast_menu') {
        fieldName = 'BROADCAST_OPTION';

        if (shadowObscured) {
          fieldValue = '';
        }
      } else if (expectedArg.inputOp === 'sensing_of_object_menu') {
        if (shadowObscured) {
          fieldValue = '_stage_';
        } else if (fieldValue === 'Stage') {
          fieldValue = '_stage_';
        }
      } else if (expectedArg.inputOp === 'note') {
        if (shadowObscured) {
          fieldValue = 60;
        }
      } else if (expectedArg.inputOp === 'music.menu.DRUM') {
        if (shadowObscured) {
          fieldValue = 1;
        }
      } else if (expectedArg.inputOp === 'music.menu.INSTRUMENT') {
        if (shadowObscured) {
          fieldValue = 1;
        }
      } else if (expectedArg.inputOp === 'videoSensing.menu.ATTRIBUTE') {
        if (shadowObscured) {
          fieldValue = 'motion';
        }
      } else if (expectedArg.inputOp === 'videoSensing.menu.SUBJECT') {
        if (shadowObscured) {
          fieldValue = 'this sprite';
        }
      } else if (expectedArg.inputOp === 'videoSensing.menu.VIDEO_STATE') {
        if (shadowObscured) {
          fieldValue = 'on';
        }
      } else if (shadowObscured) {
        // Filled drop-down menu.
        fieldValue = '';
      }

      const fields = {};
      fields[fieldName] = {
        name: fieldName,
        value: fieldValue
      }; // event_broadcast_menus have some extra properties to add to the
      // field and a different value than the rest

      if (expectedArg.inputOp === 'event_broadcast_menu') {
        // Need to update the broadcast message name map with
        // the value of this field.
        // Also need to provide the fields[fieldName] object,
        // so that we can later update its value property, e.g.
        // if sb2 message name is empty string, we will later
        // replace this field's value with messageN
        // once we can traverse through all the existing message names
        // and come up with a fresh messageN.
        const broadcastId = addBroadcastMsg(fieldValue, fields[fieldName]);
        fields[fieldName].id = broadcastId;
        fields[fieldName].variableType = expectedArg.variableType;
      }

      activeBlock.children.push({
        id: inputUid,
        opcode: expectedArg.inputOp,
        inputs: {},
        fields: fields,
        next: null,
        topLevel: false,
        parent: activeBlock.id,
        shadow: true
      });
      activeBlock.inputs[expectedArg.inputName].shadow = inputUid; // If no block occupying the input, alias to the shadow.

      if (!activeBlock.inputs[expectedArg.inputName].block) {
        activeBlock.inputs[expectedArg.inputName].block = inputUid;
      }
    } else if (expectedArg.type === 'field') {
      // Add as a field on this block.
      activeBlock.fields[expectedArg.fieldName] = {
        name: expectedArg.fieldName,
        value: providedArg
      };

      if (expectedArg.fieldName === 'CURRENTMENU') {
        // In 3.0, the field value of the `sensing_current` block
        // is in all caps.
        activeBlock.fields[expectedArg.fieldName].value = providedArg.toUpperCase();

        if (providedArg === 'day of week') {
          activeBlock.fields[expectedArg.fieldName].value = 'DAYOFWEEK';
        }
      }

      if (expectedArg.fieldName === 'VARIABLE') {
        // Add `id` property to variable fields
        activeBlock.fields[expectedArg.fieldName].id = getVariableId(providedArg, Variable.SCALAR_TYPE);
      } else if (expectedArg.fieldName === 'LIST') {
        // Add `id` property to variable fields
        activeBlock.fields[expectedArg.fieldName].id = getVariableId(providedArg, Variable.LIST_TYPE);
      } else if (expectedArg.fieldName === 'BROADCAST_OPTION') {
        // Add the name in this field to the broadcast msg name map.
        // Also need to provide the fields[fieldName] object,
        // so that we can later update its value property, e.g.
        // if sb2 message name is empty string, we will later
        // replace this field's value with messageN
        // once we can traverse through all the existing message names
        // and come up with a fresh messageN.
        const broadcastId = addBroadcastMsg(providedArg, activeBlock.fields[expectedArg.fieldName]);
        activeBlock.fields[expectedArg.fieldName].id = broadcastId;
      }

      const varType = expectedArg.variableType;

      if (typeof varType === 'string') {
        activeBlock.fields[expectedArg.fieldName].variableType = varType;
      }
    }
  } // Updates for blocks that have new menus (e.g. in Looks)


  switch (oldOpcode) {
    case 'comeToFront':
      activeBlock.fields.FRONT_BACK = {
        name: 'FRONT_BACK',
        value: 'front'
      };
      break;

    case 'goBackByLayers:':
      activeBlock.fields.FORWARD_BACKWARD = {
        name: 'FORWARD_BACKWARD',
        value: 'backward'
      };
      break;

    case 'backgroundIndex':
      activeBlock.fields.NUMBER_NAME = {
        name: 'NUMBER_NAME',
        value: 'number'
      };
      break;

    case 'sceneName':
      activeBlock.fields.NUMBER_NAME = {
        name: 'NUMBER_NAME',
        value: 'name'
      };
      break;

    case 'costumeIndex':
      activeBlock.fields.NUMBER_NAME = {
        name: 'NUMBER_NAME',
        value: 'number'
      };
      break;

    case 'costumeName':
      activeBlock.fields.NUMBER_NAME = {
        name: 'NUMBER_NAME',
        value: 'name'
      };
      break;
  } // Special cases to generate mutations.


  if (oldOpcode === 'stopScripts') {
    // Mutation for stop block: if the argument is 'other scripts',
    // the block needs a next connection.
    if (sb2block[1] === 'other scripts in sprite' || sb2block[1] === 'other scripts in stage') {
      activeBlock.mutation = {
        tagName: 'mutation',
        hasnext: 'true',
        children: []
      };
    }
  } else if (oldOpcode === 'procDef') {
    // Mutation for procedure definition:
    // store all 2.0 proc data.
    const procData = sb2block.slice(1); // Create a new block and input metadata.

    const inputUid = uid();
    const inputName = 'custom_block';
    activeBlock.inputs[inputName] = {
      name: inputName,
      block: inputUid,
      shadow: inputUid
    };
    activeBlock.children = [{
      id: inputUid,
      opcode: 'procedures_prototype',
      inputs: {},
      fields: {},
      next: null,
      shadow: true,
      children: [],
      mutation: {
        tagName: 'mutation',
        proccode: procData[0],
        // e.g., "abc %n %b %s"
        argumentnames: JSON.stringify(procData[1]),
        // e.g. ['arg1', 'arg2']
        argumentids: JSON.stringify(parseProcedureArgIds(procData[0])),
        argumentdefaults: JSON.stringify(procData[2]),
        // e.g., [1, 'abc']
        warp: procData[3],
        // Warp mode, e.g., true/false.
        children: []
      }
    }];
  } else if (oldOpcode === 'call') {
    // Mutation for procedure call:
    // string for proc code (e.g., "abc %n %b %s").
    activeBlock.mutation = {
      tagName: 'mutation',
      children: [],
      proccode: sb2block[1],
      argumentids: JSON.stringify(parseProcedureArgIds(sb2block[1]))
    };
  } else if (oldOpcode === 'getParam') {
    let returnCode = sb2block[2]; // Ensure the returnCode is "b" if used in a boolean input.

    if (parentExpectedArg && parentExpectedArg.inputOp === 'boolean' && returnCode !== 'b') {
      returnCode = 'b';
    } // Assign correct opcode based on the block shape.


    switch (returnCode) {
      case 'r':
        activeBlock.opcode = 'argument_reporter_string_number';
        break;

      case 'b':
        activeBlock.opcode = 'argument_reporter_boolean';
        break;
    }
  }

  return [activeBlock, commentIndex];
};

module.exports = {
  deserialize: sb2import
};

/***/ }),

/***/ "./src/serialization/sb2_specmap.js":
/*!******************************************!*\
  !*** ./src/serialization/sb2_specmap.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview
 * The specMap below handles a few pieces of "translation" work between
 * the SB2 JSON format and the data we need to run a project
 * in the Scratch 3.0 VM.
 * Notably:
 *  - Map 2.0 and 1.4 opcodes (forward:) into 3.0-format (motion_movesteps).
 *  - Map ordered, unnamed args to unordered, named inputs and fields.
 * Keep this up-to-date as 3.0 blocks are renamed, changed, etc.
 * Originally this was generated largely by a hand-guided scripting process.
 * The relevant data lives here:
 * https://github.com/LLK/scratch-flash/blob/master/src/Specs.as
 * (for the old opcode and argument order).
 * and here:
 * https://github.com/LLK/scratch-blocks/tree/develop/blocks_vertical
 * (for the new opcodes and argument names).
 * and here:
 * https://github.com/LLK/scratch-blocks/blob/develop/tests/
 * (for the shadow blocks created for each block).
 * I started with the `commands` array in Specs.as, and discarded irrelevant
 * properties. By hand, I matched the opcode name to the 3.0 opcode.
 * Finally, I filled in the expected arguments as below.
 */
const Variable = __webpack_require__(/*! ../engine/variable */ "./src/engine/variable.js");
/**
 * @typedef {object} SB2SpecMap_blockInfo
 * @property {string} opcode - the Scratch 3.0 block opcode. Use 'extensionID.opcode' for extension opcodes.
 * @property {Array.<SB2SpecMap_argInfo>} argMap - metadata for this block's arguments.
 */

/**
 * @typedef {object} SB2SpecMap_argInfo
 * @property {string} type - the type of this arg (such as 'input' or 'field')
 * @property {string} inputOp - the scratch-blocks shadow type for this arg
 * @property {string} inputName - the name this argument will take when provided to the block implementation
 */

/**
 * Mapping of Scratch 2.0 opcode to Scratch 3.0 block metadata.
 * @type {object.<SB2SpecMap_blockInfo>}
 */


const specMap = {
  'forward:': {
    opcode: 'motion_movesteps',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'STEPS'
    }]
  },
  'turnRight:': {
    opcode: 'motion_turnright',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DEGREES'
    }]
  },
  'turnLeft:': {
    opcode: 'motion_turnleft',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DEGREES'
    }]
  },
  'heading:': {
    opcode: 'motion_pointindirection',
    argMap: [{
      type: 'input',
      inputOp: 'math_angle',
      inputName: 'DIRECTION'
    }]
  },
  'pointTowards:': {
    opcode: 'motion_pointtowards',
    argMap: [{
      type: 'input',
      inputOp: 'motion_pointtowards_menu',
      inputName: 'TOWARDS'
    }]
  },
  'gotoX:y:': {
    opcode: 'motion_gotoxy',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'X'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'Y'
    }]
  },
  'gotoSpriteOrMouse:': {
    opcode: 'motion_goto',
    argMap: [{
      type: 'input',
      inputOp: 'motion_goto_menu',
      inputName: 'TO'
    }]
  },
  'glideSecs:toX:y:elapsed:from:': {
    opcode: 'motion_glidesecstoxy',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SECS'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'X'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'Y'
    }]
  },
  'changeXposBy:': {
    opcode: 'motion_changexby',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DX'
    }]
  },
  'xpos:': {
    opcode: 'motion_setx',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'X'
    }]
  },
  'changeYposBy:': {
    opcode: 'motion_changeyby',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DY'
    }]
  },
  'ypos:': {
    opcode: 'motion_sety',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'Y'
    }]
  },
  'bounceOffEdge': {
    opcode: 'motion_ifonedgebounce',
    argMap: []
  },
  'setRotationStyle': {
    opcode: 'motion_setrotationstyle',
    argMap: [{
      type: 'field',
      fieldName: 'STYLE'
    }]
  },
  'xpos': {
    opcode: 'motion_xposition',
    argMap: []
  },
  'ypos': {
    opcode: 'motion_yposition',
    argMap: []
  },
  'heading': {
    opcode: 'motion_direction',
    argMap: []
  },
  'scrollRight': {
    opcode: 'motion_scroll_right',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DISTANCE'
    }]
  },
  'scrollUp': {
    opcode: 'motion_scroll_up',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DISTANCE'
    }]
  },
  'scrollAlign': {
    opcode: 'motion_align_scene',
    argMap: [{
      type: 'field',
      fieldName: 'ALIGNMENT'
    }]
  },
  'xScroll': {
    opcode: 'motion_xscroll',
    argMap: []
  },
  'yScroll': {
    opcode: 'motion_yscroll',
    argMap: []
  },
  'say:duration:elapsed:from:': {
    opcode: 'looks_sayforsecs',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'MESSAGE'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SECS'
    }]
  },
  'say:': {
    opcode: 'looks_say',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'MESSAGE'
    }]
  },
  'think:duration:elapsed:from:': {
    opcode: 'looks_thinkforsecs',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'MESSAGE'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SECS'
    }]
  },
  'think:': {
    opcode: 'looks_think',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'MESSAGE'
    }]
  },
  'show': {
    opcode: 'looks_show',
    argMap: []
  },
  'hide': {
    opcode: 'looks_hide',
    argMap: []
  },
  'hideAll': {
    opcode: 'looks_hideallsprites',
    argMap: []
  },
  'lookLike:': {
    opcode: 'looks_switchcostumeto',
    argMap: [{
      type: 'input',
      inputOp: 'looks_costume',
      inputName: 'COSTUME'
    }]
  },
  'nextCostume': {
    opcode: 'looks_nextcostume',
    argMap: []
  },
  'startScene': {
    opcode: 'looks_switchbackdropto',
    argMap: [{
      type: 'input',
      inputOp: 'looks_backdrops',
      inputName: 'BACKDROP'
    }]
  },
  'changeGraphicEffect:by:': {
    opcode: 'looks_changeeffectby',
    argMap: [{
      type: 'field',
      fieldName: 'EFFECT'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'CHANGE'
    }]
  },
  'setGraphicEffect:to:': {
    opcode: 'looks_seteffectto',
    argMap: [{
      type: 'field',
      fieldName: 'EFFECT'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'VALUE'
    }]
  },
  'filterReset': {
    opcode: 'looks_cleargraphiceffects',
    argMap: []
  },
  'changeSizeBy:': {
    opcode: 'looks_changesizeby',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'CHANGE'
    }]
  },
  'setSizeTo:': {
    opcode: 'looks_setsizeto',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SIZE'
    }]
  },
  'changeStretchBy:': {
    opcode: 'looks_changestretchby',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'CHANGE'
    }]
  },
  'setStretchTo:': {
    opcode: 'looks_setstretchto',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'STRETCH'
    }]
  },
  'comeToFront': {
    opcode: 'looks_gotofrontback',
    argMap: []
  },
  'goBackByLayers:': {
    opcode: 'looks_goforwardbackwardlayers',
    argMap: [{
      type: 'input',
      inputOp: 'math_integer',
      inputName: 'NUM'
    }]
  },
  'costumeIndex': {
    opcode: 'looks_costumenumbername',
    argMap: []
  },
  'costumeName': {
    opcode: 'looks_costumenumbername',
    argMap: []
  },
  'sceneName': {
    opcode: 'looks_backdropnumbername',
    argMap: []
  },
  'scale': {
    opcode: 'looks_size',
    argMap: []
  },
  'startSceneAndWait': {
    opcode: 'looks_switchbackdroptoandwait',
    argMap: [{
      type: 'input',
      inputOp: 'looks_backdrops',
      inputName: 'BACKDROP'
    }]
  },
  'nextScene': {
    opcode: 'looks_nextbackdrop',
    argMap: []
  },
  'backgroundIndex': {
    opcode: 'looks_backdropnumbername',
    argMap: []
  },
  'playSound:': {
    opcode: 'sound_play',
    argMap: [{
      type: 'input',
      inputOp: 'sound_sounds_menu',
      inputName: 'SOUND_MENU'
    }]
  },
  'doPlaySoundAndWait': {
    opcode: 'sound_playuntildone',
    argMap: [{
      type: 'input',
      inputOp: 'sound_sounds_menu',
      inputName: 'SOUND_MENU'
    }]
  },
  'stopAllSounds': {
    opcode: 'sound_stopallsounds',
    argMap: []
  },
  'playDrum': {
    opcode: 'music_playDrumForBeats',
    argMap: [{
      type: 'input',
      inputOp: 'music_menu_DRUM',
      inputName: 'DRUM'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'BEATS'
    }]
  },
  'drum:duration:elapsed:from:': {
    opcode: 'music_midiPlayDrumForBeats',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'DRUM'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'BEATS'
    }]
  },
  'rest:elapsed:from:': {
    opcode: 'music_restForBeats',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'BEATS'
    }]
  },
  'noteOn:duration:elapsed:from:': {
    opcode: 'music_playNoteForBeats',
    argMap: [{
      type: 'input',
      inputOp: 'note',
      inputName: 'NOTE'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'BEATS'
    }]
  },
  'instrument:': {
    opcode: 'music_setInstrument',
    argMap: [{
      type: 'input',
      inputOp: 'music_menu_INSTRUMENT',
      inputName: 'INSTRUMENT'
    }]
  },
  'midiInstrument:': {
    opcode: 'music_midiSetInstrument',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'INSTRUMENT'
    }]
  },
  'changeVolumeBy:': {
    opcode: 'sound_changevolumeby',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'VOLUME'
    }]
  },
  'setVolumeTo:': {
    opcode: 'sound_setvolumeto',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'VOLUME'
    }]
  },
  'volume': {
    opcode: 'sound_volume',
    argMap: []
  },
  'changeTempoBy:': {
    opcode: 'music_changeTempo',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'TEMPO'
    }]
  },
  'setTempoTo:': {
    opcode: 'music_setTempo',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'TEMPO'
    }]
  },
  'tempo': {
    opcode: 'music_getTempo',
    argMap: []
  },
  'clearPenTrails': {
    opcode: 'pen_clear',
    argMap: []
  },
  'stampCostume': {
    opcode: 'pen_stamp',
    argMap: []
  },
  'putPenDown': {
    opcode: 'pen_penDown',
    argMap: []
  },
  'putPenUp': {
    opcode: 'pen_penUp',
    argMap: []
  },
  'penColor:': {
    opcode: 'pen_setPenColorToColor',
    argMap: [{
      type: 'input',
      inputOp: 'colour_picker',
      inputName: 'COLOR'
    }]
  },
  'changePenHueBy:': {
    opcode: 'pen_changePenHueBy',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'HUE'
    }]
  },
  'setPenHueTo:': {
    opcode: 'pen_setPenHueToNumber',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'HUE'
    }]
  },
  'changePenShadeBy:': {
    opcode: 'pen_changePenShadeBy',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SHADE'
    }]
  },
  'setPenShadeTo:': {
    opcode: 'pen_setPenShadeToNumber',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SHADE'
    }]
  },
  'changePenSizeBy:': {
    opcode: 'pen_changePenSizeBy',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SIZE'
    }]
  },
  'penSize:': {
    opcode: 'pen_setPenSizeTo',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'SIZE'
    }]
  },
  'senseVideoMotion': {
    opcode: 'videoSensing_videoOn',
    argMap: [{
      type: 'input',
      inputOp: 'videoSensing_menu_ATTRIBUTE',
      inputName: 'ATTRIBUTE'
    }, {
      type: 'input',
      inputOp: 'videoSensing_menu_SUBJECT',
      inputName: 'SUBJECT'
    }]
  },
  'whenGreenFlag': {
    opcode: 'event_whenflagclicked',
    argMap: []
  },
  'whenKeyPressed': {
    opcode: 'event_whenkeypressed',
    argMap: [{
      type: 'field',
      fieldName: 'KEY_OPTION'
    }]
  },
  'whenClicked': {
    opcode: 'event_whenthisspriteclicked',
    argMap: []
  },
  'whenSceneStarts': {
    opcode: 'event_whenbackdropswitchesto',
    argMap: [{
      type: 'field',
      fieldName: 'BACKDROP'
    }]
  },
  'whenSensorGreaterThan': (_ref) => {
    let [, sensor] = _ref;

    if (sensor === 'video motion') {
      return {
        opcode: 'videoSensing_whenMotionGreaterThan',
        argMap: [// skip the first arg, since we converted to a video specific sensing block
        {}, {
          type: 'input',
          inputOp: 'math_number',
          inputName: 'REFERENCE'
        }]
      };
    }

    return {
      opcode: 'event_whengreaterthan',
      argMap: [{
        type: 'field',
        fieldName: 'WHENGREATERTHANMENU'
      }, {
        type: 'input',
        inputOp: 'math_number',
        inputName: 'VALUE'
      }]
    };
  },
  'whenIReceive': {
    opcode: 'event_whenbroadcastreceived',
    argMap: [{
      type: 'field',
      fieldName: 'BROADCAST_OPTION',
      variableType: Variable.BROADCAST_MESSAGE_TYPE
    }]
  },
  'broadcast:': {
    opcode: 'event_broadcast',
    argMap: [{
      type: 'input',
      inputOp: 'event_broadcast_menu',
      inputName: 'BROADCAST_INPUT',
      variableType: Variable.BROADCAST_MESSAGE_TYPE
    }]
  },
  'doBroadcastAndWait': {
    opcode: 'event_broadcastandwait',
    argMap: [{
      type: 'input',
      inputOp: 'event_broadcast_menu',
      inputName: 'BROADCAST_INPUT',
      variableType: Variable.BROADCAST_MESSAGE_TYPE
    }]
  },
  'wait:elapsed:from:': {
    opcode: 'control_wait',
    argMap: [{
      type: 'input',
      inputOp: 'math_positive_number',
      inputName: 'DURATION'
    }]
  },
  'doRepeat': {
    opcode: 'control_repeat',
    argMap: [{
      type: 'input',
      inputOp: 'math_whole_number',
      inputName: 'TIMES'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'doForever': {
    opcode: 'control_forever',
    argMap: [{
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'doIf': {
    opcode: 'control_if',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'CONDITION'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'doIfElse': {
    opcode: 'control_if_else',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'CONDITION'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK2'
    }]
  },
  'doWaitUntil': {
    opcode: 'control_wait_until',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'CONDITION'
    }]
  },
  'doUntil': {
    opcode: 'control_repeat_until',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'CONDITION'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'doWhile': {
    opcode: 'control_while',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'CONDITION'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'doForLoop': {
    opcode: 'control_for_each',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'VALUE'
    }, {
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'stopScripts': {
    opcode: 'control_stop',
    argMap: [{
      type: 'field',
      fieldName: 'STOP_OPTION'
    }]
  },
  'whenCloned': {
    opcode: 'control_start_as_clone',
    argMap: []
  },
  'createCloneOf': {
    opcode: 'control_create_clone_of',
    argMap: [{
      type: 'input',
      inputOp: 'control_create_clone_of_menu',
      inputName: 'CLONE_OPTION'
    }]
  },
  'deleteClone': {
    opcode: 'control_delete_this_clone',
    argMap: []
  },
  'COUNT': {
    opcode: 'control_get_counter',
    argMap: []
  },
  'INCR_COUNT': {
    opcode: 'control_incr_counter',
    argMap: []
  },
  'CLR_COUNT': {
    opcode: 'control_clear_counter',
    argMap: []
  },
  'warpSpeed': {
    opcode: 'control_all_at_once',
    argMap: [{
      type: 'input',
      inputOp: 'substack',
      inputName: 'SUBSTACK'
    }]
  },
  'touching:': {
    opcode: 'sensing_touchingobject',
    argMap: [{
      type: 'input',
      inputOp: 'sensing_touchingobjectmenu',
      inputName: 'TOUCHINGOBJECTMENU'
    }]
  },
  'touchingColor:': {
    opcode: 'sensing_touchingcolor',
    argMap: [{
      type: 'input',
      inputOp: 'colour_picker',
      inputName: 'COLOR'
    }]
  },
  'color:sees:': {
    opcode: 'sensing_coloristouchingcolor',
    argMap: [{
      type: 'input',
      inputOp: 'colour_picker',
      inputName: 'COLOR'
    }, {
      type: 'input',
      inputOp: 'colour_picker',
      inputName: 'COLOR2'
    }]
  },
  'distanceTo:': {
    opcode: 'sensing_distanceto',
    argMap: [{
      type: 'input',
      inputOp: 'sensing_distancetomenu',
      inputName: 'DISTANCETOMENU'
    }]
  },
  'doAsk': {
    opcode: 'sensing_askandwait',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'QUESTION'
    }]
  },
  'answer': {
    opcode: 'sensing_answer',
    argMap: []
  },
  'keyPressed:': {
    opcode: 'sensing_keypressed',
    argMap: [{
      type: 'input',
      inputOp: 'sensing_keyoptions',
      inputName: 'KEY_OPTION'
    }]
  },
  'mousePressed': {
    opcode: 'sensing_mousedown',
    argMap: []
  },
  'mouseX': {
    opcode: 'sensing_mousex',
    argMap: []
  },
  'mouseY': {
    opcode: 'sensing_mousey',
    argMap: []
  },
  'soundLevel': {
    opcode: 'sensing_loudness',
    argMap: []
  },
  'isLoud': {
    opcode: 'sensing_loud',
    argMap: []
  },
  // 'senseVideoMotion': {
  //     opcode: 'sensing_videoon',
  //     argMap: [
  //         {
  //             type: 'input',
  //             inputOp: 'sensing_videoonmenuone',
  //             inputName: 'VIDEOONMENU1'
  //         },
  //         {
  //             type: 'input',
  //             inputOp: 'sensing_videoonmenutwo',
  //             inputName: 'VIDEOONMENU2'
  //         }
  //     ]
  // },
  'setVideoState': {
    opcode: 'videoSensing_videoToggle',
    argMap: [{
      type: 'input',
      inputOp: 'videoSensing_menu_VIDEO_STATE',
      inputName: 'VIDEO_STATE'
    }]
  },
  'setVideoTransparency': {
    opcode: 'videoSensing_setVideoTransparency',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'TRANSPARENCY'
    }]
  },
  'timer': {
    opcode: 'sensing_timer',
    argMap: []
  },
  'timerReset': {
    opcode: 'sensing_resettimer',
    argMap: []
  },
  'getAttribute:of:': {
    opcode: 'sensing_of',
    argMap: [{
      type: 'field',
      fieldName: 'PROPERTY'
    }, {
      type: 'input',
      inputOp: 'sensing_of_object_menu',
      inputName: 'OBJECT'
    }]
  },
  'timeAndDate': {
    opcode: 'sensing_current',
    argMap: [{
      type: 'field',
      fieldName: 'CURRENTMENU'
    }]
  },
  'timestamp': {
    opcode: 'sensing_dayssince2000',
    argMap: []
  },
  'getUserName': {
    opcode: 'sensing_username',
    argMap: []
  },
  'getUserId': {
    opcode: 'sensing_userid',
    argMap: []
  },
  '+': {
    opcode: 'operator_add',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM1'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM2'
    }]
  },
  '-': {
    opcode: 'operator_subtract',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM1'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM2'
    }]
  },
  '*': {
    opcode: 'operator_multiply',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM1'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM2'
    }]
  },
  '/': {
    opcode: 'operator_divide',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM1'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM2'
    }]
  },
  'randomFrom:to:': {
    opcode: 'operator_random',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'FROM'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'TO'
    }]
  },
  '<': {
    opcode: 'operator_lt',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND1'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND2'
    }]
  },
  '=': {
    opcode: 'operator_equals',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND1'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND2'
    }]
  },
  '>': {
    opcode: 'operator_gt',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND1'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'OPERAND2'
    }]
  },
  '&': {
    opcode: 'operator_and',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'OPERAND1'
    }, {
      type: 'input',
      inputOp: 'boolean',
      inputName: 'OPERAND2'
    }]
  },
  '|': {
    opcode: 'operator_or',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'OPERAND1'
    }, {
      type: 'input',
      inputOp: 'boolean',
      inputName: 'OPERAND2'
    }]
  },
  'not': {
    opcode: 'operator_not',
    argMap: [{
      type: 'input',
      inputOp: 'boolean',
      inputName: 'OPERAND'
    }]
  },
  'concatenate:with:': {
    opcode: 'operator_join',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'STRING1'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'STRING2'
    }]
  },
  'letter:of:': {
    opcode: 'operator_letter_of',
    argMap: [{
      type: 'input',
      inputOp: 'math_whole_number',
      inputName: 'LETTER'
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'STRING'
    }]
  },
  'stringLength:': {
    opcode: 'operator_length',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'STRING'
    }]
  },
  '%': {
    opcode: 'operator_mod',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM1'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM2'
    }]
  },
  'rounded': {
    opcode: 'operator_round',
    argMap: [{
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM'
    }]
  },
  'computeFunction:of:': {
    opcode: 'operator_mathop',
    argMap: [{
      type: 'field',
      fieldName: 'OPERATOR'
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'NUM'
    }]
  },
  'readVariable': {
    opcode: 'data_variable',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }]
  },
  // Scratch 2 uses this alternative variable getter opcode only in monitors,
  // blocks use the `readVariable` opcode above.
  'getVar:': {
    opcode: 'data_variable',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }]
  },
  'setVar:to:': {
    opcode: 'data_setvariableto',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'VALUE'
    }]
  },
  'changeVar:by:': {
    opcode: 'data_changevariableby',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }, {
      type: 'input',
      inputOp: 'math_number',
      inputName: 'VALUE'
    }]
  },
  'showVariable:': {
    opcode: 'data_showvariable',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }]
  },
  'hideVariable:': {
    opcode: 'data_hidevariable',
    argMap: [{
      type: 'field',
      fieldName: 'VARIABLE',
      variableType: Variable.SCALAR_TYPE
    }]
  },
  'contentsOfList:': {
    opcode: 'data_listcontents',
    argMap: [{
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'append:toList:': {
    opcode: 'data_addtolist',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'ITEM'
    }, {
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'deleteLine:ofList:': {
    opcode: 'data_deleteoflist',
    argMap: [{
      type: 'input',
      inputOp: 'math_integer',
      inputName: 'INDEX'
    }, {
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'insert:at:ofList:': {
    opcode: 'data_insertatlist',
    argMap: [{
      type: 'input',
      inputOp: 'text',
      inputName: 'ITEM'
    }, {
      type: 'input',
      inputOp: 'math_integer',
      inputName: 'INDEX'
    }, {
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'setLine:ofList:to:': {
    opcode: 'data_replaceitemoflist',
    argMap: [{
      type: 'input',
      inputOp: 'math_integer',
      inputName: 'INDEX'
    }, {
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'ITEM'
    }]
  },
  'getLine:ofList:': {
    opcode: 'data_itemoflist',
    argMap: [{
      type: 'input',
      inputOp: 'math_integer',
      inputName: 'INDEX'
    }, {
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'lineCountOfList:': {
    opcode: 'data_lengthoflist',
    argMap: [{
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'list:contains:': {
    opcode: 'data_listcontainsitem',
    argMap: [{
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }, {
      type: 'input',
      inputOp: 'text',
      inputName: 'ITEM'
    }]
  },
  'showList:': {
    opcode: 'data_showlist',
    argMap: [{
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'hideList:': {
    opcode: 'data_hidelist',
    argMap: [{
      type: 'field',
      fieldName: 'LIST',
      variableType: Variable.LIST_TYPE
    }]
  },
  'procDef': {
    opcode: 'procedures_definition',
    argMap: []
  },
  'getParam': {
    // Doesn't map to single opcode. Import step assigns final correct opcode.
    opcode: 'argument_reporter_string_number',
    argMap: [{
      type: 'field',
      fieldName: 'VALUE'
    }]
  },
  'call': {
    opcode: 'procedures_call',
    argMap: []
  }
};
/**
 * Add to the specMap entries for an opcode from a Scratch 2.0 extension. Two entries will be made with the same
 * metadata; this is done to support projects saved by both older and newer versions of the Scratch 2.0 editor.
 * @param {string} sb2Extension - the Scratch 2.0 name of the extension
 * @param {string} sb2Opcode - the Scratch 2.0 opcode
 * @param {SB2SpecMap_blockInfo} blockInfo - the Scratch 3.0 block info
 */

const addExtensionOp = function addExtensionOp(sb2Extension, sb2Opcode, blockInfo) {
  /**
   * This string separates the name of an extension and the name of an opcode in more recent Scratch 2.0 projects.
   * Earlier projects used '.' as a separator, up until we added the 'LEGO WeDo 2.0' extension...
   * @type {string}
   */
  const sep = '\u001F'; // Unicode Unit Separator
  // make one entry for projects saved by recent versions of the Scratch 2.0 editor

  specMap["".concat(sb2Extension).concat(sep).concat(sb2Opcode)] = blockInfo; // make a second for projects saved by older versions of the Scratch 2.0 editor

  specMap["".concat(sb2Extension, ".").concat(sb2Opcode)] = blockInfo;
};

const weDo2 = 'LEGO WeDo 2.0';
addExtensionOp(weDo2, 'motorOnFor', {
  opcode: 'wedo2_motorOnFor',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_ID',
    inputName: 'MOTOR_ID'
  }, {
    type: 'input',
    inputOp: 'math_number',
    inputName: 'DURATION'
  }]
});
addExtensionOp(weDo2, 'motorOn', {
  opcode: 'wedo2_motorOn',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_ID',
    inputName: 'MOTOR_ID'
  }]
});
addExtensionOp(weDo2, 'motorOff', {
  opcode: 'wedo2_motorOff',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_ID',
    inputName: 'MOTOR_ID'
  }]
});
addExtensionOp(weDo2, 'startMotorPower', {
  opcode: 'wedo2_startMotorPower',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_ID',
    inputName: 'MOTOR_ID'
  }, {
    type: 'input',
    inputOp: 'math_number',
    inputName: 'POWER'
  }]
});
addExtensionOp(weDo2, 'setMotorDirection', {
  opcode: 'wedo2_setMotorDirection',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_ID',
    inputName: 'MOTOR_ID'
  }, {
    type: 'input',
    inputOp: 'wedo2_menu_MOTOR_DIRECTION',
    inputName: 'MOTOR_DIRECTION'
  }]
});
addExtensionOp(weDo2, 'setLED', {
  opcode: 'wedo2_setLightHue',
  argMap: [{
    type: 'input',
    inputOp: 'math_number',
    inputName: 'HUE'
  }]
});
addExtensionOp(weDo2, 'playNote', {
  opcode: 'wedo2_playNoteFor',
  argMap: [{
    type: 'input',
    inputOp: 'math_number',
    inputName: 'NOTE'
  }, {
    type: 'input',
    inputOp: 'math_number',
    inputName: 'DURATION'
  }]
});
addExtensionOp(weDo2, 'whenDistance', {
  opcode: 'wedo2_whenDistance',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_OP',
    inputName: 'OP'
  }, {
    type: 'input',
    inputOp: 'math_number',
    inputName: 'REFERENCE'
  }]
});
addExtensionOp(weDo2, 'whenTilted', {
  opcode: 'wedo2_whenTilted',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_TILT_DIRECTION_ANY',
    inputName: 'TILT_DIRECTION_ANY'
  }]
});
addExtensionOp(weDo2, 'getDistance', {
  opcode: 'wedo2_getDistance',
  argMap: []
});
addExtensionOp(weDo2, 'isTilted', {
  opcode: 'wedo2_isTilted',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_TILT_DIRECTION_ANY',
    inputName: 'TILT_DIRECTION_ANY'
  }]
});
addExtensionOp(weDo2, 'getTilt', {
  opcode: 'wedo2_getTiltAngle',
  argMap: [{
    type: 'input',
    inputOp: 'wedo2_menu_TILT_DIRECTION',
    inputName: 'TILT_DIRECTION'
  }]
});
module.exports = specMap;

/***/ }),

/***/ "./src/serialization/sb3.js":
/*!**********************************!*\
  !*** ./src/serialization/sb3.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * @fileoverview
 * An SB3 serializer and deserializer. Parses provided
 * JSON and then generates all needed scratch-vm runtime structures.
 */
const Blocks = __webpack_require__(/*! ../engine/blocks */ "./src/engine/blocks.js");

const Sprite = __webpack_require__(/*! ../sprites/sprite */ "./src/sprites/sprite.js");

const Variable = __webpack_require__(/*! ../engine/variable */ "./src/engine/variable.js");

const Comment = __webpack_require__(/*! ../engine/comment */ "./src/engine/comment.js");

const MonitorRecord = __webpack_require__(/*! ../engine/monitor-record */ "./src/engine/monitor-record.js");

const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");

const log = __webpack_require__(/*! ../util/log */ "./src/util/log.js");

const uid = __webpack_require__(/*! ../util/uid */ "./src/util/uid.js");

const MathUtil = __webpack_require__(/*! ../util/math-util */ "./src/util/math-util.js");

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");

const VariableUtil = __webpack_require__(/*! ../util/variable-util */ "./src/util/variable-util.js");

const compress = __webpack_require__(/*! ./tw-compress-sb3 */ "./src/serialization/tw-compress-sb3.js");

const {
  loadCostume
} = __webpack_require__(/*! ../import/load-costume.js */ "./src/import/load-costume.js");

const {
  loadSound
} = __webpack_require__(/*! ../import/load-sound.js */ "./src/import/load-sound.js");

const {
  deserializeCostume,
  deserializeSound
} = __webpack_require__(/*! ./deserialize-assets.js */ "./src/serialization/deserialize-assets.js");

const hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * @typedef {object} ImportedProject
 * @property {Array.<Target>} targets - the imported Scratch 3.0 target objects.
 * @property {ImportedExtensionsInfo} extensionsInfo - the ID of each extension actually used by this project.
 */

/**
 * @typedef {object} ImportedExtensionsInfo
 * @property {Set.<string>} extensionIDs - the ID of each extension actually in use by blocks in this project.
 * @property {Map.<string, string>} extensionURLs - map of ID => URL from project metadata. May not match extensionIDs.
 */
// Constants used during serialization and deserialization

const INPUT_SAME_BLOCK_SHADOW = 1; // unobscured shadow

const INPUT_BLOCK_NO_SHADOW = 2; // no shadow

const INPUT_DIFF_BLOCK_SHADOW = 3; // obscured shadow
// There shouldn't be a case where block is null, but shadow is present...
// Constants used during deserialization of an SB3 file

const CORE_EXTENSIONS = ['argument', 'colour', 'control', 'data', 'event', 'looks', 'math', 'motion', 'operator', 'procedures', 'sensing', 'sound']; // Constants referring to 'primitive' blocks that are usually shadows,
// or in the case of variables and lists, appear quite often in projects
// math_number

const MATH_NUM_PRIMITIVE = 4; // there's no reason these constants can't collide
// math_positive_number

const POSITIVE_NUM_PRIMITIVE = 5; // with the above, but removing duplication for clarity
// math_whole_number

const WHOLE_NUM_PRIMITIVE = 6; // math_integer

const INTEGER_NUM_PRIMITIVE = 7; // math_angle

const ANGLE_NUM_PRIMITIVE = 8; // colour_picker

const COLOR_PICKER_PRIMITIVE = 9; // text

const TEXT_PRIMITIVE = 10; // event_broadcast_menu

const BROADCAST_PRIMITIVE = 11; // data_variable

const VAR_PRIMITIVE = 12; // data_listcontents

const LIST_PRIMITIVE = 13; // Map block opcodes to the above primitives and the name of the field we can use
// to find the value of the field

const primitiveOpcodeInfoMap = {
  math_number: [MATH_NUM_PRIMITIVE, 'NUM'],
  math_positive_number: [POSITIVE_NUM_PRIMITIVE, 'NUM'],
  math_whole_number: [WHOLE_NUM_PRIMITIVE, 'NUM'],
  math_integer: [INTEGER_NUM_PRIMITIVE, 'NUM'],
  math_angle: [ANGLE_NUM_PRIMITIVE, 'NUM'],
  colour_picker: [COLOR_PICKER_PRIMITIVE, 'COLOUR'],
  text: [TEXT_PRIMITIVE, 'TEXT'],
  event_broadcast_menu: [BROADCAST_PRIMITIVE, 'BROADCAST_OPTION'],
  data_variable: [VAR_PRIMITIVE, 'VARIABLE'],
  data_listcontents: [LIST_PRIMITIVE, 'LIST']
};
/**
 * Serializes primitives described above into a more compact format
 * @param {object} block the block to serialize
 * @return {array} An array representing the information in the block,
 * or null if the given block is not one of the primitives described above.
 */

const serializePrimitiveBlock = function serializePrimitiveBlock(block) {
  // Returns an array represeting a primitive block or null if not one of
  // the primitive types above
  if (hasOwnProperty.call(primitiveOpcodeInfoMap, block.opcode)) {
    const primitiveInfo = primitiveOpcodeInfoMap[block.opcode];
    const primitiveConstant = primitiveInfo[0];
    const fieldName = primitiveInfo[1];
    const field = block.fields[fieldName];
    const primitiveDesc = [primitiveConstant, field.value];

    if (block.opcode === 'event_broadcast_menu') {
      primitiveDesc.push(field.id);
    } else if (block.opcode === 'data_variable' || block.opcode === 'data_listcontents') {
      primitiveDesc.push(field.id);

      if (block.topLevel) {
        primitiveDesc.push(block.x ? Math.round(block.x) : 0);
        primitiveDesc.push(block.y ? Math.round(block.y) : 0);
      }
    }

    return primitiveDesc;
  }

  return null;
};
/**
 * Serializes the inputs field of a block in a compact form using
 * constants described above to represent the relationship between the
 * inputs of this block (e.g. if there is an unobscured shadow, an obscured shadow
 * -- a block plugged into a droppable input -- or, if there is just a block).
 * Based on this relationship, serializes the ids of the block and shadow (if present)
 *
 * @param {object} inputs The inputs to serialize
 * @return {object} An object representing the serialized inputs
 */


const serializeInputs = function serializeInputs(inputs) {
  const obj = Object.create(null);

  for (const inputName in inputs) {
    if (!hasOwnProperty.call(inputs, inputName)) continue; // if block and shadow refer to the same block, only serialize one

    if (inputs[inputName].block === inputs[inputName].shadow) {
      // has block and shadow, and they are the same
      obj[inputName] = [INPUT_SAME_BLOCK_SHADOW, inputs[inputName].block];
    } else if (inputs[inputName].shadow === null) {
      // does not have shadow
      obj[inputName] = [INPUT_BLOCK_NO_SHADOW, inputs[inputName].block];
    } else {
      // block and shadow are both present and are different
      obj[inputName] = [INPUT_DIFF_BLOCK_SHADOW, inputs[inputName].block, inputs[inputName].shadow];
    }
  }

  return obj;
};
/**
 * Serialize the fields of a block in a more compact form.
 * @param {object} fields The fields object to serialize
 * @return {object} An object representing the serialized fields
 */


const serializeFields = function serializeFields(fields) {
  const obj = Object.create(null);

  for (const fieldName in fields) {
    if (!hasOwnProperty.call(fields, fieldName)) continue;
    obj[fieldName] = [fields[fieldName].value];

    if (fields[fieldName].hasOwnProperty('id')) {
      obj[fieldName].push(fields[fieldName].id);
    }
  }

  return obj;
};
/**
 * Serialize the given block in the SB3 format with some compression of inputs,
 * fields, and primitives.
 * @param {object} block The block to serialize
 * @return {object | array} A serialized representation of the block. This is an
 * array if the block is one of the primitive types described above or an object,
 * if not.
 */


const serializeBlock = function serializeBlock(block) {
  const serializedPrimitive = serializePrimitiveBlock(block);
  if (serializedPrimitive) return serializedPrimitive; // If serializedPrimitive is null, proceed with serializing a non-primitive block

  const obj = Object.create(null);
  obj.opcode = block.opcode; // NOTE: this is extremely important to serialize even if null;
  // not serializing `next: null` results in strange behavior with block
  // execution

  obj.next = block.next;
  obj.parent = block.parent;
  obj.inputs = serializeInputs(block.inputs);
  obj.fields = serializeFields(block.fields);
  obj.shadow = block.shadow;

  if (block.topLevel) {
    obj.topLevel = true;
    obj.x = block.x ? Math.round(block.x) : 0;
    obj.y = block.y ? Math.round(block.y) : 0;
  } else {
    obj.topLevel = false;
  }

  if (block.mutation) {
    obj.mutation = block.mutation;
  }

  if (block.comment) {
    obj.comment = block.comment;
  }

  return obj;
};
/**
 * Compresses the serialized inputs replacing block/shadow ids that refer to
 * one of the primitives with the primitive itself. E.g.
 *
 * blocks: {
 *      aUidForMyBlock: {
 *          inputs: {
 *               MYINPUT: [1, 'aUidForAnUnobscuredShadowPrimitive']
 *          }
 *      },
 *      aUidForAnUnobscuredShadowPrimitive: [4, 10]
 *      // the above is a primitive representing a 'math_number' with value 10
 * }
 *
 * becomes:
 *
 * blocks: {
 *      aUidForMyBlock: {
 *          inputs: {
 *               MYINPUT: [1, [4, 10]]
 *          }
 *      }
 * }
 * Note: this function modifies the given blocks object in place
 * @param {object} block The block with inputs to compress
 * @param {objec} blocks The object containing all the blocks currently getting serialized
 * @return {object} The serialized block with compressed inputs
 */


const compressInputTree = function compressInputTree(block, blocks) {
  // This is the second pass on the block
  // so the inputs field should be an object of key - array pairs
  const serializedInputs = block.inputs;

  for (const inputName in serializedInputs) {
    // don't need to check for hasOwnProperty because of how we constructed
    // inputs
    const currInput = serializedInputs[inputName]; // traverse currInput skipping the first element, which describes whether the block
    // and shadow are the same

    for (let i = 1; i < currInput.length; i++) {
      if (!currInput[i]) continue; // need this check b/c block/shadow can be null

      const blockOrShadowID = currInput[i]; // replace element of currInput directly
      // (modifying input block directly)

      const blockOrShadow = blocks[blockOrShadowID];

      if (Array.isArray(blockOrShadow)) {
        currInput[i] = blockOrShadow; // Modifying blocks in place!

        delete blocks[blockOrShadowID];
      }
    }
  }

  return block;
};
/**
 * Get sanitized non-core extension ID for a given sb3 opcode.
 * Note that this should never return a URL. If in the future the SB3 loader supports loading extensions by URL, this
 * ID should be used to (for example) look up the extension's full URL from a table in the SB3's JSON.
 * @param {!string} opcode The opcode to examine for extension.
 * @return {?string} The extension ID, if it exists and is not a core extension.
 */


const getExtensionIdForOpcode = function getExtensionIdForOpcode(opcode) {
  // Allowed ID characters are those matching the regular expression [\w-]: A-Z, a-z, 0-9, and hyphen ("-").
  const index = opcode.indexOf('_');
  const forbiddenSymbols = /[^\w-]/g;
  const prefix = opcode.substring(0, index).replace(forbiddenSymbols, '-');

  if (CORE_EXTENSIONS.indexOf(prefix) === -1) {
    if (prefix !== '') return prefix;
  }
};
/**
 * Serialize the given blocks object (representing all the blocks for the target
 * currently being serialized.)
 * @param {object} blocks The blocks to be serialized
 * @return {Array} An array of the serialized blocks with compressed inputs and
 * compressed primitives and the list of all extension IDs present
 * in the serialized blocks.
 */


const serializeBlocks = function serializeBlocks(blocks) {
  const obj = Object.create(null);
  const extensionIDs = new Set();

  for (const blockID in blocks) {
    if (!blocks.hasOwnProperty(blockID)) continue;
    obj[blockID] = serializeBlock(blocks[blockID], blocks);
    const extensionID = getExtensionIdForOpcode(blocks[blockID].opcode);

    if (extensionID) {
      extensionIDs.add(extensionID);
    }
  } // once we have completed a first pass, do a second pass on block inputs


  for (const blockID in obj) {
    // don't need to do the hasOwnProperty check here since we
    // created an object that doesn't get extra properties/functions
    const serializedBlock = obj[blockID]; // caution, this function deletes parts of this object in place as
    // it's traversing it

    obj[blockID] = compressInputTree(serializedBlock, obj); // second pass on connecting primitives to serialized inputs directly
  } // Do one last pass and remove any top level shadows (these are caused by
  // a bug: LLK/scratch-vm#1011, and this pass should be removed once that is
  // completely fixed)


  for (const blockID in obj) {
    const serializedBlock = obj[blockID]; // If the current block is serialized as a primitive (e.g. it's an array
    // instead of an object), AND it is not one of the top level primitives
    // e.g. variable getter or list getter, then it should be deleted as it's
    // a shadow block, and there are no blocks that reference it, otherwise
    // they would have been compressed in the last pass)

    if (Array.isArray(serializedBlock) && [VAR_PRIMITIVE, LIST_PRIMITIVE].indexOf(serializedBlock[0]) < 0) {
      log.warn("Found an unexpected top level primitive with block ID: ".concat(blockID, "; deleting it from serialized blocks."));
      delete obj[blockID];
    }
  }

  return [obj, Array.from(extensionIDs)];
};
/**
 * Serialize the given costume.
 * @param {object} costume The costume to be serialized.
 * @return {object} A serialized representation of the costume.
 */


const serializeCostume = function serializeCostume(costume) {
  const obj = Object.create(null);
  obj.name = costume.name;
  const costumeToSerialize = costume.broken || costume;
  obj.bitmapResolution = costumeToSerialize.bitmapResolution;
  obj.dataFormat = costumeToSerialize.dataFormat.toLowerCase();
  obj.assetId = costumeToSerialize.assetId; // serialize this property with the name 'md5ext' because that's
  // what it's actually referring to. TODO runtime objects need to be
  // updated to actually refer to this as 'md5ext' instead of 'md5'
  // but that change should be made carefully since it is very
  // pervasive

  obj.md5ext = costumeToSerialize.md5;
  obj.rotationCenterX = costumeToSerialize.rotationCenterX;
  obj.rotationCenterY = costumeToSerialize.rotationCenterY;
  return obj;
};
/**
 * Serialize the given sound.
 * @param {object} sound The sound to be serialized.
 * @return {object} A serialized representation of the sound.
 */


const serializeSound = function serializeSound(sound) {
  const obj = Object.create(null);
  obj.name = sound.name;
  const soundToSerialize = sound.broken || sound;
  obj.assetId = soundToSerialize.assetId;
  obj.dataFormat = soundToSerialize.dataFormat.toLowerCase();
  obj.format = soundToSerialize.format;
  obj.rate = soundToSerialize.rate;
  obj.sampleCount = soundToSerialize.sampleCount; // serialize this property with the name 'md5ext' because that's
  // what it's actually referring to. TODO runtime objects need to be
  // updated to actually refer to this as 'md5ext' instead of 'md5'
  // but that change should be made carefully since it is very
  // pervasive

  obj.md5ext = soundToSerialize.md5;
  return obj;
}; // Using some bugs, it can be possible to get values like undefined, null, or complex objects into
// variables or lists. This will cause make the project unusable after exporting without JSON editing
// as it will fail validation in scratch-parser.
// To avoid this, we'll convert those objects to strings before saving them.


const isVariableValueSafeForJSON = value => typeof value === 'number' || typeof value === 'string' || typeof value === 'boolean';

const makeSafeForJSON = value => {
  if (Array.isArray(value)) {
    let copy = null;

    for (let i = 0; i < value.length; i++) {
      if (!isVariableValueSafeForJSON(value[i])) {
        if (!copy) {
          // Only copy the list when needed
          copy = value.slice();
        }

        copy[i] = "".concat(copy[i]);
      }
    }

    if (copy) {
      return copy;
    }

    return value;
  }

  if (isVariableValueSafeForJSON(value)) {
    return value;
  }

  return "".concat(value);
};
/**
 * Serialize the given variables object.
 * @param {object} variables The variables to be serialized.
 * @return {object} A serialized representation of the variables. They get
 * separated by type to compress the representation of each given variable and
 * reduce duplicate information.
 */


const serializeVariables = function serializeVariables(variables) {
  const obj = Object.create(null); // separate out variables into types at the top level so we don't have
  // keep track of a type for each

  obj.variables = Object.create(null);
  obj.lists = Object.create(null);
  obj.broadcasts = Object.create(null);

  for (const varId in variables) {
    const v = variables[varId];

    if (v.type === Variable.BROADCAST_MESSAGE_TYPE) {
      obj.broadcasts[varId] = v.value; // name and value is the same for broadcast msgs

      continue;
    }

    if (v.type === Variable.LIST_TYPE) {
      obj.lists[varId] = [v.name, makeSafeForJSON(v.value)];
      continue;
    } // otherwise should be a scalar type


    obj.variables[varId] = [v.name, makeSafeForJSON(v.value)]; // only scalar vars have the potential to be cloud vars

    if (v.isCloud) obj.variables[varId].push(true);
  }

  return obj;
};

const serializeComments = function serializeComments(comments) {
  const obj = Object.create(null);

  for (const commentId in comments) {
    if (!comments.hasOwnProperty(commentId)) continue;
    const comment = comments[commentId];
    const serializedComment = Object.create(null);
    serializedComment.blockId = comment.blockId;
    serializedComment.x = comment.x;
    serializedComment.y = comment.y;
    serializedComment.width = comment.width;
    serializedComment.height = comment.height;
    serializedComment.minimized = comment.minimized;
    serializedComment.text = comment.text;
    obj[commentId] = serializedComment;
  }

  return obj;
};
/**
 * Serialize the given target. Only serialize properties that are necessary
 * for saving and loading this target.
 * @param {object} target The target to be serialized.
 * @param {Set} extensions A set of extensions to add extension IDs to
 * @return {object} A serialized representation of the given target.
 */


const serializeTarget = function serializeTarget(target, extensions) {
  const obj = Object.create(null);
  let targetExtensions = [];
  obj.isStage = target.isStage;
  obj.name = obj.isStage ? 'Stage' : target.name;
  const vars = serializeVariables(target.variables);
  obj.variables = vars.variables;
  obj.lists = vars.lists;
  obj.broadcasts = vars.broadcasts;
  [obj.blocks, targetExtensions] = serializeBlocks(target.blocks);
  obj.comments = serializeComments(target.comments); // TODO remove this check/patch when (#1901) is fixed

  if (target.currentCostume < 0 || target.currentCostume >= target.costumes.length) {
    log.warn("currentCostume property for target ".concat(target.name, " is out of range"));
    target.currentCostume = MathUtil.clamp(target.currentCostume, 0, target.costumes.length - 1);
  }

  obj.currentCostume = target.currentCostume;
  obj.costumes = target.costumes.map(serializeCostume);
  obj.sounds = target.sounds.map(serializeSound);
  if (target.hasOwnProperty('volume')) obj.volume = target.volume;
  if (target.hasOwnProperty('layerOrder')) obj.layerOrder = target.layerOrder;

  if (obj.isStage) {
    // Only the stage should have these properties
    if (target.hasOwnProperty('tempo')) obj.tempo = target.tempo;
    if (target.hasOwnProperty('videoTransparency')) obj.videoTransparency = target.videoTransparency;
    if (target.hasOwnProperty('videoState')) obj.videoState = target.videoState;
    if (target.hasOwnProperty('textToSpeechLanguage')) obj.textToSpeechLanguage = target.textToSpeechLanguage;
  } else {
    // The stage does not need the following properties, but sprites should
    obj.visible = target.visible;
    obj.x = target.x;
    obj.y = target.y;
    obj.size = target.size;
    obj.direction = target.direction;
    obj.draggable = target.draggable;
    obj.rotationStyle = target.rotationStyle;
  } // Add found extensions to the extensions object


  targetExtensions.forEach(extensionId => {
    extensions.add(extensionId);
  });
  return obj;
};

const getSimplifiedLayerOrdering = function getSimplifiedLayerOrdering(targets) {
  const layerOrders = targets.map(t => t.getLayerOrder());
  return MathUtil.reducedSortOrdering(layerOrders);
};

const serializeMonitors = function serializeMonitors(monitors, runtime) {
  // Monitors position is always stored as position from top-left corner in 480x360 stage.
  const xOffset = (runtime.stageWidth - 480) / 2;
  const yOffset = (runtime.stageHeight - 360) / 2;
  return monitors.valueSeq() // TW: Old versions let people enable a monitor for "last key pressed" which Scratch won't remove
  // automatically. As a temporary hack until upstream fixes this, we'll make sure to remove this
  // monitor from any serialized projects so that projects won't use the TW blocks extension
  // unnecessarily as they won't be able to load in Scratch.
  // https://github.com/LLK/scratch-vm/issues/2331
  .filter(monitorData => monitorData.id !== 'tw_getLastKeyPressed').map(monitorData => {
    const serializedMonitor = {
      id: monitorData.id,
      mode: monitorData.mode,
      opcode: monitorData.opcode,
      params: monitorData.params,
      spriteName: monitorData.spriteName,
      value: Array.isArray(monitorData.value) ? [] : 0,
      width: monitorData.width,
      height: monitorData.height,
      x: monitorData.x - xOffset,
      y: monitorData.y - yOffset,
      visible: monitorData.visible
    };

    if (monitorData.mode !== 'list') {
      serializedMonitor.sliderMin = monitorData.sliderMin;
      serializedMonitor.sliderMax = monitorData.sliderMax;
      serializedMonitor.isDiscrete = monitorData.isDiscrete;
    }

    return serializedMonitor;
  });
};
/**
 * Serializes the specified VM runtime.
 * @param {!Runtime} runtime VM runtime instance to be serialized.
 * @param {string=} targetId Optional target id if serializing only a single target
 * @return {object} Serialized runtime instance.
 */


const serialize = function serialize(runtime, targetId) {
  let {
    allowOptimization = true
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  // Fetch targets
  const obj = Object.create(null); // Create extension set to hold extension ids found while serializing targets

  const extensions = new Set();
  const originalTargetsToSerialize = targetId ? [runtime.getTargetById(targetId)] : runtime.targets.filter(target => target.isOriginal);
  const layerOrdering = getSimplifiedLayerOrdering(originalTargetsToSerialize);
  const flattenedOriginalTargets = originalTargetsToSerialize.map(t => t.toJSON()); // If the renderer is attached, and we're serializing a whole project (not a sprite)
  // add a temporary layerOrder property to each target.

  if (runtime.renderer && !targetId) {
    flattenedOriginalTargets.forEach((t, index) => {
      t.layerOrder = layerOrdering[index];
    });
  }

  const serializedTargets = flattenedOriginalTargets.map(t => serializeTarget(t, extensions));

  if (targetId) {
    return serializedTargets[0];
  }

  obj.targets = serializedTargets;
  obj.monitors = serializeMonitors(runtime.getMonitorState(), runtime); // Assemble extension list

  obj.extensions = Array.from(extensions); // Assemble metadata

  const meta = Object.create(null);
  meta.semver = '3.0.0'; // TW: There isn't a good reason to put the full version number in the json, so we don't.

  meta.vm = '0.2.0';

  if (runtime.origin) {
    meta.origin = runtime.origin;
  } // Attach full user agent string to metadata if available


  meta.agent = ''; // TW: Never include full user agent to slightly improve user privacy
  // if (typeof navigator !== 'undefined') meta.agent = navigator.userAgent;
  // Assemble payload and return

  obj.meta = meta;

  if (allowOptimization) {
    compress(obj);
  }

  return obj;
};
/**
 * Deserialize a block input descriptors. This is either a
 * block id or a serialized primitive, e.g. an array
 * (see serializePrimitiveBlock function).
 * @param {string | array} inputDescOrId The block input descriptor to be serialized.
 * @param {string} parentId The id of the parent block for this input block.
 * @param {boolean} isShadow Whether or not this input block is a shadow.
 * @param {object} blocks The entire blocks object currently in the process of getting serialized.
 * @return {object} The deserialized input descriptor.
 */


const deserializeInputDesc = function deserializeInputDesc(inputDescOrId, parentId, isShadow, blocks) {
  if (!Array.isArray(inputDescOrId)) return inputDescOrId;
  const primitiveObj = Object.create(null);
  const newId = uid();
  primitiveObj.id = newId;
  primitiveObj.next = null;
  primitiveObj.parent = parentId;
  primitiveObj.shadow = isShadow;
  primitiveObj.inputs = Object.create(null); // need a reference to parent id

  switch (inputDescOrId[0]) {
    case MATH_NUM_PRIMITIVE:
      {
        primitiveObj.opcode = 'math_number';
        primitiveObj.fields = {
          NUM: {
            name: 'NUM',
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case POSITIVE_NUM_PRIMITIVE:
      {
        primitiveObj.opcode = 'math_positive_number';
        primitiveObj.fields = {
          NUM: {
            name: 'NUM',
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case WHOLE_NUM_PRIMITIVE:
      {
        primitiveObj.opcode = 'math_whole_number';
        primitiveObj.fields = {
          NUM: {
            name: 'NUM',
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case INTEGER_NUM_PRIMITIVE:
      {
        primitiveObj.opcode = 'math_integer';
        primitiveObj.fields = {
          NUM: {
            name: 'NUM',
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case ANGLE_NUM_PRIMITIVE:
      {
        primitiveObj.opcode = 'math_angle';
        primitiveObj.fields = {
          NUM: {
            name: 'NUM',
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case COLOR_PICKER_PRIMITIVE:
      {
        primitiveObj.opcode = 'colour_picker';
        primitiveObj.fields = {
          COLOUR: {
            name: 'COLOUR',
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case TEXT_PRIMITIVE:
      {
        primitiveObj.opcode = 'text';
        primitiveObj.fields = {
          TEXT: {
            name: 'TEXT',
            value: inputDescOrId[1]
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case BROADCAST_PRIMITIVE:
      {
        primitiveObj.opcode = 'event_broadcast_menu';
        primitiveObj.fields = {
          BROADCAST_OPTION: {
            name: 'BROADCAST_OPTION',
            value: inputDescOrId[1],
            id: inputDescOrId[2],
            variableType: Variable.BROADCAST_MESSAGE_TYPE
          }
        };
        primitiveObj.topLevel = false;
        break;
      }

    case VAR_PRIMITIVE:
      {
        primitiveObj.opcode = 'data_variable';
        primitiveObj.fields = {
          VARIABLE: {
            name: 'VARIABLE',
            value: inputDescOrId[1],
            id: inputDescOrId[2],
            variableType: Variable.SCALAR_TYPE
          }
        };

        if (inputDescOrId.length > 3) {
          primitiveObj.topLevel = true;
          primitiveObj.x = inputDescOrId[3];
          primitiveObj.y = inputDescOrId[4];
        }

        break;
      }

    case LIST_PRIMITIVE:
      {
        primitiveObj.opcode = 'data_listcontents';
        primitiveObj.fields = {
          LIST: {
            name: 'LIST',
            value: inputDescOrId[1],
            id: inputDescOrId[2],
            variableType: Variable.LIST_TYPE
          }
        };

        if (inputDescOrId.length > 3) {
          primitiveObj.topLevel = true;
          primitiveObj.x = inputDescOrId[3];
          primitiveObj.y = inputDescOrId[4];
        }

        break;
      }

    default:
      {
        log.error("Found unknown primitive type during deserialization: ".concat(JSON.stringify(inputDescOrId)));
        return null;
      }
  }

  blocks[newId] = primitiveObj;
  return newId;
};
/**
 * Deserialize the given block inputs.
 * @param {object} inputs The inputs to deserialize.
 * @param {string} parentId The block id of the parent block
 * @param {object} blocks The object representing the entire set of blocks currently
 * in the process of getting deserialized.
 * @return {object} The deserialized and uncompressed inputs.
 */


const deserializeInputs = function deserializeInputs(inputs, parentId, blocks) {
  // Explicitly not using Object.create(null) here
  // because we call prototype functions later in the vm
  const obj = {};

  for (const inputName in inputs) {
    if (!hasOwnProperty.call(inputs, inputName)) continue;
    const inputDescArr = inputs[inputName]; // If this block has already been deserialized (it's not an array) skip it

    if (!Array.isArray(inputDescArr)) continue;
    let block = null;
    let shadow = null;
    const blockShadowInfo = inputDescArr[0];

    if (blockShadowInfo === INPUT_SAME_BLOCK_SHADOW) {
      // block and shadow are the same id, and only one is provided
      block = shadow = deserializeInputDesc(inputDescArr[1], parentId, true, blocks);
    } else if (blockShadowInfo === INPUT_BLOCK_NO_SHADOW) {
      block = deserializeInputDesc(inputDescArr[1], parentId, false, blocks);
    } else {
      // assume INPUT_DIFF_BLOCK_SHADOW
      block = deserializeInputDesc(inputDescArr[1], parentId, false, blocks);
      shadow = deserializeInputDesc(inputDescArr[2], parentId, true, blocks);
    }

    obj[inputName] = {
      name: inputName,
      block: block,
      shadow: shadow
    };
  }

  return obj;
};
/**
 * Deserialize the given block fields.
 * @param {object} fields The fields to be deserialized
 * @return {object} The deserialized and uncompressed block fields.
 */


const deserializeFields = function deserializeFields(fields) {
  // Explicitly not using Object.create(null) here
  // because we call prototype functions later in the vm
  const obj = {};

  for (const fieldName in fields) {
    if (!hasOwnProperty.call(fields, fieldName)) continue;
    const fieldDescArr = fields[fieldName]; // If this block has already been deserialized (it's not an array) skip it

    if (!Array.isArray(fieldDescArr)) continue;
    obj[fieldName] = {
      name: fieldName,
      value: fieldDescArr[0]
    };

    if (fieldDescArr.length > 1) {
      obj[fieldName].id = fieldDescArr[1];
    }

    if (fieldName === 'BROADCAST_OPTION') {
      obj[fieldName].variableType = Variable.BROADCAST_MESSAGE_TYPE;
    } else if (fieldName === 'VARIABLE') {
      obj[fieldName].variableType = Variable.SCALAR_TYPE;
    } else if (fieldName === 'LIST') {
      obj[fieldName].variableType = Variable.LIST_TYPE;
    }
  }

  return obj;
};
/**
 * Covnert serialized INPUT and FIELD primitives back to hydrated block templates.
 * Should be able to deserialize a format that has already been deserialized.  The only
 * "east" path to adding new targets/code requires going through deserialize, so it should
 * work with pre-parsed deserialized blocks.
 *
 * @param {object} blocks Serialized SB3 "blocks" property of a target. Will be mutated.
 * @return {object} input is modified and returned
 */


const deserializeBlocks = function deserializeBlocks(blocks) {
  for (const blockId in blocks) {
    if (!Object.prototype.hasOwnProperty.call(blocks, blockId)) {
      continue;
    }

    const block = blocks[blockId];

    if (Array.isArray(block)) {
      // this is one of the primitives
      // delete the old entry in object.blocks and replace it w/the
      // deserialized object
      delete blocks[blockId];
      deserializeInputDesc(block, null, false, blocks);
      continue;
    }

    block.id = blockId; // add id back to block since it wasn't serialized

    block.inputs = deserializeInputs(block.inputs, blockId, blocks);
    block.fields = deserializeFields(block.fields);
  }

  return blocks;
};
/**
 * Parse the assets of a single "Scratch object" and load them. This
 * preprocesses objects to support loading the data for those assets over a
 * network while the objects are further processed into Blocks, Sprites, and a
 * list of needed Extensions.
 * @param {!object} object From-JSON "Scratch object:" sprite, stage, watcher.
 * @param {!Runtime} runtime Runtime object to load all structures into.
 * @param {JSZip} zip Sb3 file describing this project (to load assets from)
 * @return {?{costumePromises:Array.<Promise>,soundPromises:Array.<Promise>,soundBank:SoundBank}}
 * Object of arrays of promises for asset objects used in Sprites. As well as a
 * SoundBank for the sound assets. null for unsupported objects.
 */


const parseScratchAssets = function parseScratchAssets(object, runtime, zip) {
  if (!object.hasOwnProperty('name')) {
    // Watcher/monitor - skip this object until those are implemented in VM.
    // @todo
    return Promise.resolve(null);
  }

  const assets = {
    costumePromises: null,
    soundPromises: null,
    soundBank: runtime.audioEngine && runtime.audioEngine.createBank()
  }; // Costumes from JSON.

  assets.costumePromises = (object.costumes || []).map(costumeSource => {
    // @todo: Make sure all the relevant metadata is being pulled out.
    const costume = {
      // costumeSource only has an asset if an image is being uploaded as
      // a sprite
      asset: costumeSource.asset,
      assetId: costumeSource.assetId,
      skinId: null,
      name: costumeSource.name,
      bitmapResolution: costumeSource.bitmapResolution,
      rotationCenterX: costumeSource.rotationCenterX,
      rotationCenterY: costumeSource.rotationCenterY
    };
    const dataFormat = costumeSource.dataFormat || costumeSource.assetType && costumeSource.assetType.runtimeFormat || // older format
    'png'; // if all else fails, guess that it might be a PNG

    const costumeMd5Ext = costumeSource.hasOwnProperty('md5ext') ? costumeSource.md5ext : "".concat(costumeSource.assetId, ".").concat(dataFormat);
    costume.md5 = costumeMd5Ext;
    costume.dataFormat = dataFormat; // deserializeCostume should be called on the costume object we're
    // creating above instead of the source costume object, because this way
    // we're always loading the 'sb3' representation of the costume
    // any translation that needs to happen will happen in the process
    // of building up the costume object into an sb3 format

    return deserializeCostume(costume, runtime, zip).then(() => loadCostume(costumeMd5Ext, costume, runtime)); // Only attempt to load the costume after the deserialization
    // process has been completed
  }); // Sounds from JSON

  assets.soundPromises = (object.sounds || []).map(soundSource => {
    const sound = {
      assetId: soundSource.assetId,
      format: soundSource.format,
      rate: soundSource.rate,
      sampleCount: soundSource.sampleCount,
      name: soundSource.name,
      // TODO we eventually want this property to be called md5ext,
      // but there are many things relying on this particular name at the
      // moment, so this translation is very important
      md5: soundSource.md5ext,
      dataFormat: soundSource.dataFormat,
      data: null
    }; // deserializeSound should be called on the sound object we're
    // creating above instead of the source sound object, because this way
    // we're always loading the 'sb3' representation of the costume
    // any translation that needs to happen will happen in the process
    // of building up the costume object into an sb3 format

    return deserializeSound(sound, runtime, zip).then(() => loadSound(sound, runtime, assets.soundBank)); // Only attempt to load the sound after the deserialization
    // process has been completed.
  });
  return assets;
};
/**
 * Parse a single "Scratch object" and create all its in-memory VM objects.
 * @param {!object} object From-JSON "Scratch object:" sprite, stage, watcher.
 * @param {!Runtime} runtime Runtime object to load all structures into.
 * @param {ImportedExtensionsInfo} extensions - (in/out) parsed extension information will be stored here.
 * @param {JSZip} zip Sb3 file describing this project (to load assets from)
 * @param {object} assets - Promises for assets of this scratch object grouped
 *   into costumes and sounds
 * @return {!Promise.<Target>} Promise for the target created (stage or sprite), or null for unsupported objects.
 */


const parseScratchObject = function parseScratchObject(object, runtime, extensions, zip, assets) {
  if (!object.hasOwnProperty('name')) {
    // Watcher/monitor - skip this object until those are implemented in VM.
    // @todo
    return Promise.resolve(null);
  } // Blocks container for this object.


  const blocks = new Blocks(runtime); // @todo: For now, load all Scratch objects (stage/sprites) as a Sprite.

  const sprite = new Sprite(blocks, runtime); // Sprite/stage name from JSON.

  if (object.hasOwnProperty('name')) {
    sprite.name = object.name;
  }

  if (object.hasOwnProperty('blocks')) {
    deserializeBlocks(object.blocks); // Take a second pass to create objects and add extensions

    for (const blockId in object.blocks) {
      if (!object.blocks.hasOwnProperty(blockId)) continue;
      const blockJSON = object.blocks[blockId];
      blocks.createBlock(blockJSON); // If the block is from an extension, record it.

      const extensionID = getExtensionIdForOpcode(blockJSON.opcode);

      if (extensionID) {
        extensions.extensionIDs.add(extensionID);
      }
    }
  } // Costumes from JSON.


  const {
    costumePromises
  } = assets; // Sounds from JSON

  const {
    soundBank,
    soundPromises
  } = assets; // Create the first clone, and load its run-state from JSON.

  const target = sprite.createClone(object.isStage ? StageLayering.BACKGROUND_LAYER : StageLayering.SPRITE_LAYER); // Load target properties from JSON.

  if (object.hasOwnProperty('tempo')) {
    target.tempo = object.tempo;
  }

  if (object.hasOwnProperty('volume')) {
    target.volume = object.volume;
  }

  if (object.hasOwnProperty('videoTransparency')) {
    target.videoTransparency = object.videoTransparency;
  }

  if (object.hasOwnProperty('videoState')) {
    target.videoState = object.videoState;
  }

  if (object.hasOwnProperty('textToSpeechLanguage')) {
    target.textToSpeechLanguage = object.textToSpeechLanguage;
  }

  if (object.hasOwnProperty('variables')) {
    for (const varId in object.variables) {
      const variable = object.variables[varId]; // A variable is a cloud variable if:
      // - the project says it's a cloud variable, and
      // - it's a stage variable, and
      // - the runtime can support another cloud variable

      const isCloud = variable.length === 3 && variable[2] && object.isStage && runtime.canAddCloudVariable();
      const newVariable = new Variable(varId, // var id is the index of the variable desc array in the variables obj
      variable[0], // name of the variable
      Variable.SCALAR_TYPE, // type of the variable
      isCloud);
      if (isCloud) runtime.addCloudVariable();
      newVariable.value = variable[1];
      target.variables[newVariable.id] = newVariable;
    }
  }

  if (object.hasOwnProperty('lists')) {
    for (const listId in object.lists) {
      const list = object.lists[listId];
      const newList = new Variable(listId, list[0], Variable.LIST_TYPE, false);
      newList.value = list[1];
      target.variables[newList.id] = newList;
    }
  }

  if (object.hasOwnProperty('broadcasts')) {
    for (const broadcastId in object.broadcasts) {
      const broadcast = object.broadcasts[broadcastId];
      const newBroadcast = new Variable(broadcastId, broadcast, Variable.BROADCAST_MESSAGE_TYPE, false); // no need to explicitly set the value, variable constructor
      // sets the value to the same as the name for broadcast msgs

      target.variables[newBroadcast.id] = newBroadcast;
    }
  }

  if (object.hasOwnProperty('comments')) {
    for (const commentId in object.comments) {
      const comment = object.comments[commentId];
      const newComment = new Comment(commentId, comment.text, comment.x, comment.y, comment.width, comment.height, comment.minimized);

      if (comment.blockId) {
        newComment.blockId = comment.blockId;
      }

      target.comments[newComment.id] = newComment;
    }
  }

  if (object.hasOwnProperty('x')) {
    target.x = object.x;
  }

  if (object.hasOwnProperty('y')) {
    target.y = object.y;
  }

  if (object.hasOwnProperty('direction')) {
    target.direction = object.direction;
  }

  if (object.hasOwnProperty('size')) {
    target.size = object.size;
  }

  if (object.hasOwnProperty('visible')) {
    target.visible = object.visible;
  }

  if (object.hasOwnProperty('currentCostume')) {
    target.currentCostume = MathUtil.clamp(object.currentCostume, 0, object.costumes.length - 1);
  }

  if (object.hasOwnProperty('rotationStyle')) {
    target.rotationStyle = object.rotationStyle;
  }

  if (object.hasOwnProperty('isStage')) {
    target.isStage = object.isStage;
  }

  if (object.hasOwnProperty('targetPaneOrder')) {
    // Temporarily store the 'targetPaneOrder' property
    // so that we can correctly order sprites in the target pane.
    // This will be deleted after we are done parsing and ordering the targets list.
    target.targetPaneOrder = object.targetPaneOrder;
  }

  if (object.hasOwnProperty('draggable')) {
    target.draggable = object.draggable;
  }

  Promise.all(costumePromises).then(costumes => {
    sprite.costumes = costumes;
  });
  Promise.all(soundPromises).then(sounds => {
    sprite.sounds = sounds; // Make sure if soundBank is undefined, sprite.soundBank is then null.

    sprite.soundBank = soundBank || null;
  });
  return Promise.all(costumePromises.concat(soundPromises)).then(() => target);
};

const deserializeMonitor = function deserializeMonitor(monitorData, runtime, targets, extensions) {
  // Monitors position is always stored as position from top-left corner in 480x360 stage.
  const xOffset = (runtime.stageWidth - 480) / 2;
  const yOffset = (runtime.stageHeight - 360) / 2;
  monitorData.x += xOffset;
  monitorData.y += yOffset;
  monitorData.x = MathUtil.clamp(monitorData.x, 0, runtime.stageWidth);
  monitorData.y = MathUtil.clamp(monitorData.y, 0, runtime.stageHeight); // If the serialized monitor has spriteName defined, look up the sprite
  // by name in the given list of targets and update the monitor's targetId
  // to match the sprite's id.

  if (monitorData.spriteName) {
    const filteredTargets = targets.filter(t => t.sprite.name === monitorData.spriteName);

    if (filteredTargets && filteredTargets.length > 0) {
      monitorData.targetId = filteredTargets[0].id;
    } else {
      log.warn("Tried to deserialize sprite specific monitor ".concat(monitorData.opcode, " but could not find sprite ").concat(monitorData.spriteName, "."));
    }
  } // Get information about this monitor, if it exists, given the monitor's opcode.
  // This will be undefined for extension blocks


  const monitorBlockInfo = runtime.monitorBlockInfo[monitorData.opcode]; // Due to a bug (see https://github.com/LLK/scratch-vm/pull/2322), renamed list monitors may have been serialized
  // with an outdated/incorrect LIST parameter. Fix it up to use the current name of the actual corresponding list.

  if (monitorData.opcode === 'data_listcontents') {
    const listTarget = monitorData.targetId ? targets.find(t => t.id === monitorData.targetId) : targets.find(t => t.isStage);

    if (listTarget && Object.prototype.hasOwnProperty.call(listTarget.variables, monitorData.id)) {
      monitorData.params.LIST = listTarget.variables[monitorData.id].name;
    }
  } // Convert the serialized monitorData params into the block fields structure


  const fields = {};

  for (const paramKey in monitorData.params) {
    const field = {
      name: paramKey,
      value: monitorData.params[paramKey]
    };
    fields[paramKey] = field;
  } // Variables, lists, and non-sprite-specific monitors, including any extension
  // monitors should already have the correct monitor ID serialized in the monitorData,
  // find the correct id for all other monitors.


  if (monitorData.opcode !== 'data_variable' && monitorData.opcode !== 'data_listcontents' && monitorBlockInfo && monitorBlockInfo.isSpriteSpecific) {
    monitorData.id = monitorBlockInfo.getId(monitorData.targetId, fields);
  } else {
    // Replace unsafe characters in monitor ID, if there are any.
    // These would have come from projects that were originally 2.0 projects
    // that had unsafe characters in the variable name (and then the name was
    // used as part of the variable ID when importing the project).
    monitorData.id = StringUtil.replaceUnsafeChars(monitorData.id);
  } // If the runtime already has a monitor block for this monitor's id,
  // update the existing block with the relevant monitor information.


  const existingMonitorBlock = runtime.monitorBlocks._blocks[monitorData.id];

  if (existingMonitorBlock) {
    // A monitor block already exists if the toolbox has been loaded and
    // the monitor block is not target specific (because the block gets recycled).
    existingMonitorBlock.isMonitored = monitorData.visible;
    existingMonitorBlock.targetId = monitorData.targetId;
  } else {
    // If a monitor block doesn't already exist for this monitor,
    // construct a monitor block to add to the monitor blocks container
    const monitorBlock = {
      id: monitorData.id,
      opcode: monitorData.opcode,
      inputs: {},
      // Assuming that monitor blocks don't have droppable fields
      fields: fields,
      topLevel: true,
      next: null,
      parent: null,
      shadow: false,
      x: 0,
      y: 0,
      isMonitored: monitorData.visible,
      targetId: monitorData.targetId
    }; // Variables and lists have additional properties
    // stored in their fields, update this info in the
    // monitor block fields

    if (monitorData.opcode === 'data_variable') {
      const field = monitorBlock.fields.VARIABLE;
      field.id = monitorData.id;
      field.variableType = Variable.SCALAR_TYPE;
    } else if (monitorData.opcode === 'data_listcontents') {
      const field = monitorBlock.fields.LIST;
      field.id = monitorData.id;
      field.variableType = Variable.LIST_TYPE;
    }

    runtime.monitorBlocks.createBlock(monitorBlock); // If the block is from an extension, record it.

    const extensionID = getExtensionIdForOpcode(monitorBlock.opcode);

    if (extensionID) {
      extensions.extensionIDs.add(extensionID);
    }
  }

  runtime.requestAddMonitor(MonitorRecord(monitorData));
}; // Replace variable IDs throughout the project with
// xml-safe versions.
// This is to fix up projects imported from 2.0 where xml-unsafe names
// were getting added to the variable ids.


const replaceUnsafeCharsInVariableIds = function replaceUnsafeCharsInVariableIds(targets) {
  const allVarRefs = VariableUtil.getAllVarRefsForTargets(targets, true); // Re-id the variables in the actual targets

  targets.forEach(t => {
    Object.keys(t.variables).forEach(id => {
      const newId = StringUtil.replaceUnsafeChars(id);
      if (newId === id) return;
      t.variables[id].id = newId;
      t.variables[newId] = t.variables[id];
      delete t.variables[id];
    });
  }); // Replace the IDs in the blocks refrencing variables or lists

  for (const id in allVarRefs) {
    const newId = StringUtil.replaceUnsafeChars(id);
    if (id === newId) continue; // ID was already safe, skip
    // We're calling this on the stage target because we need a
    // target to call on but this shouldn't matter because we're passing
    // in all the varRefs we want to operate on

    VariableUtil.updateVariableIdentifiers(allVarRefs[id], newId);
  }

  return targets;
};
/**
 * Deserialize the specified representation of a VM runtime and loads it into the provided runtime instance.
 * @param  {object} json - JSON representation of a VM runtime.
 * @param  {Runtime} runtime - Runtime instance
 * @param {JSZip} zip - Sb3 file describing this project (to load assets from)
 * @param {boolean} isSingleSprite - If true treat as single sprite, else treat as whole project
 * @returns {Promise.<ImportedProject>} Promise that resolves to the list of targets after the project is deserialized
 */


const deserialize = function deserialize(json, runtime, zip, isSingleSprite) {
  const extensions = {
    extensionIDs: new Set(),
    extensionURLs: new Map()
  }; // Store the origin field (e.g. project originated at CSFirst) so that we can save it again.

  if (json.meta && json.meta.origin) {
    runtime.origin = json.meta.origin;
  } else {
    runtime.origin = null;
  } // First keep track of the current target order in the json,
  // then sort by the layer order property before parsing the targets
  // so that their corresponding render drawables can be created in
  // their layer order (e.g. back to front)


  const targetObjects = ((isSingleSprite ? [json] : json.targets) || []).map((t, i) => Object.assign(t, {
    targetPaneOrder: i
  })).sort((a, b) => a.layerOrder - b.layerOrder);
  const monitorObjects = json.monitors || [];
  return Promise.resolve(targetObjects.map(target => parseScratchAssets(target, runtime, zip))) // Force this promise to wait for the next loop in the js tick. Let
  // storage have some time to send off asset requests.
  .then(assets => Promise.resolve(assets)).then(assets => Promise.all(targetObjects.map((target, index) => parseScratchObject(target, runtime, extensions, zip, assets[index])))).then(targets => targets // Re-sort targets back into original sprite-pane ordering
  .map((t, i) => {
    // Add layer order property to deserialized targets.
    // This property is used to initialize executable targets in
    // the correct order and is deleted in VM's installTargets function
    t.layerOrder = i;
    return t;
  }).sort((a, b) => a.targetPaneOrder - b.targetPaneOrder).map(t => {
    // Delete the temporary properties used for
    // sprite pane ordering and stage layer ordering
    delete t.targetPaneOrder;
    return t;
  })).then(targets => replaceUnsafeCharsInVariableIds(targets)).then(targets => {
    monitorObjects.map(monitorDesc => deserializeMonitor(monitorDesc, runtime, targets, extensions));
    return targets;
  }).then(targets => ({
    targets,
    extensions
  }));
};

module.exports = {
  serialize: serialize,
  deserialize: deserialize,
  deserializeBlocks: deserializeBlocks,
  serializeBlocks: serializeBlocks,
  getExtensionIdForOpcode: getExtensionIdForOpcode
};

/***/ }),

/***/ "./src/serialization/serialize-assets.js":
/*!***********************************************!*\
  !*** ./src/serialization/serialize-assets.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Serialize all the assets of the given type ('sounds' or 'costumes')
 * in the provided runtime into an array of file descriptors.
 * A file descriptor is an object containing the name of the file
 * to be written and the contents of the file, the serialized asset.
 * @param {Runtime} runtime The runtime with the assets to be serialized
 * @param {string} assetType The type of assets to be serialized: 'sounds' | 'costumes'
 * @param {string=} optTargetId Optional target id to serialize assets for
 * @returns {Array<object>} An array of file descriptors for each asset
 */
const serializeAssets = function serializeAssets(runtime, assetType, optTargetId) {
  const targets = optTargetId ? [runtime.getTargetById(optTargetId)] : runtime.targets;
  const assetDescs = [];

  for (let i = 0; i < targets.length; i++) {
    const currTarget = targets[i];
    const currAssets = currTarget.sprite[assetType];

    for (let j = 0; j < currAssets.length; j++) {
      const currAsset = currAssets[j];
      const asset = currAsset.broken ? currAsset.broken.asset : currAsset.asset;

      if (asset) {
        // Serialize asset if it exists, otherwise skip
        assetDescs.push({
          fileName: "".concat(asset.assetId, ".").concat(asset.dataFormat),
          fileContent: asset.data
        });
      }
    }
  }

  return assetDescs;
};
/**
 * Serialize all the sounds in the provided runtime or, if a target id is provided,
 * in the specified target into an array of file descriptors.
 * A file descriptor is an object containing the name of the file
 * to be written and the contents of the file, the serialized sound.
 * @param {Runtime} runtime The runtime with the sounds to be serialized
 * @param {string=} optTargetId Optional targetid for serializing sounds of a single target
 * @returns {Array<object>} An array of file descriptors for each sound
 */


const serializeSounds = function serializeSounds(runtime, optTargetId) {
  return serializeAssets(runtime, 'sounds', optTargetId);
};
/**
 * Serialize all the costumes in the provided runtime into an array of file
 * descriptors. A file descriptor is an object containing the name of the file
 * to be written and the contents of the file, the serialized costume.
 * @param {Runtime} runtime The runtime with the costumes to be serialized
 * @param {string} optTargetId Optional targetid for serializing costumes of a single target
 * @returns {Array<object>} An array of file descriptors for each costume
 */


const serializeCostumes = function serializeCostumes(runtime, optTargetId) {
  return serializeAssets(runtime, 'costumes', optTargetId);
};

module.exports = {
  serializeSounds,
  serializeCostumes
};

/***/ }),

/***/ "./src/serialization/tw-compress-sb3.js":
/*!**********************************************!*\
  !*** ./src/serialization/tw-compress-sb3.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

const SOUP = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!#%()*+,-./:;=?@[]^_`{|}~';

const generateId = i => {
  let str = '';

  while (i >= 0) {
    str = SOUP[i % SOUP.length] + str;
    i = Math.floor(i / SOUP.length) - 1;
  }

  return str;
};

class Pool {
  constructor() {
    this.generatedIds = new Map();
    this.references = new Map();
    this.skippedIds = new Set(); // IDs in Object.keys(vm.runtime.monitorBlocks._blocks) already have meaning, so make sure to skip those
    // We don't bother listing many here because most would take more than ten million items to be used

    this.skippedIds.add('of');
  }

  skip(id) {
    this.skippedIds.add(id);
  }

  addReference(id) {
    const currentCount = this.references.get(id) || 0;
    this.references.set(id, currentCount + 1);
  }

  generateNewIds() {
    const entries = Array.from(this.references.entries()); // The most used original IDs should get the shortest new IDs.

    entries.sort((a, b) => b[1] - a[1]);
    let i = 0;
    let newId;

    for (const entry of entries) {
      const oldId = entry[0];

      while (true) {
        newId = generateId(i);

        if (this.skippedIds.has(newId)) {
          i++;
        } else {
          break;
        }
      }

      this.generatedIds.set(oldId, newId);
      i++;
    }
  }

  getNewId(originalId) {
    if (this.generatedIds.has(originalId)) {
      return this.generatedIds.get(originalId);
    }

    return originalId;
  }

}

const compress = projectData => {
  // projectData is modified in-place
  // The optimization here is not optimal. This is intentional.
  // We only compress block and comment IDs because we want to maintain 100% (not 99.99%; 100%) compatibility and be
  // truly lossless. Optimizing things like variable IDs will cause things such as the editor's backpack feature
  // to misbehave.
  // We use the same variable pool for all objects to avoid any possible issues if IDs are ever treated as unique
  // within a given project.
  const pool = new Pool();

  for (const target of projectData.targets) {
    // While we don't compress these IDs, we need to make sure that our compressed IDs
    // do not intersect, which could happen if the project was compressed with a
    // different tool.
    for (const variableId of Object.keys(target.variables)) {
      pool.skip(variableId);
    }

    for (const listId of Object.keys(target.lists)) {
      pool.skip(listId);
    }

    for (const broadcastId of Object.keys(target.broadcasts)) {
      pool.skip(broadcastId);
    }

    for (const blockId of Object.keys(target.blocks)) {
      const block = target.blocks[blockId];
      pool.addReference(blockId);

      if (Array.isArray(block)) {
        // Compressed native
        continue;
      }

      if (block.parent) {
        pool.addReference(block.parent);
      }

      if (block.next) {
        pool.addReference(block.next);
      }

      if (block.comment) {
        pool.addReference(block.comment);
      }

      for (const input of Object.values(block.inputs)) {
        for (let i = 1; i < input.length; i++) {
          const inputValue = input[i];

          if (typeof inputValue === 'string') {
            pool.addReference(inputValue);
          }
        }
      }
    }

    for (const commentId of Object.keys(target.comments)) {
      const comment = target.comments[commentId];
      pool.addReference(commentId);

      if (comment.blockId) {
        pool.addReference(comment.blockId);
      }
    }
  }

  pool.generateNewIds();

  for (const target of projectData.targets) {
    const newBlocks = {};
    const newComments = {};

    for (const blockId of Object.keys(target.blocks)) {
      const block = target.blocks[blockId];
      newBlocks[pool.getNewId(blockId)] = block;

      if (Array.isArray(block)) {
        // Compressed native
        continue;
      }

      if (block.parent) {
        block.parent = pool.getNewId(block.parent);
      }

      if (block.next) {
        block.next = pool.getNewId(block.next);
      }

      if (block.comment) {
        block.comment = pool.getNewId(block.comment);
      }

      for (const input of Object.values(block.inputs)) {
        for (let i = 1; i < input.length; i++) {
          const inputValue = input[i];

          if (typeof inputValue === 'string') {
            input[i] = pool.getNewId(inputValue);
          }
        }
      }
    }

    for (const commentId of Object.keys(target.comments)) {
      const comment = target.comments[commentId];
      newComments[pool.getNewId(commentId)] = comment;

      if (comment.blockId) {
        comment.blockId = pool.getNewId(comment.blockId);
      }
    }

    target.blocks = newBlocks;
    target.comments = newComments;
  }
};

module.exports = compress;

/***/ }),

/***/ "./src/serialization/tw-costume-import-export.js":
/*!*******************************************************!*\
  !*** ./src/serialization/tw-costume-import-export.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// We want to preserve the rotation center of exported SVGs when they are later imported.
// Unfortunately, the SVG itself does not have sufficient information to accomplish this.
// Instead we must add a small amount of extra information to the end of exported SVGs
// that can be read on import.
// Adding this comment in scratch-paint is not a viable approach because the user can
// open projects not made with TurboWarp and we want costumes exported from there to
// have their center saved even if they haven't been edited.
let _TextEncoder;

let _TextDecoder;

if (typeof TextEncoder === 'undefined') {
  _TextEncoder = __webpack_require__(/*! text-encoding */ "text-encoding").TextEncoder;
  _TextDecoder = __webpack_require__(/*! text-encoding */ "text-encoding").TextDecoder;
} else {
  _TextEncoder = TextEncoder;
  _TextDecoder = TextDecoder;
} // Using literal HTML comments tokens will cause this script to be very hard to inline in
// a <script> element, so we'll instead do this terrible hack which the minifier probably
// won't be able to optimize away.


const HTML_COMMENT_START = "<!".concat('-'.repeat(2));
const HTML_COMMENT_END = "".concat('-'.repeat(2), ">");
const regex = new RegExp("".concat(HTML_COMMENT_START, "rotationCenter:(-?[\\d\\.]+):(-?[\\d\\.]+)").concat(HTML_COMMENT_END, "$"));
/**
 * @param {string} svgString SVG source
 * @returns {[number, number]|null} The detected rotation center of the SVG, if any.
 */

const parseVectorMetadata = svgString => {
  // TODO: see if this is slow on large strings
  const match = svgString.match(regex);

  if (!match) {
    return null;
  }

  const detectedX = +match[1];
  const detectedY = +match[2];

  if (Number.isNaN(detectedX) || Number.isNaN(detectedY)) {
    return null;
  }

  return [detectedX, detectedY];
};
/**
 * @param {Costume} costume scratch-vm costume object
 * @returns {Uint8Array} Binary data to export
 */


const exportCostume = costume => {
  /** @type {Uint8Array} */
  const originalData = costume.asset.data;

  if (costume.dataFormat !== 'svg') {
    return originalData;
  }

  let decodedData = new _TextDecoder().decode(originalData); // It's okay that the regex isn't global because it can only match one item anyways.

  decodedData = decodedData.replace(regex, '');
  const centerX = costume.rotationCenterX;
  const centerY = costume.rotationCenterY;
  const extraData = "".concat(HTML_COMMENT_START, "rotationCenter:").concat(centerX, ":").concat(centerY).concat(HTML_COMMENT_END);
  decodedData += extraData;
  return new _TextEncoder().encode(decodedData);
};

module.exports = {
  parseVectorMetadata,
  exportCostume
};

/***/ }),

/***/ "./src/sprites/rendered-target.js":
/*!****************************************!*\
  !*** ./src/sprites/rendered-target.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const MathUtil = __webpack_require__(/*! ../util/math-util */ "./src/util/math-util.js");

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");

const Cast = __webpack_require__(/*! ../util/cast */ "./src/util/cast.js");

const Clone = __webpack_require__(/*! ../util/clone */ "./src/util/clone.js");

const Target = __webpack_require__(/*! ../engine/target */ "./src/engine/target.js");

const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");
/**
 * Rendered target: instance of a sprite (clone), or the stage.
 */


class RenderedTarget extends Target {
  /**
   * @param {!Sprite} sprite Reference to the parent sprite.
   * @param {Runtime} runtime Reference to the runtime.
   * @constructor
   */
  constructor(sprite, runtime) {
    super(runtime, sprite.blocks);
    /**
     * Reference to the sprite that this is a render of.
     * @type {!Sprite}
     */

    this.sprite = sprite;
    /**
     * Reference to the global renderer for this VM, if one exists.
     * @type {?RenderWebGL}
     */

    this.renderer = null;

    if (this.runtime) {
      this.renderer = this.runtime.renderer;
    }
    /**
     * ID of the drawable for this rendered target,
     * returned by the renderer, if rendered.
     * @type {?Number}
     */


    this.drawableID = null;
    /**
     * Drag state of this rendered target. If true, x/y position can't be
     * changed by blocks.
     * @type {boolean}
     */

    this.dragging = false;
    /**
     * Map of current graphic effect values.
     * @type {!Object.<string, number>}
     */

    this.effects = {
      color: 0,
      fisheye: 0,
      whirl: 0,
      pixelate: 0,
      mosaic: 0,
      brightness: 0,
      ghost: 0
    };
    /**
     * Whether this represents an "original" non-clone rendered-target for a sprite,
     * i.e., created by the editor and not clone blocks.
     * @type {boolean}
     */

    this.isOriginal = true;
    /**
     * Whether this rendered target represents the Scratch stage.
     * @type {boolean}
     */

    this.isStage = false;
    /**
     * Scratch X coordinate. Currently should range from -240 to 240.
     * @type {Number}
     */

    this.x = 0;
    /**
     * Scratch Y coordinate. Currently should range from -180 to 180.
     * @type {number}
     */

    this.y = 0;
    /**
     * Scratch direction. Currently should range from -179 to 180.
     * @type {number}
     */

    this.direction = 90;
    /**
     * Whether the rendered target is draggable on the stage
     * @type {boolean}
     */

    this.draggable = false;
    /**
     * Whether the rendered target is currently visible.
     * @type {boolean}
     */

    this.visible = true;
    /**
     * Size of rendered target as a percent of costume size.
     * @type {number}
     */

    this.size = 100;
    /**
     * Currently selected costume index.
     * @type {number}
     */

    this.currentCostume = 0;
    /**
     * Current rotation style.
     * @type {!string}
     */

    this.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;
    /**
     * Loudness for sound playback for this target, as a percentage.
     * @type {number}
     */

    this.volume = 100;
    /**
     * Current tempo (used by the music extension).
     * This property is global to the project and stored in the stage.
     * @type {number}
     */

    this.tempo = 60;
    /**
     * The transparency of the video (used by extensions with camera input).
     * This property is global to the project and stored in the stage.
     * @type {number}
     */

    this.videoTransparency = 50;
    /**
     * The state of the video input (used by extensions with camera input).
     * This property is global to the project and stored in the stage.
     *
     * Defaults to ON. This setting does not turn the video by itself. A
     * video extension once loaded will set the video device to this
     * setting. Set to ON when a video extension is added in the editor the
     * video will start ON. If the extension is loaded as part of loading a
     * saved project the extension will see the value set when the stage
     * was loaded from the saved values including the video state.
     *
     * @type {string}
     */

    this.videoState = RenderedTarget.VIDEO_STATE.ON;
    /**
     * The language to use for speech synthesis, in the text2speech extension.
     * It is initialized to null so that on extension load, we can check for
     * this and try setting it using the editor locale.
     * @type {string}
     */

    this.textToSpeechLanguage = null; // Node-style event emitters have non-zero performance overhead compared to function calls, so we
    // replace some very high frequency events with these specific methods that are overridden elsewhere.

    this.onTargetMoved = null;
    this.onTargetVisualChange = null;
    this.interpolationData = null;
  }
  /**
   * Create a drawable with the this.renderer.
   * @param {boolean} layerGroup The layer group this drawable should be added to
   */


  initDrawable(layerGroup) {
    if (this.renderer) {
      this.drawableID = this.renderer.createDrawable(layerGroup);
    } // If we're a clone, start the hats.


    if (!this.isOriginal) {
      this.runtime.startHats('control_start_as_clone', null, this);
    }
  }

  get audioPlayer() {
    /* eslint-disable no-console */
    console.warn('get audioPlayer deprecated, please update to use .sprite.soundBank methods');
    console.warn(new Error('stack for debug').stack);
    /* eslint-enable no-console */

    const bank = this.sprite.soundBank;
    const audioPlayerProxy = {
      playSound: soundId => bank.play(this, soundId)
    };
    Object.defineProperty(this, 'audioPlayer', {
      configurable: false,
      enumerable: true,
      writable: false,
      value: audioPlayerProxy
    });
    return audioPlayerProxy;
  }
  /**
   * Initialize the audio player for this sprite or clone.
   */


  initAudio() {}
  /**
   * Rotation style for "all around"/spinning.
   * @type {string}
   */


  static get ROTATION_STYLE_ALL_AROUND() {
    return 'all around';
  }
  /**
   * Rotation style for "left-right"/flipping.
   * @type {string}
   */


  static get ROTATION_STYLE_LEFT_RIGHT() {
    return 'left-right';
  }
  /**
   * Rotation style for "no rotation."
   * @type {string}
   */


  static get ROTATION_STYLE_NONE() {
    return "don't rotate";
  }
  /**
   * Available states for video input.
   * @enum {string}
   */


  static get VIDEO_STATE() {
    return {
      OFF: 'off',
      ON: 'on',
      ON_FLIPPED: 'on-flipped'
    };
  }

  emitVisualChange() {
    if (this.onTargetVisualChange) {
      this.onTargetVisualChange(this);
    }
  }
  /**
   * Set the X and Y coordinates.
   * @param {!number} x New X coordinate, in Scratch coordinates.
   * @param {!number} y New Y coordinate, in Scratch coordinates.
   * @param {?boolean} force Force setting X/Y, in case of dragging
   */


  setXY(x, y, force) {
    // used by compiler
    if (this.isStage) return;
    if (this.dragging && !force) return;
    const oldX = this.x;
    const oldY = this.y;

    if (this.renderer) {
      const position = this.runtime.runtimeOptions.fencing ? this.renderer.getFencedPositionOfDrawable(this.drawableID, [x, y]) : [x, y];
      this.x = position[0];
      this.y = position[1];
      this.renderer.updateDrawablePosition(this.drawableID, position);

      if (this.visible) {
        this.emitVisualChange();
        this.runtime.requestRedraw();
      }
    } else {
      this.x = x;
      this.y = y;
    }

    if (this.onTargetMoved) {
      this.onTargetMoved(this, oldX, oldY, force);
    }

    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * Get the rendered direction and scale, after applying rotation style.
   * @return {object<string, number>} Direction and scale to render.
   */


  _getRenderedDirectionAndScale() {
    // Default: no changes to `this.direction` or `this.scale`.
    let finalDirection = this.direction;
    let finalScale = [this.size, this.size];

    if (this.rotationStyle === RenderedTarget.ROTATION_STYLE_NONE) {
      // Force rendered direction to be 90.
      finalDirection = 90;
    } else if (this.rotationStyle === RenderedTarget.ROTATION_STYLE_LEFT_RIGHT) {
      // Force rendered direction to be 90, and flip drawable if needed.
      finalDirection = 90;
      const scaleFlip = this.direction < 0 ? -1 : 1;
      finalScale = [scaleFlip * this.size, this.size];
    }

    return {
      direction: finalDirection,
      scale: finalScale
    };
  }
  /**
   * Set the direction.
   * @param {!number} direction New direction.
   */


  setDirection(direction) {
    // used by compiler
    if (this.isStage) {
      return;
    }

    if (!isFinite(direction)) {
      return;
    } // Keep direction between -179 and +180.


    this.direction = MathUtil.wrapClamp(direction, -179, 180);

    if (this.renderer) {
      const {
        direction: renderedDirection,
        scale
      } = this._getRenderedDirectionAndScale();

      this.renderer.updateDrawableDirectionScale(this.drawableID, renderedDirection, scale);

      if (this.visible) {
        this.emitVisualChange();
        this.runtime.requestRedraw();
      }
    }

    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * Set draggability; i.e., whether it's able to be dragged in the player
   * @param {!boolean} draggable True if should be draggable.
   */


  setDraggable(draggable) {
    if (this.isStage) return;
    this.draggable = !!draggable;
    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * Set visibility; i.e., whether it's shown or hidden.
   * @param {!boolean} visible True if should be shown.
   */


  setVisible(visible) {
    // used by compiler
    if (this.isStage) {
      return;
    }

    this.visible = !!visible;

    if (this.renderer) {
      this.renderer.updateDrawableVisible(this.drawableID, this.visible);

      if (this.visible) {
        this.emitVisualChange();
        this.runtime.requestRedraw();
      }
    }

    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * Set size, as a percentage of the costume size.
   * @param {!number} size Size of rendered target, as % of costume size.
   */


  setSize(size) {
    // used by compiler
    if (this.isStage) {
      return;
    }

    if (this.renderer) {
      // Clamp to scales relative to costume and stage size.
      // See original ScratchSprite.as:setSize.
      const costumeSize = this.renderer.getCurrentSkinSize(this.drawableID);
      const origW = costumeSize[0];
      const origH = costumeSize[1];
      const fencing = this.runtime.runtimeOptions.fencing;
      const minScale = fencing ? Math.min(1, Math.max(5 / origW, 5 / origH)) : 0;
      const maxScale = fencing ? Math.min(1.5 * this.runtime.stageWidth / origW, 1.5 * this.runtime.stageHeight / origH) : Infinity;
      this.size = MathUtil.clamp(size / 100, minScale, maxScale) * 100;

      const {
        direction,
        scale
      } = this._getRenderedDirectionAndScale();

      this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);

      if (this.visible) {
        this.emitVisualChange();
        this.runtime.requestRedraw();
      }
    } else {
      // tw: setSize should update size even without a renderer
      // needed by tw-change-size-does-not-use-rounded-size.sb3 test
      this.size = size;
    }

    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * Set a particular graphic effect value.
   * @param {!string} effectName Name of effect (see `RenderedTarget.prototype.effects`).
   * @param {!number} value Numerical magnitude of effect.
   */


  setEffect(effectName, value) {
    // used by compiler
    if (!this.effects.hasOwnProperty(effectName)) return;
    this.effects[effectName] = value;

    if (this.renderer) {
      this.renderer.updateDrawableEffect(this.drawableID, effectName, value);

      if (this.visible) {
        this.emitVisualChange();
        this.runtime.requestRedraw();
      }
    }
  }
  /**
   * Clear all graphic effects on this rendered target.
   */


  clearEffects() {
    // used by compiler
    for (const effectName in this.effects) {
      if (!this.effects.hasOwnProperty(effectName)) continue;
      this.effects[effectName] = 0;
    }

    if (this.renderer) {
      for (const effectName in this.effects) {
        if (!this.effects.hasOwnProperty(effectName)) continue;
        this.renderer.updateDrawableEffect(this.drawableID, effectName, 0);
      }

      if (this.visible) {
        this.emitVisualChange();
        this.runtime.requestRedraw();
      }
    }
  }
  /**
   * Set the current costume.
   * @param {number} index New index of costume.
   */


  setCostume(index) {
    // Keep the costume index within possible values.
    index = Math.round(index);

    if (index === Infinity || index === -Infinity || !index) {
      index = 0;
    }

    this.currentCostume = MathUtil.wrapClamp(index, 0, this.sprite.costumes.length - 1);

    if (this.renderer) {
      const costume = this.sprite.costumes[this.currentCostume];
      this.renderer.updateDrawableSkinId(this.drawableID, costume.skinId);

      if (this.visible) {
        this.emitVisualChange();
        this.runtime.requestRedraw();
      }
    }

    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * Add a costume, taking care to avoid duplicate names.
   * @param {!object} costumeObject Object representing the costume.
   * @param {?int} index Index at which to add costume
   */


  addCostume(costumeObject, index) {
    if (typeof index === 'number' && !isNaN(index)) {
      this.sprite.addCostumeAt(costumeObject, index);
    } else {
      this.sprite.addCostumeAt(costumeObject, this.sprite.costumes.length);
    }
  }
  /**
   * Rename a costume, taking care to avoid duplicate names.
   * @param {int} costumeIndex - the index of the costume to be renamed.
   * @param {string} newName - the desired new name of the costume (will be modified if already in use).
   */


  renameCostume(costumeIndex, newName) {
    const usedNames = this.sprite.costumes.filter((costume, index) => costumeIndex !== index).map(costume => costume.name);
    const oldName = this.getCostumes()[costumeIndex].name;
    const newUnusedName = StringUtil.unusedName(newName, usedNames);
    this.getCostumes()[costumeIndex].name = newUnusedName;

    if (this.isStage) {
      // Since this is a backdrop, go through all targets and
      // update any blocks referencing the old backdrop name
      const targets = this.runtime.targets;

      for (let i = 0; i < targets.length; i++) {
        const currTarget = targets[i];
        currTarget.blocks.updateAssetName(oldName, newUnusedName, 'backdrop');
      }
    } else {
      this.blocks.updateAssetName(oldName, newUnusedName, 'costume');
    }
  }
  /**
   * Delete a costume by index.
   * @param {number} index Costume index to be deleted
   * @return {?object} The costume that was deleted or null
   * if the index was out of bounds of the costumes list or
   * this target only has one costume.
   */


  deleteCostume(index) {
    const originalCostumeCount = this.sprite.costumes.length;
    if (originalCostumeCount === 1) return null;

    if (index < 0 || index >= originalCostumeCount) {
      return null;
    }

    const deletedCostume = this.sprite.deleteCostumeAt(index);

    if (index === this.currentCostume && index === originalCostumeCount - 1) {
      this.setCostume(index - 1);
    } else if (index < this.currentCostume) {
      this.setCostume(this.currentCostume - 1);
    } else {
      this.setCostume(this.currentCostume);
    }

    this.runtime.requestTargetsUpdate(this);
    return deletedCostume;
  }
  /**
   * Add a sound, taking care to avoid duplicate names.
   * @param {!object} soundObject Object representing the sound.
   * @param {?int} index Index at which to add costume
   */


  addSound(soundObject, index) {
    const usedNames = this.sprite.sounds.map(sound => sound.name);
    soundObject.name = StringUtil.unusedName(soundObject.name, usedNames);

    if (typeof index === 'number' && !isNaN(index)) {
      this.sprite.sounds.splice(index, 0, soundObject);
    } else {
      this.sprite.sounds.push(soundObject);
    }
  }
  /**
   * Rename a sound, taking care to avoid duplicate names.
   * @param {int} soundIndex - the index of the sound to be renamed.
   * @param {string} newName - the desired new name of the sound (will be modified if already in use).
   */


  renameSound(soundIndex, newName) {
    const usedNames = this.sprite.sounds.filter((sound, index) => soundIndex !== index).map(sound => sound.name);
    const oldName = this.sprite.sounds[soundIndex].name;
    const newUnusedName = StringUtil.unusedName(newName, usedNames);
    this.sprite.sounds[soundIndex].name = newUnusedName;
    this.blocks.updateAssetName(oldName, newUnusedName, 'sound');
  }
  /**
   * Delete a sound by index.
   * @param {number} index Sound index to be deleted
   * @return {object} The deleted sound object, or null if no sound was deleted.
   */


  deleteSound(index) {
    // Make sure the sound index is not out of bounds
    if (index < 0 || index >= this.sprite.sounds.length) {
      return null;
    } // Delete the sound at the given index


    const deletedSound = this.sprite.sounds.splice(index, 1)[0];
    this.runtime.requestTargetsUpdate(this);
    return deletedSound;
  }
  /**
   * Update the rotation style.
   * @param {!string} rotationStyle New rotation style.
   */


  setRotationStyle(rotationStyle) {
    // used by compiler
    if (rotationStyle === RenderedTarget.ROTATION_STYLE_NONE) {
      this.rotationStyle = RenderedTarget.ROTATION_STYLE_NONE;
    } else if (rotationStyle === RenderedTarget.ROTATION_STYLE_ALL_AROUND) {
      this.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;
    } else if (rotationStyle === RenderedTarget.ROTATION_STYLE_LEFT_RIGHT) {
      this.rotationStyle = RenderedTarget.ROTATION_STYLE_LEFT_RIGHT;
    }

    if (this.renderer) {
      const {
        direction,
        scale
      } = this._getRenderedDirectionAndScale();

      this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);

      if (this.visible) {
        this.emitVisualChange();
        this.runtime.requestRedraw();
      }
    }

    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * Get a costume index of this rendered target, by name of the costume.
   * @param {?string} costumeName Name of a costume.
   * @return {number} Index of the named costume, or -1 if not present.
   */


  getCostumeIndexByName(costumeName) {
    const costumes = this.getCostumes();

    for (let i = 0; i < costumes.length; i++) {
      if (costumes[i].name === costumeName) {
        return i;
      }
    }

    return -1;
  }
  /**
   * Get a costume of this rendered target by id.
   * @return {object} current costume
   */


  getCurrentCostume() {
    return this.getCostumes()[this.currentCostume];
  }
  /**
   * Get full costume list
   * @return {object[]} list of costumes
   */


  getCostumes() {
    // used by compiler
    return this.sprite.costumes;
  }
  /**
   * Reorder costume list by moving costume at costumeIndex to newIndex.
   * @param {!number} costumeIndex Index of the costume to move.
   * @param {!number} newIndex New index for that costume.
   * @returns {boolean} If a change occurred (i.e. if the indices do not match)
   */


  reorderCostume(costumeIndex, newIndex) {
    newIndex = MathUtil.clamp(newIndex, 0, this.sprite.costumes.length - 1);
    costumeIndex = MathUtil.clamp(costumeIndex, 0, this.sprite.costumes.length - 1);
    if (newIndex === costumeIndex) return false;
    const currentCostume = this.getCurrentCostume();
    const costume = this.sprite.costumes[costumeIndex]; // Use the sprite method for deleting costumes because setCostume is handled manually

    this.sprite.deleteCostumeAt(costumeIndex);
    this.addCostume(costume, newIndex);
    this.currentCostume = this.getCostumeIndexByName(currentCostume.name);
    return true;
  }
  /**
   * Reorder sound list by moving sound at soundIndex to newIndex.
   * @param {!number} soundIndex Index of the sound to move.
   * @param {!number} newIndex New index for that sound.
   * @returns {boolean} If a change occurred (i.e. if the indices do not match)
   */


  reorderSound(soundIndex, newIndex) {
    newIndex = MathUtil.clamp(newIndex, 0, this.sprite.sounds.length - 1);
    soundIndex = MathUtil.clamp(soundIndex, 0, this.sprite.sounds.length - 1);
    if (newIndex === soundIndex) return false;
    const sound = this.sprite.sounds[soundIndex];
    this.deleteSound(soundIndex);
    this.addSound(sound, newIndex);
    return true;
  }
  /**
   * Get full sound list
   * @return {object[]} list of sounds
   */


  getSounds() {
    return this.sprite.sounds;
  }
  /**
   * Update all drawable properties for this rendered target.
   * Use when a batch has changed, e.g., when the drawable is first created.
   */


  updateAllDrawableProperties() {
    if (this.renderer) {
      const {
        direction,
        scale
      } = this._getRenderedDirectionAndScale();

      this.renderer.updateDrawablePosition(this.drawableID, [this.x, this.y]);
      this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);
      this.renderer.updateDrawableVisible(this.drawableID, this.visible);
      const costume = this.getCostumes()[this.currentCostume];
      this.renderer.updateDrawableSkinId(this.drawableID, costume.skinId);

      for (const effectName in this.effects) {
        if (!this.effects.hasOwnProperty(effectName)) continue;
        this.renderer.updateDrawableEffect(this.drawableID, effectName, this.effects[effectName]);
      }

      if (this.visible) {
        this.emitVisualChange();
        this.runtime.requestRedraw();
      }
    }

    this.runtime.requestTargetsUpdate(this);
  }
  /**
   * Return the human-readable name for this rendered target, e.g., the sprite's name.
   * @override
   * @returns {string} Human-readable name.
   */


  getName() {
    return this.sprite.name;
  }
  /**
   * Return whether this rendered target is a sprite (not a clone, not the stage).
   * @return {boolean} True if not a clone and not the stage.
   */


  isSprite() {
    return !this.isStage && this.isOriginal;
  }
  /**
   * Return the rendered target's tight bounding box.
   * Includes top, left, bottom, right attributes in Scratch coordinates.
   * @return {?object} Tight bounding box, or null.
   */


  getBounds() {
    if (this.renderer) {
      return this.runtime.renderer.getBounds(this.drawableID);
    }

    return null;
  }
  /**
   * Return the bounding box around a slice of the top 8px of the rendered target.
   * Includes top, left, bottom, right attributes in Scratch coordinates.
   * @return {?object} Tight bounding box, or null.
   */


  getBoundsForBubble() {
    if (this.renderer) {
      return this.runtime.renderer.getBoundsForBubble(this.drawableID);
    }

    return null;
  }
  /**
   * Return whether this target is touching the mouse, an edge, or a sprite.
   * @param {string} requestedObject an id for mouse or edge, or a sprite name.
   * @return {boolean} True if the sprite is touching the object.
   */


  isTouchingObject(requestedObject) {
    // used by compiler
    if (requestedObject === '_mouse_') {
      if (!this.runtime.ioDevices.mouse) return false;
      const mouseX = this.runtime.ioDevices.mouse.getClientX();
      const mouseY = this.runtime.ioDevices.mouse.getClientY();
      return this.isTouchingPoint(mouseX, mouseY);
    } else if (requestedObject === '_edge_') {
      return this.isTouchingEdge();
    }

    return this.isTouchingSprite(requestedObject);
  }
  /**
   * Return whether touching a point.
   * @param {number} x X coordinate of test point.
   * @param {number} y Y coordinate of test point.
   * @return {boolean} True iff the rendered target is touching the point.
   */


  isTouchingPoint(x, y) {
    if (this.renderer) {
      return this.renderer.drawableTouching(this.drawableID, x, y);
    }

    return false;
  }
  /**
   * Return whether touching a stage edge.
   * @return {boolean} True iff the rendered target is touching the stage edge.
   */


  isTouchingEdge() {
    if (this.renderer) {
      const stageWidth = this.runtime.stageWidth;
      const stageHeight = this.runtime.stageHeight;
      const bounds = this.getBounds();

      if (bounds.left < -stageWidth / 2 || bounds.right > stageWidth / 2 || bounds.top > stageHeight / 2 || bounds.bottom < -stageHeight / 2) {
        return true;
      }
    }

    return false;
  }
  /**
   * Return whether touching any of a named sprite's clones.
   * @param {string} spriteName Name of the sprite.
   * @return {boolean} True iff touching a clone of the sprite.
   */


  isTouchingSprite(spriteName) {
    spriteName = Cast.toString(spriteName);
    const firstClone = this.runtime.getSpriteTargetByName(spriteName);

    if (!firstClone || !this.renderer) {
      return false;
    } // Filter out dragging targets. This means a sprite that is being dragged
    // can detect other sprites using touching <sprite>, but cannot be detected
    // by other sprites while it is being dragged. This matches Scratch 2.0 behavior.


    const drawableCandidates = firstClone.sprite.clones.filter(clone => !clone.dragging).map(clone => clone.drawableID);
    return this.renderer.isTouchingDrawables(this.drawableID, drawableCandidates);
  }
  /**
   * Return whether touching a color.
   * @param {Array.<number>} rgb [r,g,b], values between 0-255.
   * @return {Promise.<boolean>} True iff the rendered target is touching the color.
   */


  isTouchingColor(rgb) {
    // used by compiler
    if (this.renderer) {
      return this.renderer.isTouchingColor(this.drawableID, rgb);
    }

    return false;
  }
  /**
   * Return whether rendered target's color is touching a color.
   * @param {object} targetRgb {Array.<number>} [r,g,b], values between 0-255.
   * @param {object} maskRgb {Array.<number>} [r,g,b], values between 0-255.
   * @return {Promise.<boolean>} True iff the color is touching the color.
   */


  colorIsTouchingColor(targetRgb, maskRgb) {
    // used by compiler
    if (this.renderer) {
      return this.renderer.isTouchingColor(this.drawableID, targetRgb, maskRgb);
    }

    return false;
  }

  getLayerOrder() {
    if (this.renderer) {
      return this.renderer.getDrawableOrder(this.drawableID);
    }

    return null;
  }
  /**
   * Move to the front layer.
   */


  goToFront() {
    // This should only ever be used for sprites // used by compiler
    if (this.renderer) {
      // Let the renderer re-order the sprite based on its knowledge
      // of what layers are present
      this.renderer.setDrawableOrder(this.drawableID, Infinity, StageLayering.SPRITE_LAYER);
    }

    this.runtime.setExecutablePosition(this, Infinity);
  }
  /**
   * Move to the back layer.
   */


  goToBack() {
    // This should only ever be used for sprites // used by compiler
    if (this.renderer) {
      // Let the renderer re-order the sprite based on its knowledge
      // of what layers are present
      this.renderer.setDrawableOrder(this.drawableID, -Infinity, StageLayering.SPRITE_LAYER, false);
    }

    this.runtime.setExecutablePosition(this, -Infinity);
  }
  /**
   * Move forward a number of layers.
   * @param {number} nLayers How many layers to go forward.
   */


  goForwardLayers(nLayers) {
    // used by compiler
    if (this.renderer) {
      this.renderer.setDrawableOrder(this.drawableID, nLayers, StageLayering.SPRITE_LAYER, true);
    }

    this.runtime.moveExecutable(this, nLayers);
  }
  /**
   * Move backward a number of layers.
   * @param {number} nLayers How many layers to go backward.
   */


  goBackwardLayers(nLayers) {
    // used by compiler
    if (this.renderer) {
      this.renderer.setDrawableOrder(this.drawableID, -nLayers, StageLayering.SPRITE_LAYER, true);
    }

    this.runtime.moveExecutable(this, -nLayers);
  }
  /**
   * Move behind some other rendered target.
   * @param {!RenderedTarget} other Other rendered target to move behind.
   */


  goBehindOther(other) {
    if (this.renderer) {
      const otherLayer = this.renderer.setDrawableOrder(other.drawableID, 0, StageLayering.SPRITE_LAYER, true);
      this.renderer.setDrawableOrder(this.drawableID, otherLayer, StageLayering.SPRITE_LAYER);
    }

    const executionPosition = this.runtime.executableTargets.indexOf(other);
    this.runtime.setExecutablePosition(this, executionPosition);
  }
  /**
   * Keep a desired position within a fence.
   * @param {number} newX New desired X position.
   * @param {number} newY New desired Y position.
   * @param {object=} optFence Optional fence with left, right, top bottom.
   * @return {Array.<number>} Fenced X and Y coordinates.
   */


  keepInFence(newX, newY, optFence) {
    let fence = optFence;

    if (!fence) {
      fence = {
        left: -this.runtime.stageWidth / 2,
        right: this.runtime.stageWidth / 2,
        top: this.runtime.stageHeight / 2,
        bottom: -this.runtime.stageHeight / 2
      };
    }

    const bounds = this.getBounds();
    if (!bounds) return; // Adjust the known bounds to the target position.

    bounds.left += newX - this.x;
    bounds.right += newX - this.x;
    bounds.top += newY - this.y;
    bounds.bottom += newY - this.y; // Find how far we need to move the target position.

    let dx = 0;
    let dy = 0;

    if (bounds.left < fence.left) {
      dx += fence.left - bounds.left;
    }

    if (bounds.right > fence.right) {
      dx += fence.right - bounds.right;
    }

    if (bounds.top > fence.top) {
      dy += fence.top - bounds.top;
    }

    if (bounds.bottom < fence.bottom) {
      dy += fence.bottom - bounds.bottom;
    }

    return [newX + dx, newY + dy];
  }
  /**
   * Make a clone, copying any run-time properties.
   * If we've hit the global clone limit, returns null.
   * @return {RenderedTarget} New clone.
   */


  makeClone() {
    if (!this.runtime.clonesAvailable() || this.isStage) {
      return null; // Hit max clone limit, or this is the stage.
    }

    this.runtime.changeCloneCounter(1);
    const newClone = this.sprite.createClone(); // Copy all properties.

    newClone.x = this.x;
    newClone.y = this.y;
    newClone.direction = this.direction;
    newClone.draggable = this.draggable;
    newClone.visible = this.visible;
    newClone.size = this.size;
    newClone.currentCostume = this.currentCostume;
    newClone.rotationStyle = this.rotationStyle;
    newClone.effects = Clone.simple(this.effects);
    newClone.variables = this.duplicateVariables();
    newClone._edgeActivatedHatValues = Clone.simple(this._edgeActivatedHatValues);
    newClone.initDrawable(StageLayering.SPRITE_LAYER);
    newClone.updateAllDrawableProperties();
    return newClone;
  }
  /**
   * Make a duplicate using a duplicate sprite.
   * @return {RenderedTarget} New clone.
   */


  duplicate() {
    return this.sprite.duplicate().then(newSprite => {
      const newTarget = newSprite.createClone(); // Copy all properties.
      // @todo refactor with clone methods

      newTarget.x = (Math.random() - 0.5) * 400 / 2;
      newTarget.y = (Math.random() - 0.5) * 300 / 2;
      newTarget.direction = this.direction;
      newTarget.draggable = this.draggable;
      newTarget.visible = this.visible;
      newTarget.size = this.size;
      newTarget.currentCostume = this.currentCostume;
      newTarget.rotationStyle = this.rotationStyle;
      newTarget.effects = JSON.parse(JSON.stringify(this.effects));
      newTarget.variables = this.duplicateVariables(newTarget.blocks);
      newTarget.updateAllDrawableProperties();
      return newTarget;
    });
  }
  /**
   * Called when the project receives a "green flag."
   * For a rendered target, this clears graphic effects.
   */


  onGreenFlag() {
    this.clearEffects();
  }
  /**
   * Called when the project receives a "stop all"
   * Stop all sounds and clear graphic effects.
   */


  onStopAll() {
    this.clearEffects();
  }
  /**
   * Post/edit sprite info.
   * @param {object} data An object with sprite info data to set.
   */


  postSpriteInfo(data) {
    const force = data.hasOwnProperty('force') ? data.force : null;
    const isXChanged = data.hasOwnProperty('x');
    const isYChanged = data.hasOwnProperty('y');

    if (isXChanged || isYChanged) {
      this.setXY(isXChanged ? data.x : this.x, isYChanged ? data.y : this.y, force);
    }

    if (data.hasOwnProperty('direction')) {
      this.setDirection(data.direction);
    }

    if (data.hasOwnProperty('draggable')) {
      this.setDraggable(data.draggable);
    }

    if (data.hasOwnProperty('rotationStyle')) {
      this.setRotationStyle(data.rotationStyle);
    }

    if (data.hasOwnProperty('visible')) {
      this.setVisible(data.visible);
    }

    if (data.hasOwnProperty('size')) {
      this.setSize(data.size);
    }
  }
  /**
   * Put the sprite into the drag state. While in effect, setXY must be forced
   */


  startDrag() {
    this.dragging = true;
  }
  /**
   * Remove the sprite from the drag state.
   */


  stopDrag() {
    this.dragging = false;
  }
  /**
   * Serialize sprite info, used when emitting events about the sprite
   * @returns {object} Sprite data as a simple object
   */


  toJSON() {
    const costumes = this.getCostumes();
    return {
      id: this.id,
      name: this.getName(),
      isStage: this.isStage,
      x: this.x,
      y: this.y,
      size: this.size,
      direction: this.direction,
      draggable: this.draggable,
      currentCostume: this.currentCostume,
      costume: costumes[this.currentCostume],
      costumeCount: costumes.length,
      visible: this.visible,
      rotationStyle: this.rotationStyle,
      comments: this.comments,
      blocks: this.blocks._blocks,
      variables: this.variables,
      costumes: costumes,
      sounds: this.getSounds(),
      textToSpeechLanguage: this.textToSpeechLanguage,
      tempo: this.tempo,
      volume: this.volume,
      videoTransparency: this.videoTransparency,
      videoState: this.videoState
    };
  }
  /**
   * Dispose, destroying any run-time properties.
   */


  dispose() {
    if (!this.isOriginal) {
      this.runtime.changeCloneCounter(-1);
    }

    this.runtime.stopForTarget(this);
    this.runtime.removeExecutable(this);
    this.sprite.removeClone(this);

    if (this.renderer && this.drawableID !== null) {
      this.renderer.destroyDrawable(this.drawableID, this.isStage ? StageLayering.BACKGROUND_LAYER : StageLayering.SPRITE_LAYER);

      if (this.visible) {
        this.emitVisualChange();
        this.runtime.requestRedraw();
      }
    }
  }

}

module.exports = RenderedTarget;

/***/ }),

/***/ "./src/sprites/sprite.js":
/*!*******************************!*\
  !*** ./src/sprites/sprite.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const RenderedTarget = __webpack_require__(/*! ./rendered-target */ "./src/sprites/rendered-target.js");

const Blocks = __webpack_require__(/*! ../engine/blocks */ "./src/engine/blocks.js");

const {
  loadSoundFromAsset
} = __webpack_require__(/*! ../import/load-sound */ "./src/import/load-sound.js");

const {
  loadCostumeFromAsset
} = __webpack_require__(/*! ../import/load-costume */ "./src/import/load-costume.js");

const newBlockIds = __webpack_require__(/*! ../util/new-block-ids */ "./src/util/new-block-ids.js");

const StringUtil = __webpack_require__(/*! ../util/string-util */ "./src/util/string-util.js");

const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ "./src/engine/stage-layering.js");

class Sprite {
  /**
   * Sprite to be used on the Scratch stage.
   * All clones of a sprite have shared blocks, shared costumes, shared variables,
   * shared sounds, etc.
   * @param {?Blocks} blocks Shared blocks object for all clones of sprite.
   * @param {Runtime} runtime Reference to the runtime.
   * @constructor
   */
  constructor(blocks, runtime) {
    this.runtime = runtime;

    if (!blocks) {
      // Shared set of blocks for all clones.
      blocks = new Blocks(runtime);
    }

    this.blocks = blocks;
    /**
     * Human-readable name for this sprite (and all clones).
     * @type {string}
     */

    this.name = '';
    /**
     * List of costumes for this sprite.
     * Each entry is an object, e.g.,
     * {
     *      skinId: 1,
     *      name: "Costume Name",
     *      bitmapResolution: 2,
     *      rotationCenterX: 0,
     *      rotationCenterY: 0
     * }
     * @type {Array.<!Object>}
     */

    this.costumes_ = [];
    /**
     * List of sounds for this sprite.
    */

    this.sounds = [];
    /**
     * List of clones for this sprite, including the original.
     * @type {Array.<!RenderedTarget>}
     */

    this.clones = [];
    this.soundBank = null;

    if (this.runtime && this.runtime.audioEngine) {
      this.soundBank = this.runtime.audioEngine.createBank();
    }
  }
  /**
   * Add an array of costumes, taking care to avoid duplicate names.
   * @param {!Array<object>} costumes Array of objects representing costumes.
   */


  set costumes(costumes) {
    this.costumes_ = [];

    for (const costume of costumes) {
      this.addCostumeAt(costume, this.costumes_.length);
    }
  }
  /**
   * Get full costume list
   * @return {object[]} list of costumes. Note that mutating the returned list will not
   *     mutate the list on the sprite. The sprite list should be mutated by calling
   *     addCostumeAt, deleteCostumeAt, or setting costumes.
   */


  get costumes() {
    return this.costumes_;
  }
  /**
   * Add a costume at the given index, taking care to avoid duplicate names.
   * @param {!object} costumeObject Object representing the costume.
   * @param {!int} index Index at which to add costume
   */


  addCostumeAt(costumeObject, index) {
    if (!costumeObject.name) {
      costumeObject.name = '';
    }

    const usedNames = this.costumes_.map(costume => costume.name);
    costumeObject.name = StringUtil.unusedName(costumeObject.name, usedNames);
    this.costumes_.splice(index, 0, costumeObject);
  }
  /**
   * Delete a costume by index.
   * @param {number} index Costume index to be deleted
   * @return {?object} The deleted costume
   */


  deleteCostumeAt(index) {
    return this.costumes.splice(index, 1)[0];
  }
  /**
   * Create a clone of this sprite.
   * @param {string=} optLayerGroup Optional layer group the clone's drawable should be added to
   * Defaults to the sprite layer group
   * @returns {!RenderedTarget} Newly created clone.
   */


  createClone(optLayerGroup) {
    const newClone = new RenderedTarget(this, this.runtime);
    newClone.isOriginal = this.clones.length === 0;
    this.clones.push(newClone);
    newClone.initAudio();

    if (newClone.isOriginal) {
      // Default to the sprite layer group if optLayerGroup is not provided
      const layerGroup = typeof optLayerGroup === 'string' ? optLayerGroup : StageLayering.SPRITE_LAYER;
      newClone.initDrawable(layerGroup);
      this.runtime.fireTargetWasCreated(newClone);
    } else {
      this.runtime.fireTargetWasCreated(newClone, this.clones[0]);
    }

    return newClone;
  }
  /**
   * Disconnect a clone from this sprite. The clone is unmodified.
   * In particular, the clone's dispose() method is not called.
   * @param {!RenderedTarget} clone - the clone to be removed.
   */


  removeClone(clone) {
    this.runtime.fireTargetWasRemoved(clone);
    const cloneIndex = this.clones.indexOf(clone);

    if (cloneIndex >= 0) {
      this.clones.splice(cloneIndex, 1);
    }
  }

  duplicate() {
    const newSprite = new Sprite(null, this.runtime);
    const blocksContainer = this.blocks._blocks;
    const originalBlocks = Object.keys(blocksContainer).map(key => blocksContainer[key]);
    const copiedBlocks = JSON.parse(JSON.stringify(originalBlocks));
    newBlockIds(copiedBlocks);
    copiedBlocks.forEach(block => {
      newSprite.blocks.createBlock(block);
    });
    const allNames = this.runtime.targets.map(t => t.sprite.name);
    newSprite.name = StringUtil.unusedName(this.name, allNames);
    const assetPromises = [];
    newSprite.costumes = this.costumes_.map(costume => {
      const newCostume = Object.assign({}, costume);
      assetPromises.push(loadCostumeFromAsset(newCostume, this.runtime));
      return newCostume;
    });
    newSprite.sounds = this.sounds.map(sound => {
      const newSound = Object.assign({}, sound);
      const soundAsset = sound.asset;
      assetPromises.push(loadSoundFromAsset(newSound, soundAsset, this.runtime, newSprite.soundBank));
      return newSound;
    });
    return Promise.all(assetPromises).then(() => newSprite);
  }

  dispose() {
    if (this.soundBank) {
      this.soundBank.dispose();
    }
  }

}

module.exports = Sprite;

/***/ }),

/***/ "./src/util/async-limiter.js":
/*!***********************************!*\
  !*** ./src/util/async-limiter.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

class AsyncLimiter {
  constructor(callback, maxConcurrent) {
    this.callback = callback;
    this.maxConcurrent = maxConcurrent;
    this._current = 0;
    this._queue = [];
  }

  do() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return new Promise((resolve, reject) => {
      this._queue.push([resolve, reject, args]);

      this._startNext();
    });
  }

  _startNext() {
    if (this._current >= this.maxConcurrent || this._queue.length === 0) {
      return;
    }

    this._current++;

    const [resolve, reject, args] = this._queue.shift();

    this.callback.apply(null, args).then(result => {
      resolve(result);
      this._current--;

      this._startNext();
    }).catch(error => {
      reject(error);
      this._current--;

      this._startNext();
    });
  }

}

module.exports = AsyncLimiter;

/***/ }),

/***/ "./src/util/base64-util.js":
/*!*********************************!*\
  !*** ./src/util/base64-util.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const atob = __webpack_require__(/*! atob */ "./node_modules/atob/node-atob.js");

const btoa = __webpack_require__(/*! btoa */ "./node_modules/btoa/index.js");

class Base64Util {
  /**
   * Convert a base64 encoded string to a Uint8Array.
   * @param {string} base64 - a base64 encoded string.
   * @return {Uint8Array} - a decoded Uint8Array.
   */
  static base64ToUint8Array(base64) {
    const binaryString = atob(base64);
    const len = binaryString.length;
    const array = new Uint8Array(len);

    for (let i = 0; i < len; i++) {
      array[i] = binaryString.charCodeAt(i);
    }

    return array;
  }
  /**
   * Convert a Uint8Array to a base64 encoded string.
   * @param {Uint8Array} array - the array to convert.
   * @return {string} - the base64 encoded string.
   */


  static uint8ArrayToBase64(array) {
    let binary = '';
    const len = array.byteLength;

    for (let i = 0; i < len; i++) {
      binary += String.fromCharCode(array[i]);
    }

    return btoa(binary);
  }
  /**
  * Convert an array buffer to a base64 encoded string.
  * @param {array} buffer - an array buffer to convert.
  * @return {string} - the base64 encoded string.
  */


  static arrayBufferToBase64(buffer) {
    return Base64Util.uint8ArrayToBase64(new Uint8Array(buffer));
  }

}

module.exports = Base64Util;

/***/ }),

/***/ "./src/util/cast.js":
/*!**************************!*\
  !*** ./src/util/cast.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Color = __webpack_require__(/*! ../util/color */ "./src/util/color.js");
/**
 * @fileoverview
 * Utilities for casting and comparing Scratch data-types.
 * Scratch behaves slightly differently from JavaScript in many respects,
 * and these differences should be encapsulated below.
 * For example, in Scratch, add(1, join("hello", world")) -> 1.
 * This is because "hello world" is cast to 0.
 * In JavaScript, 1 + Number("hello" + "world") would give you NaN.
 * Use when coercing a value before computation.
 */


class Cast {
  /**
   * Scratch cast to number.
   * Treats NaN as 0.
   * In Scratch 2.0, this is captured by `interp.numArg.`
   * @param {*} value Value to cast to number.
   * @return {number} The Scratch-casted number value.
   */
  static toNumber(value) {
    // If value is already a number we don't need to coerce it with
    // Number().
    if (typeof value === 'number') {
      // Scratch treats NaN as 0, when needed as a number.
      // E.g., 0 + NaN -> 0.
      if (Number.isNaN(value)) {
        return 0;
      }

      return value;
    }

    const n = Number(value);

    if (Number.isNaN(n)) {
      // Scratch treats NaN as 0, when needed as a number.
      // E.g., 0 + NaN -> 0.
      return 0;
    }

    return n;
  }
  /**
   * Scratch cast to boolean.
   * In Scratch 2.0, this is captured by `interp.boolArg.`
   * Treats some string values differently from JavaScript.
   * @param {*} value Value to cast to boolean.
   * @return {boolean} The Scratch-casted boolean value.
   */


  static toBoolean(value) {
    // Already a boolean?
    if (typeof value === 'boolean') {
      return value;
    }

    if (typeof value === 'string') {
      // These specific strings are treated as false in Scratch.
      if (value === '' || value === '0' || value.toLowerCase() === 'false') {
        return false;
      } // All other strings treated as true.


      return true;
    } // Coerce other values and numbers.


    return Boolean(value);
  }
  /**
   * Scratch cast to string.
   * @param {*} value Value to cast to string.
   * @return {string} The Scratch-casted string value.
   */


  static toString(value) {
    return String(value);
  }
  /**
   * Cast any Scratch argument to an RGB color array to be used for the renderer.
   * @param {*} value Value to convert to RGB color array.
   * @return {Array.<number>} [r,g,b], values between 0-255.
   */


  static toRgbColorList(value) {
    const color = Cast.toRgbColorObject(value);
    return [color.r, color.g, color.b];
  }
  /**
   * Cast any Scratch argument to an RGB color object to be used for the renderer.
   * @param {*} value Value to convert to RGB color object.
   * @return {RGBOject} [r,g,b], values between 0-255.
   */


  static toRgbColorObject(value) {
    let color;

    if (typeof value === 'string' && value.substring(0, 1) === '#') {
      color = Color.hexToRgb(value); // If the color wasn't *actually* a hex color, cast to black

      if (!color) color = {
        r: 0,
        g: 0,
        b: 0,
        a: 255
      };
    } else {
      color = Color.decimalToRgb(Cast.toNumber(value));
    }

    return color;
  }
  /**
   * Determine if a Scratch argument is a white space string (or null / empty).
   * @param {*} val value to check.
   * @return {boolean} True if the argument is all white spaces or null / empty.
   */


  static isWhiteSpace(val) {
    return val === null || typeof val === 'string' && val.trim().length === 0;
  }
  /**
   * Compare two values, using Scratch cast, case-insensitive string compare, etc.
   * In Scratch 2.0, this is captured by `interp.compare.`
   * @param {*} v1 First value to compare.
   * @param {*} v2 Second value to compare.
   * @returns {number} Negative number if v1 < v2; 0 if equal; positive otherwise.
   */


  static compare(v1, v2) {
    let n1 = Number(v1);
    let n2 = Number(v2);

    if (n1 === 0 && Cast.isWhiteSpace(v1)) {
      n1 = NaN;
    } else if (n2 === 0 && Cast.isWhiteSpace(v2)) {
      n2 = NaN;
    }

    if (isNaN(n1) || isNaN(n2)) {
      // At least one argument can't be converted to a number.
      // Scratch compares strings as case insensitive.
      const s1 = String(v1).toLowerCase();
      const s2 = String(v2).toLowerCase();

      if (s1 < s2) {
        return -1;
      } else if (s1 > s2) {
        return 1;
      }

      return 0;
    } // Handle the special case of Infinity


    if (n1 === Infinity && n2 === Infinity || n1 === -Infinity && n2 === -Infinity) {
      return 0;
    } // Compare as numbers.


    return n1 - n2;
  }
  /**
   * Determine if a Scratch argument number represents a round integer.
   * @param {*} val Value to check.
   * @return {boolean} True if number looks like an integer.
   */


  static isInt(val) {
    // Values that are already numbers.
    if (typeof val === 'number') {
      if (isNaN(val)) {
        // NaN is considered an integer.
        return true;
      } // True if it's "round" (e.g., 2.0 and 2).


      return val === Math.floor(val);
    } else if (typeof val === 'boolean') {
      // `True` and `false` always represent integer after Scratch cast.
      return true;
    } else if (typeof val === 'string') {
      // If it contains a decimal point, don't consider it an int.
      return val.indexOf('.') < 0;
    }

    return false;
  }

  static get LIST_INVALID() {
    return 'INVALID';
  }

  static get LIST_ALL() {
    return 'ALL';
  }
  /**
   * Compute a 1-based index into a list, based on a Scratch argument.
   * Two special cases may be returned:
   * LIST_ALL: if the block is referring to all of the items in the list.
   * LIST_INVALID: if the index was invalid in any way.
   * @param {*} index Scratch arg, including 1-based numbers or special cases.
   * @param {number} length Length of the list.
   * @param {boolean} acceptAll Whether it should accept "all" or not.
   * @return {(number|string)} 1-based index for list, LIST_ALL, or LIST_INVALID.
   */


  static toListIndex(index, length, acceptAll) {
    if (typeof index !== 'number') {
      if (index === 'all') {
        return acceptAll ? Cast.LIST_ALL : Cast.LIST_INVALID;
      }

      if (index === 'last') {
        if (length > 0) {
          return length;
        }

        return Cast.LIST_INVALID;
      } else if (index === 'random' || index === 'any') {
        if (length > 0) {
          return 1 + Math.floor(Math.random() * length);
        }

        return Cast.LIST_INVALID;
      }
    }

    index = Math.floor(Cast.toNumber(index));

    if (index < 1 || index > length) {
      return Cast.LIST_INVALID;
    }

    return index;
  }

}

module.exports = Cast;

/***/ }),

/***/ "./src/util/clone.js":
/*!***************************!*\
  !*** ./src/util/clone.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Methods for cloning JavaScript objects.
 * @type {object}
 */
class Clone {
  /**
   * Deep-clone a "simple" object: one which can be fully expressed with JSON.
   * Non-JSON values, such as functions, will be stripped from the clone.
   * @param {object} original - the object to be cloned.
   * @returns {object} a deep clone of the original object.
   */
  static simple(original) {
    return JSON.parse(JSON.stringify(original));
  }

}

module.exports = Clone;

/***/ }),

/***/ "./src/util/color.js":
/*!***************************!*\
  !*** ./src/util/color.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

class Color {
  /**
   * @typedef {object} RGBObject - An object representing a color in RGB format.
   * @property {number} r - the red component, in the range [0, 255].
   * @property {number} g - the green component, in the range [0, 255].
   * @property {number} b - the blue component, in the range [0, 255].
   */

  /**
   * @typedef {object} HSVObject - An object representing a color in HSV format.
   * @property {number} h - hue, in the range [0-359).
   * @property {number} s - saturation, in the range [0,1].
   * @property {number} v - value, in the range [0,1].
   */

  /** @type {RGBObject} */
  static get RGB_BLACK() {
    return {
      r: 0,
      g: 0,
      b: 0
    };
  }
  /** @type {RGBObject} */


  static get RGB_WHITE() {
    return {
      r: 255,
      g: 255,
      b: 255
    };
  }
  /**
   * Convert a Scratch decimal color to a hex string, #RRGGBB.
   * @param {number} decimal RGB color as a decimal.
   * @return {string} RGB color as #RRGGBB hex string.
   */


  static decimalToHex(decimal) {
    if (decimal < 0) {
      decimal += 0xFFFFFF + 1;
    }

    let hex = Number(decimal).toString(16);
    hex = "#".concat('000000'.substr(0, 6 - hex.length)).concat(hex);
    return hex;
  }
  /**
   * Convert a Scratch decimal color to an RGB color object.
   * @param {number} decimal RGB color as decimal.
   * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
   */


  static decimalToRgb(decimal) {
    const a = decimal >> 24 & 0xFF;
    const r = decimal >> 16 & 0xFF;
    const g = decimal >> 8 & 0xFF;
    const b = decimal & 0xFF;
    return {
      r: r,
      g: g,
      b: b,
      a: a > 0 ? a : 255
    };
  }
  /**
   * Convert a hex color (e.g., F00, #03F, #0033FF) to an RGB color object.
   * @param {!string} hex Hex representation of the color.
   * @return {RGBObject} null on failure, or rgb: {r: red [0,255], g: green [0,255], b: blue [0,255]}.
   */


  static hexToRgb(hex) {
    if (hex.startsWith('#')) {
      hex = hex.substring(1);
    }

    const parsed = parseInt(hex, 16);

    if (isNaN(parsed)) {
      return null;
    }

    if (hex.length === 6) {
      return {
        r: parsed >> 16 & 0xff,
        g: parsed >> 8 & 0xff,
        b: parsed & 0xff
      };
    } else if (hex.length === 3) {
      const r = parsed >> 8 & 0xf;
      const g = parsed >> 4 & 0xf;
      const b = parsed & 0xf;
      return {
        r: r << 4 | r,
        g: g << 4 | g,
        b: b << 4 | b
      };
    }

    return null;
  }
  /**
   * Convert an RGB color object to a hex color.
   * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
   * @return {!string} Hex representation of the color.
   */


  static rgbToHex(rgb) {
    return Color.decimalToHex(Color.rgbToDecimal(rgb));
  }
  /**
   * Convert an RGB color object to a Scratch decimal color.
   * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
   * @return {!number} Number representing the color.
   */


  static rgbToDecimal(rgb) {
    return (rgb.r << 16) + (rgb.g << 8) + rgb.b;
  }
  /**
  * Convert a hex color (e.g., F00, #03F, #0033FF) to a decimal color number.
  * @param {!string} hex Hex representation of the color.
  * @return {!number} Number representing the color.
  */


  static hexToDecimal(hex) {
    return Color.rgbToDecimal(Color.hexToRgb(hex));
  }
  /**
   * Convert an HSV color to RGB format.
   * @param {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
   * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
   */


  static hsvToRgb(hsv) {
    let h = hsv.h % 360;
    if (h < 0) h += 360;
    const s = Math.max(0, Math.min(hsv.s, 1));
    const v = Math.max(0, Math.min(hsv.v, 1));
    const i = Math.floor(h / 60);
    const f = h / 60 - i;
    const p = v * (1 - s);
    const q = v * (1 - s * f);
    const t = v * (1 - s * (1 - f));
    let r;
    let g;
    let b;

    switch (i) {
      default:
      case 0:
        r = v;
        g = t;
        b = p;
        break;

      case 1:
        r = q;
        g = v;
        b = p;
        break;

      case 2:
        r = p;
        g = v;
        b = t;
        break;

      case 3:
        r = p;
        g = q;
        b = v;
        break;

      case 4:
        r = t;
        g = p;
        b = v;
        break;

      case 5:
        r = v;
        g = p;
        b = q;
        break;
    }

    return {
      r: Math.floor(r * 255),
      g: Math.floor(g * 255),
      b: Math.floor(b * 255)
    };
  }
  /**
   * Convert an RGB color to HSV format.
   * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.
   * @return {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}
   */


  static rgbToHsv(rgb) {
    const r = rgb.r / 255;
    const g = rgb.g / 255;
    const b = rgb.b / 255;
    const x = Math.min(Math.min(r, g), b);
    const v = Math.max(Math.max(r, g), b); // For grays, hue will be arbitrarily reported as zero. Otherwise, calculate

    let h = 0;
    let s = 0;

    if (x !== v) {
      const f = r === x ? g - b : g === x ? b - r : r - g;
      const i = r === x ? 3 : g === x ? 5 : 1;
      h = (i - f / (v - x)) * 60 % 360;
      s = (v - x) / v;
    }

    return {
      h: h,
      s: s,
      v: v
    };
  }
  /**
   * Linear interpolation between rgb0 and rgb1.
   * @param {RGBObject} rgb0 - the color corresponding to fraction1 <= 0.
   * @param {RGBObject} rgb1 - the color corresponding to fraction1 >= 1.
   * @param {number} fraction1 - the interpolation parameter. If this is 0.5, for example, mix the two colors equally.
   * @return {RGBObject} the interpolated color.
   */


  static mixRgb(rgb0, rgb1, fraction1) {
    if (fraction1 <= 0) return rgb0;
    if (fraction1 >= 1) return rgb1;
    const fraction0 = 1 - fraction1;
    return {
      r: fraction0 * rgb0.r + fraction1 * rgb1.r,
      g: fraction0 * rgb0.g + fraction1 * rgb1.g,
      b: fraction0 * rgb0.b + fraction1 * rgb1.b
    };
  }

}

module.exports = Color;

/***/ }),

/***/ "./src/util/fetch-with-timeout.js":
/*!****************************************!*\
  !*** ./src/util/fetch-with-timeout.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Fetch a remote resource like `fetch` does, but with a time limit.
 * @param {Request|string} resource Remote resource to fetch.
 * @param {?object} init An options object containing any custom settings that you want to apply to the request.
 * @param {number} timeout The amount of time before the request is canceled, in milliseconds
 * @returns {Promise<Response>} The response from the server.
 */
const fetchWithTimeout = (resource, init, timeout) => {
  let timeoutID = null; // Not supported in Safari <11

  const controller = window.AbortController ? new window.AbortController() : null;
  const signal = controller ? controller.signal : null; // The fetch call races a timer.

  return Promise.race([fetch(resource, Object.assign({
    signal
  }, init)).then(response => {
    clearTimeout(timeoutID);
    return response;
  }), new Promise((resolve, reject) => {
    timeoutID = setTimeout(() => {
      if (controller) controller.abort();
      reject(new Error("Fetch timed out after ".concat(timeout, " ms")));
    }, timeout);
  })]);
};

module.exports = fetchWithTimeout;

/***/ }),

/***/ "./src/util/get-monitor-id.js":
/*!************************************!*\
  !*** ./src/util/get-monitor-id.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Returns a string representing a unique id for a monitored block
 * where a single reporter block can have more than one monitor
 * (and therefore more than one monitor block) associated
 * with it (e.g. when reporter blocks have inputs).
 * @param {string} baseId The base id to use for the different monitor blocks
 * @param {object} fields The monitor block's fields object.
 */
// TODO this function should eventually be the single place where all monitor
// IDs are obtained given an opcode for the reporter block and the list of
// selected parameters.
const getMonitorIdForBlockWithArgs = function getMonitorIdForBlockWithArgs(id, fields) {
  let fieldString = '';

  for (const fieldKey in fields) {
    let fieldValue = fields[fieldKey].value;

    if (fieldKey === 'CURRENTMENU') {
      // The 'sensing_current' block has field values in all caps.
      // However, when importing from scratch 2.0, these
      // could have gotten imported as lower case field values.
      // Normalize the field value here so that we don't ever
      // end up with a different monitor ID representing the same
      // block configuration
      // Note: we are not doing this for every block field that comes into
      // this function so as not to make the faulty assumption that block
      // field values coming in would be unique after being made lower case
      fieldValue = fieldValue.toLowerCase();
    }

    fieldString += "_".concat(fieldValue);
  }

  return "".concat(id).concat(fieldString);
};

module.exports = getMonitorIdForBlockWithArgs;

/***/ }),

/***/ "./src/util/jsonrpc.js":
/*!*****************************!*\
  !*** ./src/util/jsonrpc.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

class JSONRPC {
  constructor() {
    this._requestID = 0;
    this._openRequests = {};
  }
  /**
   * Make an RPC request and retrieve the result.
   * @param {string} method - the remote method to call.
   * @param {object} params - the parameters to pass to the remote method.
   * @returns {Promise} - a promise for the result of the call.
   */


  sendRemoteRequest(method, params) {
    const requestID = this._requestID++;
    const promise = new Promise((resolve, reject) => {
      this._openRequests[requestID] = {
        resolve,
        reject
      };
    });

    this._sendRequest(method, params, requestID);

    return promise;
  }
  /**
   * Make an RPC notification with no expectation of a result or callback.
   * @param {string} method - the remote method to call.
   * @param {object} params - the parameters to pass to the remote method.
   */


  sendRemoteNotification(method, params) {
    this._sendRequest(method, params);
  }
  /**
   * Handle an RPC request from remote, should return a result or Promise for result, if appropriate.
   * @param {string} method - the method requested by the remote caller.
   * @param {object} params - the parameters sent with the remote caller's request.
   */


  didReceiveCall()
  /* method , params */
  {
    throw new Error('Must override didReceiveCall');
  }

  _sendMessage()
  /* jsonMessageObject */
  {
    throw new Error('Must override _sendMessage');
  }

  _sendRequest(method, params, id) {
    const request = {
      jsonrpc: '2.0',
      method,
      params
    };

    if (id !== null) {
      request.id = id;
    }

    this._sendMessage(request);
  }

  _handleMessage(json) {
    if (json.jsonrpc !== '2.0') {
      throw new Error("Bad or missing JSON-RPC version in message: ".concat(json));
    }

    if (json.hasOwnProperty('method')) {
      this._handleRequest(json);
    } else {
      this._handleResponse(json);
    }
  }

  _sendResponse(id, result, error) {
    const response = {
      jsonrpc: '2.0',
      id
    };

    if (error) {
      response.error = error;
    } else {
      response.result = result || null;
    }

    this._sendMessage(response);
  }

  _handleResponse(json) {
    const {
      result,
      error,
      id
    } = json;
    const openRequest = this._openRequests[id];
    delete this._openRequests[id];

    if (openRequest) {
      if (error) {
        openRequest.reject(error);
      } else {
        openRequest.resolve(result);
      }
    }
  }

  _handleRequest(json) {
    const {
      method,
      params,
      id
    } = json;
    const rawResult = this.didReceiveCall(method, params);

    if (id) {
      Promise.resolve(rawResult).then(result => {
        this._sendResponse(id, result);
      }, error => {
        this._sendResponse(id, null, error);
      });
    }
  }

}

module.exports = JSONRPC;

/***/ }),

/***/ "./src/util/log.js":
/*!*************************!*\
  !*** ./src/util/log.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const minilog = __webpack_require__(/*! minilog */ "minilog");

minilog.enable();
module.exports = minilog('vm');

/***/ }),

/***/ "./src/util/math-util.js":
/*!*******************************!*\
  !*** ./src/util/math-util.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

class MathUtil {
  /**
   * Convert a value from degrees to radians.
   * @param {!number} deg Value in degrees.
   * @return {!number} Equivalent value in radians.
   */
  static degToRad(deg) {
    return deg * Math.PI / 180;
  }
  /**
   * Convert a value from radians to degrees.
   * @param {!number} rad Value in radians.
   * @return {!number} Equivalent value in degrees.
   */


  static radToDeg(rad) {
    return rad * 180 / Math.PI;
  }
  /**
   * Clamp a number between two limits.
   * If n < min, return min. If n > max, return max. Else, return n.
   * @param {!number} n Number to clamp.
   * @param {!number} min Minimum limit.
   * @param {!number} max Maximum limit.
   * @return {!number} Value of n clamped to min and max.
   */


  static clamp(n, min, max) {
    return Math.min(Math.max(n, min), max);
  }
  /**
   * Keep a number between two limits, wrapping "extra" into the range.
   * e.g., wrapClamp(7, 1, 5) == 2
   * wrapClamp(0, 1, 5) == 5
   * wrapClamp(-11, -10, 6) == 6, etc.
   * @param {!number} n Number to wrap.
   * @param {!number} min Minimum limit.
   * @param {!number} max Maximum limit.
   * @return {!number} Value of n wrapped between min and max.
   */


  static wrapClamp(n, min, max) {
    const range = max - min + 1;
    return n - Math.floor((n - min) / range) * range;
  }
  /**
   * Convert a value from tan function in degrees.
   * @param {!number} angle in degrees
   * @return {!number} Correct tan value
   */


  static tan(angle) {
    angle = angle % 360;

    switch (angle) {
      case -270:
      case 90:
        return Infinity;

      case -90:
      case 270:
        return -Infinity;

      default:
        return Math.round(Math.tan(Math.PI * angle / 180) * 1e10) / 1e10;
    }
  }
  /**
   * Given an array of unique numbers,
   * returns a reduced array such that each element of the reduced array
   * represents the position of that element in a sorted version of the
   * original array.
   * E.g. [5, 19. 13, 1] => [1, 3, 2, 0]
   * @param {Array<number>} elts The elements to sort and reduce
   * @return {Array<number>} The array of reduced orderings
   */


  static reducedSortOrdering(elts) {
    const sorted = elts.slice(0).sort((a, b) => a - b);
    return elts.map(e => sorted.indexOf(e));
  }
  /**
   * Return a random number given an inclusive range and a number in that
   * range that should be excluded.
   *
   * For instance, (1, 5, 3) will only pick 1, 2, 4, or 5 (with equal
   * probability)
   *
   * @param {number} lower - The lower bound (inlcusive)
   * @param {number} upper - The upper bound (inclusive), such that lower <= upper
   * @param {number} excluded - The number to exclude (MUST be in the range)
   * @return {number} A random integer in the range [lower, upper] that is not "excluded"
   */


  static inclusiveRandIntWithout(lower, upper, excluded) {
    // Note that subtraction is the number of items in the
    // inclusive range [lower, upper] minus 1 already
    // (e.g. in the set {3, 4, 5}, 5 - 3 = 2).
    const possibleOptions = upper - lower;
    const randInt = lower + Math.floor(Math.random() * possibleOptions);

    if (randInt >= excluded) {
      return randInt + 1;
    }

    return randInt;
  }
  /**
   * Scales a number from one range to another.
   * @param {number} i number to be scaled
   * @param {number} iMin input range minimum
   * @param {number} iMax input range maximum
   * @param {number} oMin output range minimum
   * @param {number} oMax output range maximum
   * @return {number} scaled number
   */


  static scale(i, iMin, iMax, oMin, oMax) {
    const p = (i - iMin) / (iMax - iMin);
    return p * (oMax - oMin) + oMin;
  }

}

module.exports = MathUtil;

/***/ }),

/***/ "./src/util/maybe-format-message.js":
/*!******************************************!*\
  !*** ./src/util/maybe-format-message.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const formatMessage = __webpack_require__(/*! format-message */ "format-message");
/**
 * Check if `maybeMessage` looks like a message object, and if so pass it to `formatMessage`.
 * Otherwise, return `maybeMessage` as-is.
 * @param {*} maybeMessage - something that might be a message descriptor object.
 * @param {object} [args] - the arguments to pass to `formatMessage` if it gets called.
 * @param {string} [locale] - the locale to pass to `formatMessage` if it gets called.
 * @return {string|*} - the formatted message OR the original `maybeMessage` input.
 */


const maybeFormatMessage = function maybeFormatMessage(maybeMessage, args, locale) {
  if (maybeMessage && maybeMessage.id && maybeMessage.default) {
    return formatMessage(maybeMessage, args, locale);
  }

  return maybeMessage;
};

module.exports = maybeFormatMessage;

/***/ }),

/***/ "./src/util/new-block-ids.js":
/*!***********************************!*\
  !*** ./src/util/new-block-ids.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const uid = __webpack_require__(/*! ./uid */ "./src/util/uid.js");
/**
 * Mutate the given blocks to have new IDs and update all internal ID references.
 * Does not return anything to make it clear that the blocks are updated in-place.
 * @param {array} blocks - blocks to be mutated.
 */


module.exports = blocks => {
  const oldToNew = {}; // First update all top-level IDs and create old-to-new mapping

  for (let i = 0; i < blocks.length; i++) {
    const newId = uid();
    const oldId = blocks[i].id;
    blocks[i].id = oldToNew[oldId] = newId;
  } // Then go back through and update inputs (block/shadow)
  // and next/parent properties


  for (let i = 0; i < blocks.length; i++) {
    for (const key in blocks[i].inputs) {
      const input = blocks[i].inputs[key];
      input.block = oldToNew[input.block];
      input.shadow = oldToNew[input.shadow];
    }

    if (blocks[i].parent) {
      blocks[i].parent = oldToNew[blocks[i].parent];
    }

    if (blocks[i].next) {
      blocks[i].next = oldToNew[blocks[i].next];
    }
  }
};

/***/ }),

/***/ "./src/util/rateLimiter.js":
/*!*********************************!*\
  !*** ./src/util/rateLimiter.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const Timer = __webpack_require__(/*! ../util/timer */ "./src/util/timer.js");

class RateLimiter {
  /**
   * A utility for limiting the rate of repetitive send operations, such as
   * bluetooth messages being sent to hardware devices. It uses the token bucket
   * strategy: a counter accumulates tokens at a steady rate, and each send costs
   * a token. If no tokens remain, it's not okay to send.
   * @param {number} maxRate the maximum number of sends allowed per second
   * @constructor
   */
  constructor(maxRate) {
    /**
     * The maximum number of tokens.
     * @type {number}
     */
    this._maxTokens = maxRate;
    /**
     * The interval in milliseconds for refilling one token. It is calculated
     * so that the tokens will be filled to maximum in one second.
     * @type {number}
     */

    this._refillInterval = 1000 / maxRate;
    /**
     * The current number of tokens in the bucket.
     * @type {number}
     */

    this._count = this._maxTokens;
    this._timer = new Timer();

    this._timer.start();
    /**
     * The last time in milliseconds when the token count was updated.
     * @type {number}
     */


    this._lastUpdateTime = this._timer.timeElapsed();
  }
  /**
   * Check if it is okay to send a message, by updating the token count,
   * taking a token and then checking if we are still under the rate limit.
   * @return {boolean} true if we are under the rate limit
   */


  okayToSend() {
    // Calculate the number of tokens to refill the bucket with, based on the
    // amount of time since the last refill.
    const now = this._timer.timeElapsed();

    const timeSinceRefill = now - this._lastUpdateTime;
    const refillCount = Math.floor(timeSinceRefill / this._refillInterval); // If we're adding at least one token, reset _lastUpdateTime to now.
    // Otherwise, don't reset it so that we can continue measuring time until
    // the next refill.

    if (refillCount > 0) {
      this._lastUpdateTime = now;
    } // Refill the tokens up to the maximum


    this._count = Math.min(this._maxTokens, this._count + refillCount); // If we have at least one token, use one, and it's okay to send.

    if (this._count > 0) {
      this._count--;
      return true;
    }

    return false;
  }

}

module.exports = RateLimiter;

/***/ }),

/***/ "./src/util/scratch-link-websocket.js":
/*!********************************************!*\
  !*** ./src/util/scratch-link-websocket.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This class provides a ScratchLinkSocket implementation using WebSockets,
 * attempting to connect with the locally installed Scratch-Link.
 *
 * To connect with ScratchLink without WebSockets, you must implement all of the
 * public methods in this class.
 * - open()
 * - close()
 * - setOn[Open|Close|Error]
 * - setHandleMessage
 * - sendMessage(msgObj)
 * - isOpen()
 */
class ScratchLinkWebSocket {
  constructor(type) {
    this._type = type;
    this._onOpen = null;
    this._onClose = null;
    this._onError = null;
    this._handleMessage = null;
    this._ws = null;
  }

  open() {
    if (!(this._onOpen && this._onClose && this._onError && this._handleMessage)) {
      throw new Error('Must set open, close, message and error handlers before calling open on the socket');
    }

    let pathname;

    switch (this._type) {
      case 'BLE':
        pathname = 'scratch/ble';
        break;

      case 'BT':
        pathname = 'scratch/bt';
        break;

      default:
        throw new Error("Unknown ScratchLink socket Type: ".concat(this._type));
    } // Try ws:// (the new way) and wss:// (the old way) simultaneously. If either connects, close the other. If we
    // were to try one and fall back to the other on failure, that could mean a delay of 30 seconds or more for
    // those who need the fallback.
    // If both connections fail we should report only one error.


    const setSocket = (socketToUse, socketToClose) => {
      socketToClose.onopen = socketToClose.onerror = null;
      socketToClose.close();
      this._ws = socketToUse;
      this._ws.onopen = this._onOpen;
      this._ws.onclose = this._onClose;
      this._ws.onerror = this._onError;
      this._ws.onmessage = this._onMessage.bind(this);
    };

    const ws = new WebSocket("ws://127.0.0.1:20111/".concat(pathname));
    const wss = new WebSocket("wss://device-manager.scratch.mit.edu:20110/".concat(pathname));
    const connectTimeout = setTimeout(() => {
      // neither socket succeeded before the timeout
      setSocket(ws, wss);

      this._ws.onerror(new Event('timeout'));
    }, 15 * 1000);

    ws.onopen = openEvent => {
      clearTimeout(connectTimeout);
      setSocket(ws, wss);

      this._ws.onopen(openEvent);
    };

    wss.onopen = openEvent => {
      clearTimeout(connectTimeout);
      setSocket(wss, ws);

      this._ws.onopen(openEvent);
    };

    let wsError;
    let wssError;

    const errorHandler = () => {
      // if only one has received an error, we haven't overall failed yet
      if (wsError && wssError) {
        clearTimeout(connectTimeout);
        setSocket(ws, wss);

        this._ws.onerror(wsError);
      }
    };

    ws.onerror = errorEvent => {
      wsError = errorEvent;
      errorHandler();
    };

    wss.onerror = errorEvent => {
      wssError = errorEvent;
      errorHandler();
    };
  }

  close() {
    this._ws.close();

    this._ws = null;
  }

  sendMessage(message) {
    const messageText = JSON.stringify(message);

    this._ws.send(messageText);
  }

  setOnOpen(fn) {
    this._onOpen = fn;
  }

  setOnClose(fn) {
    this._onClose = fn;
  }

  setOnError(fn) {
    this._onError = fn;
  }

  setHandleMessage(fn) {
    this._handleMessage = fn;
  }

  isOpen() {
    return this._ws && this._ws.readyState === this._ws.OPEN;
  }

  _onMessage(e) {
    const json = JSON.parse(e.data);

    this._handleMessage(json);
  }

}

module.exports = ScratchLinkWebSocket;

/***/ }),

/***/ "./src/util/string-util.js":
/*!*********************************!*\
  !*** ./src/util/string-util.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const log = __webpack_require__(/*! ./log */ "./src/util/log.js");

class StringUtil {
  static withoutTrailingDigits(s) {
    let i = s.length - 1;

    while (i >= 0 && '0123456789'.indexOf(s.charAt(i)) > -1) i--;

    return s.slice(0, i + 1);
  }

  static unusedName(name, existingNames) {
    if (existingNames.indexOf(name) < 0) return name;
    name = StringUtil.withoutTrailingDigits(name);
    let i = 2;

    while (existingNames.indexOf(name + i) >= 0) i++;

    return name + i;
  }
  /**
   * Split a string on the first occurrence of a split character.
   * @param {string} text - the string to split.
   * @param {string} separator - split the text on this character.
   * @returns {string[]} - the two parts of the split string, or [text, null] if no split character found.
   * @example
   * // returns ['foo', 'tar.gz']
   * splitFirst('foo.tar.gz', '.');
   * @example
   * // returns ['foo', null]
   * splitFirst('foo', '.');
   * @example
   * // returns ['foo', '']
   * splitFirst('foo.', '.');
   */


  static splitFirst(text, separator) {
    const index = text.indexOf(separator);

    if (index >= 0) {
      return [text.substring(0, index), text.substring(index + 1)];
    }

    return [text, null];
  }
  /**
   * A customized version of JSON.stringify that sets Infinity/NaN to 0,
   * instead of the default (null).
   * Needed because null is not of type number, but Infinity/NaN are, which
   * can lead to serialization producing JSON that isn't valid based on the parser schema.
   * It is also consistent with the behavior of saving 2.0 projects.
   * This is only needed when stringifying an object for saving.
   *
   * @param {!object} obj - The object to serialize
   * @return {!string} The JSON.stringified string with Infinity/NaN replaced with 0
   */


  static stringify(obj) {
    return JSON.stringify(obj, (_key, value) => {
      if (typeof value === 'number' && (value === Infinity || value === -Infinity || isNaN(value))) {
        return 0;
      }

      return value;
    });
  }
  /**
   * A function to replace unsafe characters (not allowed in XML) with safe ones. This is used
   * in cases where we're replacing non-user facing strings (e.g. variable IDs).
   * When replacing user facing strings, the xmlEscape utility function should be used
   * instead so that the user facing string does not change how it displays.
   * @param {!string | !Array.<string>} unsafe Unsafe string possibly containing unicode control characters.
   * In some cases this argument may be an array (e.g. hacked inputs from 2.0)
   * @return {string} String with control characters replaced.
   */


  static replaceUnsafeChars(unsafe) {
    if (typeof unsafe !== 'string') {
      if (Array.isArray(unsafe)) {
        // This happens when we have hacked blocks from 2.0
        // See #1030
        unsafe = String(unsafe);
      } else {
        log.error('Unexpected input recieved in replaceUnsafeChars');
        return unsafe;
      }
    }

    return unsafe.replace(/[<>&'"]/g, c => {
      switch (c) {
        case '<':
          return 'lt';

        case '>':
          return 'gt';

        case '&':
          return 'amp';

        case '\'':
          return 'apos';

        case '"':
          return 'quot';
      }
    });
  }

}

module.exports = StringUtil;

/***/ }),

/***/ "./src/util/timer.js":
/*!***************************!*\
  !*** ./src/util/timer.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @fileoverview
 * A utility for accurately measuring time.
 * To use:
 * ---
 * var timer = new Timer();
 * timer.start();
 * ... pass some time ...
 * var timeDifference = timer.timeElapsed();
 * ---
 * Or, you can use the `time` and `relativeTime`
 * to do some measurement yourself.
 */
class Timer {
  constructor() {
    let nowObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Timer.nowObj;

    /**
     * Used to store the start time of a timer action.
     * Updated when calling `timer.start`.
     */
    this.startTime = 0;
    /**
     * Used to pass custom logic for determining the value for "now",
     * which is sometimes useful for compatibility with Scratch 2
     */

    this.nowObj = nowObj;
  }
  /**
   * Disable use of self.performance for now as it results in lower performance
   * However, instancing it like below (caching the self.performance to a local variable) negates most of the issues.
   * @type {boolean}
   */


  static get USE_PERFORMANCE() {
    return false;
  }
  /**
   * Legacy object to allow for us to call now to get the old style date time (for backwards compatibility)
   * @deprecated This is only called via the nowObj.now() if no other means is possible...
   */


  static get legacyDateCode() {
    return {
      now: function now() {
        return new Date().getTime();
      }
    };
  }
  /**
   * Use this object to route all time functions through single access points.
   */


  static get nowObj() {
    if (Timer.USE_PERFORMANCE && typeof self !== 'undefined' && self.performance && 'now' in self.performance) {
      return self.performance;
    } else if (Date.now) {
      return Date;
    }

    return Timer.legacyDateCode;
  }
  /**
   * Return the currently known absolute time, in ms precision.
   * @returns {number} ms elapsed since 1 January 1970 00:00:00 UTC.
   */


  time() {
    return this.nowObj.now();
  }
  /**
   * Returns a time accurate relative to other times produced by this function.
   * If possible, will use sub-millisecond precision.
   * If not, will use millisecond precision.
   * Not guaranteed to produce the same absolute values per-system.
   * @returns {number} ms-scale accurate time relative to other relative times.
   */


  relativeTime() {
    return this.nowObj.now();
  }
  /**
   * Start a timer for measuring elapsed time,
   * at the most accurate precision possible.
   */


  start() {
    this.startTime = this.nowObj.now();
  }

  timeElapsed() {
    return this.nowObj.now() - this.startTime;
  }
  /**
   * Call a handler function after a specified amount of time has elapsed.
   * @param {function} handler - function to call after the timeout
   * @param {number} timeout - number of milliseconds to delay before calling the handler
   * @returns {number} - the ID of the new timeout
   */


  setTimeout(handler, timeout) {
    return global.setTimeout(handler, timeout);
  }
  /**
   * Clear a timeout from the pending timeout pool.
   * @param {number} timeoutId - the ID returned by `setTimeout()`
   * @memberof Timer
   */


  clearTimeout(timeoutId) {
    global.clearTimeout(timeoutId);
  }

}

module.exports = Timer;

/***/ }),

/***/ "./src/util/uid.js":
/*!*************************!*\
  !*** ./src/util/uid.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @fileoverview UID generator, from Blockly.
 */

/**
 * Legal characters for the unique ID.
 * Should be all on a US keyboard.  No XML special characters or control codes.
 * Removed $ due to issue 251.
 * @private
 */
const soup_ = '!#%()*+,-./:;=?@[]^_`{|}~' + 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
/**
 * Generate a unique ID, from Blockly.  This should be globally unique.
 * 87 characters ^ 20 length > 128 bits (better than a UUID).
 * @return {string} A globally unique ID string.
 */

const uid = function uid() {
  const length = 20;
  const soupLength = soup_.length;
  const id = [];

  for (let i = 0; i < length; i++) {
    id[i] = soup_.charAt(Math.random() * soupLength);
  }

  return id.join('');
};

module.exports = uid;

/***/ }),

/***/ "./src/util/variable-util.js":
/*!***********************************!*\
  !*** ./src/util/variable-util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

class VariableUtil {
  static _mergeVarRefObjects(accum, obj2) {
    for (const id in obj2) {
      if (accum[id]) {
        accum[id] = accum[id].concat(obj2[id]);
      } else {
        accum[id] = obj2[id];
      }
    }

    return accum;
  }
  /**
   * Get all variable/list references in the given list of targets
   * in the project.
   * @param {Array.<Target>} targets The list of targets to get the variable
   * and list references from.
   * @param {boolean} shouldIncludeBroadcast Whether to include broadcast message fields.
   * @return {object} An object with variable ids as the keys and a list of block fields referencing
   * the variable.
   */


  static getAllVarRefsForTargets(targets, shouldIncludeBroadcast) {
    return targets.map(t => t.blocks.getAllVariableAndListReferences(null, shouldIncludeBroadcast)).reduce(VariableUtil._mergeVarRefObjects, {});
  }
  /**
   * Give all variable references provided a new id and possibly new name.
   * @param {Array<object>} referencesToUpdate Context of the change, the object containing variable
   * references to update.
   * @param {string} newId ID of the variable that the old references should be replaced with
   * @param {?string} optNewName New variable name to merge with. The old
   * variable name in the references being updated should be replaced with this new name.
   * If this parameter is not provided or is '', no name change occurs.
   */


  static updateVariableIdentifiers(referencesToUpdate, newId, optNewName) {
    referencesToUpdate.map(ref => {
      ref.referencingField.id = newId;

      if (optNewName) {
        ref.referencingField.value = optNewName;
      }

      return ref;
    });
  }

}

module.exports = VariableUtil;

/***/ }),

/***/ "./src/util/xml-escape.js":
/*!********************************!*\
  !*** ./src/util/xml-escape.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

const log = __webpack_require__(/*! ./log */ "./src/util/log.js");
/**
 * Escape a string to be safe to use in XML content.
 * CC-BY-SA: hgoebl
 * https://stackoverflow.com/questions/7918868/
 * how-to-escape-xml-entities-in-javascript
 * @param {!string | !Array.<string>} unsafe Unsafe string.
 * @return {string} XML-escaped string, for use within an XML tag.
 */


const xmlEscape = function xmlEscape(unsafe) {
  if (typeof unsafe !== 'string') {
    if (Array.isArray(unsafe)) {
      // This happens when we have hacked blocks from 2.0
      // See #1030
      unsafe = String(unsafe);
    } else {
      log.error('Unexpected input recieved in replaceUnsafeChars');
      return unsafe;
    }
  }

  return unsafe.replace(/[<>&'"]/g, c => {
    switch (c) {
      case '<':
        return '&lt;';

      case '>':
        return '&gt;';

      case '&':
        return '&amp;';

      case '\'':
        return '&apos;';

      case '"':
        return '&quot;';
    }
  });
};

module.exports = xmlEscape;

/***/ }),

/***/ "./src/virtual-machine.js":
/*!********************************!*\
  !*** ./src/virtual-machine.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

console.log('hi lmao');
console.log('fghytfvghjuyhg');

let _TextEncoder;

if (typeof TextEncoder === 'undefined') {
  _TextEncoder = __webpack_require__(/*! text-encoding */ "text-encoding").TextEncoder;
} else {
  /* global TextEncoder */
  _TextEncoder = TextEncoder;
}

const EventEmitter = __webpack_require__(/*! events */ "events");

const JSZip = __webpack_require__(/*! jszip */ "jszip");

const Buffer = __webpack_require__(/*! buffer */ "buffer").Buffer;

const centralDispatch = __webpack_require__(/*! ./dispatch/central-dispatch */ "./src/dispatch/central-dispatch.js");

const ExtensionManager = __webpack_require__(/*! ./extension-support/extension-manager */ "./src/extension-support/extension-manager.js");

const log = __webpack_require__(/*! ./util/log */ "./src/util/log.js");

const MathUtil = __webpack_require__(/*! ./util/math-util */ "./src/util/math-util.js");

const Runtime = __webpack_require__(/*! ./engine/runtime */ "./src/engine/runtime.js");

const StringUtil = __webpack_require__(/*! ./util/string-util */ "./src/util/string-util.js");

const formatMessage = __webpack_require__(/*! format-message */ "format-message");

const Variable = __webpack_require__(/*! ./engine/variable */ "./src/engine/variable.js");

const newBlockIds = __webpack_require__(/*! ./util/new-block-ids */ "./src/util/new-block-ids.js");

const {
  loadCostume
} = __webpack_require__(/*! ./import/load-costume.js */ "./src/import/load-costume.js");

const {
  loadSound
} = __webpack_require__(/*! ./import/load-sound.js */ "./src/import/load-sound.js");

const {
  serializeSounds,
  serializeCostumes
} = __webpack_require__(/*! ./serialization/serialize-assets */ "./src/serialization/serialize-assets.js");

__webpack_require__(/*! canvas-toBlob */ "./node_modules/canvas-toBlob/canvas-toBlob.js");

const {
  exportCostume
} = __webpack_require__(/*! ./serialization/tw-costume-import-export */ "./src/serialization/tw-costume-import-export.js");

const Base64Util = __webpack_require__(/*! ./util/base64-util */ "./src/util/base64-util.js");

const RESERVED_NAMES = ['_mouse_', '_stage_', '_edge_', '_myself_', '_random_'];
const CORE_EXTENSIONS = [// 'motion',
  // 'looks',
  // 'sound',
  // 'events',
  // 'control',
  // 'sensing',
  // 'operators',
  // 'variables',
  // 'myBlocks'
]; // Disable missing translation warnings in console

formatMessage.setup({
  missingTranslation: 'ignore'
});

const createRuntimeService = runtime => {
  const service = {};
  service._refreshExtensionPrimitives = runtime._refreshExtensionPrimitives.bind(runtime);
  service._registerExtensionPrimitives = runtime._registerExtensionPrimitives.bind(runtime);
  return service;
};
/**
 * Handles connections between blocks, stage, and extensions.
 * @constructor
 */


class VirtualMachine extends EventEmitter {
  constructor() {
    super();
    /**
     * VM runtime, to store blocks, I/O devices, sprites/targets, etc.
     * @type {!Runtime}
     */

    this.runtime = new Runtime();
    centralDispatch.setService('runtime', createRuntimeService(this.runtime)).catch(e => {
      log.error("Failed to register runtime service: ".concat(JSON.stringify(e)));
    });
    /**
     * The "currently editing"/selected target ID for the VM.
     * Block events from any Blockly workspace are routed to this target.
     * @type {Target}
     */

    this.editingTarget = null;
    /**
     * The currently dragging target, for redirecting IO data.
     * @type {Target}
     */

    this._dragTarget = null; // Runtime emits are passed along as VM emits.

    this.runtime.on(Runtime.SCRIPT_GLOW_ON, glowData => {
      this.emit(Runtime.SCRIPT_GLOW_ON, glowData);
    });
    this.runtime.on(Runtime.SCRIPT_GLOW_OFF, glowData => {
      this.emit(Runtime.SCRIPT_GLOW_OFF, glowData);
    });
    this.runtime.on(Runtime.BLOCK_GLOW_ON, glowData => {
      this.emit(Runtime.BLOCK_GLOW_ON, glowData);
    });
    this.runtime.on(Runtime.BLOCK_GLOW_OFF, glowData => {
      this.emit(Runtime.BLOCK_GLOW_OFF, glowData);
    });
    this.runtime.on(Runtime.PROJECT_START, () => {
      this.emit(Runtime.PROJECT_START);
    });
    this.runtime.on(Runtime.PROJECT_RUN_START, () => {
      this.emit(Runtime.PROJECT_RUN_START);
    });
    this.runtime.on(Runtime.PROJECT_RUN_STOP, () => {
      this.emit(Runtime.PROJECT_RUN_STOP);
    });
    this.runtime.on(Runtime.PROJECT_CHANGED, () => {
      this.emit(Runtime.PROJECT_CHANGED);
    });
    this.runtime.on(Runtime.VISUAL_REPORT, visualReport => {
      this.emit(Runtime.VISUAL_REPORT, visualReport);
    });
    this.runtime.on(Runtime.TARGETS_UPDATE, emitProjectChanged => {
      this.emitTargetsUpdate(emitProjectChanged);
    });
    this.runtime.on(Runtime.MONITORS_UPDATE, monitorList => {
      this.emit(Runtime.MONITORS_UPDATE, monitorList);
    });
    this.runtime.on(Runtime.BLOCK_DRAG_UPDATE, areBlocksOverGui => {
      this.emit(Runtime.BLOCK_DRAG_UPDATE, areBlocksOverGui);
    });
    this.runtime.on(Runtime.BLOCK_DRAG_END, (blocks, topBlockId) => {
      this.emit(Runtime.BLOCK_DRAG_END, blocks, topBlockId);
    });
    this.runtime.on(Runtime.EXTENSION_ADDED, categoryInfo => {
      this.emit(Runtime.EXTENSION_ADDED, categoryInfo);
    });
    this.runtime.on(Runtime.EXTENSION_FIELD_ADDED, (fieldName, fieldImplementation) => {
      this.emit(Runtime.EXTENSION_FIELD_ADDED, fieldName, fieldImplementation);
    });
    this.runtime.on(Runtime.BLOCKSINFO_UPDATE, categoryInfo => {
      this.emit(Runtime.BLOCKSINFO_UPDATE, categoryInfo);
    });
    this.runtime.on(Runtime.BLOCKS_NEED_UPDATE, () => {
      this.emitWorkspaceUpdate();
    });
    this.runtime.on(Runtime.TOOLBOX_EXTENSIONS_NEED_UPDATE, () => {
      this.extensionManager.refreshBlocks();
    });
    this.runtime.on(Runtime.PERIPHERAL_LIST_UPDATE, info => {
      this.emit(Runtime.PERIPHERAL_LIST_UPDATE, info);
    });
    this.runtime.on(Runtime.USER_PICKED_PERIPHERAL, info => {
      this.emit(Runtime.USER_PICKED_PERIPHERAL, info);
    });
    this.runtime.on(Runtime.PERIPHERAL_CONNECTED, () => this.emit(Runtime.PERIPHERAL_CONNECTED));
    this.runtime.on(Runtime.PERIPHERAL_REQUEST_ERROR, () => this.emit(Runtime.PERIPHERAL_REQUEST_ERROR));
    this.runtime.on(Runtime.PERIPHERAL_DISCONNECTED, () => this.emit(Runtime.PERIPHERAL_DISCONNECTED));
    this.runtime.on(Runtime.PERIPHERAL_CONNECTION_LOST_ERROR, data => this.emit(Runtime.PERIPHERAL_CONNECTION_LOST_ERROR, data));
    this.runtime.on(Runtime.PERIPHERAL_SCAN_TIMEOUT, () => this.emit(Runtime.PERIPHERAL_SCAN_TIMEOUT));
    this.runtime.on(Runtime.MIC_LISTENING, listening => {
      this.emit(Runtime.MIC_LISTENING, listening);
    });
    this.runtime.on(Runtime.RUNTIME_STARTED, () => {
      this.emit(Runtime.RUNTIME_STARTED);
    });
    this.runtime.on(Runtime.RUNTIME_STOPPED, () => {
      this.emit(Runtime.RUNTIME_STOPPED);
    });
    this.runtime.on(Runtime.HAS_CLOUD_DATA_UPDATE, hasCloudData => {
      this.emit(Runtime.HAS_CLOUD_DATA_UPDATE, hasCloudData);
    });
    this.runtime.on(Runtime.RUNTIME_OPTIONS_CHANGED, runtimeOptions => {
      this.emit(Runtime.RUNTIME_OPTIONS_CHANGED, runtimeOptions);
    });
    this.runtime.on(Runtime.COMPILER_OPTIONS_CHANGED, compilerOptions => {
      this.emit(Runtime.COMPILER_OPTIONS_CHANGED, compilerOptions);
    });
    this.runtime.on(Runtime.FRAMERATE_CHANGED, framerate => {
      this.emit(Runtime.FRAMERATE_CHANGED, framerate);
    });
    this.runtime.on(Runtime.INTERPOLATION_CHANGED, framerate => {
      this.emit(Runtime.INTERPOLATION_CHANGED, framerate);
    });
    this.runtime.on(Runtime.STAGE_SIZE_CHANGED, (width, height) => {
      this.emit(Runtime.STAGE_SIZE_CHANGED, width, height);
    });
    this.runtime.on(Runtime.COMPILE_ERROR, (target, error) => {
      this.emit(Runtime.COMPILE_ERROR, target, error);
    });
    this.runtime.on(Runtime.TURBO_MODE_OFF, () => {
      this.emit(Runtime.TURBO_MODE_OFF);
    });
    this.runtime.on(Runtime.TURBO_MODE_ON, () => {
      this.emit(Runtime.TURBO_MODE_ON);
    });
    this.extensionManager = new ExtensionManager(this.runtime); // Load core extensions

    for (const id of CORE_EXTENSIONS) {
      this.extensionManager.loadExtensionIdSync(id);
    }

    this.blockListener = this.blockListener.bind(this);
    this.flyoutBlockListener = this.flyoutBlockListener.bind(this);
    this.monitorBlockListener = this.monitorBlockListener.bind(this);
    this.variableListener = this.variableListener.bind(this);
  }
  /**
   * Start running the VM - do this before anything else.
   */


  start() {
    this.runtime.start();
  }
  /**
   * tw: Stop running the VM
   * Note: This only stops the loop. It will not stop any threads the next time the VM starts
   */


  stop() {
    this.runtime.stop();
  }
  /**
   * "Green flag" handler - start all threads starting with a green flag.
   */


  greenFlag() {
    this.runtime.greenFlag();
  }
  /**
   * Set whether the VM is in "turbo mode."
   * When true, loops don't yield to redraw.
   * @param {boolean} turboModeOn Whether turbo mode should be set.
   */


  setTurboMode(turboModeOn) {
    this.runtime.turboMode = !!turboModeOn;

    if (this.runtime.turboMode) {
      this.emit(Runtime.TURBO_MODE_ON);
    } else {
      this.emit(Runtime.TURBO_MODE_OFF);
    }
  }
  /**
   * Set whether the VM is in 2.0 "compatibility mode."
   * When true, ticks go at 2.0 speed (30 TPS).
   * @param {boolean} compatibilityModeOn Whether compatibility mode is set.
   */


  setCompatibilityMode(compatibilityModeOn) {
    this.runtime.setCompatibilityMode(!!compatibilityModeOn);
  }

  setFramerate(framerate) {
    this.runtime.setFramerate(framerate);
  }

  setInterpolation(interpolationEnabled) {
    this.runtime.setInterpolation(interpolationEnabled);
  }

  setRuntimeOptions(runtimeOptions) {
    this.runtime.setRuntimeOptions(runtimeOptions);
  }

  setCompilerOptions(compilerOptions) {
    this.runtime.setCompilerOptions(compilerOptions);
  }

  setStageSize(width, height) {
    this.runtime.setStageSize(width, height);
  }

  setInEditor(inEditor) {
    this.runtime.setInEditor(inEditor);
  }

  convertToPackagedRuntime() {
    this.runtime.convertToPackagedRuntime();
  }

  addAddonBlock(options) {
    this.runtime.addAddonBlock(options);
  }

  getAddonBlock(procedureCode) {
    return this.runtime.getAddonBlock(procedureCode);
  }

  storeProjectOptions() {
    this.runtime.storeProjectOptions();

    if (this.editingTarget.isStage) {
      this.emitWorkspaceUpdate();
    }
  }

  enableDebug() {
    this.runtime.enableDebug();
    return 'enabled debug mode';
  }
  /**
   * Stop all threads and running activities.
   */


  stopAll() {
    this.runtime.stopAll();
  }
  /**
   * Clear out current running project data.
   */


  clear() {
    this.runtime.dispose();
    this.editingTarget = null;
    this.emitTargetsUpdate(false
    /* Don't emit project change */
    );
  }
  /**
   * Get data for playground. Data comes back in an emitted event.
   */


  getPlaygroundData() {
    const instance = this; // Only send back thread data for the current editingTarget.

    const threadData = this.runtime.threads.filter(thread => thread.target === instance.editingTarget); // Remove the target key, since it's a circular reference.

    const filteredThreadData = JSON.stringify(threadData, (key, value) => {
      if (key === 'target' || key === 'blockContainer') return;
      return value;
    }, 2);
    this.emit('playgroundData', {
      blocks: this.editingTarget.blocks,
      threads: filteredThreadData
    });
  }
  /**
   * Post I/O data to the virtual devices.
   * @param {?string} device Name of virtual I/O device.
   * @param {object} data Any data object to post to the I/O device.
   */


  postIOData(device, data) {
    if (this.runtime.ioDevices[device]) {
      this.runtime.ioDevices[device].postData(data);
    }
  }

  setVideoProvider(videoProvider) {
    this.runtime.ioDevices.video.setProvider(videoProvider);
  }

  setCloudProvider(cloudProvider) {
    this.runtime.ioDevices.cloud.setProvider(cloudProvider);
  }
  /**
   * Tell the specified extension to scan for a peripheral.
   * @param {string} extensionId - the id of the extension.
   */


  scanForPeripheral(extensionId) {
    this.runtime.scanForPeripheral(extensionId);
  }
  /**
   * Connect to the extension's specified peripheral.
   * @param {string} extensionId - the id of the extension.
   * @param {number} peripheralId - the id of the peripheral.
   */


  connectPeripheral(extensionId, peripheralId) {
    this.runtime.connectPeripheral(extensionId, peripheralId);
  }
  /**
   * Disconnect from the extension's connected peripheral.
   * @param {string} extensionId - the id of the extension.
   */


  disconnectPeripheral(extensionId) {
    this.runtime.disconnectPeripheral(extensionId);
  }
  /**
   * Returns whether the extension has a currently connected peripheral.
   * @param {string} extensionId - the id of the extension.
   * @return {boolean} - whether the extension has a connected peripheral.
   */


  getPeripheralIsConnected(extensionId) {
    return this.runtime.getPeripheralIsConnected(extensionId);
  }
  /**
   * Load a Scratch project from a .sb, .sb2, .sb3 or json string.
   * @param {string | object} input A json string, object, or ArrayBuffer representing the project to load.
   * @return {!Promise} Promise that resolves after targets are installed.
   */


  loadProject(input) {
    if (typeof input === 'object' && !(input instanceof ArrayBuffer) && !ArrayBuffer.isView(input)) {
      // If the input is an object and not any ArrayBuffer
      // or an ArrayBuffer view (this includes all typed arrays and DataViews)
      // turn the object into a JSON string, because we suspect
      // this is a project.json as an object
      // validate expects a string or buffer as input
      // TODO not sure if we need to check that it also isn't a data view
      input = JSON.stringify(input);
    }

    const validationPromise = new Promise((resolve, reject) => {
      const validate = __webpack_require__(/*! scratch-parser */ "scratch-parser"); // The second argument of false below indicates to the validator that the
      // input should be parsed/validated as an entire project (and not a single sprite)


      validate(input, false, (error, res) => {
        if (error) {
          return reject(error);
        }

        resolve(res);
      });
    }).catch(error => {
      const {
        SB1File,
        ValidationError
      } = __webpack_require__(/*! scratch-sb1-converter */ "./node_modules/scratch-sb1-converter/playground/main.js");

      try {
        const sb1 = new SB1File(input);
        const json = sb1.json;
        json.projectVersion = 2;
        return Promise.resolve([json, sb1.zip]);
      } catch (sb1Error) {
        if (sb1Error instanceof ValidationError || "".concat(sb1Error).includes('Non-ascii character in FixedAsciiString')) {// The input does not validate as a Scratch 1 file.
        } else {
          // The project appears to be a Scratch 1 file but it
          // could not be successfully translated into a Scratch 2
          // project.
          return Promise.reject(sb1Error);
        }
      } // Throw original error since the input does not appear to be
      // an SB1File.


      return Promise.reject(error);
    });
    return validationPromise.then(validatedInput => this.deserializeProject(validatedInput[0], validatedInput[1])).then(() => this.runtime.emitProjectLoaded()).catch(error => {
      // Intentionally rejecting here (want errors to be handled by caller)
      if (error.hasOwnProperty('validationError')) {
        return Promise.reject(JSON.stringify(error));
      }

      return Promise.reject(error);
    });
  }
  /**
   * Load a project from the Scratch web site, by ID.
   * @param {string} id - the ID of the project to download, as a string.
   */


  downloadProjectId(id) {
    const storage = this.runtime.storage;

    if (!storage) {
      log.error('No storage module present; cannot load project: ', id);
      return;
    }

    const vm = this;
    const promise = storage.load(storage.AssetType.Project, id);
    promise.then(projectAsset => {
      if (!projectAsset) {
        log.error("Failed to fetch project with id: ".concat(id));
        return null;
      }

      return vm.loadProject(projectAsset.data);
    });
  }
  /**
   * @returns {string} Project in a Scratch 3.0 JSON representation.
   */


  saveProjectSb3() {
    const soundDescs = serializeSounds(this.runtime);
    const costumeDescs = serializeCostumes(this.runtime);
    const projectJson = this.toJSON(); // TODO want to eventually move zip creation out of here, and perhaps
    // into scratch-storage

    const zip = new JSZip(); // Put everything in a zip file

    zip.file('project.json', projectJson);

    this._addFileDescsToZip(soundDescs.concat(costumeDescs), zip);

    return zip.generateAsync({
      type: 'blob',
      mimeType: 'application/x.scratch.sb3',
      compression: 'DEFLATE',
      compressionOptions: {
        level: 6 // Tradeoff between best speed (1) and best compression (9)

      }
    });
  }
  /**
   * tw: Serailize the project into a map of files without actually zipping the project.
   * @returns {Record<Uint8Array>} Files of the project.
   */


  saveProjectSb3DontZip() {
    const soundDescs = serializeSounds(this.runtime);
    const costumeDescs = serializeCostumes(this.runtime);
    const projectJson = this.toJSON();
    const files = {
      'project.json': new _TextEncoder().encode(projectJson)
    };

    for (const fileDesc of soundDescs.concat(costumeDescs)) {
      files[fileDesc.fileName] = fileDesc.fileContent;
    }

    return files;
  }
  /*
   * @type {Array<object>} Array of all costumes and sounds currently in the runtime
   */


  get assets() {
    return this.runtime.targets.reduce((acc, target) => acc.concat(target.sprite.sounds.map(sound => sound.asset)).concat(target.sprite.costumes.map(costume => costume.asset)), []);
  }

  _addFileDescsToZip(fileDescs, zip) {
    for (let i = 0; i < fileDescs.length; i++) {
      const currFileDesc = fileDescs[i];
      zip.file(currFileDesc.fileName, currFileDesc.fileContent);
    }
  }
  /**
   * Exports a sprite in the sprite3 format.
   * @param {string} targetId ID of the target to export
   * @param {string=} optZipType Optional type that the resulting
   * zip should be outputted in. Options are: base64, binarystring,
   * array, uint8array, arraybuffer, blob, or nodebuffer. Defaults to
   * blob if argument not provided.
   * See https://stuk.github.io/jszip/documentation/api_jszip/generate_async.html#type-option
   * for more information about these options.
   * @return {object} A generated zip of the sprite and its assets in the format
   * specified by optZipType or blob by default.
   */


  exportSprite(targetId, optZipType) {
    const soundDescs = serializeSounds(this.runtime, targetId);
    const costumeDescs = serializeCostumes(this.runtime, targetId);
    const spriteJson = this.toJSON(targetId);
    const zip = new JSZip();
    zip.file('sprite.json', spriteJson);

    this._addFileDescsToZip(soundDescs.concat(costumeDescs), zip);

    return zip.generateAsync({
      type: typeof optZipType === 'string' ? optZipType : 'blob',
      mimeType: 'application/x.scratch.sprite3',
      compression: 'DEFLATE',
      compressionOptions: {
        level: 6
      }
    });
  }
  /**
   * Export project or sprite as a Scratch 3.0 JSON representation.
   * @param {string=} optTargetId - Optional id of a sprite to serialize
   * @param {*} serializationOptions Options to pass to the serializer
   * @return {string} Serialized state of the runtime.
   */


  toJSON(optTargetId, serializationOptions) {
    const sb3 = __webpack_require__(/*! ./serialization/sb3 */ "./src/serialization/sb3.js");

    return StringUtil.stringify(sb3.serialize(this.runtime, optTargetId, serializationOptions));
  } // TODO do we still need this function? Keeping it here so as not to introduce
  // a breaking change.

  /**
   * Load a project from a Scratch JSON representation.
   * @param {string} json JSON string representing a project.
   * @returns {Promise} Promise that resolves after the project has loaded
   */


  fromJSON(json) {
    log.warning('fromJSON is now just a wrapper around loadProject, please use that function instead.');
    return this.loadProject(json);
  }
  /**
   * Load a project from a Scratch JSON representation.
   * @param {string} projectJSON JSON string representing a project.
   * @param {?JSZip} zip Optional zipped project containing assets to be loaded.
   * @returns {Promise} Promise that resolves after the project has loaded
   */


  deserializeProject(projectJSON, zip) {
    // Clear the current runtime
    this.clear();

    if (typeof performance !== 'undefined') {
      performance.mark('scratch-vm-deserialize-start');
    }

    const runtime = this.runtime;

    const deserializePromise = function deserializePromise() {
      const projectVersion = projectJSON.projectVersion;

      if (projectVersion === 2) {
        const sb2 = __webpack_require__(/*! ./serialization/sb2 */ "./src/serialization/sb2.js");

        return sb2.deserialize(projectJSON, runtime, false, zip);
      }

      if (projectVersion === 3) {
        const sb3 = __webpack_require__(/*! ./serialization/sb3 */ "./src/serialization/sb3.js");

        return sb3.deserialize(projectJSON, runtime, zip);
      }

      return Promise.reject('Unable to verify Scratch Project version.');
    };

    return deserializePromise().then((_ref) => {
      let {
        targets,
        extensions
      } = _ref;

      if (typeof performance !== 'undefined') {
        performance.mark('scratch-vm-deserialize-end');

        try {
          performance.measure('scratch-vm-deserialize', 'scratch-vm-deserialize-start', 'scratch-vm-deserialize-end');
        } catch (e) {
          // performance.measure() will throw an error if the start deserialize
          // marker was removed from memory before we finished deserializing
          // the project. We've seen this happen a couple times when loading
          // very large projects.
          log.error(e);
        }
      }

      return this.installTargets(targets, extensions, true);
    });
  }
  /**
   * Install `deserialize` results: zero or more targets after the extensions (if any) used by those targets.
   * @param {Array.<Target>} targets - the targets to be installed
   * @param {ImportedExtensionsInfo} extensions - metadata about extensions used by these targets
   * @param {boolean} wholeProject - set to true if installing a whole project, as opposed to a single sprite.
   * @returns {Promise} resolved once targets have been installed
   */


  async installTargets(targets, extensions, wholeProject) {
    await this.extensionManager.allAsyncExtensionsLoaded();
    const extensionPromises = [];
    extensions.extensionIDs.forEach(extensionID => {
      if (!this.extensionManager.isExtensionLoaded(extensionID)) {
        const extensionURL = extensions.extensionURLs.get(extensionID) || extensionID;
        extensionPromises.push(this.extensionManager.loadExtensionURL(extensionURL));
      }
    });
    targets = targets.filter(target => !!target);
    return Promise.all(extensionPromises).then(() => {
      targets.forEach(target => {
        this.runtime.addTarget(target);

        /** @type RenderedTarget */
        target.updateAllDrawableProperties(); // Ensure unique sprite name

        if (target.isSprite()) this.renameSprite(target.id, target.getName());
      }); // Sort the executable targets by layerOrder.
      // Remove layerOrder property after use.

      this.runtime.executableTargets.sort((a, b) => a.layerOrder - b.layerOrder);
      targets.forEach(target => {
        delete target.layerOrder;
      }); // Select the first target for editing, e.g., the first sprite.

      if (wholeProject && targets.length > 1) {
        this.editingTarget = targets[1];
      } else {
        this.editingTarget = targets[0];
      }

      if (!wholeProject) {
        this.editingTarget.fixUpVariableReferences();
      }

      if (wholeProject) {
        this.runtime.parseProjectOptions();
      } // Update the VM user's knowledge of targets and blocks on the workspace.


      this.emitTargetsUpdate(false
      /* Don't emit project change */
      );
      this.emitWorkspaceUpdate();
      this.runtime.setEditingTarget(this.editingTarget);
      this.runtime.ioDevices.cloud.setStage(this.runtime.getTargetForStage());
    });
  }
  /**
   * Add a sprite, this could be .sprite2 or .sprite3. Unpack and validate
   * such a file first.
   * @param {string | object} input A json string, object, or ArrayBuffer representing the project to load.
   * @return {!Promise} Promise that resolves after targets are installed.
   */


  addSprite(input) {
    const errorPrefix = 'Sprite Upload Error:';

    if (typeof input === 'object' && !(input instanceof ArrayBuffer) && !ArrayBuffer.isView(input)) {
      // If the input is an object and not any ArrayBuffer
      // or an ArrayBuffer view (this includes all typed arrays and DataViews)
      // turn the object into a JSON string, because we suspect
      // this is a project.json as an object
      // validate expects a string or buffer as input
      // TODO not sure if we need to check that it also isn't a data view
      input = JSON.stringify(input);
    }

    const validationPromise = new Promise((resolve, reject) => {
      const validate = __webpack_require__(/*! scratch-parser */ "scratch-parser"); // The second argument of true below indicates to the parser/validator
      // that the given input should be treated as a single sprite and not
      // an entire project


      validate(input, true, (error, res) => {
        if (error) return reject(error);
        resolve(res);
      });
    });
    return validationPromise.then(validatedInput => {
      const projectVersion = validatedInput[0].projectVersion;

      if (projectVersion === 2) {
        return this._addSprite2(validatedInput[0], validatedInput[1]);
      }

      if (projectVersion === 3) {
        return this._addSprite3(validatedInput[0], validatedInput[1]);
      }

      return Promise.reject("".concat(errorPrefix, " Unable to verify sprite version."));
    }).then(() => this.runtime.emitProjectChanged()).catch(error => {
      // Intentionally rejecting here (want errors to be handled by caller)
      if (error.hasOwnProperty('validationError')) {
        return Promise.reject(JSON.stringify(error));
      }

      return Promise.reject("".concat(errorPrefix, " ").concat(error));
    });
  }
  /**
   * Add a single sprite from the "Sprite2" (i.e., SB2 sprite) format.
   * @param {object} sprite Object representing 2.0 sprite to be added.
   * @param {?ArrayBuffer} zip Optional zip of assets being referenced by json
   * @returns {Promise} Promise that resolves after the sprite is added
   */


  _addSprite2(sprite, zip) {
    // Validate & parse
    const sb2 = __webpack_require__(/*! ./serialization/sb2 */ "./src/serialization/sb2.js");

    return sb2.deserialize(sprite, this.runtime, true, zip).then((_ref2) => {
      let {
        targets,
        extensions
      } = _ref2;
      return this.installTargets(targets, extensions, false);
    });
  }
  /**
   * Add a single sb3 sprite.
   * @param {object} sprite Object rperesenting 3.0 sprite to be added.
   * @param {?ArrayBuffer} zip Optional zip of assets being referenced by target json
   * @returns {Promise} Promise that resolves after the sprite is added
   */


  _addSprite3(sprite, zip) {
    // Validate & parse
    const sb3 = __webpack_require__(/*! ./serialization/sb3 */ "./src/serialization/sb3.js");

    return sb3.deserialize(sprite, this.runtime, zip, true).then((_ref3) => {
      let {
        targets,
        extensions
      } = _ref3;
      return this.installTargets(targets, extensions, false);
    });
  }
  /**
   * Add a costume to the current editing target.
   * @param {string} md5ext - the MD5 and extension of the costume to be loaded.
   * @param {!object} costumeObject Object representing the costume.
   * @property {int} skinId - the ID of the costume's render skin, once installed.
   * @property {number} rotationCenterX - the X component of the costume's origin.
   * @property {number} rotationCenterY - the Y component of the costume's origin.
   * @property {number} [bitmapResolution] - the resolution scale for a bitmap costume.
   * @param {string} optTargetId - the id of the target to add to, if not the editing target.
   * @param {string} optVersion - if this is 2, load costume as sb2, otherwise load costume as sb3.
   * @returns {?Promise} - a promise that resolves when the costume has been added
   */


  addCostume(md5ext, costumeObject, optTargetId, optVersion) {
    const target = optTargetId ? this.runtime.getTargetById(optTargetId) : this.editingTarget;

    if (target) {
      return loadCostume(md5ext, costumeObject, this.runtime, optVersion).then(() => {
        target.addCostume(costumeObject);
        target.setCostume(target.getCostumes().length - 1);
        this.runtime.emitProjectChanged();
      });
    } // If the target cannot be found by id, return a rejected promise


    return Promise.reject();
  }
  /**
   * Add a costume loaded from the library to the current editing target.
   * @param {string} md5ext - the MD5 and extension of the costume to be loaded.
   * @param {!object} costumeObject Object representing the costume.
   * @property {int} skinId - the ID of the costume's render skin, once installed.
   * @property {number} rotationCenterX - the X component of the costume's origin.
   * @property {number} rotationCenterY - the Y component of the costume's origin.
   * @property {number} [bitmapResolution] - the resolution scale for a bitmap costume.
   * @returns {?Promise} - a promise that resolves when the costume has been added
   */


  addCostumeFromLibrary(md5ext, costumeObject) {
    if (!this.editingTarget) return Promise.reject();
    return this.addCostume(md5ext, costumeObject, this.editingTarget.id, 2
    /* optVersion */
    );
  }
  /**
   * Duplicate the costume at the given index. Add it at that index + 1.
   * @param {!int} costumeIndex Index of costume to duplicate
   * @returns {?Promise} - a promise that resolves when the costume has been decoded and added
   */


  duplicateCostume(costumeIndex) {
    const originalCostume = this.editingTarget.getCostumes()[costumeIndex];
    const clone = Object.assign({}, originalCostume);
    const md5ext = "".concat(clone.assetId, ".").concat(clone.dataFormat);
    return loadCostume(md5ext, clone, this.runtime).then(() => {
      this.editingTarget.addCostume(clone, costumeIndex + 1);
      this.editingTarget.setCostume(costumeIndex + 1);
      this.emitTargetsUpdate();
    });
  }
  /**
   * Duplicate the sound at the given index. Add it at that index + 1.
   * @param {!int} soundIndex Index of sound to duplicate
   * @returns {?Promise} - a promise that resolves when the sound has been decoded and added
   */


  duplicateSound(soundIndex) {
    const originalSound = this.editingTarget.getSounds()[soundIndex];
    const clone = Object.assign({}, originalSound);
    return loadSound(clone, this.runtime, this.editingTarget.sprite.soundBank).then(() => {
      this.editingTarget.addSound(clone, soundIndex + 1);
      this.emitTargetsUpdate();
    });
  }
  /**
   * Rename a costume on the current editing target.
   * @param {int} costumeIndex - the index of the costume to be renamed.
   * @param {string} newName - the desired new name of the costume (will be modified if already in use).
   */


  renameCostume(costumeIndex, newName) {
    this.editingTarget.renameCostume(costumeIndex, newName);
    this.emitTargetsUpdate();
  }
  /**
   * Delete a costume from the current editing target.
   * @param {int} costumeIndex - the index of the costume to be removed.
   * @return {?function} A function to restore the deleted costume, or null,
   * if no costume was deleted.
   */


  deleteCostume(costumeIndex) {
    const deletedCostume = this.editingTarget.deleteCostume(costumeIndex);

    if (deletedCostume) {
      const target = this.editingTarget;
      this.runtime.emitProjectChanged();
      return () => {
        target.addCostume(deletedCostume);
        this.emitTargetsUpdate();
      };
    }

    return null;
  }
  /**
   * Add a sound to the current editing target.
   * @param {!object} soundObject Object representing the costume.
   * @param {string} optTargetId - the id of the target to add to, if not the editing target.
   * @returns {?Promise} - a promise that resolves when the sound has been decoded and added
   */


  addSound(soundObject, optTargetId) {
    const target = optTargetId ? this.runtime.getTargetById(optTargetId) : this.editingTarget;

    if (target) {
      return loadSound(soundObject, this.runtime, target.sprite.soundBank).then(() => {
        target.addSound(soundObject);
        this.emitTargetsUpdate();
      });
    } // If the target cannot be found by id, return a rejected promise


    return Promise.reject(new Error("No target with ID: ".concat(optTargetId)));
  }
  /**
   * Rename a sound on the current editing target.
   * @param {int} soundIndex - the index of the sound to be renamed.
   * @param {string} newName - the desired new name of the sound (will be modified if already in use).
   */


  renameSound(soundIndex, newName) {
    this.editingTarget.renameSound(soundIndex, newName);
    this.emitTargetsUpdate();
  }
  /**
   * Get a sound buffer from the audio engine.
   * @param {int} soundIndex - the index of the sound to be got.
   * @return {AudioBuffer} the sound's audio buffer.
   */


  getSoundBuffer(soundIndex) {
    const id = this.editingTarget.sprite.sounds[soundIndex].soundId;

    if (id && this.runtime && this.runtime.audioEngine) {
      return this.editingTarget.sprite.soundBank.getSoundPlayer(id).buffer;
    }

    return null;
  }
  /**
   * Update a sound buffer.
   * @param {int} soundIndex - the index of the sound to be updated.
   * @param {AudioBuffer} newBuffer - new audio buffer for the audio engine.
   * @param {ArrayBuffer} soundEncoding - the new (wav) encoded sound to be stored
   */


  updateSoundBuffer(soundIndex, newBuffer, soundEncoding) {
    const sound = this.editingTarget.sprite.sounds[soundIndex];
    if (sound && sound.broken) delete sound.broken;
    const id = sound ? sound.soundId : null;

    if (id && this.runtime && this.runtime.audioEngine) {
      this.editingTarget.sprite.soundBank.getSoundPlayer(id).buffer = newBuffer;
    } // Update sound in runtime


    if (soundEncoding) {
      // Now that we updated the sound, the format should also be updated
      // so that the sound can eventually be decoded the right way.
      // Sounds that were formerly 'adpcm', but were updated in sound editor
      // will not get decoded by the audio engine correctly unless the format
      // is updated as below.
      sound.format = '';
      const storage = this.runtime.storage;
      sound.asset = storage.createAsset(storage.AssetType.Sound, storage.DataFormat.WAV, soundEncoding, null, true // generate md5
      );
      sound.assetId = sound.asset.assetId;
      sound.dataFormat = storage.DataFormat.WAV;
      sound.md5 = "".concat(sound.assetId, ".").concat(sound.dataFormat);
      sound.sampleCount = newBuffer.length;
      sound.rate = newBuffer.sampleRate;
    } // If soundEncoding is null, it's because gui had a problem
    // encoding the updated sound. We don't want to store anything in this
    // case, and gui should have logged an error.


    this.emitTargetsUpdate();
  }
  /**
   * Delete a sound from the current editing target.
   * @param {int} soundIndex - the index of the sound to be removed.
   * @return {?Function} A function to restore the sound that was deleted,
   * or null, if no sound was deleted.
   */


  deleteSound(soundIndex) {
    const target = this.editingTarget;
    const deletedSound = this.editingTarget.deleteSound(soundIndex);

    if (deletedSound) {
      this.runtime.emitProjectChanged();

      const restoreFun = () => {
        target.addSound(deletedSound);
        this.emitTargetsUpdate();
      };

      return restoreFun;
    }

    return null;
  }
  /**
   * Get a string representation of the image from storage.
   * @param {int} costumeIndex - the index of the costume to be got.
   * @return {string} the costume's SVG string if it's SVG,
   *     a dataURI if it's a PNG or JPG, or null if it couldn't be found or decoded.
   */


  getCostume(costumeIndex) {
    const asset = this.editingTarget.getCostumes()[costumeIndex].asset;
    if (!asset || !this.runtime || !this.runtime.storage) return null;
    const format = asset.dataFormat;

    if (format === this.runtime.storage.DataFormat.SVG) {
      return asset.decodeText();
    } else if (format === this.runtime.storage.DataFormat.PNG || format === this.runtime.storage.DataFormat.JPG) {
      return asset.encodeDataURI();
    }

    log.error("Unhandled format: ".concat(asset.dataFormat));
    return null;
  }
  /**
   * TW: Get the raw binary data to use when exporting a costume to the user's local file system.
   * @param {Costume} costumeObject scratch-vm costume object
   * @returns {Uint8Array}
   */


  getExportedCostume(costumeObject) {
    return exportCostume(costumeObject);
  }
  /**
   * TW: Get a base64 string to use when exporting a costume to the user's local file system.
   * @param {Costume} costumeObject scratch-vm costume object
   * @returns {string} base64 string. Not a data: URI.
   */


  getExportedCostumeBase64(costumeObject) {
    const binaryData = this.getExportedCostume(costumeObject);
    return Base64Util.uint8ArrayToBase64(binaryData);
  }
  /**
   * Update a costume with the given bitmap
   * @param {!int} costumeIndex - the index of the costume to be updated.
   * @param {!ImageData} bitmap - new bitmap for the renderer.
   * @param {!number} rotationCenterX x of point about which the costume rotates, relative to its upper left corner
   * @param {!number} rotationCenterY y of point about which the costume rotates, relative to its upper left corner
   * @param {!number} bitmapResolution 1 for bitmaps that have 1 pixel per unit of stage,
   *     2 for double-resolution bitmaps
   */


  updateBitmap(costumeIndex, bitmap, rotationCenterX, rotationCenterY, bitmapResolution) {
    return this._updateBitmap(this.editingTarget.getCostumes()[costumeIndex], bitmap, rotationCenterX, rotationCenterY, bitmapResolution);
  }

  _updateBitmap(costume, bitmap, rotationCenterX, rotationCenterY, bitmapResolution) {
    if (!(costume && this.runtime && this.runtime.renderer)) return;
    if (costume && costume.broken) delete costume.broken;
    costume.rotationCenterX = rotationCenterX;
    costume.rotationCenterY = rotationCenterY; // If the bitmap originally had a zero width or height, use that value

    const bitmapWidth = bitmap.sourceWidth === 0 ? 0 : bitmap.width;
    const bitmapHeight = bitmap.sourceHeight === 0 ? 0 : bitmap.height; // @todo: updateBitmapSkin does not take ImageData

    const canvas = document.createElement('canvas');
    canvas.width = bitmapWidth;
    canvas.height = bitmapHeight;
    const context = canvas.getContext('2d');
    context.putImageData(bitmap, 0, 0); // Divide by resolution because the renderer's definition of the rotation center
    // is the rotation center divided by the bitmap resolution

    this.runtime.renderer.updateBitmapSkin(costume.skinId, canvas, bitmapResolution, [rotationCenterX / bitmapResolution, rotationCenterY / bitmapResolution]); // @todo there should be a better way to get from ImageData to a decodable storage format

    canvas.toBlob(blob => {
      const reader = new FileReader();
      reader.addEventListener('loadend', () => {
        const storage = this.runtime.storage;
        costume.dataFormat = storage.DataFormat.PNG;
        costume.bitmapResolution = bitmapResolution;
        costume.size = [bitmapWidth, bitmapHeight];
        costume.asset = storage.createAsset(storage.AssetType.ImageBitmap, costume.dataFormat, Buffer.from(reader.result), null, // id
        true // generate md5
        );
        costume.assetId = costume.asset.assetId;
        costume.md5 = "".concat(costume.assetId, ".").concat(costume.dataFormat);
        this.emitTargetsUpdate();
      }); // Bitmaps with a zero width or height return null for their blob

      if (blob) {
        reader.readAsArrayBuffer(blob);
      }
    });
  }
  /**
   * Update a costume with the given SVG
   * @param {int} costumeIndex - the index of the costume to be updated.
   * @param {string} svg - new SVG for the renderer.
   * @param {number} rotationCenterX x of point about which the costume rotates, relative to its upper left corner
   * @param {number} rotationCenterY y of point about which the costume rotates, relative to its upper left corner
   */


  updateSvg(costumeIndex, svg, rotationCenterX, rotationCenterY) {
    return this._updateSvg(this.editingTarget.getCostumes()[costumeIndex], svg, rotationCenterX, rotationCenterY);
  }

  _updateSvg(costume, svg, rotationCenterX, rotationCenterY) {
    if (costume && costume.broken) delete costume.broken;

    if (costume && this.runtime && this.runtime.renderer) {
      costume.rotationCenterX = rotationCenterX;
      costume.rotationCenterY = rotationCenterY;
      this.runtime.renderer.updateSVGSkin(costume.skinId, svg, [rotationCenterX, rotationCenterY]);
      costume.size = this.runtime.renderer.getSkinSize(costume.skinId);
    }

    const storage = this.runtime.storage; // If we're in here, we've edited an svg in the vector editor,
    // so the dataFormat should be 'svg'

    costume.dataFormat = storage.DataFormat.SVG;
    costume.bitmapResolution = 1;
    costume.asset = storage.createAsset(storage.AssetType.ImageVector, costume.dataFormat, new _TextEncoder().encode(svg), null, true // generate md5
    );
    costume.assetId = costume.asset.assetId;
    costume.md5 = "".concat(costume.assetId, ".").concat(costume.dataFormat);
    this.emitTargetsUpdate();
  }
  /**
   * Add a backdrop to the stage.
   * @param {string} md5ext - the MD5 and extension of the backdrop to be loaded.
   * @param {!object} backdropObject Object representing the backdrop.
   * @property {int} skinId - the ID of the backdrop's render skin, once installed.
   * @property {number} rotationCenterX - the X component of the backdrop's origin.
   * @property {number} rotationCenterY - the Y component of the backdrop's origin.
   * @property {number} [bitmapResolution] - the resolution scale for a bitmap backdrop.
   * @returns {?Promise} - a promise that resolves when the backdrop has been added
   */


  addBackdrop(md5ext, backdropObject) {
    return loadCostume(md5ext, backdropObject, this.runtime).then(() => {
      const stage = this.runtime.getTargetForStage();
      stage.addCostume(backdropObject);
      stage.setCostume(stage.getCostumes().length - 1);
      this.runtime.emitProjectChanged();
    });
  }
  /**
   * Rename a sprite.
   * @param {string} targetId ID of a target whose sprite to rename.
   * @param {string} newName New name of the sprite.
   */


  renameSprite(targetId, newName) {
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      if (!target.isSprite()) {
        throw new Error('Cannot rename non-sprite targets.');
      }

      const sprite = target.sprite;

      if (!sprite) {
        throw new Error('No sprite associated with this target.');
      }

      if (newName && RESERVED_NAMES.indexOf(newName) === -1) {
        const names = this.runtime.targets.filter(runtimeTarget => runtimeTarget.isSprite() && runtimeTarget.id !== target.id).map(runtimeTarget => runtimeTarget.sprite.name);
        const oldName = sprite.name;
        const newUnusedName = StringUtil.unusedName(newName, names);
        sprite.name = newUnusedName;

        if (oldName === newUnusedName) {
          return;
        }

        const allTargets = this.runtime.targets;

        for (let i = 0; i < allTargets.length; i++) {
          const currTarget = allTargets[i];
          currTarget.blocks.updateAssetName(oldName, newName, 'sprite');
        }

        if (newUnusedName !== oldName) this.emitTargetsUpdate();
      }
    } else {
      throw new Error('No target with the provided id.');
    }
  }
  /**
   * Delete a sprite and all its clones.
   * @param {string} targetId ID of a target whose sprite to delete.
   * @return {Function} Returns a function to restore the sprite that was deleted
   */


  deleteSprite(targetId) {
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      const targetIndexBeforeDelete = this.runtime.targets.map(t => t.id).indexOf(target.id);

      if (!target.isSprite()) {
        throw new Error('Cannot delete non-sprite targets.');
      }

      const sprite = target.sprite;

      if (!sprite) {
        throw new Error('No sprite associated with this target.');
      }

      const spritePromise = this.exportSprite(targetId, 'uint8array');

      const restoreSprite = () => spritePromise.then(spriteBuffer => this.addSprite(spriteBuffer)); // Remove monitors from the runtime state and remove the
      // target-specific monitored blocks (e.g. local variables)


      target.deleteMonitors();
      const currentEditingTarget = this.editingTarget;

      for (let i = 0; i < sprite.clones.length; i++) {
        const clone = sprite.clones[i];
        this.runtime.stopForTarget(sprite.clones[i]);
        this.runtime.disposeTarget(sprite.clones[i]); // Ensure editing target is switched if we are deleting it.

        if (clone === currentEditingTarget) {
          const nextTargetIndex = Math.min(this.runtime.targets.length - 1, targetIndexBeforeDelete);

          if (this.runtime.targets.length > 0) {
            this.setEditingTarget(this.runtime.targets[nextTargetIndex].id);
          } else {
            this.editingTarget = null;
          }
        }
      } // Sprite object should be deleted by GC.


      this.emitTargetsUpdate();
      return restoreSprite;
    }

    throw new Error('No target with the provided id.');
  }
  /**
   * Duplicate a sprite.
   * @param {string} targetId ID of a target whose sprite to duplicate.
   * @returns {Promise} Promise that resolves when duplicated target has
   *     been added to the runtime.
   */


  duplicateSprite(targetId) {
    const target = this.runtime.getTargetById(targetId);

    if (!target) {
      throw new Error('No target with the provided id.');
    } else if (!target.isSprite()) {
      throw new Error('Cannot duplicate non-sprite targets.');
    } else if (!target.sprite) {
      throw new Error('No sprite associated with this target.');
    }

    return target.duplicate().then(newTarget => {
      this.runtime.addTarget(newTarget);
      newTarget.goBehindOther(target);
      this.setEditingTarget(newTarget.id);
    });
  }
  /**
   * Set the audio engine for the VM/runtime
   * @param {!AudioEngine} audioEngine The audio engine to attach
   */


  attachAudioEngine(audioEngine) {
    this.runtime.attachAudioEngine(audioEngine);
  }
  /**
   * Set the renderer for the VM/runtime
   * @param {!RenderWebGL} renderer The renderer to attach
   */


  attachRenderer(renderer) {
    this.runtime.attachRenderer(renderer);
  }
  /**
   * @returns {RenderWebGL} The renderer attached to the vm
   */


  get renderer() {
    return this.runtime && this.runtime.renderer;
  } // @deprecated


  attachV2SVGAdapter() {}
  /**
   * Set the bitmap adapter for the VM/runtime, which converts scratch 2
   * bitmaps to scratch 3 bitmaps. (Scratch 3 bitmaps are all bitmap resolution 2)
   * @param {!function} bitmapAdapter The adapter to attach
   */


  attachV2BitmapAdapter(bitmapAdapter) {
    this.runtime.attachV2BitmapAdapter(bitmapAdapter);
  }
  /**
   * Set the storage module for the VM/runtime
   * @param {!ScratchStorage} storage The storage module to attach
   */


  attachStorage(storage) {
    this.runtime.attachStorage(storage);
  }
  /**
   * set the current locale and builtin messages for the VM
   * @param {!string} locale       current locale
   * @param {!object} messages     builtin messages map for current locale
   * @returns {Promise} Promise that resolves when all the blocks have been
   *     updated for a new locale (or empty if locale hasn't changed.)
   */


  setLocale(locale, messages) {
    if (locale !== formatMessage.setup().locale) {
      formatMessage.setup({
        locale: locale,
        translations: {
          [locale]: messages
        }
      });
    }

    return this.extensionManager.refreshBlocks();
  }
  /**
   * get the current locale for the VM
   * @returns {string} the current locale in the VM
   */


  getLocale() {
    return formatMessage.setup().locale;
  }
  /**
   * Handle a Blockly event for the current editing target.
   * @param {!Blockly.Event} e Any Blockly event.
   */


  blockListener(e) {
    if (this.editingTarget) {
      this.editingTarget.blocks.blocklyListen(e);
    }
  }
  /**
   * Handle a Blockly event for the flyout.
   * @param {!Blockly.Event} e Any Blockly event.
   */


  flyoutBlockListener(e) {
    this.runtime.flyoutBlocks.blocklyListen(e);
  }
  /**
   * Handle a Blockly event for the flyout to be passed to the monitor container.
   * @param {!Blockly.Event} e Any Blockly event.
   */


  monitorBlockListener(e) {
    // Filter events by type, since monitor blocks only need to listen to these events.
    // Monitor blocks shouldn't be destroyed when flyout blocks are deleted.
    if (['create', 'change'].indexOf(e.type) !== -1) {
      this.runtime.monitorBlocks.blocklyListen(e);
    }
  }
  /**
   * Handle a Blockly event for the variable map.
   * @param {!Blockly.Event} e Any Blockly event.
   */


  variableListener(e) {
    // Filter events by type, since blocks only needs to listen to these
    // var events.
    if (['var_create', 'var_rename', 'var_delete'].indexOf(e.type) !== -1) {
      this.runtime.getTargetForStage().blocks.blocklyListen(e);
    }
  }
  /**
   * Set an editing target. An editor UI can use this function to switch
   * between editing different targets, sprites, etc.
   * After switching the editing target, the VM may emit updates
   * to the list of targets and any attached workspace blocks
   * (see `emitTargetsUpdate` and `emitWorkspaceUpdate`).
   * @param {string} targetId Id of target to set as editing.
   */


  setEditingTarget(targetId) {
    // Has the target id changed? If not, exit.
    if (this.editingTarget && targetId === this.editingTarget.id) {
      return;
    }

    const target = this.runtime.getTargetById(targetId);

    if (target) {
      this.editingTarget = target; // Emit appropriate UI updates.

      this.emitTargetsUpdate(false
      /* Don't emit project change */
      );
      this.emitWorkspaceUpdate();
      this.runtime.setEditingTarget(target);
    }
  }
  /**
   * Called when blocks are dragged from one sprite to another. Adds the blocks to the
   * workspace of the given target.
   * @param {!Array<object>} blocks Blocks to add.
   * @param {!string} targetId Id of target to add blocks to.
   * @param {?string} optFromTargetId Optional target id indicating that blocks are being
   * shared from that target. This is needed for resolving any potential variable conflicts.
   * @return {!Promise} Promise that resolves when the extensions and blocks have been added.
   */


  shareBlocksToTarget(blocks, targetId, optFromTargetId) {
    const sb3 = __webpack_require__(/*! ./serialization/sb3 */ "./src/serialization/sb3.js");

    const copiedBlocks = JSON.parse(JSON.stringify(blocks));
    newBlockIds(copiedBlocks);
    const target = this.runtime.getTargetById(targetId);

    if (optFromTargetId) {
      // If the blocks are being shared from another target,
      // resolve any possible variable conflicts that may arise.
      const fromTarget = this.runtime.getTargetById(optFromTargetId);
      fromTarget.resolveVariableSharingConflictsWithTarget(copiedBlocks, target);
    } // Create a unique set of extensionIds that are not yet loaded


    const extensionIDs = new Set(copiedBlocks.map(b => sb3.getExtensionIdForOpcode(b.opcode)).filter(id => !!id) // Remove ids that do not exist
    .filter(id => !this.extensionManager.isExtensionLoaded(id)) // and remove loaded extensions
    ); // Create an array promises for extensions to load

    const extensionPromises = Array.from(extensionIDs, id => this.extensionManager.loadExtensionURL(id));
    return Promise.all(extensionPromises).then(() => {
      copiedBlocks.forEach(block => {
        target.blocks.createBlock(block);
      });
      target.blocks.updateTargetSpecificBlocks(target.isStage);
    });
  }
  /**
   * Called when costumes are dragged from editing target to another target.
   * Sets the newly added costume as the current costume.
   * @param {!number} costumeIndex Index of the costume of the editing target to share.
   * @param {!string} targetId Id of target to add the costume.
   * @return {Promise} Promise that resolves when the new costume has been loaded.
   */


  shareCostumeToTarget(costumeIndex, targetId) {
    const originalCostume = this.editingTarget.getCostumes()[costumeIndex];
    const clone = Object.assign({}, originalCostume);
    const md5ext = "".concat(clone.assetId, ".").concat(clone.dataFormat);
    return loadCostume(md5ext, clone, this.runtime).then(() => {
      const target = this.runtime.getTargetById(targetId);

      if (target) {
        target.addCostume(clone);
        target.setCostume(target.getCostumes().length - 1);
      }
    });
  }
  /**
   * Called when sounds are dragged from editing target to another target.
   * @param {!number} soundIndex Index of the sound of the editing target to share.
   * @param {!string} targetId Id of target to add the sound.
   * @return {Promise} Promise that resolves when the new sound has been loaded.
   */


  shareSoundToTarget(soundIndex, targetId) {
    const originalSound = this.editingTarget.getSounds()[soundIndex];
    const clone = Object.assign({}, originalSound);
    const target = this.runtime.getTargetById(targetId);
    return loadSound(clone, this.runtime, target.sprite.soundBank).then(() => {
      if (target) {
        target.addSound(clone);
        this.emitTargetsUpdate();
      }
    });
  }
  /**
   * Repopulate the workspace with the blocks of the current editingTarget. This
   * allows us to get around bugs like gui#413.
   */


  refreshWorkspace() {
    if (this.editingTarget) {
      this.emitWorkspaceUpdate();
      this.runtime.setEditingTarget(this.editingTarget);
      this.emitTargetsUpdate(false
      /* Don't emit project change */
      );
    }
  }
  /**
   * Emit metadata about available targets.
   * An editor UI could use this to display a list of targets and show
   * the currently editing one.
   * @param {bool} triggerProjectChange If true, also emit a project changed event.
   * Disabled selectively by updates that don't affect project serialization.
   * Defaults to true.
   */


  emitTargetsUpdate(triggerProjectChange) {
    if (typeof triggerProjectChange === 'undefined') triggerProjectChange = true;
    let lazyTargetList;

    const getTargetListLazily = () => {
      if (!lazyTargetList) {
        lazyTargetList = this.runtime.targets.filter( // Don't report clones.
        target => !target.hasOwnProperty('isOriginal') || target.isOriginal).map(target => target.toJSON());
      }

      return lazyTargetList;
    };

    this.emit('targetsUpdate', {
      // [[target id, human readable target name], ...].
      get targetList() {
        return getTargetListLazily();
      },

      // Currently editing target id.
      editingTarget: this.editingTarget ? this.editingTarget.id : null
    });

    if (triggerProjectChange) {
      this.runtime.emitProjectChanged();
    }
  }
  /**
   * Emit an Blockly/scratch-blocks compatible XML representation
   * of the current editing target's blocks.
   */


  emitWorkspaceUpdate() {
    // Create a list of broadcast message Ids according to the stage variables
    const stageVariables = this.runtime.getTargetForStage().variables;
    let messageIds = [];

    for (const varId in stageVariables) {
      if (stageVariables[varId].type === Variable.BROADCAST_MESSAGE_TYPE) {
        messageIds.push(varId);
      }
    } // Go through all blocks on all targets, removing referenced
    // broadcast ids from the list.


    for (let i = 0; i < this.runtime.targets.length; i++) {
      const currTarget = this.runtime.targets[i];
      const currBlocks = currTarget.blocks._blocks;

      for (const blockId in currBlocks) {
        if (currBlocks[blockId].fields.BROADCAST_OPTION) {
          const id = currBlocks[blockId].fields.BROADCAST_OPTION.id;
          const index = messageIds.indexOf(id);

          if (index !== -1) {
            messageIds = messageIds.slice(0, index).concat(messageIds.slice(index + 1));
          }
        }
      }
    } // Anything left in messageIds is not referenced by a block, so delete it.


    for (let i = 0; i < messageIds.length; i++) {
      const id = messageIds[i];
      delete this.runtime.getTargetForStage().variables[id];
    }

    const globalVarMap = Object.assign({}, this.runtime.getTargetForStage().variables);
    const localVarMap = this.editingTarget.isStage ? Object.create(null) : Object.assign({}, this.editingTarget.variables);
    const globalVariables = Object.keys(globalVarMap).map(k => globalVarMap[k]);
    const localVariables = Object.keys(localVarMap).map(k => localVarMap[k]);
    const workspaceComments = Object.keys(this.editingTarget.comments).map(k => this.editingTarget.comments[k]).filter(c => c.blockId === null);
    const xmlString = "<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n                            <variables>\n                                ".concat(globalVariables.map(v => v.toXML()).join(), "\n                                ").concat(localVariables.map(v => v.toXML(true)).join(), "\n                            </variables>\n                            ").concat(workspaceComments.map(c => c.toXML()).join(), "\n                            ").concat(this.editingTarget.blocks.toXML(this.editingTarget.comments), "\n                        </xml>");
    this.emit('workspaceUpdate', {
      xml: xmlString
    });
  }
  /**
   * Get a target id for a drawable id. Useful for interacting with the renderer
   * @param {int} drawableId The drawable id to request the target id for
   * @returns {?string} The target id, if found. Will also be null if the target found is the stage.
   */


  getTargetIdForDrawableId(drawableId) {
    const target = this.runtime.getTargetByDrawableId(drawableId);

    if (target && target.hasOwnProperty('id') && target.hasOwnProperty('isStage') && !target.isStage) {
      return target.id;
    }

    return null;
  }
  /**
   * Reorder target by index. Return whether a change was made.
   * @param {!string} targetIndex Index of the target.
   * @param {!number} newIndex index that the target should be moved to.
   * @returns {boolean} Whether a target was reordered.
   */


  reorderTarget(targetIndex, newIndex) {
    let targets = this.runtime.targets;
    targetIndex = MathUtil.clamp(targetIndex, 0, targets.length - 1);
    newIndex = MathUtil.clamp(newIndex, 0, targets.length - 1);
    if (targetIndex === newIndex) return false;
    const target = targets[targetIndex];
    targets = targets.slice(0, targetIndex).concat(targets.slice(targetIndex + 1));
    targets.splice(newIndex, 0, target);
    this.runtime.targets = targets;
    this.emitTargetsUpdate();
    return true;
  }
  /**
   * Reorder the costumes of a target if it exists. Return whether it succeeded.
   * @param {!string} targetId ID of the target which owns the costumes.
   * @param {!number} costumeIndex index of the costume to move.
   * @param {!number} newIndex index that the costume should be moved to.
   * @returns {boolean} Whether a costume was reordered.
   */


  reorderCostume(targetId, costumeIndex, newIndex) {
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      const reorderSuccessful = target.reorderCostume(costumeIndex, newIndex);

      if (reorderSuccessful) {
        this.runtime.emitProjectChanged();
      }

      return reorderSuccessful;
    }

    return false;
  }
  /**
   * Reorder the sounds of a target if it exists. Return whether it occured.
   * @param {!string} targetId ID of the target which owns the sounds.
   * @param {!number} soundIndex index of the sound to move.
   * @param {!number} newIndex index that the sound should be moved to.
   * @returns {boolean} Whether a sound was reordered.
   */


  reorderSound(targetId, soundIndex, newIndex) {
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      const reorderSuccessful = target.reorderSound(soundIndex, newIndex);

      if (reorderSuccessful) {
        this.runtime.emitProjectChanged();
      }

      return reorderSuccessful;
    }

    return false;
  }
  /**
   * Put a target into a "drag" state, during which its X/Y positions will be unaffected
   * by blocks.
   * @param {string} targetId The id for the target to put into a drag state
   */


  startDrag(targetId) {
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      this._dragTarget = target;
      target.startDrag();
    }
  }
  /**
   * Remove a target from a drag state, so blocks may begin affecting X/Y position again
   * @param {string} targetId The id for the target to remove from the drag state
   */


  stopDrag(targetId) {
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      this._dragTarget = null;
      target.stopDrag();
      this.setEditingTarget(target.sprite && target.sprite.clones[0] ? target.sprite.clones[0].id : target.id);
    }
  }
  /**
   * Post/edit sprite info for the current editing target or the drag target.
   * @param {object} data An object with sprite info data to set.
   */


  postSpriteInfo(data) {
    if (this._dragTarget) {
      this._dragTarget.postSpriteInfo(data);
    } else {
      this.editingTarget.postSpriteInfo(data);
    } // Post sprite info means the gui has changed something about a sprite,
    // either through the sprite info pane fields (e.g. direction, size) or
    // through dragging a sprite on the stage
    // Emit a project changed event.


    this.runtime.emitProjectChanged();
  }
  /**
   * Set a target's variable's value. Return whether it succeeded.
   * @param {!string} targetId ID of the target which owns the variable.
   * @param {!string} variableId ID of the variable to set.
   * @param {!*} value The new value of that variable.
   * @returns {boolean} whether the target and variable were found and updated.
   */


  setVariableValue(targetId, variableId, value) {
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      const variable = target.lookupVariableById(variableId);

      if (variable) {
        variable.value = value;

        if (variable.isCloud) {
          this.runtime.ioDevices.cloud.requestUpdateVariable(variable.name, variable.value);
        }

        return true;
      }
    }

    return false;
  }
  /**
   * Get a target's variable's value. Return null if the target or variable does not exist.
   * @param {!string} targetId ID of the target which owns the variable.
   * @param {!string} variableId ID of the variable to set.
   * @returns {?*} The value of the variable, or null if it could not be looked up.
   */


  getVariableValue(targetId, variableId) {
    const target = this.runtime.getTargetById(targetId);

    if (target) {
      const variable = target.lookupVariableById(variableId);

      if (variable) {
        return variable.value;
      }
    }

    return null;
  }
  /**
   * Allow VM consumer to configure the ScratchLink socket creator.
   * @param {Function} factory The custom ScratchLink socket factory.
   */


  configureScratchLinkSocketFactory(factory) {
    this.runtime.configureScratchLinkSocketFactory(factory);
  }

}

module.exports = VirtualMachine;

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("buffer");

/***/ }),

/***/ "decode-html":
/*!******************************!*\
  !*** external "decode-html" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("decode-html");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),

/***/ "format-message":
/*!*********************************!*\
  !*** external "format-message" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("format-message");

/***/ }),

/***/ "htmlparser2":
/*!******************************!*\
  !*** external "htmlparser2" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("htmlparser2");

/***/ }),

/***/ "immutable":
/*!****************************!*\
  !*** external "immutable" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("immutable");

/***/ }),

/***/ "jszip":
/*!************************!*\
  !*** external "jszip" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("jszip");

/***/ }),

/***/ "minilog":
/*!**************************!*\
  !*** external "minilog" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("minilog");

/***/ }),

/***/ "scratch-parser":
/*!*********************************!*\
  !*** external "scratch-parser" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("scratch-parser");

/***/ }),

/***/ "text-encoding":
/*!********************************!*\
  !*** external "text-encoding" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("text-encoding");

/***/ })

/******/ });
//# sourceMappingURL=scratch-vm.js.map